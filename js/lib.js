(function() {
    var undefined;
    var VERSION = "3.3.1";
    var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, REARG_FLAG = 128, ARY_FLAG = 256;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 150, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 0, LAZY_MAP_FLAG = 1, LAZY_WHILE_FLAG = 2;
    var FUNC_ERROR_TEXT = "Expected a function";
    var PLACEHOLDER = "__lodash_placeholder__";
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    var reHexPrefix = /^0[xX]/;
    var reHostCtor = /^\[object .+?Constructor\]$/;
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    var reNoMatch = /($^)/;
    var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g, reHasRegExpChars = RegExp(reRegExpChars.source);
    var reThis = /\bthis\b/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var reWords = function() {
        var upper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", lower = "[a-z\\xdf-\\xf6\\xf8-\\xff]+";
        return RegExp(upper + "{2,}(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
    }();
    var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
    var contextProps = [ "Array", "ArrayBuffer", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Math", "Number", "Object", "RegExp", "Set", "String", "_", "clearTimeout", "document", "isFinite", "parseInt", "setTimeout", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "window", "WinRTError" ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
    var debounceOptions = {
        leading: false,
        maxWait: 0,
        trailing: false
    };
    var deburredLetters = {
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss"
    };
    var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "`": "&#96;"
    };
    var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
        "&#96;": "`"
    };
    var objectTypes = {
        "function": true,
        object: true
    };
    var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var root = objectTypes[typeof window] && window !== (this && this.window) ? window : this;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var freeGlobal = freeExports && freeModule && typeof global == "object" && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
    }
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    function baseCompareAscending(value, other) {
        if (value !== other) {
            var valIsReflexive = value === value, othIsReflexive = other === other;
            if (value > other || !valIsReflexive || typeof value == "undefined" && othIsReflexive) {
                return 1;
            }
            if (value < other || !othIsReflexive || typeof other == "undefined" && valIsReflexive) {
                return -1;
            }
        }
        return 0;
    }
    function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
            return indexOfNaN(array, fromIndex);
        }
        var index = (fromIndex || 0) - 1, length = array.length;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function baseIsFunction(value) {
        return typeof value == "function" || false;
    }
    function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
            array[length] = array[length].value;
        }
        return array;
    }
    function baseToString(value) {
        if (typeof value == "string") {
            return value;
        }
        return value == null ? "" : value + "";
    }
    function charAtCallback(string) {
        return string.charCodeAt(0);
    }
    function charsLeftIndex(string, chars) {
        var index = -1, length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
    }
    function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
    }
    function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index;
    }
    function compareMultipleAscending(object, other) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length;
        while (++index < length) {
            var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
                return result;
            }
        }
        return object.index - other.index;
    }
    function deburrLetter(letter) {
        return deburredLetters[letter];
    }
    function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
    }
    function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
    }
    function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length, index = fromRight ? fromIndex || length : (fromIndex || 0) - 1;
        while (fromRight ? index-- : ++index < length) {
            var other = array[index];
            if (other !== other) {
                return index;
            }
        }
        return -1;
    }
    function isObjectLike(value) {
        return value && typeof value == "object" || false;
    }
    function isSpace(charCode) {
        return charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160 || charCode == 5760 || charCode == 6158 || charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279);
    }
    function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            if (array[index] === placeholder) {
                array[index] = PLACEHOLDER;
                result[++resIndex] = index;
            }
        }
        return result;
    }
    function sortedUniq(array, iteratee) {
        var seen, index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
            if (!index || seen !== computed) {
                seen = computed;
                result[++resIndex] = value;
            }
        }
        return result;
    }
    function trimmedLeftIndex(string) {
        var index = -1, length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
    }
    function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
    }
    function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayProto = Array.prototype, objectProto = Object.prototype;
        var document = (document = context.window) && document.document;
        var fnToString = Function.prototype.toString;
        var getLength = baseProperty("length");
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = context._;
        var reNative = RegExp("^" + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer, bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice, ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, push = arrayProto.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, Set = isNative(Set = context.Set) && Set, setTimeout = context.setTimeout, splice = arrayProto.splice, Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array, WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
        var Float64Array = function() {
            try {
                var func = isNative(func = context.Float64Array) && func, result = new func(new ArrayBuffer(10), 0, 1) && func;
            } catch (e) {}
            return result;
        }();
        var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsFinite = context.isFinite, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeNow = isNative(nativeNow = Date.now) && nativeNow, nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
        var metaMap = WeakMap && new WeakMap();
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) {
                    return value;
                }
                if (hasOwnProperty.call(value, "__chain__") && hasOwnProperty.call(value, "__wrapped__")) {
                    return wrapperClone(value);
                }
            }
            return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
            this.__wrapped__ = value;
            this.__actions__ = actions || [];
            this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        (function(x) {
            support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
            support.funcNames = typeof Function.name == "string";
            try {
                support.dom = document.createDocumentFragment().nodeType === 11;
            } catch (e) {
                support.dom = false;
            }
            try {
                support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
            } catch (e) {
                support.nonEnumArgs = true;
            }
        })(0, 0);
        lodash.templateSettings = {
            escape: reEscape,
            evaluate: reEvaluate,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        };
        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = null;
            this.__dir__ = 1;
            this.__dropCount__ = 0;
            this.__filtered__ = false;
            this.__iteratees__ = null;
            this.__takeCount__ = POSITIVE_INFINITY;
            this.__views__ = null;
        }
        function lazyClone() {
            var actions = this.__actions__, iteratees = this.__iteratees__, views = this.__views__, result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = actions ? arrayCopy(actions) : null;
            result.__dir__ = this.__dir__;
            result.__dropCount__ = this.__dropCount__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = views ? arrayCopy(views) : null;
            return result;
        }
        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1;
                result.__filtered__ = true;
            } else {
                result = this.clone();
                result.__dir__ *= -1;
            }
            return result;
        }
        function lazyValue() {
            var array = this.__wrapped__.value();
            if (!isArray(array)) {
                return baseWrapperValue(array, this.__actions__);
            }
            var dir = this.__dir__, isRight = dir < 0, view = getView(0, array.length, this.__views__), start = view.start, end = view.end, length = end - start, dropCount = this.__dropCount__, takeCount = nativeMin(length, this.__takeCount__), index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees ? iteratees.length : 0, resIndex = 0, result = [];
            outer: while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                    var data = iteratees[iterIndex], iteratee = data.iteratee, computed = iteratee(value, index, array), type = data.type;
                    if (type == LAZY_MAP_FLAG) {
                        value = computed;
                    } else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) {
                            continue outer;
                        } else {
                            break outer;
                        }
                    }
                }
                if (dropCount) {
                    dropCount--;
                } else {
                    result[resIndex++] = value;
                }
            }
            return result;
        }
        function MapCache() {
            this.__data__ = {};
        }
        function mapDelete(key) {
            return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
            return key == "__proto__" ? undefined : this.__data__[key];
        }
        function mapHas(key) {
            return key != "__proto__" && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
            if (key != "__proto__") {
                this.__data__[key] = value;
            }
            return this;
        }
        function SetCache(values) {
            var length = values ? values.length : 0;
            this.data = {
                hash: nativeCreate(null),
                set: new Set()
            };
            while (length--) {
                this.push(values[length]);
            }
        }
        function cacheIndexOf(cache, value) {
            var data = cache.data, result = typeof value == "string" || isObject(value) ? data.set.has(value) : data.hash[value];
            return result ? 0 : -1;
        }
        function cachePush(value) {
            var data = this.data;
            if (typeof value == "string" || isObject(value)) {
                data.set.add(value);
            } else {
                data.hash[value] = true;
            }
        }
        function arrayCopy(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }
        function arrayEach(array, iteratee) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEachRight(array, iteratee) {
            var length = array.length;
            while (length--) {
                if (iteratee(array[length], length, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEvery(array, predicate) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (!predicate(array[index], index, array)) {
                    return false;
                }
            }
            return true;
        }
        function arrayFilter(array, predicate) {
            var index = -1, length = array.length, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        function arrayMap(array, iteratee) {
            var index = -1, length = array.length, result = Array(length);
            while (++index < length) {
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }
        function arrayMax(array) {
            var index = -1, length = array.length, result = NEGATIVE_INFINITY;
            while (++index < length) {
                var value = array[index];
                if (value > result) {
                    result = value;
                }
            }
            return result;
        }
        function arrayMin(array) {
            var index = -1, length = array.length, result = POSITIVE_INFINITY;
            while (++index < length) {
                var value = array[index];
                if (value < result) {
                    result = value;
                }
            }
            return result;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var index = -1, length = array.length;
            if (initFromArray && length) {
                accumulator = array[++index];
            }
            while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
            var length = array.length;
            if (initFromArray && length) {
                accumulator = array[--length];
            }
            while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
            }
            return accumulator;
        }
        function arraySome(array, predicate) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (predicate(array[index], index, array)) {
                    return true;
                }
            }
            return false;
        }
        function assignDefaults(objectValue, sourceValue) {
            return typeof objectValue == "undefined" ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
            return typeof objectValue == "undefined" || !hasOwnProperty.call(object, key) ? sourceValue : objectValue;
        }
        function baseAssign(object, source, customizer) {
            var props = keys(source);
            if (!customizer) {
                return baseCopy(source, object, props);
            }
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
                if ((result === result ? result !== value : value === value) || typeof value == "undefined" && !(key in object)) {
                    object[key] = result;
                }
            }
            return object;
        }
        function baseAt(collection, props) {
            var index = -1, length = collection.length, isArr = isLength(length), propsLength = props.length, result = Array(propsLength);
            while (++index < propsLength) {
                var key = props[index];
                if (isArr) {
                    key = parseFloat(key);
                    result[index] = isIndex(key, length) ? collection[key] : undefined;
                } else {
                    result[index] = collection[key];
                }
            }
            return result;
        }
        function baseCopy(source, object, props) {
            if (!props) {
                props = object;
                object = {};
            }
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index];
                object[key] = source[key];
            }
            return object;
        }
        function baseBindAll(object, methodNames) {
            var index = -1, length = methodNames.length;
            while (++index < length) {
                var key = methodNames[index];
                object[key] = createWrapper(object[key], BIND_FLAG, object);
            }
            return object;
        }
        function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == "function") {
                return typeof thisArg != "undefined" && isBindable(func) ? bindCallback(func, thisArg, argCount) : func;
            }
            if (func == null) {
                return identity;
            }
            if (type == "object") {
                return baseMatches(func);
            }
            return typeof thisArg == "undefined" ? baseProperty(func + "") : baseMatchesProperty(func + "", thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object) : customizer(value);
            }
            if (typeof result != "undefined") {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return arrayCopy(value, result);
                }
            } else {
                var tag = objToString.call(value), isFunc = tag == funcTag;
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return baseCopy(value, result, keys(value));
                    }
                } else {
                    return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
                }
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == value) {
                    return stackB[length];
                }
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
                result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
            });
            return result;
        }
        var baseCreate = function() {
            function Object() {}
            return function(prototype) {
                if (isObject(prototype)) {
                    Object.prototype = prototype;
                    var result = new Object();
                    Object.prototype = null;
                }
                return result || context.Object();
            };
        }();
        function baseDelay(func, wait, args, fromIndex) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function() {
                func.apply(undefined, baseSlice(args, fromIndex));
            }, wait);
        }
        function baseDifference(array, values) {
            var length = array ? array.length : 0, result = [];
            if (!length) {
                return result;
            }
            var index = -1, indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, cache = isCommon && values.length >= 200 ? createCache(values) : null, valuesLength = values.length;
            if (cache) {
                indexOf = cacheIndexOf;
                isCommon = false;
                values = cache;
            }
            outer: while (++index < length) {
                var value = array[index];
                if (isCommon && value === value) {
                    var valuesIndex = valuesLength;
                    while (valuesIndex--) {
                        if (values[valuesIndex] === value) {
                            continue outer;
                        }
                    }
                    result.push(value);
                } else if (indexOf(values, value) < 0) {
                    result.push(value);
                }
            }
            return result;
        }
        function baseEach(collection, iteratee) {
            var length = collection ? collection.length : 0;
            if (!isLength(length)) {
                return baseForOwn(collection, iteratee);
            }
            var index = -1, iterable = toObject(collection);
            while (++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                    break;
                }
            }
            return collection;
        }
        function baseEachRight(collection, iteratee) {
            var length = collection ? collection.length : 0;
            if (!isLength(length)) {
                return baseForOwnRight(collection, iteratee);
            }
            var iterable = toObject(collection);
            while (length--) {
                if (iteratee(iterable[length], length, iterable) === false) {
                    break;
                }
            }
            return collection;
        }
        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function(value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }
        function baseFill(array, value, start, end) {
            var length = array.length;
            start = start == null ? 0 : +start || 0;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = typeof end == "undefined" || end > length ? length : +end || 0;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end >>> 0;
            start >>>= 0;
            while (start < length) {
                array[start++] = value;
            }
            return array;
        }
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function(value, index, collection) {
                if (predicate(value, index, collection)) {
                    result.push(value);
                }
            });
            return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
            var result;
            eachFunc(collection, function(value, key, collection) {
                if (predicate(value, key, collection)) {
                    result = retKey ? key : value;
                    return false;
                }
            });
            return result;
        }
        function baseFlatten(array, isDeep, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array.length, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
                    if (isDeep) {
                        value = baseFlatten(value, isDeep, isStrict);
                    }
                    var valIndex = -1, valLength = value.length;
                    result.length += valLength;
                    while (++valIndex < valLength) {
                        result[++resIndex] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        function baseFor(object, iteratee, keysFunc) {
            var index = -1, iterable = toObject(object), props = keysFunc(object), length = props.length;
            while (++index < length) {
                var key = props[index];
                if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                }
            }
            return object;
        }
        function baseForRight(object, iteratee, keysFunc) {
            var iterable = toObject(object), props = keysFunc(object), length = props.length;
            while (length--) {
                var key = props[length];
                if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                }
            }
            return object;
        }
        function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
            return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
            var index = -1, length = props.length, resIndex = -1, result = [];
            while (++index < length) {
                var key = props[index];
                if (isFunction(object[key])) {
                    result[++resIndex] = key;
                }
            }
            return result;
        }
        function baseInvoke(collection, methodName, args) {
            var index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = isLength(length) ? Array(length) : [];
            baseEach(collection, function(value) {
                var func = isFunc ? methodName : value != null && value[methodName];
                result[++index] = func ? func.apply(value, args) : undefined;
            });
            return result;
        }
        function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
            if (value === other) {
                return value !== 0 || 1 / value == 1 / other;
            }
            var valType = typeof value, othType = typeof other;
            if (valType != "function" && valType != "object" && othType != "function" && othType != "object" || value == null || other == null) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
            if (!objIsArr) {
                objTag = objToString.call(object);
                if (objTag == argsTag) {
                    objTag = objectTag;
                } else if (objTag != objectTag) {
                    objIsArr = isTypedArray(object);
                }
            }
            if (!othIsArr) {
                othTag = objToString.call(other);
                if (othTag == argsTag) {
                    othTag = objectTag;
                } else if (othTag != objectTag) {
                    othIsArr = isTypedArray(other);
                }
            }
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && !(objIsArr || objIsObj)) {
                return equalByTag(object, other, objTag);
            }
            var valWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (valWrapped || othWrapped) {
                return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
            }
            if (!isSameTag) {
                return false;
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == object) {
                    return stackB[length] == other;
                }
            }
            stackA.push(object);
            stackB.push(other);
            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);
            stackA.pop();
            stackB.pop();
            return result;
        }
        function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
            var length = props.length;
            if (object == null) {
                return !length;
            }
            var index = -1, noCustomizer = !customizer;
            while (++index < length) {
                if (noCustomizer && strictCompareFlags[index] ? values[index] !== object[props[index]] : !hasOwnProperty.call(object, props[index])) {
                    return false;
                }
            }
            index = -1;
            while (++index < length) {
                var key = props[index];
                if (noCustomizer && strictCompareFlags[index]) {
                    var result = hasOwnProperty.call(object, key);
                } else {
                    var objValue = object[key], srcValue = values[index];
                    result = customizer ? customizer(objValue, srcValue, key) : undefined;
                    if (typeof result == "undefined") {
                        result = baseIsEqual(srcValue, objValue, customizer, true);
                    }
                }
                if (!result) {
                    return false;
                }
            }
            return true;
        }
        function baseMap(collection, iteratee) {
            var result = [];
            baseEach(collection, function(value, key, collection) {
                result.push(iteratee(value, key, collection));
            });
            return result;
        }
        function baseMatches(source) {
            var props = keys(source), length = props.length;
            if (length == 1) {
                var key = props[0], value = source[key];
                if (isStrictComparable(value)) {
                    return function(object) {
                        return object != null && object[key] === value && hasOwnProperty.call(object, key);
                    };
                }
            }
            var values = Array(length), strictCompareFlags = Array(length);
            while (length--) {
                value = source[props[length]];
                values[length] = value;
                strictCompareFlags[length] = isStrictComparable(value);
            }
            return function(object) {
                return baseIsMatch(object, props, values, strictCompareFlags);
            };
        }
        function baseMatchesProperty(key, value) {
            if (isStrictComparable(value)) {
                return function(object) {
                    return object != null && object[key] === value;
                };
            }
            return function(object) {
                return object != null && baseIsEqual(value, object[key], null, true);
            };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
                return object;
            }
            var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
            (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
                if (isObjectLike(srcValue)) {
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                }
                var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = typeof result == "undefined";
                if (isCommon) {
                    result = srcValue;
                }
                if ((isSrcArr || typeof result != "undefined") && (isCommon || (result === result ? result !== value : value === value))) {
                    object[key] = result;
                }
            });
            return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length, srcValue = source[key];
            while (length--) {
                if (stackA[length] == srcValue) {
                    object[key] = stackB[length];
                    return;
                }
            }
            var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = typeof result == "undefined";
            if (isCommon) {
                result = srcValue;
                if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
                    result = isArray(value) ? value : value ? arrayCopy(value) : [];
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {};
                } else {
                    isCommon = false;
                }
            }
            stackA.push(srcValue);
            stackB.push(result);
            if (isCommon) {
                object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? result !== value : value === value) {
                object[key] = result;
            }
        }
        function baseProperty(key) {
            return function(object) {
                return object == null ? undefined : object[key];
            };
        }
        function basePullAt(array, indexes) {
            var length = indexes.length, result = baseAt(array, indexes);
            indexes.sort(baseCompareAscending);
            while (length--) {
                var index = parseFloat(indexes[length]);
                if (index != previous && isIndex(index)) {
                    var previous = index;
                    splice.call(array, index, 1);
                }
            }
            return result;
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function(value, index, collection) {
                accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
        };
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            start = start == null ? 0 : +start || 0;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = typeof end == "undefined" || end > length ? length : +end || 0;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
                result[index] = array[index + start];
            }
            return result;
        }
        function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function(value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }
        function baseUniq(array, iteratee) {
            var index = -1, indexOf = getIndexOf(), length = array.length, isCommon = indexOf == baseIndexOf, isLarge = isCommon && length >= 200, seen = isLarge ? createCache() : null, result = [];
            if (seen) {
                indexOf = cacheIndexOf;
                isCommon = false;
            } else {
                isLarge = false;
                seen = iteratee ? [] : result;
            }
            outer: while (++index < length) {
                var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                if (isCommon && value === value) {
                    var seenIndex = seen.length;
                    while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                            continue outer;
                        }
                    }
                    if (iteratee) {
                        seen.push(computed);
                    }
                    result.push(value);
                } else if (indexOf(seen, computed) < 0) {
                    if (iteratee || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            return result;
        }
        function baseValues(object, props) {
            var index = -1, length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
                result = result.value();
            }
            var index = -1, length = actions.length;
            while (++index < length) {
                var args = [ result ], action = actions[index];
                push.apply(args, action.args);
                result = action.func.apply(action.thisArg, args);
            }
            return result;
        }
        function binaryIndex(array, value, retHighest) {
            var low = 0, high = array ? array.length : low;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (retHighest ? computed <= value : computed < value) {
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }
                return high;
            }
            return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsUndef = typeof value == "undefined";
            while (low < high) {
                var mid = floor((low + high) / 2), computed = iteratee(array[mid]), isReflexive = computed === computed;
                if (valIsNaN) {
                    var setLow = isReflexive || retHighest;
                } else if (valIsUndef) {
                    setLow = isReflexive && (retHighest || typeof computed != "undefined");
                } else {
                    setLow = retHighest ? computed <= value : computed < value;
                }
                if (setLow) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
            if (typeof func != "function") {
                return identity;
            }
            if (typeof thisArg == "undefined") {
                return func;
            }
            switch (argCount) {
              case 1:
                return function(value) {
                    return func.call(thisArg, value);
                };

              case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };

              case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };

              case 5:
                return function(value, other, key, object, source) {
                    return func.call(thisArg, value, other, key, object, source);
                };
            }
            return function() {
                return func.apply(thisArg, arguments);
            };
        }
        function bufferClone(buffer) {
            return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
            bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
                var byteLength = buffer.byteLength, floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0, offset = floatLength * FLOAT64_BYTES_PER_ELEMENT, result = new ArrayBuffer(byteLength);
                if (floatLength) {
                    var view = new Float64Array(result, 0, floatLength);
                    view.set(new Float64Array(buffer, 0, floatLength));
                }
                if (byteLength != offset) {
                    view = new Uint8Array(result, offset);
                    view.set(new Uint8Array(buffer, offset));
                }
                return result;
            };
        }
        function composeArgs(args, partials, holders) {
            var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(argsLength + leftLength);
            while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
                result[holders[argsIndex]] = args[argsIndex];
            }
            while (argsLength--) {
                result[leftIndex++] = args[argsIndex++];
            }
            return result;
        }
        function composeArgsRight(args, partials, holders) {
            var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength);
            while (++argsIndex < argsLength) {
                result[argsIndex] = args[argsIndex];
            }
            var pad = argsIndex;
            while (++rightIndex < rightLength) {
                result[pad + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
                result[pad + holders[holdersIndex]] = args[argsIndex++];
            }
            return result;
        }
        function createAggregator(setter, initializer) {
            return function(collection, iteratee, thisArg) {
                var result = initializer ? initializer() : {};
                iteratee = getCallback(iteratee, thisArg, 3);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, iteratee(value, index, collection), collection);
                    }
                } else {
                    baseEach(collection, function(value, key, collection) {
                        setter(result, value, iteratee(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createAssigner(assigner) {
            return function() {
                var length = arguments.length, object = arguments[0];
                if (length < 2 || object == null) {
                    return object;
                }
                if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
                    length = 2;
                }
                if (length > 3 && typeof arguments[length - 2] == "function") {
                    var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
                } else if (length > 2 && typeof arguments[length - 1] == "function") {
                    customizer = arguments[--length];
                }
                var index = 0;
                while (++index < length) {
                    var source = arguments[index];
                    if (source) {
                        assigner(object, source, customizer);
                    }
                }
                return object;
            };
        }
        function createBindWrapper(func, thisArg) {
            var Ctor = createCtorWrapper(func);
            function wrapper() {
                return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
            }
            return wrapper;
        }
        var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
            return new SetCache(values);
        };
        function createCompounder(callback) {
            return function(string) {
                var index = -1, array = words(deburr(string)), length = array.length, result = "";
                while (++index < length) {
                    result = callback(result, array[index], index);
                }
                return result;
            };
        }
        function createCtorWrapper(Ctor) {
            return function() {
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, arguments);
                return isObject(result) ? result : thisBinding;
            };
        }
        function createExtremum(arrayFunc, isMin) {
            return function(collection, iteratee, thisArg) {
                if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                    iteratee = null;
                }
                var func = getCallback(), noIteratee = iteratee == null;
                if (!(func === baseCallback && noIteratee)) {
                    noIteratee = false;
                    iteratee = func(iteratee, thisArg, 3);
                }
                if (noIteratee) {
                    var isArr = isArray(collection);
                    if (!isArr && isString(collection)) {
                        iteratee = charAtCallback;
                    } else {
                        return arrayFunc(isArr ? collection : toIterable(collection));
                    }
                }
                return extremumBy(collection, iteratee, isMin);
            };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG;
            var Ctor = !isBindKey && createCtorWrapper(func), key = func;
            function wrapper() {
                var length = arguments.length, index = length, args = Array(length);
                while (index--) {
                    args[index] = arguments[index];
                }
                if (partials) {
                    args = composeArgs(args, partials, holders);
                }
                if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight);
                }
                if (isCurry || isCurryRight) {
                    var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
                    length -= argsHolders.length;
                    if (length < arity) {
                        var newArgPos = argPos ? arrayCopy(argPos) : null, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : null, newHoldersRight = isCurry ? null : argsHolders, newPartials = isCurry ? args : null, newPartialsRight = isCurry ? null : args;
                        bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                        if (!isCurryBound) {
                            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                        }
                        var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
                        result.placeholder = placeholder;
                        return result;
                    }
                }
                var thisBinding = isBind ? thisArg : this;
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (argPos) {
                    args = reorder(args, argPos);
                }
                if (isAry && ary < args.length) {
                    args.length = ary;
                }
                return (this instanceof wrapper ? Ctor || createCtorWrapper(func) : func).apply(thisBinding, args);
            }
            return wrapper;
        }
        function createPad(string, length, chars) {
            var strLength = string.length;
            length = +length;
            if (strLength >= length || !nativeIsFinite(length)) {
                return "";
            }
            var padLength = length - strLength;
            chars = chars == null ? " " : chars + "";
            return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(argsLength + leftLength);
                while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                }
                while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                }
                return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
            }
            return wrapper;
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = null;
            }
            length -= holders ? holders.length : 0;
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = null;
            }
            var data = !isBindKey && getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
            if (data && data !== true) {
                mergeData(newData, data);
                bitmask = newData[1];
                arity = newData[9];
            }
            newData[9] = arity == null ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0;
            if (bitmask == BIND_FLAG) {
                var result = createBindWrapper(newData[0], newData[2]);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                result = createPartialWrapper.apply(undefined, newData);
            } else {
                result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
            var index = -1, arrLength = array.length, othLength = other.length, result = true;
            if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
                return false;
            }
            while (result && ++index < arrLength) {
                var arrValue = array[index], othValue = other[index];
                result = undefined;
                if (customizer) {
                    result = isWhere ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
                }
                if (typeof result == "undefined") {
                    if (isWhere) {
                        var othIndex = othLength;
                        while (othIndex--) {
                            othValue = other[othIndex];
                            result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                            if (result) {
                                break;
                            }
                        }
                    } else {
                        result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
                    }
                }
            }
            return !!result;
        }
        function equalByTag(object, other, tag) {
            switch (tag) {
              case boolTag:
              case dateTag:
                return +object == +other;

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case numberTag:
                return object != +object ? other != +other : object == 0 ? 1 / object == 1 / other : object == +other;

              case regexpTag:
              case stringTag:
                return object == other + "";
            }
            return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
            var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
            if (objLength != othLength && !isWhere) {
                return false;
            }
            var hasCtor, index = -1;
            while (++index < objLength) {
                var key = objProps[index], result = hasOwnProperty.call(other, key);
                if (result) {
                    var objValue = object[key], othValue = other[key];
                    result = undefined;
                    if (customizer) {
                        result = isWhere ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
                    }
                    if (typeof result == "undefined") {
                        result = objValue && objValue === othValue || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
                    }
                }
                if (!result) {
                    return false;
                }
                hasCtor || (hasCtor = key == "constructor");
            }
            if (!hasCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    return false;
                }
            }
            return true;
        }
        function extremumBy(collection, iteratee, isMin) {
            var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY, computed = exValue, result = computed;
            baseEach(collection, function(value, index, collection) {
                var current = iteratee(value, index, collection);
                if ((isMin ? current < computed : current > computed) || current === exValue && current === result) {
                    computed = current;
                    result = value;
                }
            });
            return result;
        }
        function getCallback(func, thisArg, argCount) {
            var result = lodash.callback || callback;
            result = result === callback ? baseCallback : result;
            return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
        };
        function getIndexOf(collection, target, fromIndex) {
            var result = lodash.indexOf || indexOf;
            result = result === indexOf ? baseIndexOf : result;
            return collection ? result(collection, target, fromIndex) : result;
        }
        function getView(start, end, transforms) {
            var index = -1, length = transforms ? transforms.length : 0;
            while (++index < length) {
                var data = transforms[index], size = data.size;
                switch (data.type) {
                  case "drop":
                    start += size;
                    break;

                  case "dropRight":
                    end -= size;
                    break;

                  case "take":
                    end = nativeMin(end, start + size);
                    break;

                  case "takeRight":
                    start = nativeMax(start, end - size);
                    break;
                }
            }
            return {
                start: start,
                end: end
            };
        }
        function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        function initCloneObject(object) {
            var Ctor = object.constructor;
            if (!(typeof Ctor == "function" && Ctor instanceof Ctor)) {
                Ctor = Object;
            }
            return new Ctor();
        }
        function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return bufferClone(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                var buffer = object.buffer;
                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                var result = new Ctor(object.source, reFlags.exec(object));
                result.lastIndex = object.lastIndex;
            }
            return result;
        }
        function isBindable(func) {
            var support = lodash.support, result = !(support.funcNames ? func.name : support.funcDecomp);
            if (!result) {
                var source = fnToString.call(func);
                if (!support.funcNames) {
                    result = !reFuncName.test(source);
                }
                if (!result) {
                    result = reThis.test(source) || isNative(func);
                    baseSetData(func, result);
                }
            }
            return result;
        }
        function isIndex(value, length) {
            value = +value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == "number") {
                var length = object.length, prereq = isLength(length) && isIndex(index, length);
            } else {
                prereq = type == "string" && index in object;
            }
            if (prereq) {
                var other = object[index];
                return value === value ? value === other : other !== other;
            }
            return false;
        }
        function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
            return value === value && (value === 0 ? 1 / value > 0 : !isObject(value));
        }
        function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask;
            var arityFlags = ARY_FLAG | REARG_FLAG, bindFlags = BIND_FLAG | BIND_KEY_FLAG, comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;
            var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG), isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG), argPos = (isRearg ? data : source)[7], ary = (isAry ? data : source)[8];
            var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) && !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);
            var isCombo = newBitmask >= arityFlags && newBitmask <= comboFlags && (bitmask < REARG_FLAG || (isRearg || isAry) && argPos.length <= ary);
            if (!(isCommon || isCombo)) {
                return data;
            }
            if (srcBitmask & BIND_FLAG) {
                data[2] = source[2];
                newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
            }
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
            }
            value = source[7];
            if (value) {
                data[7] = arrayCopy(value);
            }
            if (srcBitmask & ARY_FLAG) {
                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
                data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
        }
        function pickByArray(object, props) {
            object = toObject(object);
            var index = -1, length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                if (key in object) {
                    result[key] = object[key];
                }
            }
            return result;
        }
        function pickByCallback(object, predicate) {
            var result = {};
            baseForIn(object, function(value, key, object) {
                if (predicate(value, key, object)) {
                    result[key] = value;
                }
            });
            return result;
        }
        function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array);
            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        var setData = function() {
            var count = 0, lastCalled = 0;
            return function(key, value) {
                var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return key;
                    }
                } else {
                    count = 0;
                }
                return baseSetData(key, value);
            };
        }();
        function shimIsPlainObject(value) {
            var Ctor, support = lodash.support;
            if (!(isObjectLike(value) && objToString.call(value) == objectTag) || !hasOwnProperty.call(value, "constructor") && (Ctor = value.constructor, 
            typeof Ctor == "function" && !(Ctor instanceof Ctor))) {
                return false;
            }
            var result;
            baseForIn(value, function(subValue, key) {
                result = key;
            });
            return typeof result == "undefined" || hasOwnProperty.call(value, result);
        }
        function shimKeys(object) {
            var props = keysIn(object), propsLength = props.length, length = propsLength && object.length, support = lodash.support;
            var allowIndexes = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object));
            var index = -1, result = [];
            while (++index < propsLength) {
                var key = props[index];
                if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
                    result.push(key);
                }
            }
            return result;
        }
        function toIterable(value) {
            if (value == null) {
                return [];
            }
            if (!isLength(value.length)) {
                return values(value);
            }
            return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
            return isObject(value) ? value : Object(value);
        }
        function wrapperClone(wrapper) {
            return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size == null) {
                size = 1;
            } else {
                size = nativeMax(+size || 1, 1);
            }
            var index = 0, length = array ? array.length : 0, resIndex = -1, result = Array(ceil(length / size));
            while (index < length) {
                result[++resIndex] = baseSlice(array, index, index += size);
            }
            return result;
        }
        function compact(array) {
            var index = -1, length = array ? array.length : 0, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        function difference() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var value = arguments[index];
                if (isArray(value) || isArguments(value)) {
                    break;
                }
            }
            return baseDifference(value, baseFlatten(arguments, false, true, ++index));
        }
        function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            predicate = getCallback(predicate, thisArg, 3);
            while (length-- && predicate(array[length], length, array)) {}
            return baseSlice(array, 0, length + 1);
        }
        function dropWhile(array, predicate, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            var index = -1;
            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length && predicate(array[index], index, array)) {}
            return baseSlice(array, index);
        }
        function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                start = 0;
                end = length;
            }
            return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, thisArg) {
            var index = -1, length = array ? array.length : 0;
            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length) {
                if (predicate(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }
        function findLastIndex(array, predicate, thisArg) {
            var length = array ? array.length : 0;
            predicate = getCallback(predicate, thisArg, 3);
            while (length--) {
                if (predicate(array[length], length, array)) {
                    return length;
                }
            }
            return -1;
        }
        function first(array) {
            return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
                isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            if (typeof fromIndex == "number") {
                fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
            } else if (fromIndex) {
                var index = binaryIndex(array, value), other = array[index];
                return (value === value ? value === other : other !== other) ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array) {
            return dropRight(array, 1);
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = [], indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf;
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArray(value) || isArguments(value)) {
                    args.push(value);
                    caches.push(isCommon && value.length >= 120 ? createCache(argsIndex && value) : null);
                }
            }
            argsLength = args.length;
            var array = args[0], index = -1, length = array ? array.length : 0, result = [], seen = caches[0];
            outer: while (++index < length) {
                value = array[index];
                if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
                    argsIndex = argsLength;
                    while (--argsIndex) {
                        var cache = caches[argsIndex];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                            continue outer;
                        }
                    }
                    if (seen) {
                        seen.push(value);
                    }
                    result.push(value);
                }
            }
            return result;
        }
        function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            var index = length;
            if (typeof fromIndex == "number") {
                index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
            } else if (fromIndex) {
                index = binaryIndex(array, value, true) - 1;
                var other = array[index];
                return (value === value ? value === other : other !== other) ? index : -1;
            }
            if (value !== value) {
                return indexOfNaN(array, index, true);
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull() {
            var array = arguments[0];
            if (!(array && array.length)) {
                return array;
            }
            var index = 0, indexOf = getIndexOf(), length = arguments.length;
            while (++index < length) {
                var fromIndex = 0, value = arguments[index];
                while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                    splice.call(array, fromIndex, 1);
                }
            }
            return array;
        }
        function pullAt(array) {
            return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
        }
        function remove(array, predicate, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result.push(value);
                    splice.call(array, index--, 1);
                    length--;
                }
            }
            return result;
        }
        function rest(array) {
            return drop(array, 1);
        }
        function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                start = 0;
                end = length;
            }
            return baseSlice(array, start, end);
        }
        function sortedIndex(array, value, iteratee, thisArg) {
            var func = getCallback(iteratee);
            return func === baseCallback && iteratee == null ? binaryIndex(array, value) : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
        }
        function sortedLastIndex(array, value, iteratee, thisArg) {
            var func = getCallback(iteratee);
            return func === baseCallback && iteratee == null ? binaryIndex(array, value, true) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
        }
        function take(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            predicate = getCallback(predicate, thisArg, 3);
            while (length-- && predicate(array[length], length, array)) {}
            return baseSlice(array, length + 1);
        }
        function takeWhile(array, predicate, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            var index = -1;
            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length && predicate(array[index], index, array)) {}
            return baseSlice(array, 0, index);
        }
        function union() {
            return baseUniq(baseFlatten(arguments, false, true));
        }
        function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (isSorted != null && typeof isSorted != "boolean") {
                thisArg = iteratee;
                iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
                isSorted = false;
            }
            var func = getCallback();
            if (!(func === baseCallback && iteratee == null)) {
                iteratee = func(iteratee, thisArg, 3);
            }
            return isSorted && getIndexOf() == baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
            var index = -1, length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0, result = Array(length);
            while (++index < length) {
                result[index] = arrayMap(array, baseProperty(index));
            }
            return result;
        }
        function without(array) {
            return baseDifference(array, baseSlice(arguments, 1));
        }
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArray(array) || isArguments(array)) {
                    var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
                }
            }
            return result ? baseUniq(result) : [];
        }
        function zip() {
            var length = arguments.length, array = Array(length);
            while (length--) {
                array[length] = arguments[length];
            }
            return unzip(array);
        }
        function zipObject(props, values) {
            var index = -1, length = props ? props.length : 0, result = {};
            if (length && !values && !isArray(props[0])) {
                values = [];
            }
            while (++index < length) {
                var key = props[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
        }
        function tap(value, interceptor, thisArg) {
            interceptor.call(thisArg, value);
            return value;
        }
        function thru(value, interceptor, thisArg) {
            return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
            return chain(this);
        }
        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperPlant(value) {
            var result, parent = this;
            while (parent instanceof baseLodash) {
                var clone = wrapperClone(parent);
                if (result) {
                    previous.__wrapped__ = clone;
                } else {
                    result = clone;
                }
                var previous = clone;
                parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
        }
        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                if (this.__actions__.length) {
                    value = new LazyWrapper(this);
                }
                return new LodashWrapper(value.reverse(), this.__chain__);
            }
            return this.thru(function(value) {
                return value.reverse();
            });
        }
        function wrapperToString() {
            return this.value() + "";
        }
        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        function at(collection) {
            var length = collection ? collection.length : 0;
            if (isLength(length)) {
                collection = toIterable(collection);
            }
            return baseAt(collection, baseFlatten(arguments, false, false, 1));
        }
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
        });
        function every(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (typeof predicate != "function" || typeof thisArg != "undefined") {
                predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, predicate);
        }
        function find(collection, predicate, thisArg) {
            if (isArray(collection)) {
                var index = findIndex(collection, predicate, thisArg);
                return index > -1 ? collection[index] : undefined;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(collection, predicate, baseEach);
        }
        function findLast(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(collection, predicate, baseEachRight);
        }
        function findWhere(collection, source) {
            return find(collection, baseMatches(source));
        }
        function forEach(collection, iteratee, thisArg) {
            return typeof iteratee == "function" && typeof thisArg == "undefined" && isArray(collection) ? arrayEach(collection, iteratee) : baseEach(collection, bindCallback(iteratee, thisArg, 3));
        }
        function forEachRight(collection, iteratee, thisArg) {
            return typeof iteratee == "function" && typeof thisArg == "undefined" && isArray(collection) ? arrayEachRight(collection, iteratee) : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
        }
        var groupBy = createAggregator(function(result, value, key) {
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                result[key] = [ value ];
            }
        });
        function includes(collection, target, fromIndex) {
            var length = collection ? collection.length : 0;
            if (!isLength(length)) {
                collection = values(collection);
                length = collection.length;
            }
            if (!length) {
                return false;
            }
            if (typeof fromIndex == "number") {
                fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
            } else {
                fromIndex = 0;
            }
            return typeof collection == "string" || !isArray(collection) && isString(collection) ? fromIndex < length && collection.indexOf(target, fromIndex) > -1 : getIndexOf(collection, target, fromIndex) > -1;
        }
        var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
        });
        function invoke(collection, methodName) {
            return baseInvoke(collection, methodName, baseSlice(arguments, 2));
        }
        function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = getCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
        }
        var max = createExtremum(arrayMax);
        var min = createExtremum(arrayMin, true);
        var partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function() {
            return [ [], [] ];
        });
        function pluck(collection, key) {
            return map(collection, baseProperty(key));
        }
        function reduce(collection, iteratee, accumulator, thisArg) {
            var func = isArray(collection) ? arrayReduce : baseReduce;
            return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator, thisArg) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce;
            return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
        }
        function reject(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, function(value, index, collection) {
                return !predicate(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                collection = toIterable(collection);
                var length = collection.length;
                return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(n < 0 ? 0 : +n || 0, result.length);
            return result;
        }
        function shuffle(collection) {
            collection = toIterable(collection);
            var index = -1, length = collection.length, result = Array(length);
            while (++index < length) {
                var rand = baseRandom(0, index);
                if (index != rand) {
                    result[index] = result[rand];
                }
                result[rand] = collection[index];
            }
            return result;
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (typeof predicate != "function" || typeof thisArg != "undefined") {
                predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
            var index = -1, length = collection ? collection.length : 0, result = isLength(length) ? Array(length) : [];
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = null;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            baseEach(collection, function(value, key, collection) {
                result[++index] = {
                    criteria: iteratee(value, key, collection),
                    index: index,
                    value: value
                };
            });
            return baseSortBy(result, compareAscending);
        }
        function sortByAll(collection) {
            var args = arguments;
            if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
                args = [ collection, args[1] ];
            }
            var index = -1, length = collection ? collection.length : 0, props = baseFlatten(args, false, false, 1), result = isLength(length) ? Array(length) : [];
            baseEach(collection, function(value) {
                var length = props.length, criteria = Array(length);
                while (length--) {
                    criteria[length] = value == null ? undefined : value[props[length]];
                }
                result[++index] = {
                    criteria: criteria,
                    index: index,
                    value: value
                };
            });
            return baseSortBy(result, compareMultipleAscending);
        }
        function where(collection, source) {
            return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
            return new Date().getTime();
        };
        function after(n, func) {
            if (typeof func != "function") {
                if (typeof n == "function") {
                    var temp = n;
                    n = func;
                    func = temp;
                } else {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
            }
            n = nativeIsFinite(n = +n) ? n : 0;
            return function() {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function ary(func, n, guard) {
            if (guard && isIterateeCall(func, n, guard)) {
                n = null;
            }
            n = func && n == null ? func.length : nativeMax(+n || 0, 0);
            return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
        function before(n, func) {
            var result;
            if (typeof func != "function") {
                if (typeof n == "function") {
                    var temp = n;
                    n = func;
                    func = temp;
                } else {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
            }
            return function() {
                if (--n > 0) {
                    result = func.apply(this, arguments);
                } else {
                    func = null;
                }
                return result;
            };
        }
        function bind(func, thisArg) {
            var bitmask = BIND_FLAG;
            if (arguments.length > 2) {
                var partials = baseSlice(arguments, 2), holders = replaceHolders(partials, bind.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
        }
        function bindAll(object) {
            return baseBindAll(object, arguments.length > 1 ? baseFlatten(arguments, false, false, 1) : functions(object));
        }
        function bindKey(object, key) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (arguments.length > 2) {
                var partials = baseSlice(arguments, 2), holders = replaceHolders(partials, bindKey.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
        }
        function curry(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
                arity = null;
            }
            var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
            result.placeholder = curry.placeholder;
            return result;
        }
        function curryRight(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
                arity = null;
            }
            var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
            result.placeholder = curryRight.placeholder;
            return result;
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = wait < 0 ? 0 : +wait || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = "maxWait" in options && nativeMax(+options.maxWait || 0, wait);
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            function cancel() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                if (maxTimeoutId) {
                    clearTimeout(maxTimeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
            }
            function delayed() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0 || remaining > wait) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            }
            function maxDelayed() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            }
            function debounced() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            }
            debounced.cancel = cancel;
            return debounced;
        }
        function defer(func) {
            return baseDelay(func, 1, arguments, 1);
        }
        function delay(func, wait) {
            return baseDelay(func, wait, arguments, 2);
        }
        function flow() {
            var funcs = arguments, length = funcs.length;
            if (!length) {
                return function() {
                    return arguments[0];
                };
            }
            if (!arrayEvery(funcs, baseIsFunction)) {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function() {
                var index = 0, result = funcs[index].apply(this, arguments);
                while (++index < length) {
                    result = funcs[index].call(this, result);
                }
                return result;
            };
        }
        function flowRight() {
            var funcs = arguments, fromIndex = funcs.length - 1;
            if (fromIndex < 0) {
                return function() {
                    return arguments[0];
                };
            }
            if (!arrayEvery(funcs, baseIsFunction)) {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function() {
                var index = fromIndex, result = funcs[index].apply(this, arguments);
                while (index--) {
                    result = funcs[index].call(this, result);
                }
                return result;
            };
        }
        function memoize(func, resolver) {
            if (typeof func != "function" || resolver && typeof resolver != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : arguments[0];
                if (cache.has(key)) {
                    return cache.get(key);
                }
                var result = func.apply(this, arguments);
                cache.set(key, result);
                return result;
            };
            memoized.cache = new memoize.Cache();
            return memoized;
        }
        function negate(predicate) {
            if (typeof predicate != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function() {
                return !predicate.apply(this, arguments);
            };
        }
        function once(func) {
            return before(func, 2);
        }
        function partial(func) {
            var partials = baseSlice(arguments, 1), holders = replaceHolders(partials, partial.placeholder);
            return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
        }
        function partialRight(func) {
            var partials = baseSlice(arguments, 1), holders = replaceHolders(partials, partialRight.placeholder);
            return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
        }
        function rearg(func) {
            var indexes = baseFlatten(arguments, false, false, 1);
            return createWrapper(func, REARG_FLAG, null, null, null, indexes);
        }
        function spread(func) {
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function(array) {
                return func.apply(this, array);
            };
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = +wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return createWrapper(wrapper, PARTIAL_FLAG, null, [ value ], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
            if (isDeep && typeof isDeep != "boolean" && isIterateeCall(value, isDeep, customizer)) {
                isDeep = false;
            } else if (typeof isDeep == "function") {
                thisArg = customizer;
                customizer = isDeep;
                isDeep = false;
            }
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 1);
            return baseClone(value, isDeep, customizer);
        }
        function cloneDeep(value, customizer, thisArg) {
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 1);
            return baseClone(value, true, customizer);
        }
        function isArguments(value) {
            var length = isObjectLike(value) ? value.length : undefined;
            return isLength(length) && objToString.call(value) == argsTag || false;
        }
        var isArray = nativeIsArray || function(value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag || false;
        };
        function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag || false;
        }
        function isDate(value) {
            return isObjectLike(value) && objToString.call(value) == dateTag || false;
        }
        function isElement(value) {
            return value && value.nodeType === 1 && isObjectLike(value) && objToString.call(value).indexOf("Element") > -1 || false;
        }
        if (!support.dom) {
            isElement = function(value) {
                return value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value) || false;
            };
        }
        function isEmpty(value) {
            if (value == null) {
                return true;
            }
            var length = value.length;
            if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) {
                return !length;
            }
            return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 3);
            if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
                return value === other;
            }
            var result = customizer ? customizer(value, other) : undefined;
            return typeof result == "undefined" ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
            return isObjectLike(value) && typeof value.message == "string" && objToString.call(value) == errorTag || false;
        }
        var isFinite = nativeNumIsFinite || function(value) {
            return typeof value == "number" && nativeIsFinite(value);
        };
        var isFunction = !(baseIsFunction(/x/) || Uint8Array && !baseIsFunction(Uint8Array)) ? baseIsFunction : function(value) {
            return objToString.call(value) == funcTag;
        };
        function isObject(value) {
            var type = typeof value;
            return type == "function" || value && type == "object" || false;
        }
        function isMatch(object, source, customizer, thisArg) {
            var props = keys(source), length = props.length;
            customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 3);
            if (!customizer && length == 1) {
                var key = props[0], value = source[key];
                if (isStrictComparable(value)) {
                    return object != null && value === object[key] && hasOwnProperty.call(object, key);
                }
            }
            var values = Array(length), strictCompareFlags = Array(length);
            while (length--) {
                value = values[length] = source[props[length]];
                strictCompareFlags[length] = isStrictComparable(value);
            }
            return baseIsMatch(object, props, values, strictCompareFlags, customizer);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNative(value) {
            if (value == null) {
                return false;
            }
            if (objToString.call(value) == funcTag) {
                return reNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reHostCtor.test(value) || false;
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && objToString.call(value) == numberTag || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && objToString.call(value) == objectTag)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return isObjectLike(value) && objToString.call(value) == regexpTag || false;
        }
        function isString(value) {
            return typeof value == "string" || isObjectLike(value) && objToString.call(value) == stringTag || false;
        }
        function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)] || false;
        }
        function isUndefined(value) {
            return typeof value == "undefined";
        }
        function toArray(value) {
            var length = value ? value.length : 0;
            if (!isLength(length)) {
                return values(value);
            }
            if (!length) {
                return [];
            }
            return arrayCopy(value);
        }
        function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
        }
        var assign = createAssigner(baseAssign);
        function create(prototype, properties, guard) {
            var result = baseCreate(prototype);
            if (guard && isIterateeCall(prototype, properties, guard)) {
                properties = null;
            }
            return properties ? baseCopy(properties, result, keys(properties)) : result;
        }
        function defaults(object) {
            if (object == null) {
                return object;
            }
            var args = arrayCopy(arguments);
            args.push(assignDefaults);
            return assign.apply(undefined, args);
        }
        function findKey(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, baseForOwn, true);
        }
        function findLastKey(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, baseForOwnRight, true);
        }
        function forIn(object, iteratee, thisArg) {
            if (typeof iteratee != "function" || typeof thisArg != "undefined") {
                iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return baseFor(object, iteratee, keysIn);
        }
        function forInRight(object, iteratee, thisArg) {
            iteratee = bindCallback(iteratee, thisArg, 3);
            return baseForRight(object, iteratee, keysIn);
        }
        function forOwn(object, iteratee, thisArg) {
            if (typeof iteratee != "function" || typeof thisArg != "undefined") {
                iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return baseForOwn(object, iteratee);
        }
        function forOwnRight(object, iteratee, thisArg) {
            iteratee = bindCallback(iteratee, thisArg, 3);
            return baseForRight(object, iteratee, keys);
        }
        function functions(object) {
            return baseFunctions(object, keysIn(object));
        }
        function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object, multiValue, guard) {
            if (guard && isIterateeCall(object, multiValue, guard)) {
                multiValue = null;
            }
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index], value = object[key];
                if (multiValue) {
                    if (hasOwnProperty.call(result, value)) {
                        result[value].push(key);
                    } else {
                        result[value] = [ key ];
                    }
                } else {
                    result[value] = key;
                }
            }
            return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
            if (object) {
                var Ctor = object.constructor, length = object.length;
            }
            if (typeof Ctor == "function" && Ctor.prototype === object || typeof object != "function" && (length && isLength(length))) {
                return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
            if (object == null) {
                return [];
            }
            if (!isObject(object)) {
                object = Object(object);
            }
            var length = object.length;
            length = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)) && length || 0;
            var Ctor = object.constructor, index = -1, isProto = typeof Ctor == "function" && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
            while (++index < length) {
                result[index] = index + "";
            }
            for (var key in object) {
                if (!(skipIndexes && isIndex(key, length)) && !(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }
        function mapValues(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
            baseForOwn(object, function(value, key, object) {
                result[key] = iteratee(value, key, object);
            });
            return result;
        }
        var merge = createAssigner(baseMerge);
        function omit(object, predicate, thisArg) {
            if (object == null) {
                return {};
            }
            if (typeof predicate != "function") {
                var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
                return pickByArray(object, baseDifference(keysIn(object), props));
            }
            predicate = bindCallback(predicate, thisArg, 3);
            return pickByCallback(object, function(value, key, object) {
                return !predicate(value, key, object);
            });
        }
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [ key, object[key] ];
            }
            return result;
        }
        function pick(object, predicate, thisArg) {
            if (object == null) {
                return {};
            }
            return typeof predicate == "function" ? pickByCallback(object, bindCallback(predicate, thisArg, 3)) : pickByArray(object, baseFlatten(arguments, false, false, 1));
        }
        function result(object, key, defaultValue) {
            var value = object == null ? undefined : object[key];
            if (typeof value == "undefined") {
                value = defaultValue;
            }
            return isFunction(value) ? value.call(object) : value;
        }
        function transform(object, iteratee, accumulator, thisArg) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getCallback(iteratee, thisArg, 4);
            if (accumulator == null) {
                if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) {
                        accumulator = isArray(object) ? new Ctor() : [];
                    } else {
                        accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
                    }
                } else {
                    accumulator = {};
                }
            }
            (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                return iteratee(accumulator, value, index, object);
            });
            return accumulator;
        }
        function values(object) {
            return baseValues(object, keys(object));
        }
        function valuesIn(object) {
            return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
            start = +start || 0;
            if (typeof end === "undefined") {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            return value >= start && value < end;
        }
        function random(min, max, floating) {
            if (floating && isIterateeCall(min, max, floating)) {
                max = floating = null;
            }
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (noMax && typeof min == "boolean") {
                    floating = min;
                    min = 1;
                } else if (typeof max == "boolean") {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
                noMax = false;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
            }
            return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
            word = word.toLowerCase();
            return result + (index ? word.charAt(0).toUpperCase() + word.slice(1) : word);
        });
        function capitalize(string) {
            string = baseToString(string);
            return string && string.charAt(0).toUpperCase() + string.slice(1);
        }
        function deburr(string) {
            string = baseToString(string);
            return string && string.replace(reLatin1, deburrLetter);
        }
        function endsWith(string, target, position) {
            string = baseToString(string);
            target = target + "";
            var length = string.length;
            position = (typeof position == "undefined" ? length : nativeMin(position < 0 ? 0 : +position || 0, length)) - target.length;
            return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
            string = baseToString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
            string = baseToString(string);
            return string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase();
        });
        function pad(string, length, chars) {
            string = baseToString(string);
            length = +length;
            var strLength = string.length;
            if (strLength >= length || !nativeIsFinite(length)) {
                return string;
            }
            var mid = (length - strLength) / 2, leftLength = floor(mid), rightLength = ceil(mid);
            chars = createPad("", rightLength, chars);
            return chars.slice(0, leftLength) + string + chars;
        }
        function padLeft(string, length, chars) {
            string = baseToString(string);
            return string && createPad(string, length, chars) + string;
        }
        function padRight(string, length, chars) {
            string = baseToString(string);
            return string && string + createPad(string, length, chars);
        }
        function parseInt(string, radix, guard) {
            if (guard && isIterateeCall(string, radix, guard)) {
                radix = 0;
            }
            return nativeParseInt(string, radix);
        }
        if (nativeParseInt(whitespace + "08") != 8) {
            parseInt = function(string, radix, guard) {
                if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                    radix = 0;
                } else if (radix) {
                    radix = +radix;
                }
                string = trim(string);
                return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
            };
        }
        function repeat(string, n) {
            var result = "";
            string = baseToString(string);
            n = +n;
            if (n < 1 || !string || !nativeIsFinite(n)) {
                return result;
            }
            do {
                if (n % 2) {
                    result += string;
                }
                n = floor(n / 2);
                string += string;
            } while (n);
            return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
            string = baseToString(string);
            position = position == null ? 0 : nativeMin(position < 0 ? 0 : +position || 0, string.length);
            return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
            var settings = lodash.templateSettings;
            if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                options = otherOptions = null;
            }
            string = baseToString(string);
            options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
            var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            var variable = options.variable;
            if (!variable) {
                source = "with (obj) {\n" + source + "\n}\n";
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function() {
                return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
            });
            result.source = source;
            if (isError(result)) {
                throw result;
            }
            return result;
        }
        function trim(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
            }
            chars = chars + "";
            return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(trimmedLeftIndex(string));
            }
            return string.slice(charsLeftIndex(string, chars + ""));
        }
        function trimRight(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(0, trimmedRightIndex(string) + 1);
            }
            return string.slice(0, charsRightIndex(string, chars + "") + 1);
        }
        function trunc(string, options, guard) {
            if (guard && isIterateeCall(string, options, guard)) {
                options = null;
            }
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (options != null) {
                if (isObject(options)) {
                    var separator = "separator" in options ? options.separator : separator;
                    length = "length" in options ? +options.length || 0 : length;
                    omission = "omission" in options ? baseToString(options.omission) : omission;
                } else {
                    length = +options || 0;
                }
            }
            string = baseToString(string);
            if (length >= string.length) {
                return string;
            }
            var end = length - omission.length;
            if (end < 1) {
                return omission;
            }
            var result = string.slice(0, end);
            if (separator == null) {
                return result + omission;
            }
            if (isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, newEnd, substring = string.slice(0, end);
                    if (!separator.global) {
                        separator = RegExp(separator.source, (reFlags.exec(separator) || "") + "g");
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                        newEnd = match.index;
                    }
                    result = result.slice(0, newEnd == null ? end : newEnd);
                }
            } else if (string.indexOf(separator, end) != end) {
                var index = result.lastIndexOf(separator);
                if (index > -1) {
                    result = result.slice(0, index);
                }
            }
            return result + omission;
        }
        function unescape(string) {
            string = baseToString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
            if (guard && isIterateeCall(string, pattern, guard)) {
                pattern = null;
            }
            string = baseToString(string);
            return string.match(pattern || reWords) || [];
        }
        function attempt() {
            var length = arguments.length, func = arguments[0];
            try {
                var args = Array(length ? length - 1 : 0);
                while (--length > 0) {
                    args[length - 1] = arguments[length];
                }
                return func.apply(undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        }
        function callback(func, thisArg, guard) {
            if (guard && isIterateeCall(func, thisArg, guard)) {
                thisArg = null;
            }
            return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function identity(value) {
            return value;
        }
        function matches(source) {
            return baseMatches(baseClone(source, true));
        }
        function matchesProperty(key, value) {
            return baseMatchesProperty(key + "", baseClone(value, true));
        }
        function mixin(object, source, options) {
            if (options == null) {
                var isObj = isObject(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
                if (!(methodNames ? methodNames.length : isObj)) {
                    methodNames = false;
                    options = source;
                    source = object;
                    object = this;
                }
            }
            if (!methodNames) {
                methodNames = baseFunctions(source, keys(source));
            }
            var chain = true, index = -1, isFunc = isFunction(object), length = methodNames.length;
            if (options === false) {
                chain = false;
            } else if (isObject(options) && "chain" in options) {
                chain = options.chain;
            }
            while (++index < length) {
                var methodName = methodNames[index], func = source[methodName];
                object[methodName] = func;
                if (isFunc) {
                    object.prototype[methodName] = function(func) {
                        return function() {
                            var chainAll = this.__chain__;
                            if (chain || chainAll) {
                                var result = object(this.__wrapped__);
                                (result.__actions__ = arrayCopy(this.__actions__)).push({
                                    func: func,
                                    args: arguments,
                                    thisArg: object
                                });
                                result.__chain__ = chainAll;
                                return result;
                            }
                            var args = [ this.value() ];
                            push.apply(args, arguments);
                            return func.apply(object, args);
                        };
                    }(func);
                }
            }
            return object;
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {}
        function property(key) {
            return baseProperty(key + "");
        }
        function propertyOf(object) {
            return function(key) {
                return object == null ? undefined : object[key];
            };
        }
        function range(start, end, step) {
            if (step && isIterateeCall(start, end, step)) {
                end = step = null;
            }
            start = +start || 0;
            step = step == null ? 1 : +step || 0;
            if (end == null) {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            var index = -1, length = nativeMax(ceil((end - start) / (step || 1)), 0), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function times(n, iteratee, thisArg) {
            n = +n;
            if (n < 1 || !nativeIsFinite(n)) {
                return [];
            }
            var index = -1, result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
            iteratee = bindCallback(iteratee, thisArg, 1);
            while (++index < n) {
                if (index < MAX_ARRAY_LENGTH) {
                    result[index] = iteratee(index);
                } else {
                    iteratee(index);
                }
            }
            return result;
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return baseToString(prefix) + id;
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype["delete"] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
            if (!this.__chain__ && n == null) {
                return sample(this.value());
            }
            return this.thru(function(value) {
                return sample(value, n);
            });
        };
        lodash.VERSION = VERSION;
        arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
            lodash[methodName].placeholder = lodash;
        });
        arrayEach([ "filter", "map", "takeWhile" ], function(methodName, index) {
            var isFilter = index == LAZY_FILTER_FLAG || index == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
                var result = this.clone(), iteratees = result.__iteratees__ || (result.__iteratees__ = []);
                result.__filtered__ = result.__filtered__ || isFilter;
                iteratees.push({
                    iteratee: getCallback(iteratee, thisArg, 3),
                    type: index
                });
                return result;
            };
        });
        arrayEach([ "drop", "take" ], function(methodName, index) {
            var countName = "__" + methodName + "Count__", whileName = methodName + "While";
            LazyWrapper.prototype[methodName] = function(n) {
                n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
                var result = this.clone();
                if (result.__filtered__) {
                    var value = result[countName];
                    result[countName] = index ? nativeMin(value, n) : value + n;
                } else {
                    var views = result.__views__ || (result.__views__ = []);
                    views.push({
                        size: n,
                        type: methodName + (result.__dir__ < 0 ? "Right" : "")
                    });
                }
                return result;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
                return this.reverse()[methodName](n).reverse();
            };
            LazyWrapper.prototype[methodName + "RightWhile"] = function(predicate, thisArg) {
                return this.reverse()[whileName](predicate, thisArg).reverse();
            };
        });
        arrayEach([ "first", "last" ], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
                return this[takeName](1).value()[0];
            };
        });
        arrayEach([ "initial", "rest" ], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
                return this[dropName](1);
            };
        });
        arrayEach([ "pluck", "where" ], function(methodName, index) {
            var operationName = index ? "filter" : "map", createCallback = index ? baseMatches : baseProperty;
            LazyWrapper.prototype[methodName] = function(value) {
                return this[operationName](createCallback(value));
            };
        });
        LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
        };
        LazyWrapper.prototype.dropWhile = function(predicate, thisArg) {
            var done, lastIndex, isRight = this.__dir__ < 0;
            predicate = getCallback(predicate, thisArg, 3);
            return this.filter(function(value, index, array) {
                done = done && (isRight ? index < lastIndex : index > lastIndex);
                lastIndex = index;
                return done || (done = !predicate(value, index, array));
            });
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return this.filter(function(value, index, array) {
                return !predicate(value, index, array);
            });
        };
        LazyWrapper.prototype.slice = function(start, end) {
            start = start == null ? 0 : +start || 0;
            var result = start < 0 ? this.takeRight(-start) : this.drop(start);
            if (typeof end != "undefined") {
                end = +end || 0;
                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
        };
        LazyWrapper.prototype.toArray = function() {
            return this.drop(0);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName], retUnwrapped = /^(?:first|last)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var value = this.__wrapped__, args = arguments, chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isLazy = value instanceof LazyWrapper, onlyLazy = isLazy && !isHybrid;
                if (retUnwrapped && !chainAll) {
                    return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
                }
                var interceptor = function(value) {
                    var otherArgs = [ value ];
                    push.apply(otherArgs, args);
                    return lodashFunc.apply(lodash, otherArgs);
                };
                if (isLazy || isArray(value)) {
                    var wrapper = onlyLazy ? value : new LazyWrapper(this), result = func.apply(wrapper, args);
                    if (!retUnwrapped && (isHybrid || result.__actions__)) {
                        var actions = result.__actions__ || (result.__actions__ = []);
                        actions.push({
                            func: thru,
                            args: [ interceptor ],
                            thisArg: lodash
                        });
                    }
                    return new LodashWrapper(result, chainAll);
                }
                return this.thru(interceptor);
            };
        });
        arrayEach([ "concat", "join", "pop", "push", "shift", "sort", "splice", "unshift" ], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    return func.apply(this.value(), args);
                }
                return this[chainName](function(value) {
                    return func.apply(value, args);
                });
            };
        });
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}).call(this);

!function(e, n) {
    "use strict";
    function r(e, n) {
        var r, t, u = e.toLowerCase();
        for (n = [].concat(n), r = 0; r < n.length; r += 1) if (t = n[r]) {
            if (t.test && t.test(e)) return !0;
            if (t.toLowerCase() === u) return !0;
        }
    }
    var t = n.prototype.trim, u = n.prototype.trimRight, i = n.prototype.trimLeft, l = function(e) {
        return 1 * e || 0;
    }, o = function(e, n) {
        if (1 > n) return "";
        for (var r = ""; n > 0; ) 1 & n && (r += e), n >>= 1, e += e;
        return r;
    }, a = [].slice, c = function(e) {
        return null == e ? "\\s" : e.source ? e.source : "[" + g.escapeRegExp(e) + "]";
    }, s = {
        lt: "<",
        gt: ">",
        quot: '"',
        amp: "&",
        apos: "'"
    }, f = {};
    for (var p in s) f[s[p]] = p;
    f["'"] = "#39";
    var h = function() {
        function e(e) {
            return Object.prototype.toString.call(e).slice(8, -1).toLowerCase();
        }
        var r = o, t = function() {
            return t.cache.hasOwnProperty(arguments[0]) || (t.cache[arguments[0]] = t.parse(arguments[0])), 
            t.format.call(null, t.cache[arguments[0]], arguments);
        };
        return t.format = function(t, u) {
            var i, l, o, a, c, s, f, p = 1, g = t.length, d = "", m = [];
            for (l = 0; g > l; l++) if (d = e(t[l]), "string" === d) m.push(t[l]); else if ("array" === d) {
                if (a = t[l], a[2]) for (i = u[p], o = 0; o < a[2].length; o++) {
                    if (!i.hasOwnProperty(a[2][o])) throw new Error(h('[_.sprintf] property "%s" does not exist', a[2][o]));
                    i = i[a[2][o]];
                } else i = a[1] ? u[a[1]] : u[p++];
                if (/[^s]/.test(a[8]) && "number" != e(i)) throw new Error(h("[_.sprintf] expecting number but found %s", e(i)));
                switch (a[8]) {
                  case "b":
                    i = i.toString(2);
                    break;

                  case "c":
                    i = n.fromCharCode(i);
                    break;

                  case "d":
                    i = parseInt(i, 10);
                    break;

                  case "e":
                    i = a[7] ? i.toExponential(a[7]) : i.toExponential();
                    break;

                  case "f":
                    i = a[7] ? parseFloat(i).toFixed(a[7]) : parseFloat(i);
                    break;

                  case "o":
                    i = i.toString(8);
                    break;

                  case "s":
                    i = (i = n(i)) && a[7] ? i.substring(0, a[7]) : i;
                    break;

                  case "u":
                    i = Math.abs(i);
                    break;

                  case "x":
                    i = i.toString(16);
                    break;

                  case "X":
                    i = i.toString(16).toUpperCase();
                }
                i = /[def]/.test(a[8]) && a[3] && i >= 0 ? "+" + i : i, s = a[4] ? "0" == a[4] ? "0" : a[4].charAt(1) : " ", 
                f = a[6] - n(i).length, c = a[6] ? r(s, f) : "", m.push(a[5] ? i + c : c + i);
            }
            return m.join("");
        }, t.cache = {}, t.parse = function(e) {
            for (var n = e, r = [], t = [], u = 0; n; ) {
                if (null !== (r = /^[^\x25]+/.exec(n))) t.push(r[0]); else if (null !== (r = /^\x25{2}/.exec(n))) t.push("%"); else {
                    if (null === (r = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(n))) throw new Error("[_.sprintf] huh?");
                    if (r[2]) {
                        u |= 1;
                        var i = [], l = r[2], o = [];
                        if (null === (o = /^([a-z_][a-z_\d]*)/i.exec(l))) throw new Error("[_.sprintf] huh?");
                        for (i.push(o[1]); "" !== (l = l.substring(o[0].length)); ) if (null !== (o = /^\.([a-z_][a-z_\d]*)/i.exec(l))) i.push(o[1]); else {
                            if (null === (o = /^\[(\d+)\]/.exec(l))) throw new Error("[_.sprintf] huh?");
                            i.push(o[1]);
                        }
                        r[2] = i;
                    } else u |= 2;
                    if (3 === u) throw new Error("[_.sprintf] mixing positional and named placeholders is not (yet) supported");
                    t.push(r);
                }
                n = n.substring(r[0].length);
            }
            return t;
        }, t;
    }(), g = {
        VERSION: "2.4.0",
        isBlank: function(e) {
            return null == e && (e = ""), /^\s*$/.test(e);
        },
        stripTags: function(e) {
            return null == e ? "" : n(e).replace(/<\/?[^>]+>/g, "");
        },
        capitalize: function(e) {
            return e = null == e ? "" : n(e), e.charAt(0).toUpperCase() + e.slice(1);
        },
        chop: function(e, r) {
            return null == e ? [] : (e = n(e), r = ~~r, r > 0 ? e.match(new RegExp(".{1," + r + "}", "g")) : [ e ]);
        },
        clean: function(e) {
            return g.strip(e).replace(/\s+/g, " ");
        },
        count: function(e, r) {
            if (null == e || null == r) return 0;
            e = n(e), r = n(r);
            for (var t = 0, u = 0, i = r.length; ;) {
                if (u = e.indexOf(r, u), -1 === u) break;
                t++, u += i;
            }
            return t;
        },
        chars: function(e) {
            return null == e ? [] : n(e).split("");
        },
        swapCase: function(e) {
            return null == e ? "" : n(e).replace(/\S/g, function(e) {
                return e === e.toUpperCase() ? e.toLowerCase() : e.toUpperCase();
            });
        },
        escapeHTML: function(e) {
            return null == e ? "" : n(e).replace(/[&<>"']/g, function(e) {
                return "&" + f[e] + ";";
            });
        },
        unescapeHTML: function(e) {
            return null == e ? "" : n(e).replace(/\&([^;]+);/g, function(e, r) {
                var t;
                return r in s ? s[r] : (t = r.match(/^#x([\da-fA-F]+)$/)) ? n.fromCharCode(parseInt(t[1], 16)) : (t = r.match(/^#(\d+)$/)) ? n.fromCharCode(~~t[1]) : e;
            });
        },
        escapeRegExp: function(e) {
            return null == e ? "" : n(e).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        },
        splice: function(e, n, r, t) {
            var u = g.chars(e);
            return u.splice(~~n, ~~r, t), u.join("");
        },
        insert: function(e, n, r) {
            return g.splice(e, n, 0, r);
        },
        include: function(e, r) {
            return "" === r ? !0 : null == e ? !1 : -1 !== n(e).indexOf(r);
        },
        join: function() {
            var e = a.call(arguments), n = e.shift();
            return null == n && (n = ""), e.join(n);
        },
        lines: function(e) {
            return null == e ? [] : n(e).split("\n");
        },
        reverse: function(e) {
            return g.chars(e).reverse().join("");
        },
        startsWith: function(e, r) {
            return "" === r ? !0 : null == e || null == r ? !1 : (e = n(e), r = n(r), e.length >= r.length && e.slice(0, r.length) === r);
        },
        endsWith: function(e, r) {
            return "" === r ? !0 : null == e || null == r ? !1 : (e = n(e), r = n(r), e.length >= r.length && e.slice(e.length - r.length) === r);
        },
        succ: function(e) {
            return null == e ? "" : (e = n(e), e.slice(0, -1) + n.fromCharCode(e.charCodeAt(e.length - 1) + 1));
        },
        titleize: function(e) {
            return null == e ? "" : (e = n(e).toLowerCase(), e.replace(/(?:^|\s|-)\S/g, function(e) {
                return e.toUpperCase();
            }));
        },
        camelize: function(e) {
            return g.trim(e).replace(/[-_\s]+(.)?/g, function(e, n) {
                return n ? n.toUpperCase() : "";
            });
        },
        underscored: function(e) {
            return g.trim(e).replace(/([a-z\d])([A-Z]+)/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase();
        },
        dasherize: function(e) {
            return g.trim(e).replace(/([A-Z])/g, "-$1").replace(/[-_\s]+/g, "-").toLowerCase();
        },
        classify: function(e) {
            return g.capitalize(g.camelize(n(e).replace(/[\W_]/g, " ")).replace(/\s/g, ""));
        },
        humanize: function(e) {
            return g.capitalize(g.underscored(e).replace(/_id$/, "").replace(/_/g, " "));
        },
        trim: function(e, r) {
            return null == e ? "" : !r && t ? t.call(e) : (r = c(r), n(e).replace(new RegExp("^" + r + "+|" + r + "+$", "g"), ""));
        },
        ltrim: function(e, r) {
            return null == e ? "" : !r && i ? i.call(e) : (r = c(r), n(e).replace(new RegExp("^" + r + "+"), ""));
        },
        rtrim: function(e, r) {
            return null == e ? "" : !r && u ? u.call(e) : (r = c(r), n(e).replace(new RegExp(r + "+$"), ""));
        },
        truncate: function(e, r, t) {
            return null == e ? "" : (e = n(e), t = t || "...", r = ~~r, e.length > r ? e.slice(0, r) + t : e);
        },
        prune: function(e, r, t) {
            if (null == e) return "";
            if (e = n(e), r = ~~r, t = null != t ? n(t) : "...", e.length <= r) return e;
            var u = function(e) {
                return e.toUpperCase() !== e.toLowerCase() ? "A" : " ";
            }, i = e.slice(0, r + 1).replace(/.(?=\W*\w*$)/g, u);
            return i = i.slice(i.length - 2).match(/\w\w/) ? i.replace(/\s*\S+$/, "") : g.rtrim(i.slice(0, i.length - 1)), 
            (i + t).length > e.length ? e : e.slice(0, i.length) + t;
        },
        words: function(e, n) {
            return g.isBlank(e) ? [] : g.trim(e, n).split(n || /\s+/);
        },
        pad: function(e, r, t, u) {
            e = null == e ? "" : n(e), r = ~~r;
            var i = 0;
            switch (t ? t.length > 1 && (t = t.charAt(0)) : t = " ", u) {
              case "right":
                return i = r - e.length, e + o(t, i);

              case "both":
                return i = r - e.length, o(t, Math.ceil(i / 2)) + e + o(t, Math.floor(i / 2));

              default:
                return i = r - e.length, o(t, i) + e;
            }
        },
        lpad: function(e, n, r) {
            return g.pad(e, n, r);
        },
        rpad: function(e, n, r) {
            return g.pad(e, n, r, "right");
        },
        lrpad: function(e, n, r) {
            return g.pad(e, n, r, "both");
        },
        sprintf: h,
        vsprintf: function(e, n) {
            return n.unshift(e), h.apply(null, n);
        },
        toNumber: function(e, n) {
            return e ? (e = g.trim(e), e.match(/^-?\d+(?:\.\d+)?$/) ? l(l(e).toFixed(~~n)) : 0 / 0) : 0;
        },
        numberFormat: function(e, n, r, t) {
            if (isNaN(e) || null == e) return "";
            e = e.toFixed(~~n), t = "string" == typeof t ? t : ",";
            var u = e.split("."), i = u[0], l = u[1] ? (r || ".") + u[1] : "";
            return i.replace(/(\d)(?=(?:\d{3})+$)/g, "$1" + t) + l;
        },
        strRight: function(e, r) {
            if (null == e) return "";
            e = n(e), r = null != r ? n(r) : r;
            var t = r ? e.indexOf(r) : -1;
            return ~t ? e.slice(t + r.length, e.length) : e;
        },
        strRightBack: function(e, r) {
            if (null == e) return "";
            e = n(e), r = null != r ? n(r) : r;
            var t = r ? e.lastIndexOf(r) : -1;
            return ~t ? e.slice(t + r.length, e.length) : e;
        },
        strLeft: function(e, r) {
            if (null == e) return "";
            e = n(e), r = null != r ? n(r) : r;
            var t = r ? e.indexOf(r) : -1;
            return ~t ? e.slice(0, t) : e;
        },
        strLeftBack: function(e, n) {
            if (null == e) return "";
            e += "", n = null != n ? "" + n : n;
            var r = e.lastIndexOf(n);
            return ~r ? e.slice(0, r) : e;
        },
        toSentence: function(e, n, r, t) {
            n = n || ", ", r = r || " and ";
            var u = e.slice(), i = u.pop();
            return e.length > 2 && t && (r = g.rtrim(n) + r), u.length ? u.join(n) + r + i : i;
        },
        toSentenceSerial: function() {
            var e = a.call(arguments);
            return e[3] = !0, g.toSentence.apply(g, e);
        },
        slugify: function(e) {
            if (null == e) return "";
            var r = "ąàáäâãåæăćęèéëêìíïîłńòóöôõøśșțùúüûñçżź", t = "aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz", u = new RegExp(c(r), "g");
            return e = n(e).toLowerCase().replace(u, function(e) {
                var n = r.indexOf(e);
                return t.charAt(n) || "-";
            }), g.dasherize(e.replace(/[^\w\s-]/g, ""));
        },
        surround: function(e, n) {
            return [ n, e, n ].join("");
        },
        quote: function(e, n) {
            return g.surround(e, n || '"');
        },
        unquote: function(e, n) {
            return n = n || '"', e[0] === n && e[e.length - 1] === n ? e.slice(1, e.length - 1) : e;
        },
        exports: function() {
            var e = {};
            for (var n in this) this.hasOwnProperty(n) && !n.match(/^(?:include|contains|reverse)$/) && (e[n] = this[n]);
            return e;
        },
        repeat: function(e, r, t) {
            if (null == e) return "";
            if (r = ~~r, null == t) return o(n(e), r);
            for (var u = []; r > 0; u[--r] = e) ;
            return u.join(t);
        },
        naturalCmp: function(e, r) {
            if (e == r) return 0;
            if (!e) return -1;
            if (!r) return 1;
            for (var t = /(\.\d+)|(\d+)|(\D+)/g, u = n(e).toLowerCase().match(t), i = n(r).toLowerCase().match(t), l = Math.min(u.length, i.length), o = 0; l > o; o++) {
                var a = u[o], c = i[o];
                if (a !== c) {
                    var s = parseInt(a, 10);
                    if (!isNaN(s)) {
                        var f = parseInt(c, 10);
                        if (!isNaN(f) && s - f) return s - f;
                    }
                    return c > a ? -1 : 1;
                }
            }
            return u.length === i.length ? u.length - i.length : r > e ? -1 : 1;
        },
        levenshtein: function(e, r) {
            if (null == e && null == r) return 0;
            if (null == e) return n(r).length;
            if (null == r) return n(e).length;
            e = n(e), r = n(r);
            for (var t, u, i = [], l = 0; l <= r.length; l++) for (var o = 0; o <= e.length; o++) u = l && o ? e.charAt(o - 1) === r.charAt(l - 1) ? t : Math.min(i[o], i[o - 1], t) + 1 : l + o, 
            t = i[o], i[o] = u;
            return i.pop();
        },
        toBoolean: function(e, n, t) {
            return "number" == typeof e && (e = "" + e), "string" != typeof e ? !!e : (e = g.trim(e), 
            r(e, n || [ "true", "1" ]) ? !0 : r(e, t || [ "false", "0" ]) ? !1 : void 0);
        }
    };
    g.strip = g.trim, g.lstrip = g.ltrim, g.rstrip = g.rtrim, g.center = g.lrpad, g.rjust = g.lpad, 
    g.ljust = g.rpad, g.contains = g.include, g.q = g.quote, g.toBool = g.toBoolean, 
    "undefined" != typeof exports && ("undefined" != typeof module && module.exports && (module.exports = g), 
    exports._s = g), "function" == typeof define && define.amd && define("underscore.string", [], function() {
        return g;
    }), e._ = e._ || {}, e._.string = e._.str = g;
}(this, String);

(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var document = window.document, version = "2.1.3", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
        },
        isPlainObject: function(obj) {
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
            return true;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (;j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for (;i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
            setDocument();
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            nodeType = context.nodeType;
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed && documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType !== 1 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);
                        if (old = context.getAttribute("id")) {
                            nid = old.replace(rescape, "\\$&");
                        } else {
                            context.setAttribute("id", nid);
                        }
                        nid = "[id='" + nid + "'] ";
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",");
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {} finally {
                            if (!old) {
                                context.removeAttribute("id");
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            parent = doc.defaultView;
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler);
                }
            }
            documentIsHTML = !isXML(doc);
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function(div) {
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });
                assert(function(div) {
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    support.disconnectedMatch = matches.call(div, "div");
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context !== document && context;
                }
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    if (bySet) {
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched);
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        if (!selector) {
            return this;
        }
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem && elem.parentNode) {
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || rootjQuery).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },
        sibling: function(n, elem) {
            var matched = [];
            for (;n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        }
    });
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (;i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (;list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                    memory = false;
                    break;
                }
            }
            firing = false;
            if (list) {
                if (stack) {
                    if (stack.length) {
                        fire(stack.shift());
                    }
                } else if (memory) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        }, self = {
            add: function() {
                if (list) {
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && type !== "string") {
                                add(arg);
                            }
                        });
                    })(arguments);
                    if (firing) {
                        firingLength = list.length;
                    } else if (memory) {
                        firingStart = start;
                        fire(memory);
                    }
                }
                return this;
            },
            remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--;
                                }
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
            },
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
            locked: function() {
                return !stack;
            },
            fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if (firing) {
                        stack.push(args);
                    } else {
                        fire(args);
                    }
                }
                return this;
            },
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [ jQuery ]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete") {
                setTimeout(jQuery.ready);
            } else {
                document.addEventListener("DOMContentLoaded", completed, false);
                window.addEventListener("load", completed, false);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    jQuery.acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {};
            }
        });
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function(owner) {
            if (!Data.accepts(owner)) {
                return 0;
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    };
                    Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }
            return unlock;
        },
        set: function(owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key];
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {};
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [ key, camel ];
                    } else {
                        name = camel;
                        name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();
    var data_user = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function(elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function(elem, name) {
            data_user.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            data_priv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    data_user.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function() {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = data_priv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;
    support.focusinBubbles = "onfocusin" in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events");
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                for (;cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);
                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (;i < l; i++) {
            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
        }
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur);
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (;i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));
                        tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = "";
                    }
                }
            }
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), "script");
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        },
        cleanData: function(elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0;
            for (;(elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key];
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });
    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (;(elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, true);
        },
        domManip: function(args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    for (;i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        }
        return window.getComputedStyle(elem, null);
    };
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function() {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
        container.appendChild(div);
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";
            docElem.removeChild(container);
        }
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function() {
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function() {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function() {
                    var ret, marginDiv = div.appendChild(document.createElement("div"));
                    marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                    docElem.removeChild(container);
                    div.removeChild(marginDiv);
                    return ret;
                }
            });
        }
    })();
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number";
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
            }
        };
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                unit = unit || start[3];
                parts = parts || [];
                start = +target || 1;
                do {
                    scale = scale || ".5";
                    start = start / scale;
                    jQuery.style(tween.elem, prop, start + unit);
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
            }
            if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
            }
            return tween;
        } ]
    };
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            display = jQuery.css(elem, "display");
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || data_priv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === "string" && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function() {
                if (type === "string") {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        data_priv.set(this, "__className__", this.className);
                    }
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (;i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (;i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window.location.href, ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.attachEvent) {
        window.attachEvent("onunload", function() {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    complete(xhr.status, xhr.statusText);
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {
                                        text: xhr.responseText
                                    } : undefined, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    xhr.onerror = callback("error");
                    callback = xhrCallbacks[id] = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = jQuery.buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments;
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }
        return this;
    };
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function() {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

(function(window, document, exportName, undefined) {
    "use strict";
    var VENDOR_PREFIXES = [ "", "webkit", "moz", "MS", "ms", "o" ];
    var TEST_ELEMENT = document.createElement("div");
    var TYPE_FUNCTION = "function";
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = "ontouchstart" in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, "PointerEvent") !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [ "x", "y" ];
    var PROPS_CLIENT_XY = [ "clientX", "clientY" ];
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [ manager ])) {
                self.handler(ev);
            }
        };
        this.init();
    }
    Input.prototype = {
        handler: function() {},
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true;
        this.pressed = false;
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }
            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }
            if (!this.pressed || !this.allow) {
                return;
            }
            if (eventType & INPUT_END) {
                this.pressed = false;
            }
            this.callback(this.manager, eventType, {
                pointers: [ ev ],
                changedPointers: [ ev ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    if (window.MSPointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }
            if (storeIndex < 0) {
                return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ ev ],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) {
                store.splice(storeIndex, 1);
            }
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START) {
                this.started = true;
            }
            if (!this.started) {
                return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [ all, changed ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [ allTouches, allTouches ];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [ uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true), changedTargetTouches ];
    }
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }
    inherit(TouchMouseInput, Input, {
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isTouch) {
                this.mouse.allow = false;
            } else if (isMouse && !this.mouse.allow) {
                return;
            }
            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                this.mouse.allow = true;
            }
            this.callback(manager, inputEvent, inputData);
        },
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation";
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },
        update: function() {
            this.set(this.manager.options.touchAction);
        },
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [ recognizer ])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(" "));
        },
        preventDefaults: function(input) {
            if (NATIVE_TOUCH_ACTION) {
                return;
            }
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE);
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                return this.preventSrc(srcEvent);
            }
        },
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + " " + TOUCH_ACTION_PAN_Y;
        }
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        defaults: {},
        set: function(options) {
            extend(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
        },
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
                return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
                return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        emit: function(input) {
            var self = this;
            var state = this.state;
            function emit(withState) {
                self.manager.emit(self.options.event + (withState ? stateStr(state) : ""), input);
            }
            if (state < STATE_ENDED) {
                emit(true);
            }
            emit();
            if (state >= STATE_ENDED) {
                emit(true);
            }
        },
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            this.state = STATE_FAILED;
        },
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },
        recognize: function(inputData) {
            var inputDataClone = extend({}, inputData);
            if (!boolOrFn(this.options.enable, [ this, inputDataClone ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },
        process: function(inputData) {},
        getTouchAction: function() {},
        reset: function() {}
    };
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return "cancel";
        } else if (state & STATE_ENDED) {
            return "end";
        } else if (state & STATE_CHANGED) {
            return "move";
        } else if (state & STATE_BEGAN) {
            return "start";
        }
        return "";
    }
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return "down";
        } else if (direction == DIRECTION_UP) {
            return "up";
        } else if (direction == DIRECTION_LEFT) {
            return "left";
        } else if (direction == DIRECTION_RIGHT) {
            return "right";
        }
        return "";
    }
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        defaults: {
            pointers: 1
        },
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },
        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }
            this._super.emit.call(this, input);
        }
    });
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
            this._super.emit.call(this, input);
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? "in" : "out";
                this.manager.emit(this.options.event + inOut, input);
            }
        }
    });
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        defaults: {
            event: "press",
            pointers: 1,
            time: 500,
            threshold: 5
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_AUTO ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }
            if (input && input.eventType & INPUT_END) {
                this.manager.emit(this.options.event + "up", input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        defaults: {
            event: "swipe",
            threshold: 10,
            velocity: .65,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.velocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.velocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.velocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
        }
    });
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 2,
            posThreshold: 10
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_MANIPULATION ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) {
                return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }
                this._input = input;
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    Hammer.VERSION = "2.0.4";
    Hammer.defaults = {
        domEvents: false,
        touchAction: TOUCH_ACTION_COMPUTE,
        enable: true,
        inputTarget: null,
        inputClass: null,
        preset: [ [ RotateRecognizer, {
            enable: false
        } ], [ PinchRecognizer, {
            enable: false
        }, [ "rotate" ] ], [ SwipeRecognizer, {
            direction: DIRECTION_HORIZONTAL
        } ], [ PanRecognizer, {
            direction: DIRECTION_HORIZONTAL
        }, [ "swipe" ] ], [ TapRecognizer ], [ TapRecognizer, {
            event: "doubletap",
            taps: 2
        }, [ "tap" ] ], [ PressRecognizer ] ],
        cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        set: function(options) {
            extend(this.options, options);
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
                return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
                return this;
            }
            var recognizers = this.recognizers;
            recognizer = this.get(recognizer);
            recognizers.splice(inArray(recognizers, recognizer), 1);
            this.touchAction.update();
            return this;
        },
        on: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        off: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },
        emit: function(event, data) {
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },
        destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function(value, name) {
            element.style[prefixed(element.style, name)] = add ? value : "";
        });
    }
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    extend(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    if (typeof define == TYPE_FUNCTION && define.amd) {
        define(function() {
            return Hammer;
        });
    } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }
})(window, document, "Hammer");

(function(undefined) {
    var moment, VERSION = "2.9.0", globalScope = typeof global !== "undefined" && (typeof window === "undefined" || window === global.window) ? global : this, oldGlobalMoment, round = Math.round, hasOwnProperty = Object.prototype.hasOwnProperty, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = typeof module !== "undefined" && module && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenOffsetMs = /[\+\-]?\d+/, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }, unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        Q: "quarter",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
    }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
    }, formatFunctions = {}, relativeTimeThresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
            return this.month() + 1;
        },
        MMM: function(format) {
            return this.localeData().monthsShort(this, format);
        },
        MMMM: function(format) {
            return this.localeData().months(this, format);
        },
        D: function() {
            return this.date();
        },
        DDD: function() {
            return this.dayOfYear();
        },
        d: function() {
            return this.day();
        },
        dd: function(format) {
            return this.localeData().weekdaysMin(this, format);
        },
        ddd: function(format) {
            return this.localeData().weekdaysShort(this, format);
        },
        dddd: function(format) {
            return this.localeData().weekdays(this, format);
        },
        w: function() {
            return this.week();
        },
        W: function() {
            return this.isoWeek();
        },
        YY: function() {
            return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
            return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
            return leftZeroFill(this.year(), 5);
        },
        YYYYYY: function() {
            var y = this.year(), sign = y >= 0 ? "+" : "-";
            return sign + leftZeroFill(Math.abs(y), 6);
        },
        gg: function() {
            return leftZeroFill(this.weekYear() % 100, 2);
        },
        gggg: function() {
            return leftZeroFill(this.weekYear(), 4);
        },
        ggggg: function() {
            return leftZeroFill(this.weekYear(), 5);
        },
        GG: function() {
            return leftZeroFill(this.isoWeekYear() % 100, 2);
        },
        GGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 4);
        },
        GGGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 5);
        },
        e: function() {
            return this.weekday();
        },
        E: function() {
            return this.isoWeekday();
        },
        a: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), true);
        },
        A: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), false);
        },
        H: function() {
            return this.hours();
        },
        h: function() {
            return this.hours() % 12 || 12;
        },
        m: function() {
            return this.minutes();
        },
        s: function() {
            return this.seconds();
        },
        S: function() {
            return toInt(this.milliseconds() / 100);
        },
        SS: function() {
            return leftZeroFill(toInt(this.milliseconds() / 10), 2);
        },
        SSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        SSSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
            var a = this.utcOffset(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
        },
        ZZ: function() {
            var a = this.utcOffset(), b = "+";
            if (a < 0) {
                a = -a;
                b = "-";
            }
            return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
        },
        z: function() {
            return this.zoneAbbr();
        },
        zz: function() {
            return this.zoneName();
        },
        x: function() {
            return this.valueOf();
        },
        X: function() {
            return this.unix();
        },
        Q: function() {
            return this.quarter();
        }
    }, deprecations = {}, lists = [ "months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin" ], updateInProgress = false;
    function dfl(a, b, c) {
        switch (arguments.length) {
          case 2:
            return a != null ? a : b;

          case 3:
            return a != null ? a : b != null ? b : c;

          default:
            throw new Error("Implement me");
        }
    }
    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }
    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }
    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function(a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }
    function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust);
    }
    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function Locale() {}
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
        if (updateInProgress === false) {
            updateInProgress = true;
            moment.updateOffset(this);
            updateInProgress = false;
        }
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = moment.localeData();
        this._bubble();
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
            to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
            to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
            to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
            to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
            to._pf = from._pf;
        }
        if (typeof from._locale !== "undefined") {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== "undefined") {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }
    function leftZeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number), sign = number >= 0;
        while (output.length < targetLength) {
            output = "0" + output;
        }
        return (sign ? forceSign ? "+" : "" : "-") + output;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }
    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
    }
    function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    function makeList(field) {
        var count, setter;
        if (field.indexOf("week") === 0) {
            count = 7;
            setter = "day";
        } else if (field.indexOf("month") === 0) {
            count = 12;
            setter = "month";
        } else {
            return;
        }
        moment[field] = function(format, index) {
            var i, getter, method = moment._locale[field], results = [];
            if (typeof format === "number") {
                index = format;
                format = undefined;
            }
            getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || "");
            };
            if (index != null) {
                return getter(index);
            } else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }
        return value;
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 24 || m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 || m._a[SECOND] !== 0 || m._a[MILLISECOND] !== 0) ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            m._pf.overflow = overflow;
        }
    }
    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
            if (m._strict) {
                m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0 && m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require("./locale/" + name);
                moment.locale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ? +input : +moment(input)) - +res;
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }
    extend(Locale.prototype, {
        set: function(config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === "function") {
                    this[i] = prop;
                } else {
                    this["_" + i] = prop;
                }
            }
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName, format, strict) {
            var i, mom, regex;
            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }
            for (i = 0; i < 12; i++) {
                mom = moment.utc([ 2e3, i ]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                    this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },
        weekdaysParse: function(weekdayName) {
            var i, mom, regex;
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }
            for (i = 0; i < 7; i++) {
                if (!this._weekdaysParse[i]) {
                    mom = moment([ 2e3, 1 ]).day(i);
                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                }
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },
        _longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY LT",
            LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },
        isPM: function(input) {
            return (input + "").toLowerCase().charAt(0) === "p";
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "pm" : "PM";
            } else {
                return isLower ? "am" : "AM";
            }
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom, now) {
            var output = this._calendar[key];
            return typeof output === "function" ? output.apply(mom, [ now ]) : output;
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        _ordinalParse: /\d{1,2}/,
        preparse: function(string) {
            return string;
        },
        postformat: function(string) {
            return string;
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week: {
            dow: 0,
            doy: 6
        },
        firstDayOfWeek: function() {
            return this._week.dow;
        },
        firstDayOfYear: function() {
            return this._week.doy;
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
            return this._invalidDate;
        }
    });
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
          case "Q":
            return parseTokenOneDigit;

          case "DDDD":
            return parseTokenThreeDigits;

          case "YYYY":
          case "GGGG":
          case "gggg":
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;

          case "Y":
          case "G":
          case "g":
            return parseTokenSignedNumber;

          case "YYYYYY":
          case "YYYYY":
          case "GGGGG":
          case "ggggg":
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;

          case "S":
            if (strict) {
                return parseTokenOneDigit;
            }

          case "SS":
            if (strict) {
                return parseTokenTwoDigits;
            }

          case "SSS":
            if (strict) {
                return parseTokenThreeDigits;
            }

          case "DDD":
            return parseTokenOneToThreeDigits;

          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
            return parseTokenWord;

          case "a":
          case "A":
            return config._locale._meridiemParse;

          case "x":
            return parseTokenOffsetMs;

          case "X":
            return parseTokenTimestampMs;

          case "Z":
          case "ZZ":
            return parseTokenTimezone;

          case "T":
            return parseTokenT;

          case "SSSS":
            return parseTokenDigits;

          case "MM":
          case "DD":
          case "YY":
          case "GG":
          case "gg":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "ww":
          case "WW":
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;

          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
          case "w":
          case "W":
          case "e":
          case "E":
            return parseTokenOneOrTwoDigits;

          case "Do":
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;

          default:
            a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
            return a;
        }
    }
    function utcOffsetFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || [ "-", 0, 0 ], minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? minutes : -minutes;
    }
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
          case "Q":
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;

          case "M":
          case "MM":
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;

          case "MMM":
          case "MMMM":
            a = config._locale.monthsParse(input, token, config._strict);
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;

          case "D":
          case "DD":
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;

          case "Do":
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input.match(/\d{1,2}/)[0], 10));
            }
            break;

          case "DDD":
          case "DDDD":
            if (input != null) {
                config._dayOfYear = toInt(input);
            }
            break;

          case "YY":
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;

          case "YYYY":
          case "YYYYY":
          case "YYYYYY":
            datePartArray[YEAR] = toInt(input);
            break;

          case "a":
          case "A":
            config._meridiem = input;
            break;

          case "h":
          case "hh":
            config._pf.bigHour = true;

          case "H":
          case "HH":
            datePartArray[HOUR] = toInt(input);
            break;

          case "m":
          case "mm":
            datePartArray[MINUTE] = toInt(input);
            break;

          case "s":
          case "ss":
            datePartArray[SECOND] = toInt(input);
            break;

          case "S":
          case "SS":
          case "SSS":
          case "SSSS":
            datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3);
            break;

          case "x":
            config._d = new Date(toInt(input));
            break;

          case "X":
            config._d = new Date(parseFloat(input) * 1e3);
            break;

          case "Z":
          case "ZZ":
            config._useUTC = true;
            config._tzm = utcOffsetFromString(input);
            break;

          case "dd":
          case "ddd":
          case "dddd":
            a = config._locale.weekdaysParse(input);
            if (a != null) {
                config._w = config._w || {};
                config._w["d"] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;

          case "w":
          case "ww":
          case "W":
          case "WW":
          case "d":
          case "e":
          case "E":
            token = token.substr(0, 1);

          case "gggg":
          case "GGGG":
          case "GGGGG":
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;

          case "gg":
          case "GG":
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
            } else {
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }
            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }
    function dateFromObject(config) {
        var normalizedInput;
        if (config._d) {
            return;
        }
        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [ normalizedInput.year, normalizedInput.month, normalizedInput.day || normalizedInput.date, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond ];
        dateFromConfig(config);
    }
    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        } else {
            return [ now.getFullYear(), now.getMonth(), now.getDate() ];
        }
    }
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }
        config._a = [];
        config._pf.empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                } else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        dateFromConfig(config);
        checkOverflow(config);
    }
    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);
            if (!isValid(tempConfig)) {
                continue;
            }
            currentScore += tempConfig._pf.charsLeftOver;
            currentScore += tempConfig._pf.unusedTokens.length * 10;
            tempConfig._pf.score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function parseISO(config) {
        var i, l, string = config._i, match = isoRegex.exec(string);
        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === "string") {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof input === "object") {
            dateFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }
    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }
    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    function parseWeekday(input, locale) {
        if (typeof input === "string") {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            } else {
                input = locale.weekdaysParse(input);
                if (typeof input !== "number") {
                    return null;
                }
            }
        }
        return input;
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < relativeTimeThresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < relativeTimeThresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < relativeTimeThresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < relativeTimeThresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }
        adjustedMoment = moment(mom).add(daysToDayOfWeek, "d");
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function makeMoment(config) {
        var input = config._i, format = config._f, res;
        config._locale = config._locale || moment.localeData(config._l);
        if (input === null || format === undefined && input === "") {
            return moment.invalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }
        res = new Moment(config);
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    moment = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();
        return makeMoment(c);
    };
    moment.suppressDeprecationWarnings = false;
    moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    moment.min = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    };
    moment.max = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    };
    moment.utc = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();
        return makeMoment(c).utc();
    };
    moment.unix = function(input) {
        return moment(input * 1e3);
    };
    moment.duration = function(input, key) {
        var duration = input, match = null, sign, ret, parseIso, diffRes;
        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            parseIso = function(inp) {
                var res = inp && parseFloat(inp.replace(",", "."));
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (moment.isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    };
    moment.version = VERSION;
    moment.defaultFormat = isoFormat;
    moment.ISO_8601 = function() {};
    moment.momentProperties = momentProperties;
    moment.updateOffset = function() {};
    moment.relativeTimeThreshold = function(threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };
    moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function(key, value) {
        return moment.locale(key, value);
    });
    moment.locale = function(key, values) {
        var data;
        if (key) {
            if (typeof values !== "undefined") {
                data = moment.defineLocale(key, values);
            } else {
                data = moment.localeData(key);
            }
            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }
        return moment._locale._abbr;
    };
    moment.defineLocale = function(name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);
            moment.locale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    };
    moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function(key) {
        return moment.localeData(key);
    });
    moment.localeData = function(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return moment._locale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    };
    moment.isMoment = function(obj) {
        return obj instanceof Moment || obj != null && hasOwnProp(obj, "_isAMomentObject");
    };
    moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };
    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }
    moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
    };
    moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        } else {
            m._pf.userInvalidated = true;
        }
        return m;
    };
    moment.parseZone = function() {
        return moment.apply(null, arguments).parseZone();
    };
    moment.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    moment.isDate = isDate;
    extend(moment.fn = Moment.prototype, {
        clone: function() {
            return moment(this);
        },
        valueOf: function() {
            return +this._d - (this._offset || 0) * 6e4;
        },
        unix: function() {
            return Math.floor(+this / 1e3);
        },
        toString: function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
            return this._offset ? new Date(+this) : this._d;
        },
        toISOString: function() {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ("function" === typeof Date.prototype.toISOString) {
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
                }
            } else {
                return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        },
        toArray: function() {
            var m = this;
            return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
            return isValid(this);
        },
        isDSTShifted: function() {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }
            return false;
        },
        parsingFlags: function() {
            return extend({}, this._pf);
        },
        invalidAt: function() {
            return this._pf.overflow;
        },
        utc: function(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        },
        local: function(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;
                if (keepLocalTime) {
                    this.subtract(this._dateUtcOffset(), "m");
                }
            }
            return this;
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function(input, units, asFloat) {
            var that = makeAs(input, this), zoneDiff = (that.utcOffset() - this.utcOffset()) * 6e4, anchor, diff, output, daysAdjust;
            units = normalizeUnits(units);
            if (units === "year" || units === "month" || units === "quarter") {
                output = monthDiff(this, that);
                if (units === "quarter") {
                    output = output / 3;
                } else if (units === "year") {
                    output = output / 12;
                }
            } else {
                diff = this - that;
                output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? (diff - zoneDiff) / 864e5 : units === "week" ? (diff - zoneDiff) / 6048e5 : diff;
            }
            return asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
            return moment.duration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },
        calendar: function(time) {
            var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },
        isLeapYear: function() {
            return isLeapYear(this.year());
        },
        isDST: function() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, "d");
            } else {
                return day;
            }
        },
        month: makeAccessor("Month", true),
        startOf: function(units) {
            units = normalizeUnits(units);
            switch (units) {
              case "year":
                this.month(0);

              case "quarter":
              case "month":
                this.date(1);

              case "week":
              case "isoWeek":
              case "day":
                this.hours(0);

              case "hour":
                this.minutes(0);

              case "minute":
                this.seconds(0);

              case "second":
                this.milliseconds(0);
            }
            if (units === "week") {
                this.weekday(0);
            } else if (units === "isoWeek") {
                this.isoWeekday(1);
            }
            if (units === "quarter") {
                this.month(Math.floor(this.month() / 3) * 3);
            }
            return this;
        },
        endOf: function(units) {
            units = normalizeUnits(units);
            if (units === undefined || units === "millisecond") {
                return this;
            }
            return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
        },
        isAfter: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },
        isBefore: function(input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },
        isBetween: function(from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units);
        },
        isSame: function(input, units) {
            var inputMs;
            units = normalizeUnits(units || "millisecond");
            if (units === "millisecond") {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
            }
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function(other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        }),
        zone: deprecate("moment().zone is deprecated, use moment().utcOffset instead. " + "https://github.com/moment/moment/issues/1779", function(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== "string") {
                    input = -input;
                }
                this.utcOffset(input, keepLocalTime);
                return this;
            } else {
                return -this.utcOffset();
            }
        }),
        utcOffset: function(input, keepLocalTime) {
            var offset = this._offset || 0, localAdjust;
            if (input != null) {
                if (typeof input === "string") {
                    input = utcOffsetFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateUtcOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, "m");
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this, moment.duration(input - offset, "m"), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : this._dateUtcOffset();
            }
        },
        isLocal: function() {
            return !this._isUTC;
        },
        isUtcOffset: function() {
            return this._isUTC;
        },
        isUtc: function() {
            return this._isUTC && this._offset === 0;
        },
        zoneAbbr: function() {
            return this._isUTC ? "UTC" : "";
        },
        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },
        parseZone: function() {
            if (this._tzm) {
                this.utcOffset(this._tzm);
            } else if (typeof this._i === "string") {
                this.utcOffset(utcOffsetFromString(this._i));
            }
            return this;
        },
        hasAlignedHourOffset: function(input) {
            if (!input) {
                input = 0;
            } else {
                input = moment(input).utcOffset();
            }
            return (this.utcOffset() - input) % 60 === 0;
        },
        daysInMonth: function() {
            return daysInMonth(this.year(), this.month());
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        },
        quarter: function(input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },
        weekYear: function(input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add(input - year, "y");
        },
        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add(input - year, "y");
        },
        week: function(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, "d");
        },
        weekday: function(input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, "d");
        },
        isoWeekday: function(input) {
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },
        isoWeeksInYear: function() {
            return weeksInYear(this.year(), 1, 4);
        },
        weeksInYear: function() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units]();
        },
        set: function(units, value) {
            var unit;
            if (typeof units === "object") {
                for (unit in units) {
                    this.set(unit, units[unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (typeof this[units] === "function") {
                    this[units](value);
                }
            }
            return this;
        },
        locale: function(key) {
            var newLocaleData;
            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },
        lang: deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }),
        localeData: function() {
            return this._locale;
        },
        _dateUtcOffset: function() {
            return -Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });
    function rawMonthSetter(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== "number") {
                return mom;
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function rawSetter(mom, unit, value) {
        if (unit === "Month") {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
    }
    function makeAccessor(unit, keepTime) {
        return function(value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }
    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", false);
    moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", false);
    moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", false);
    moment.fn.hour = moment.fn.hours = makeAccessor("Hours", true);
    moment.fn.date = makeAccessor("Date", true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", true));
    moment.fn.year = makeAccessor("FullYear", true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", true));
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;
    moment.fn.toJSON = moment.fn.toISOString;
    moment.fn.isUTC = moment.fn.isUtc;
    function daysToYears(days) {
        return days * 400 / 146097;
    }
    function yearsToDays(years) {
        return years * 146097 / 400;
    }
    extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
            var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years = 0;
            data.milliseconds = milliseconds % 1e3;
            seconds = absRound(milliseconds / 1e3);
            data.seconds = seconds % 60;
            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;
            hours = absRound(minutes / 60);
            data.hours = hours % 24;
            days += absRound(hours / 24);
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));
            months += absRound(days / 30);
            days %= 30;
            years += absRound(months / 12);
            months %= 12;
            data.days = days;
            data.months = months;
            data.years = years;
        },
        abs: function() {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);
            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);
            return this;
        },
        weeks: function() {
            return absRound(this.days() / 7);
        },
        valueOf: function() {
            return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        },
        humanize: function(withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());
            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }
            return this.localeData().postformat(output);
        },
        add: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;
            this._bubble();
            return this;
        },
        subtract: function(input, val) {
            var dur = moment.duration(input, val);
            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;
            this._bubble();
            return this;
        },
        get: function(units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + "s"]();
        },
        as: function(units) {
            var days, months;
            units = normalizeUnits(units);
            if (units === "month" || units === "year") {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === "month" ? months : months / 12;
            } else {
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                  case "week":
                    return days / 7 + this._milliseconds / 6048e5;

                  case "day":
                    return days + this._milliseconds / 864e5;

                  case "hour":
                    return days * 24 + this._milliseconds / 36e5;

                  case "minute":
                    return days * 24 * 60 + this._milliseconds / 6e4;

                  case "second":
                    return days * 24 * 60 * 60 + this._milliseconds / 1e3;

                  case "millisecond":
                    return Math.floor(days * 24 * 60 * 60 * 1e3) + this._milliseconds;

                  default:
                    throw new Error("Unknown unit " + units);
                }
            }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead " + "(notice the capitals)", function() {
            return this.toISOString();
        }),
        toISOString: function() {
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
            if (!this.asSeconds()) {
                return "P0D";
            }
            return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "");
        },
        localeData: function() {
            return this._locale;
        },
        toJSON: function() {
            return this.toISOString();
        }
    });
    moment.duration.fn.toString = moment.duration.fn.toISOString;
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }
    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }
    moment.duration.fn.asMilliseconds = function() {
        return this.as("ms");
    };
    moment.duration.fn.asSeconds = function() {
        return this.as("s");
    };
    moment.duration.fn.asMinutes = function() {
        return this.as("m");
    };
    moment.duration.fn.asHours = function() {
        return this.as("h");
    };
    moment.duration.fn.asDays = function() {
        return this.as("d");
    };
    moment.duration.fn.asWeeks = function() {
        return this.as("weeks");
    };
    moment.duration.fn.asMonths = function() {
        return this.as("M");
    };
    moment.duration.fn.asYears = function() {
        return this.as("y");
    };
    moment.locale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    function makeGlobal(shouldDeprecate) {
        if (typeof ender !== "undefined") {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate("Accessing Moment through the global scope is " + "deprecated, and will be removed in an upcoming " + "release.", moment);
        } else {
            globalScope.moment = moment;
        }
    }
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === "function" && define.amd) {
        define(function(require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                globalScope.moment = oldGlobalMoment;
            }
            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

(function() {
    var root = this;
    var PIXI = PIXI || {};
    PIXI.WEBGL_RENDERER = 0;
    PIXI.CANVAS_RENDERER = 1;
    PIXI.VERSION = "v1.6.1";
    PIXI.blendModes = {
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16
    };
    PIXI.scaleModes = {
        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1
    };
    PIXI._UID = 0;
    if (typeof Float32Array != "undefined") {
        PIXI.Float32Array = Float32Array;
        PIXI.Uint16Array = Uint16Array;
    } else {
        PIXI.Float32Array = Array;
        PIXI.Uint16Array = Array;
    }
    PIXI.INTERACTION_FREQUENCY = 30;
    PIXI.AUTO_PREVENT_DEFAULT = true;
    PIXI.RAD_TO_DEG = 180 / Math.PI;
    PIXI.DEG_TO_RAD = Math.PI / 180;
    PIXI.dontSayHello = false;
    PIXI.sayHello = function(type) {
        if (PIXI.dontSayHello) return;
        if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
            var args = [ "%c %c %c Pixi.js " + PIXI.VERSION + " - " + type + "  %c " + " %c " + " http://www.pixijs.com/  %c %c ♥%c♥%c♥ ", "background: #ff66a5", "background: #ff66a5", "color: #ff66a5; background: #030307;", "background: #ff66a5", "background: #ffc3dc", "background: #ff66a5", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff", "color: #ff2424; background: #fff" ];
            console.log.apply(console, args);
        } else if (window["console"]) {
            console.log("Pixi.js " + PIXI.VERSION + " - http://www.pixijs.com/");
        }
        PIXI.dontSayHello = true;
    };
    PIXI.Matrix = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
    };
    PIXI.Matrix.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    };
    PIXI.Matrix.prototype.toArray = function(transpose) {
        if (!this.array) this.array = new Float32Array(9);
        var array = this.array;
        if (transpose) {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = 0;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        } else {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = this.tx;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }
        return array;
    };
    PIXI.Matrix.prototype.apply = function(pos, newPos) {
        newPos = newPos || new PIXI.Point();
        newPos.x = this.a * pos.x + this.b * pos.y + this.tx;
        newPos.y = this.c * pos.x + this.d * pos.y + this.ty;
        return newPos;
    };
    PIXI.Matrix.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new PIXI.Point();
        var id = 1 / (this.a * this.d + this.b * -this.c);
        newPos.x = this.d * id * pos.x - this.b * id * pos.y + (this.ty * this.b - this.tx * this.d) * id;
        newPos.y = this.a * id * pos.y - this.c * id * pos.x + (this.tx * this.c - this.ty * this.a) * id;
        return newPos;
    };
    PIXI.identityMatrix = new PIXI.Matrix();
    PIXI.determineMatrixArrayType = function() {
        return typeof Float32Array !== "undefined" ? Float32Array : Array;
    };
    PIXI.Matrix2 = PIXI.determineMatrixArrayType();
    PIXI.DisplayObject = function() {
        this.position = new PIXI.Point();
        this.scale = new PIXI.Point(1, 1);
        this.pivot = new PIXI.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = true;
        this.hitArea = null;
        this.buttonMode = false;
        this.renderable = false;
        this.parent = null;
        this.stage = null;
        this.worldAlpha = 1;
        this._interactive = false;
        this.defaultCursor = "pointer";
        this.worldTransform = new PIXI.Matrix();
        this.color = [];
        this.dynamic = true;
        this._sr = 0;
        this._cr = 1;
        this.filterArea = null;
        this._bounds = new PIXI.Rectangle(0, 0, 1, 1);
        this._currentBounds = null;
        this._mask = null;
        this._cacheAsBitmap = false;
        this._cacheIsDirty = false;
    };
    PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;
    PIXI.DisplayObject.prototype.setInteractive = function(interactive) {
        this.interactive = interactive;
    };
    Object.defineProperty(PIXI.DisplayObject.prototype, "interactive", {
        get: function() {
            return this._interactive;
        },
        set: function(value) {
            this._interactive = value;
            if (this.stage) this.stage.dirty = true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "worldVisible", {
        get: function() {
            var item = this;
            do {
                if (!item.visible) return false;
                item = item.parent;
            } while (item);
            return true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "mask", {
        get: function() {
            return this._mask;
        },
        set: function(value) {
            if (this._mask) this._mask.isMask = false;
            this._mask = value;
            if (this._mask) this._mask.isMask = true;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "filters", {
        get: function() {
            return this._filters;
        },
        set: function(value) {
            if (value) {
                var passes = [];
                for (var i = 0; i < value.length; i++) {
                    var filterPasses = value[i].passes;
                    for (var j = 0; j < filterPasses.length; j++) {
                        passes.push(filterPasses[j]);
                    }
                }
                this._filterBlock = {
                    target: this,
                    filterPasses: passes
                };
            }
            this._filters = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(value) {
            if (this._cacheAsBitmap === value) return;
            if (value) {
                this._generateCachedSprite();
            } else {
                this._destroyCachedSprite();
            }
            this._cacheAsBitmap = value;
        }
    });
    PIXI.DisplayObject.prototype.updateTransform = function() {
        if (this.rotation !== this.rotationCache) {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation);
        }
        var parentTransform = this.parent.worldTransform;
        var worldTransform = this.worldTransform;
        var px = this.pivot.x;
        var py = this.pivot.y;
        var a00 = this._cr * this.scale.x, a01 = -this._sr * this.scale.y, a10 = this._sr * this.scale.x, a11 = this._cr * this.scale.y, a02 = this.position.x - a00 * px - py * a01, a12 = this.position.y - a11 * py - px * a10, b00 = parentTransform.a, b01 = parentTransform.b, b10 = parentTransform.c, b11 = parentTransform.d;
        worldTransform.a = b00 * a00 + b01 * a10;
        worldTransform.b = b00 * a01 + b01 * a11;
        worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx;
        worldTransform.c = b10 * a00 + b11 * a10;
        worldTransform.d = b10 * a01 + b11 * a11;
        worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty;
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
    };
    PIXI.DisplayObject.prototype.getBounds = function(matrix) {
        matrix = matrix;
        return PIXI.EmptyRectangle;
    };
    PIXI.DisplayObject.prototype.getLocalBounds = function() {
        return this.getBounds(PIXI.identityMatrix);
    };
    PIXI.DisplayObject.prototype.setStageReference = function(stage) {
        this.stage = stage;
        if (this._interactive) this.stage.dirty = true;
    };
    PIXI.DisplayObject.prototype.generateTexture = function(renderer) {
        var bounds = this.getLocalBounds();
        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer);
        renderTexture.render(this, new PIXI.Point(-bounds.x, -bounds.y));
        return renderTexture;
    };
    PIXI.DisplayObject.prototype.updateCache = function() {
        this._generateCachedSprite();
    };
    PIXI.DisplayObject.prototype.toGlobal = function(pos) {
        this.updateTransform();
        return this.worldTransform.apply(pos);
    };
    PIXI.DisplayObject.prototype.toLocal = function(pos, from) {
        if (from) {
            pos = from.toGlobal(pos);
        }
        this.updateTransform();
        return this.worldTransform.applyInverse(pos);
    };
    PIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession) {
        this._cachedSprite.worldAlpha = this.worldAlpha;
        if (renderSession.gl) {
            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
        } else {
            PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
        }
    };
    PIXI.DisplayObject.prototype._generateCachedSprite = function() {
        this._cacheAsBitmap = false;
        var bounds = this.getLocalBounds();
        if (!this._cachedSprite) {
            var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0);
            this._cachedSprite = new PIXI.Sprite(renderTexture);
            this._cachedSprite.worldTransform = this.worldTransform;
        } else {
            this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0);
        }
        var tempFilters = this._filters;
        this._filters = null;
        this._cachedSprite.filters = tempFilters;
        this._cachedSprite.texture.render(this, new PIXI.Point(-bounds.x, -bounds.y));
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this._filters = tempFilters;
        this._cacheAsBitmap = true;
    };
    PIXI.DisplayObject.prototype._destroyCachedSprite = function() {
        if (!this._cachedSprite) return;
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null;
    };
    PIXI.DisplayObject.prototype._renderWebGL = function(renderSession) {
        renderSession = renderSession;
    };
    PIXI.DisplayObject.prototype._renderCanvas = function(renderSession) {
        renderSession = renderSession;
    };
    Object.defineProperty(PIXI.DisplayObject.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObject.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
        }
    });
    PIXI.DisplayObjectContainer = function() {
        PIXI.DisplayObject.call(this);
        this.children = [];
    };
    PIXI.DisplayObjectContainer.prototype = Object.create(PIXI.DisplayObject.prototype);
    PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;
    Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value) {
            var width = this.getLocalBounds().width;
            if (width !== 0) {
                this.scale.x = value / (width / this.scale.x);
            } else {
                this.scale.x = 1;
            }
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value) {
            var height = this.getLocalBounds().height;
            if (height !== 0) {
                this.scale.y = value / (height / this.scale.y);
            } else {
                this.scale.y = 1;
            }
            this._height = value;
        }
    });
    PIXI.DisplayObjectContainer.prototype.addChild = function(child) {
        return this.addChildAt(child, this.children.length);
    };
    PIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index) {
        if (index >= 0 && index <= this.children.length) {
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            this.children.splice(index, 0, child);
            if (this.stage) child.setStageReference(this.stage);
            return child;
        } else {
            throw new Error(child + " The index " + index + " supplied is out of bounds " + this.children.length);
        }
    };
    PIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
            return;
        }
        var index1 = this.children.indexOf(child);
        var index2 = this.children.indexOf(child2);
        if (index1 < 0 || index2 < 0) {
            throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
        }
        this.children[index1] = child2;
        this.children[index2] = child;
    };
    PIXI.DisplayObjectContainer.prototype.getChildAt = function(index) {
        if (index >= 0 && index < this.children.length) {
            return this.children[index];
        } else {
            throw new Error("Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        }
    };
    PIXI.DisplayObjectContainer.prototype.removeChild = function(child) {
        return this.removeChildAt(this.children.indexOf(child));
    };
    PIXI.DisplayObjectContainer.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        if (this.stage) child.removeStageReference();
        child.parent = undefined;
        this.children.splice(index, 1);
        return child;
    };
    PIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex) {
        var begin = beginIndex || 0;
        var end = typeof endIndex === "number" ? endIndex : this.children.length;
        var range = end - begin;
        if (range > 0 && range <= end) {
            var removed = this.children.splice(begin, range);
            for (var i = 0; i < removed.length; i++) {
                var child = removed[i];
                if (this.stage) child.removeStageReference();
                child.parent = undefined;
            }
            return removed;
        } else if (range === 0 && this.children.length === 0) {
            return [];
        } else {
            throw new Error("Range Error, numeric values are outside the acceptable range");
        }
    };
    PIXI.DisplayObjectContainer.prototype.updateTransform = function() {
        if (!this.visible) return;
        PIXI.DisplayObject.prototype.updateTransform.call(this);
        if (this._cacheAsBitmap) return;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
    };
    PIXI.DisplayObjectContainer.prototype.getBounds = function(matrix) {
        if (this.children.length === 0) return PIXI.EmptyRectangle;
        if (matrix) {
            var matrixCache = this.worldTransform;
            this.worldTransform = matrix;
            this.updateTransform();
            this.worldTransform = matrixCache;
        }
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var childBounds;
        var childMaxX;
        var childMaxY;
        var childVisible = false;
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            if (!child.visible) continue;
            childVisible = true;
            childBounds = this.children[i].getBounds(matrix);
            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;
            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;
            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
        }
        if (!childVisible) return PIXI.EmptyRectangle;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.y = minY;
        bounds.width = maxX - minX;
        bounds.height = maxY - minY;
        return bounds;
    };
    PIXI.DisplayObjectContainer.prototype.getLocalBounds = function() {
        var matrixCache = this.worldTransform;
        this.worldTransform = PIXI.identityMatrix;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
        var bounds = this.getBounds();
        this.worldTransform = matrixCache;
        return bounds;
    };
    PIXI.DisplayObjectContainer.prototype.setStageReference = function(stage) {
        this.stage = stage;
        if (this._interactive) this.stage.dirty = true;
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            child.setStageReference(stage);
        }
    };
    PIXI.DisplayObjectContainer.prototype.removeStageReference = function() {
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            child.removeStageReference();
        }
        if (this._interactive) this.stage.dirty = true;
        this.stage = null;
    };
    PIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(renderSession);
            return;
        }
        var i, j;
        if (this._mask || this._filters) {
            if (this._filters) {
                renderSession.spriteBatch.flush();
                renderSession.filterManager.pushFilter(this._filterBlock);
            }
            if (this._mask) {
                renderSession.spriteBatch.stop();
                renderSession.maskManager.pushMask(this.mask, renderSession);
                renderSession.spriteBatch.start();
            }
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
            renderSession.spriteBatch.stop();
            if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.popFilter();
            renderSession.spriteBatch.start();
        } else {
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
        }
    };
    PIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0) return;
        if (this._cacheAsBitmap) {
            this._renderCachedSprite(renderSession);
            return;
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession.context);
        }
        for (var i = 0, j = this.children.length; i < j; i++) {
            var child = this.children[i];
            child._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
    };
    PIXI.Sprite = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.anchor = new PIXI.Point();
        this.texture = texture;
        this._width = 0;
        this._height = 0;
        this.tint = 16777215;
        this.blendMode = PIXI.blendModes.NORMAL;
        if (texture.baseTexture.hasLoaded) {
            this.onTextureUpdate();
        } else {
            this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
            this.texture.addEventListener("update", this.onTextureUpdateBind);
        }
        this.renderable = true;
    };
    PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Sprite.prototype.constructor = PIXI.Sprite;
    Object.defineProperty(PIXI.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width;
        },
        set: function(value) {
            this.scale.x = value / this.texture.frame.width;
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height;
        },
        set: function(value) {
            this.scale.y = value / this.texture.frame.height;
            this._height = value;
        }
    });
    PIXI.Sprite.prototype.setTexture = function(texture) {
        this.texture = texture;
        this.cachedTint = 16777215;
    };
    PIXI.Sprite.prototype.onTextureUpdate = function() {
        if (this._width) this.scale.x = this._width / this.texture.frame.width;
        if (this._height) this.scale.y = this._height / this.texture.frame.height;
    };
    PIXI.Sprite.prototype.getBounds = function(matrix) {
        var width = this.texture.frame.width;
        var height = this.texture.frame.height;
        var w0 = width * (1 - this.anchor.x);
        var w1 = width * -this.anchor.x;
        var h0 = height * (1 - this.anchor.y);
        var h1 = height * -this.anchor.y;
        var worldTransform = matrix || this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        minX = x1 < minX ? x1 : minX;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y1 < minY ? y1 : minY;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x1 > maxX ? x1 : maxX;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y1 > maxY ? y1 : maxY;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
    };
    PIXI.Sprite.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        var i, j;
        if (this._mask || this._filters) {
            var spriteBatch = renderSession.spriteBatch;
            if (this._filters) {
                spriteBatch.flush();
                renderSession.filterManager.pushFilter(this._filterBlock);
            }
            if (this._mask) {
                spriteBatch.stop();
                renderSession.maskManager.pushMask(this.mask, renderSession);
                spriteBatch.start();
            }
            spriteBatch.render(this);
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
            spriteBatch.stop();
            if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.popFilter();
            spriteBatch.start();
        } else {
            renderSession.spriteBatch.render(this);
            for (i = 0, j = this.children.length; i < j; i++) {
                this.children[i]._renderWebGL(renderSession);
            }
        }
    };
    PIXI.Sprite.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.texture.crop.width <= 0 || this.texture.crop.height <= 0) return;
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession.context);
        }
        if (this.texture.valid) {
            renderSession.context.globalAlpha = this.worldAlpha;
            if (renderSession.roundPixels) {
                renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, this.worldTransform.tx | 0, this.worldTransform.ty | 0);
            } else {
                renderSession.context.setTransform(this.worldTransform.a, this.worldTransform.c, this.worldTransform.b, this.worldTransform.d, this.worldTransform.tx, this.worldTransform.ty);
            }
            if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) {
                renderSession.scaleMode = this.texture.baseTexture.scaleMode;
                renderSession.context[renderSession.smoothProperty] = renderSession.scaleMode === PIXI.scaleModes.LINEAR;
            }
            var dx = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;
            var dy = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
            if (this.tint !== 16777215) {
                if (this.cachedTint !== this.tint) {
                    this.cachedTint = this.tint;
                    this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);
                }
                renderSession.context.drawImage(this.tintedTexture, 0, 0, this.texture.crop.width, this.texture.crop.height, dx, dy, this.texture.crop.width, this.texture.crop.height);
            } else {
                renderSession.context.drawImage(this.texture.baseTexture.source, this.texture.crop.x, this.texture.crop.y, this.texture.crop.width, this.texture.crop.height, dx, dy, this.texture.crop.width, this.texture.crop.height);
            }
        }
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
    };
    PIXI.Sprite.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache' + this);
        return new PIXI.Sprite(texture);
    };
    PIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode) {
        var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);
        return new PIXI.Sprite(texture);
    };
    PIXI.SpriteBatch = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.textureThing = texture;
        this.ready = false;
    };
    PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.SpriteBatch.constructor = PIXI.SpriteBatch;
    PIXI.SpriteBatch.prototype.initWebGL = function(gl) {
        this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);
        this.ready = true;
    };
    PIXI.SpriteBatch.prototype.updateTransform = function() {
        PIXI.DisplayObject.prototype.updateTransform.call(this);
    };
    PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0 || !this.children.length) return;
        if (!this.ready) this.initWebGL(renderSession.gl);
        renderSession.spriteBatch.stop();
        renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader);
        this.fastSpriteBatch.begin(this, renderSession);
        this.fastSpriteBatch.render(this);
        renderSession.spriteBatch.start();
    };
    PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession) {
        var context = renderSession.context;
        context.globalAlpha = this.worldAlpha;
        PIXI.DisplayObject.prototype.updateTransform.call(this);
        var transform = this.worldTransform;
        var isRotated = true;
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (!child.visible) continue;
            var texture = child.texture;
            var frame = texture.frame;
            context.globalAlpha = this.worldAlpha * child.alpha;
            if (child.rotation % (Math.PI * 2) === 0) {
                if (isRotated) {
                    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
                    isRotated = false;
                }
                context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * (-frame.width * child.scale.x) + child.position.x + .5 | 0, child.anchor.y * (-frame.height * child.scale.y) + child.position.y + .5 | 0, frame.width * child.scale.x, frame.height * child.scale.y);
            } else {
                if (!isRotated) isRotated = true;
                PIXI.DisplayObject.prototype.updateTransform.call(child);
                var childTransform = child.worldTransform;
                if (renderSession.roundPixels) {
                    context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);
                } else {
                    context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx, childTransform.ty);
                }
                context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, child.anchor.x * -frame.width + .5 | 0, child.anchor.y * -frame.height + .5 | 0, frame.width, frame.height);
            }
        }
    };
    PIXI.AbstractFilter = function(fragmentSrc, uniforms) {
        this.passes = [ this ];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.uniforms = uniforms || {};
        this.fragmentSrc = fragmentSrc || [];
    };
    PIXI.FilterBlock = function() {
        this.visible = true;
        this.renderable = true;
    };
    PIXI.Text = function(text, style) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));
        this.setText(text);
        this.setStyle(style);
    };
    PIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);
    PIXI.Text.prototype.constructor = PIXI.Text;
    Object.defineProperty(PIXI.Text.prototype, "width", {
        get: function() {
            if (this.dirty) {
                this.updateText();
                this.dirty = false;
            }
            return this.scale.x * this.texture.frame.width;
        },
        set: function(value) {
            this.scale.x = value / this.texture.frame.width;
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.Text.prototype, "height", {
        get: function() {
            if (this.dirty) {
                this.updateText();
                this.dirty = false;
            }
            return this.scale.y * this.texture.frame.height;
        },
        set: function(value) {
            this.scale.y = value / this.texture.frame.height;
            this._height = value;
        }
    });
    PIXI.Text.prototype.setStyle = function(style) {
        style = style || {};
        style.font = style.font || "bold 20pt Arial";
        style.fill = style.fill || "black";
        style.align = style.align || "left";
        style.stroke = style.stroke || "black";
        style.strokeThickness = style.strokeThickness || 0;
        style.wordWrap = style.wordWrap || false;
        style.wordWrapWidth = style.wordWrapWidth || 100;
        style.dropShadow = style.dropShadow || false;
        style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;
        style.dropShadowDistance = style.dropShadowDistance || 4;
        style.dropShadowColor = style.dropShadowColor || "black";
        this.style = style;
        this.dirty = true;
    };
    PIXI.Text.prototype.setText = function(text) {
        this.text = text.toString() || " ";
        this.dirty = true;
    };
    PIXI.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var outputText = this.text;
        if (this.style.wordWrap) outputText = this.wordWrap(this.text);
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = [];
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = this.context.measureText(lines[i]).width;
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + this.style.strokeThickness;
        if (this.style.dropShadow) width += this.style.dropShadowDistance;
        this.canvas.width = width + this.context.lineWidth;
        var lineHeight = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness;
        var height = lineHeight * lines.length;
        if (this.style.dropShadow) height += this.style.dropShadowDistance;
        this.canvas.height = height;
        if (navigator.isCocoonJS) this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.textBaseline = "top";
        var linePositionX;
        var linePositionY;
        if (this.style.dropShadow) {
            this.context.fillStyle = this.style.dropShadowColor;
            var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;
            var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;
            for (i = 0; i < lines.length; i++) {
                linePositionX = this.style.strokeThickness / 2;
                linePositionY = this.style.strokeThickness / 2 + i * lineHeight;
                if (this.style.align === "right") {
                    linePositionX += maxLineWidth - lineWidths[i];
                } else if (this.style.align === "center") {
                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;
                }
                if (this.style.fill) {
                    this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);
                }
            }
        }
        this.context.fillStyle = this.style.fill;
        for (i = 0; i < lines.length; i++) {
            linePositionX = this.style.strokeThickness / 2;
            linePositionY = this.style.strokeThickness / 2 + i * lineHeight;
            if (this.style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i];
            } else if (this.style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(lines[i], linePositionX, linePositionY);
            }
            if (this.style.fill) {
                this.context.fillText(lines[i], linePositionX, linePositionY);
            }
        }
        this.updateTexture();
    };
    PIXI.Text.prototype.updateTexture = function() {
        this.texture.baseTexture.width = this.canvas.width;
        this.texture.baseTexture.height = this.canvas.height;
        this.texture.crop.width = this.texture.frame.width = this.canvas.width;
        this.texture.crop.height = this.texture.frame.height = this.canvas.height;
        this._width = this.canvas.width;
        this._height = this.canvas.height;
        this.requiresUpdate = true;
    };
    PIXI.Text.prototype._renderWebGL = function(renderSession) {
        if (this.requiresUpdate) {
            this.requiresUpdate = false;
            PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl);
        }
        PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);
    };
    PIXI.Text.prototype.updateTransform = function() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        PIXI.Sprite.prototype.updateTransform.call(this);
    };
    PIXI.Text.prototype.determineFontHeight = function(fontStyle) {
        var result = PIXI.Text.heightCache[fontStyle];
        if (!result) {
            var body = document.getElementsByTagName("body")[0];
            var dummy = document.createElement("div");
            var dummyText = document.createTextNode("M");
            dummy.appendChild(dummyText);
            dummy.setAttribute("style", fontStyle + ";position:absolute;top:0;left:0");
            body.appendChild(dummy);
            result = dummy.offsetHeight;
            PIXI.Text.heightCache[fontStyle] = result;
            body.removeChild(dummy);
        }
        return result;
    };
    PIXI.Text.prototype.wordWrap = function(text) {
        var result = "";
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var spaceLeft = this.style.wordWrapWidth;
            var words = lines[i].split(" ");
            for (var j = 0; j < words.length; j++) {
                var wordWidth = this.context.measureText(words[j]).width;
                var wordWidthWithSpace = wordWidth + this.context.measureText(" ").width;
                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                        result += "\n";
                    }
                    result += words[j];
                    spaceLeft = this.style.wordWrapWidth - wordWidth;
                } else {
                    spaceLeft -= wordWidthWithSpace;
                    result += " " + words[j];
                }
            }
            if (i < lines.length - 1) {
                result += "\n";
            }
        }
        return result;
    };
    PIXI.Text.prototype.destroy = function(destroyBaseTexture) {
        this.context = null;
        this.canvas = null;
        this.texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
    };
    PIXI.Text.heightCache = {};
    PIXI.BitmapText = function(text, style) {
        PIXI.DisplayObjectContainer.call(this);
        this._pool = [];
        this.setText(text);
        this.setStyle(style);
        this.updateText();
        this.dirty = false;
    };
    PIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.BitmapText.prototype.constructor = PIXI.BitmapText;
    PIXI.BitmapText.prototype.setText = function(text) {
        this.text = text || " ";
        this.dirty = true;
    };
    PIXI.BitmapText.prototype.setStyle = function(style) {
        style = style || {};
        style.align = style.align || "left";
        this.style = style;
        var font = style.font.split(" ");
        this.fontName = font[font.length - 1];
        this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;
        this.dirty = true;
        this.tint = style.tint;
    };
    PIXI.BitmapText.prototype.updateText = function() {
        var data = PIXI.BitmapText.fonts[this.fontName];
        var pos = new PIXI.Point();
        var prevCharCode = null;
        var chars = [];
        var maxLineWidth = 0;
        var lineWidths = [];
        var line = 0;
        var scale = this.fontSize / data.size;
        for (var i = 0; i < this.text.length; i++) {
            var charCode = this.text.charCodeAt(i);
            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) {
                lineWidths.push(pos.x);
                maxLineWidth = Math.max(maxLineWidth, pos.x);
                line++;
                pos.x = 0;
                pos.y += data.lineHeight;
                prevCharCode = null;
                continue;
            }
            var charData = data.chars[charCode];
            if (!charData) continue;
            if (prevCharCode && charData[prevCharCode]) {
                pos.x += charData.kerning[prevCharCode];
            }
            chars.push({
                texture: charData.texture,
                line: line,
                charCode: charCode,
                position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)
            });
            pos.x += charData.xAdvance;
            prevCharCode = charCode;
        }
        lineWidths.push(pos.x);
        maxLineWidth = Math.max(maxLineWidth, pos.x);
        var lineAlignOffsets = [];
        for (i = 0; i <= line; i++) {
            var alignOffset = 0;
            if (this.style.align === "right") {
                alignOffset = maxLineWidth - lineWidths[i];
            } else if (this.style.align === "center") {
                alignOffset = (maxLineWidth - lineWidths[i]) / 2;
            }
            lineAlignOffsets.push(alignOffset);
        }
        var lenChildren = this.children.length;
        var lenChars = chars.length;
        var tint = this.tint || 16777215;
        for (i = 0; i < lenChars; i++) {
            var c = i < lenChildren ? this.children[i] : this._pool.pop();
            if (c) c.setTexture(chars[i].texture); else c = new PIXI.Sprite(chars[i].texture);
            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
            c.position.y = chars[i].position.y * scale;
            c.scale.x = c.scale.y = scale;
            c.tint = tint;
            if (!c.parent) this.addChild(c);
        }
        while (this.children.length > lenChars) {
            var child = this.getChildAt(this.children.length - 1);
            this._pool.push(child);
            this.removeChild(child);
        }
        this.textWidth = maxLineWidth * scale;
        this.textHeight = (pos.y + data.lineHeight) * scale;
    };
    PIXI.BitmapText.prototype.updateTransform = function() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.BitmapText.fonts = {};
    PIXI.Stage = function(backgroundColor) {
        PIXI.DisplayObjectContainer.call(this);
        this.worldTransform = new PIXI.Matrix();
        this.interactive = true;
        this.interactionManager = new PIXI.InteractionManager(this);
        this.dirty = true;
        this.stage = this;
        this.stage.hitArea = new PIXI.Rectangle(0, 0, 1e5, 1e5);
        this.setBackgroundColor(backgroundColor);
    };
    PIXI.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Stage.prototype.constructor = PIXI.Stage;
    PIXI.Stage.prototype.setInteractionDelegate = function(domElement) {
        this.interactionManager.setTargetDomElement(domElement);
    };
    PIXI.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i].updateTransform();
        }
        if (this.dirty) {
            this.dirty = false;
            this.interactionManager.dirty = true;
        }
        if (this.interactive) this.interactionManager.update();
    };
    PIXI.Stage.prototype.setBackgroundColor = function(backgroundColor) {
        this.backgroundColor = backgroundColor || 0;
        this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);
        var hex = this.backgroundColor.toString(16);
        hex = "000000".substr(0, 6 - hex.length) + hex;
        this.backgroundColorString = "#" + hex;
    };
    PIXI.Stage.prototype.getMousePosition = function() {
        return this.interactionManager.mouse.global;
    };
    (function(window) {
        var lastTime = 0;
        var vendors = [ "ms", "moz", "webkit", "o" ];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        }
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
        window.requestAnimFrame = window.requestAnimationFrame;
    })(this);
    PIXI.hex2rgb = function(hex) {
        return [ (hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255 ];
    };
    PIXI.rgb2hex = function(rgb) {
        return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
    };
    if (typeof Function.prototype.bind !== "function") {
        Function.prototype.bind = function() {
            return function(thisArg) {
                var target = this, i = arguments.length - 1, boundArgs = [];
                if (i > 0) {
                    boundArgs.length = i;
                    while (i--) boundArgs[i] = arguments[i + 1];
                }
                if (typeof target !== "function") throw new TypeError();
                function bound() {
                    var i = arguments.length, args = new Array(i);
                    while (i--) args[i] = arguments[i];
                    args = boundArgs.concat(args);
                    target.apply(this instanceof bound ? this : thisArg, args);
                }
                bound.prototype = function F(proto) {
                    if (proto) F.prototype = proto;
                    if (!(this instanceof F)) return new F();
                }(target.prototype);
                return bound;
            };
        }();
    }
    PIXI.AjaxRequest = function() {
        var activexmodes = [ "Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Microsoft.XMLHTTP" ];
        if (window.ActiveXObject) {
            for (var i = 0; i < activexmodes.length; i++) {
                try {
                    return new window.ActiveXObject(activexmodes[i]);
                } catch (e) {}
            }
        } else if (window.XMLHttpRequest) {
            return new window.XMLHttpRequest();
        } else {
            return false;
        }
    };
    PIXI.canUseNewCanvasBlendModes = function() {
        if (typeof document === "undefined") return false;
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        var context = canvas.getContext("2d");
        context.fillStyle = "#000";
        context.fillRect(0, 0, 1, 1);
        context.globalCompositeOperation = "multiply";
        context.fillStyle = "#fff";
        context.fillRect(0, 0, 1, 1);
        return context.getImageData(0, 0, 1, 1).data[0] === 0;
    };
    PIXI.getNextPowerOfTwo = function(number) {
        if (number > 0 && (number & number - 1) === 0) return number; else {
            var result = 1;
            while (result < number) result <<= 1;
            return result;
        }
    };
    PIXI.EventTarget = function() {
        var listeners = {};
        this.addEventListener = this.on = function(type, listener) {
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].unshift(listener);
            }
        };
        this.dispatchEvent = this.emit = function(event) {
            if (!listeners[event.type] || !listeners[event.type].length) {
                return;
            }
            for (var i = listeners[event.type].length - 1; i >= 0; i--) {
                listeners[event.type][i](event);
            }
        };
        this.removeEventListener = this.off = function(type, listener) {
            if (listeners[type] === undefined) return;
            var index = listeners[type].indexOf(listener);
            if (index !== -1) {
                listeners[type].splice(index, 1);
            }
        };
        this.removeAllEventListeners = function(type) {
            var a = listeners[type];
            if (a) a.length = 0;
        };
    };
    PIXI.PolyK = {};
    PIXI.PolyK.Triangulate = function(p) {
        var sign = true;
        var n = p.length >> 1;
        if (n < 3) return [];
        var tgs = [];
        var avl = [];
        for (var i = 0; i < n; i++) avl.push(i);
        i = 0;
        var al = n;
        while (al > 3) {
            var i0 = avl[(i + 0) % al];
            var i1 = avl[(i + 1) % al];
            var i2 = avl[(i + 2) % al];
            var ax = p[2 * i0], ay = p[2 * i0 + 1];
            var bx = p[2 * i1], by = p[2 * i1 + 1];
            var cx = p[2 * i2], cy = p[2 * i2 + 1];
            var earFound = false;
            if (PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign)) {
                earFound = true;
                for (var j = 0; j < al; j++) {
                    var vi = avl[j];
                    if (vi === i0 || vi === i1 || vi === i2) continue;
                    if (PIXI.PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }
            if (earFound) {
                tgs.push(i0, i1, i2);
                avl.splice((i + 1) % al, 1);
                al--;
                i = 0;
            } else if (i++ > 3 * al) {
                if (sign) {
                    tgs = [];
                    avl = [];
                    for (i = 0; i < n; i++) avl.push(i);
                    i = 0;
                    al = n;
                    sign = false;
                } else {
                    window.console.log("PIXI Warning: shape too complex to fill");
                    return [];
                }
            }
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    };
    PIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = px - ax;
        var v2y = py - ay;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return u >= 0 && v >= 0 && u + v < 1;
    };
    PIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign) {
        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0 === sign;
    };
    PIXI.initDefaultShaders = function() {};
    PIXI.CompileVertexShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
    };
    PIXI.CompileFragmentShader = function(gl, shaderSrc) {
        return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
    };
    PIXI._CompileShader = function(gl, shaderSrc, shaderType) {
        var src = shaderSrc.join("\n");
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            window.console.log(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    };
    PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc) {
        var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
        var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            window.console.log("Could not initialise shaders");
        }
        return shaderProgram;
    };
    PIXI.PixiShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ];
        this.textureCount = 0;
        this.attributes = [];
        this.init();
    };
    PIXI.PixiShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.dimensions = gl.getUniformLocation(program, "dimensions");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2;
        }
        this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute ];
        for (var key in this.uniforms) {
            this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
        }
        this.initUniforms();
        this.program = program;
    };
    PIXI.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var gl = this.gl;
        var uniform;
        for (var key in this.uniforms) {
            uniform = this.uniforms[key];
            var type = uniform.type;
            if (type === "sampler2D") {
                uniform._init = false;
                if (uniform.value !== null) {
                    this.initSampler2D(uniform);
                }
            } else if (type === "mat2" || type === "mat3" || type === "mat4") {
                uniform.glMatrix = true;
                uniform.glValueLength = 1;
                if (type === "mat2") {
                    uniform.glFunc = gl.uniformMatrix2fv;
                } else if (type === "mat3") {
                    uniform.glFunc = gl.uniformMatrix3fv;
                } else if (type === "mat4") {
                    uniform.glFunc = gl.uniformMatrix4fv;
                }
            } else {
                uniform.glFunc = gl["uniform" + type];
                if (type === "2f" || type === "2i") {
                    uniform.glValueLength = 2;
                } else if (type === "3f" || type === "3i") {
                    uniform.glValueLength = 3;
                } else if (type === "4f" || type === "4i") {
                    uniform.glValueLength = 4;
                } else {
                    uniform.glValueLength = 1;
                }
            }
        }
    };
    PIXI.PixiShader.prototype.initSampler2D = function(uniform) {
        if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded) {
            return;
        }
        var gl = this.gl;
        gl.activeTexture(gl["TEXTURE" + this.textureCount]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);
        if (uniform.textureData) {
            var data = uniform.textureData;
            var magFilter = data.magFilter ? data.magFilter : gl.LINEAR;
            var minFilter = data.minFilter ? data.minFilter : gl.LINEAR;
            var wrapS = data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE;
            var wrapT = data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE;
            var format = data.luminance ? gl.LUMINANCE : gl.RGBA;
            if (data.repeat) {
                wrapS = gl.REPEAT;
                wrapT = gl.REPEAT;
            }
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
            if (data.width) {
                var width = data.width ? data.width : 512;
                var height = data.height ? data.height : 2;
                var border = data.border ? data.border : 0;
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
            }
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
        }
        gl.uniform1i(uniform.uniformLocation, this.textureCount);
        uniform._init = true;
        this.textureCount++;
    };
    PIXI.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var uniform;
        var gl = this.gl;
        for (var key in this.uniforms) {
            uniform = this.uniforms[key];
            if (uniform.glValueLength === 1) {
                if (uniform.glMatrix === true) {
                    uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);
                } else {
                    uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);
                }
            } else if (uniform.glValueLength === 2) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);
            } else if (uniform.glValueLength === 3) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);
            } else if (uniform.glValueLength === 4) {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);
            } else if (uniform.type === "sampler2D") {
                if (uniform._init) {
                    gl.activeTexture(gl["TEXTURE" + this.textureCount]);
                    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(uniform.value.baseTexture, gl));
                    gl.uniform1i(uniform.uniformLocation, this.textureCount);
                    this.textureCount++;
                } else {
                    this.initSampler2D(uniform);
                }
            }
        }
    };
    PIXI.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.PixiShader.defaultVertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec2 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;", "   vColor = vec4(color * aColor.x, aColor.x);", "}" ];
    PIXI.PixiFastShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}" ];
        this.textureCount = 0;
        this.init();
    };
    PIXI.PixiFastShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.dimensions = gl.getUniformLocation(program, "dimensions");
        this.uMatrix = gl.getUniformLocation(program, "uMatrix");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aPositionCoord = gl.getAttribLocation(program, "aPositionCoord");
        this.aScale = gl.getAttribLocation(program, "aScale");
        this.aRotation = gl.getAttribLocation(program, "aRotation");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        if (this.colorAttribute === -1) {
            this.colorAttribute = 2;
        }
        this.attributes = [ this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute ];
        this.program = program;
    };
    PIXI.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.StripShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}" ];
        this.init();
    };
    PIXI.StripShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.uSampler = gl.getUniformLocation(program, "uSampler");
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(program, "aTextureCoord");
        this.attributes = [ this.aVertexPosition, this.aTextureCoord ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attribute = null;
    };
    PIXI.PrimitiveShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}" ];
        this.init();
    };
    PIXI.PrimitiveShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.tintColor = gl.getUniformLocation(program, "tint");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.colorAttribute = gl.getAttribLocation(program, "aColor");
        this.attributes = [ this.aVertexPosition, this.colorAttribute ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attributes = null;
    };
    PIXI.ComplexPrimitiveShader = function(gl) {
        this._UID = PIXI._UID++;
        this.gl = gl;
        this.program = null;
        this.fragmentSrc = [ "precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}" ];
        this.vertexSrc = [ "attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}" ];
        this.init();
    };
    PIXI.ComplexPrimitiveShader.prototype.init = function() {
        var gl = this.gl;
        var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(program);
        this.projectionVector = gl.getUniformLocation(program, "projectionVector");
        this.offsetVector = gl.getUniformLocation(program, "offsetVector");
        this.tintColor = gl.getUniformLocation(program, "tint");
        this.color = gl.getUniformLocation(program, "color");
        this.aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
        this.attributes = [ this.aVertexPosition, this.colorAttribute ];
        this.translationMatrix = gl.getUniformLocation(program, "translationMatrix");
        this.alpha = gl.getUniformLocation(program, "alpha");
        this.program = program;
    };
    PIXI.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program);
        this.uniforms = null;
        this.gl = null;
        this.attribute = null;
    };
    PIXI.WebGLGraphics = function() {};
    PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession) {
        var gl = renderSession.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.primitiveShader, webGLData;
        if (graphics.dirty) {
            PIXI.WebGLGraphics.updateGraphics(graphics, gl);
        }
        var webGL = graphics._webGL[gl.id];
        for (var i = 0; i < webGL.data.length; i++) {
            if (webGL.data[i].mode === 1) {
                webGLData = webGL.data[i];
                renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession);
                gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
                renderSession.stencilManager.popStencil(graphics, webGLData, renderSession);
            } else {
                webGLData = webGL.data[i];
                renderSession.shaderManager.setShader(shader);
                shader = renderSession.shaderManager.primitiveShader;
                gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
                gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
                gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
                gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
                gl.uniform1f(shader.alpha, graphics.worldAlpha);
                gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
                gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
                gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
                gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
            }
        }
    };
    PIXI.WebGLGraphics.updateGraphics = function(graphics, gl) {
        var webGL = graphics._webGL[gl.id];
        if (!webGL) webGL = graphics._webGL[gl.id] = {
            lastIndex: 0,
            data: [],
            gl: gl
        };
        graphics.dirty = false;
        var i;
        if (graphics.clearDirty) {
            graphics.clearDirty = false;
            for (i = 0; i < webGL.data.length; i++) {
                var graphicsData = webGL.data[i];
                graphicsData.reset();
                PIXI.WebGLGraphics.graphicsDataPool.push(graphicsData);
            }
            webGL.data = [];
            webGL.lastIndex = 0;
        }
        var webGLData;
        for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            if (data.type === PIXI.Graphics.POLY) {
                if (data.fill) {
                    if (data.points.length > 6) {
                        if (data.points.length > 5 * 2) {
                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1);
                            PIXI.WebGLGraphics.buildComplexPoly(data, webGLData);
                        } else {
                            webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                            PIXI.WebGLGraphics.buildPoly(data, webGLData);
                        }
                    }
                }
                if (data.lineWidth > 0) {
                    webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                    PIXI.WebGLGraphics.buildLine(data, webGLData);
                }
            } else {
                webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0);
                if (data.type === PIXI.Graphics.RECT) {
                    PIXI.WebGLGraphics.buildRectangle(data, webGLData);
                } else if (data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP) {
                    PIXI.WebGLGraphics.buildCircle(data, webGLData);
                } else if (data.type === PIXI.Graphics.RREC) {
                    PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData);
                }
            }
            webGL.lastIndex++;
        }
        for (i = 0; i < webGL.data.length; i++) {
            webGLData = webGL.data[i];
            if (webGLData.dirty) webGLData.upload();
        }
    };
    PIXI.WebGLGraphics.switchMode = function(webGL, type) {
        var webGLData;
        if (!webGL.data.length) {
            webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        } else {
            webGLData = webGL.data[webGL.data.length - 1];
            if (webGLData.mode !== type || type === 1) {
                webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl);
                webGLData.mode = type;
                webGL.data.push(webGLData);
            }
        }
        webGLData.dirty = true;
        return webGLData;
    };
    PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData) {
        var rectData = graphicsData.points;
        var x = rectData[0];
        var y = rectData[1];
        var width = rectData[2];
        var height = rectData[3];
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vertPos = verts.length / 6;
            verts.push(x, y);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y);
            verts.push(r, g, b, alpha);
            verts.push(x, y + height);
            verts.push(r, g, b, alpha);
            verts.push(x + width, y + height);
            verts.push(r, g, b, alpha);
            indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = [ x, y, x + width, y, x + width, y + height, x, y + height, x, y ];
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData) {
        var points = graphicsData.points;
        var x = points[0];
        var y = points[1];
        var width = points[2];
        var height = points[3];
        var radius = points[4];
        var recPoints = [];
        recPoints.push(x, y + radius);
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y));
        recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius));
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vecPos = verts.length / 6;
            var triangles = PIXI.PolyK.Triangulate(recPoints);
            var i = 0;
            for (i = 0; i < triangles.length; i += 3) {
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i + 1] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
            }
            for (i = 0; i < recPoints.length; i++) {
                verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
            }
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = recPoints;
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) {
        var xa, ya, xb, yb, x, y, n = 20, points = [];
        function getPt(n1, n2, perc) {
            var diff = n2 - n1;
            return n1 + diff * perc;
        }
        var j = 0;
        for (var i = 0; i <= n; i++) {
            j = i / n;
            xa = getPt(fromX, cpX, j);
            ya = getPt(fromY, cpY, j);
            xb = getPt(cpX, toX, j);
            yb = getPt(cpY, toY, j);
            x = getPt(xa, xb, j);
            y = getPt(ya, yb, j);
            points.push(x, y);
        }
        return points;
    };
    PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData) {
        var rectData = graphicsData.points;
        var x = rectData[0];
        var y = rectData[1];
        var width = rectData[2];
        var height = rectData[3];
        var totalSegs = 40;
        var seg = Math.PI * 2 / totalSegs;
        var i = 0;
        if (graphicsData.fill) {
            var color = PIXI.hex2rgb(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
            var verts = webGLData.points;
            var indices = webGLData.indices;
            var vecPos = verts.length / 6;
            indices.push(vecPos);
            for (i = 0; i < totalSegs + 1; i++) {
                verts.push(x, y, r, g, b, alpha);
                verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);
                indices.push(vecPos++, vecPos++);
            }
            indices.push(vecPos - 1);
        }
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
            graphicsData.points = [];
            for (i = 0; i < totalSegs + 1; i++) {
                graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height);
            }
            PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);
            graphicsData.points = tempPoints;
        }
    };
    PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData) {
        var i = 0;
        var points = graphicsData.points;
        if (points.length === 0) return;
        if (graphicsData.lineWidth % 2) {
            for (i = 0; i < points.length; i++) {
                points[i] += .5;
            }
        }
        var firstPoint = new PIXI.Point(points[0], points[1]);
        var lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
        if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
            points = points.slice();
            points.pop();
            points.pop();
            lastPoint = new PIXI.Point(points[points.length - 2], points[points.length - 1]);
            var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * .5;
            var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * .5;
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 6;
        var width = graphicsData.lineWidth / 2;
        var color = PIXI.hex2rgb(graphicsData.lineColor);
        var alpha = graphicsData.lineAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
        var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
        var a1, b1, c1, a2, b2, c2;
        var denom, pdist, dist;
        p1x = points[0];
        p1y = points[1];
        p2x = points[2];
        p2y = points[3];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);
        verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);
        for (i = 1; i < length - 1; i++) {
            p1x = points[(i - 1) * 2];
            p1y = points[(i - 1) * 2 + 1];
            p2x = points[i * 2];
            p2y = points[i * 2 + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[(i + 1) * 2 + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            a1 = -perpy + p1y - (-perpy + p2y);
            b1 = -perpx + p2x - (-perpx + p1x);
            c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
            a2 = -perp2y + p3y - (-perp2y + p2y);
            b2 = -perp2x + p2x - (-perp2x + p3x);
            c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
            denom = a1 * b2 - a2 * b1;
            if (Math.abs(denom) < .1) {
                denom += 10.1;
                verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);
                verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);
                continue;
            }
            px = (b1 * c2 - b2 * c1) / denom;
            py = (a2 * c1 - a1 * c2) / denom;
            pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
            if (pdist > 140 * 140) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x + perp3x, p2y + perp3y);
                verts.push(r, g, b, alpha);
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
                indexCount++;
            } else {
                verts.push(px, py);
                verts.push(r, g, b, alpha);
                verts.push(p2x - (px - p2x), p2y - (py - p2y));
                verts.push(r, g, b, alpha);
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[(length - 2) * 2 + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[(length - 1) * 2 + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - perpx, p2y - perpy);
        verts.push(r, g, b, alpha);
        verts.push(p2x + perpx, p2y + perpy);
        verts.push(r, g, b, alpha);
        indices.push(indexStart);
        for (i = 0; i < indexCount; i++) {
            indices.push(indexStart++);
        }
        indices.push(indexStart - 1);
    };
    PIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points.slice();
        if (points.length < 6) return;
        var indices = webGLData.indices;
        webGLData.points = points;
        webGLData.alpha = graphicsData.fillAlpha;
        webGLData.color = PIXI.hex2rgb(graphicsData.fillColor);
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var x, y;
        for (var i = 0; i < points.length; i += 2) {
            x = points[i];
            y = points[i + 1];
            minX = x < minX ? x : minX;
            maxX = x > maxX ? x : maxX;
            minY = y < minY ? y : minY;
            maxY = y > maxY ? y : maxY;
        }
        points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY);
        var length = points.length / 2;
        for (i = 0; i < length; i++) {
            indices.push(i);
        }
    };
    PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData) {
        var points = graphicsData.points;
        if (points.length < 6) return;
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var color = PIXI.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
        var triangles = PIXI.PolyK.Triangulate(points);
        var vertPos = verts.length / 6;
        var i = 0;
        for (i = 0; i < triangles.length; i += 3) {
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i] + vertPos);
            indices.push(triangles[i + 1] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
            indices.push(triangles[i + 2] + vertPos);
        }
        for (i = 0; i < length; i++) {
            verts.push(points[i * 2], points[i * 2 + 1], r, g, b, alpha);
        }
    };
    PIXI.WebGLGraphics.graphicsDataPool = [];
    PIXI.WebGLGraphicsData = function(gl) {
        this.gl = gl;
        this.color = [ 0, 0, 0 ];
        this.points = [];
        this.indices = [];
        this.lastIndex = 0;
        this.buffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.mode = 1;
        this.alpha = 1;
        this.dirty = true;
    };
    PIXI.WebGLGraphicsData.prototype.reset = function() {
        this.points = [];
        this.indices = [];
        this.lastIndex = 0;
    };
    PIXI.WebGLGraphicsData.prototype.upload = function() {
        var gl = this.gl;
        this.glPoints = new Float32Array(this.points);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);
        this.glIndicies = new Uint16Array(this.indices);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW);
        this.dirty = false;
    };
    PIXI.glContexts = [];
    PIXI.WebGLRenderer = function(width, height, view, transparent, antialias, preserveDrawingBuffer) {
        if (!PIXI.defaultRenderer) {
            PIXI.sayHello("webGL");
            PIXI.defaultRenderer = this;
        }
        this.type = PIXI.WEBGL_RENDERER;
        this.transparent = !!transparent;
        this.preserveDrawingBuffer = preserveDrawingBuffer;
        this.width = width || 800;
        this.height = height || 600;
        this.view = view || document.createElement("canvas");
        this.view.width = this.width;
        this.view.height = this.height;
        this.contextLost = this.handleContextLost.bind(this);
        this.contextRestoredLost = this.handleContextRestored.bind(this);
        this.view.addEventListener("webglcontextlost", this.contextLost, false);
        this.view.addEventListener("webglcontextrestored", this.contextRestoredLost, false);
        this.options = {
            alpha: this.transparent,
            antialias: !!antialias,
            premultipliedAlpha: !!transparent && transparent !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: preserveDrawingBuffer
        };
        var gl = null;
        [ "experimental-webgl", "webgl" ].forEach(function(name) {
            try {
                gl = gl || this.view.getContext(name, this.options);
            } catch (e) {}
        }, this);
        if (!gl) {
            throw new Error("This browser does not support webGL. Try using the canvas renderer" + this);
        }
        this.gl = gl;
        this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;
        PIXI.glContexts[this.glContextId] = gl;
        if (!PIXI.blendModesWebGL) {
            PIXI.blendModesWebGL = [];
            PIXI.blendModesWebGL[PIXI.blendModes.NORMAL] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.ADD] = [ gl.SRC_ALPHA, gl.DST_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY] = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SCREEN] = [ gl.SRC_ALPHA, gl.ONE ];
            PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.DARKEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.HUE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.SATURATION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.COLOR] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
            PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];
        }
        this.projection = new PIXI.Point();
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
        this.offset = new PIXI.Point(0, 0);
        this.resize(this.width, this.height);
        this.contextLost = false;
        this.shaderManager = new PIXI.WebGLShaderManager(gl);
        this.spriteBatch = new PIXI.WebGLSpriteBatch(gl);
        this.maskManager = new PIXI.WebGLMaskManager(gl);
        this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent);
        this.stencilManager = new PIXI.WebGLStencilManager(gl);
        this.blendModeManager = new PIXI.WebGLBlendModeManager(gl);
        this.renderSession = {};
        this.renderSession.gl = this.gl;
        this.renderSession.drawCount = 0;
        this.renderSession.shaderManager = this.shaderManager;
        this.renderSession.maskManager = this.maskManager;
        this.renderSession.filterManager = this.filterManager;
        this.renderSession.blendModeManager = this.blendModeManager;
        this.renderSession.spriteBatch = this.spriteBatch;
        this.renderSession.stencilManager = this.stencilManager;
        this.renderSession.renderer = this;
        gl.useProgram(this.shaderManager.defaultShader.program);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.colorMask(true, true, true, this.transparent);
    };
    PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;
    PIXI.WebGLRenderer.prototype.render = function(stage) {
        if (this.contextLost) return;
        if (this.__stage !== stage) {
            if (stage.interactive) stage.interactionManager.removeEvents();
            this.__stage = stage;
        }
        PIXI.WebGLRenderer.updateTextures();
        stage.updateTransform();
        if (stage._interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        }
        var gl = this.gl;
        gl.viewport(0, 0, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        if (this.transparent) {
            gl.clearColor(0, 0, 0, 0);
        } else {
            gl.clearColor(stage.backgroundColorSplit[0], stage.backgroundColorSplit[1], stage.backgroundColorSplit[2], 1);
        }
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.renderDisplayObject(stage, this.projection);
        if (stage.interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        } else {
            if (stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = false;
                stage.interactionManager.setTarget(this);
            }
        }
    };
    PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer) {
        this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);
        this.renderSession.drawCount = 0;
        this.renderSession.currentBlendMode = 9999;
        this.renderSession.projection = projection;
        this.renderSession.offset = this.offset;
        this.spriteBatch.begin(this.renderSession);
        this.filterManager.begin(this.renderSession, buffer);
        displayObject._renderWebGL(this.renderSession);
        this.spriteBatch.end();
    };
    PIXI.WebGLRenderer.updateTextures = function() {
        var i = 0;
        for (i = 0; i < PIXI.Texture.frameUpdates.length; i++) PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]);
        for (i = 0; i < PIXI.texturesToDestroy.length; i++) PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);
        PIXI.texturesToUpdate.length = 0;
        PIXI.texturesToDestroy.length = 0;
        PIXI.Texture.frameUpdates.length = 0;
    };
    PIXI.WebGLRenderer.destroyTexture = function(texture) {
        for (var i = texture._glTextures.length - 1; i >= 0; i--) {
            var glTexture = texture._glTextures[i];
            var gl = PIXI.glContexts[i];
            if (gl && glTexture) {
                gl.deleteTexture(glTexture);
            }
        }
        texture._glTextures.length = 0;
    };
    PIXI.WebGLRenderer.updateTextureFrame = function(texture) {
        texture._updateWebGLuvs();
    };
    PIXI.WebGLRenderer.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        this.view.width = width;
        this.view.height = height;
        this.gl.viewport(0, 0, this.width, this.height);
        this.projection.x = this.width / 2;
        this.projection.y = -this.height / 2;
    };
    PIXI.createWebGLTexture = function(texture, gl) {
        if (texture.hasLoaded) {
            texture._glTextures[gl.id] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            if (!texture._powerOf2) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            }
            gl.bindTexture(gl.TEXTURE_2D, null);
            texture._dirty[gl.id] = false;
        }
        return texture._glTextures[gl.id];
    };
    PIXI.updateWebGLTexture = function(texture, gl) {
        if (texture._glTextures[gl.id]) {
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
            if (!texture._powerOf2) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            }
            texture._dirty[gl.id] = false;
        }
    };
    PIXI.WebGLRenderer.prototype.handleContextLost = function(event) {
        event.preventDefault();
        this.contextLost = true;
    };
    PIXI.WebGLRenderer.prototype.handleContextRestored = function() {
        try {
            this.gl = this.view.getContext("experimental-webgl", this.options);
        } catch (e) {
            try {
                this.gl = this.view.getContext("webgl", this.options);
            } catch (e2) {
                throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this);
            }
        }
        PIXI.glContexts[this.glContextId] = null;
        var gl = this.gl;
        this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;
        PIXI.glContexts[this.glContextId] = gl;
        this.shaderManager.setContext(gl);
        this.spriteBatch.setContext(gl);
        this.maskManager.setContext(gl);
        this.filterManager.setContext(gl);
        this.renderSession.gl = this.gl;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.colorMask(true, true, true, this.transparent);
        this.gl.viewport(0, 0, this.width, this.height);
        for (var key in PIXI.TextureCache) {
            var texture = PIXI.TextureCache[key].baseTexture;
            texture._glTextures = [];
        }
        this.contextLost = false;
    };
    PIXI.WebGLRenderer.prototype.destroy = function() {
        this.view.removeEventListener("webglcontextlost", this.contextLost);
        this.view.removeEventListener("webglcontextrestored", this.contextRestoredLost);
        PIXI.glContexts[this.glContextId] = null;
        this.projection = null;
        this.offset = null;
        this.shaderManager.destroy();
        this.spriteBatch.destroy();
        this.maskManager.destroy();
        this.filterManager.destroy();
        this.shaderManager = null;
        this.spriteBatch = null;
        this.maskManager = null;
        this.filterManager = null;
        this.gl = null;
        this.renderSession = null;
    };
    PIXI.WebGLRenderer.glContextId = 0;
    PIXI.WebGLBlendModeManager = function(gl) {
        this.gl = gl;
        this.currentBlendMode = 99999;
    };
    PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode) {
        if (this.currentBlendMode === blendMode) return false;
        this.currentBlendMode = blendMode;
        var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];
        this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
        return true;
    };
    PIXI.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null;
    };
    PIXI.WebGLMaskManager = function(gl) {
        this.setContext(gl);
    };
    PIXI.WebGLMaskManager.prototype.setContext = function(gl) {
        this.gl = gl;
    };
    PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession) {
        var gl = renderSession.gl;
        if (maskData.dirty) {
            PIXI.WebGLGraphics.updateGraphics(maskData, gl);
        }
        if (!maskData._webGL[gl.id].data.length) return;
        renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
    };
    PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession) {
        var gl = this.gl;
        renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
    };
    PIXI.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null;
    };
    PIXI.WebGLStencilManager = function(gl) {
        this.stencilStack = [];
        this.setContext(gl);
        this.reverse = true;
        this.count = 0;
    };
    PIXI.WebGLStencilManager.prototype.setContext = function(gl) {
        this.gl = gl;
    };
    PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession) {
        var gl = this.gl;
        this.bindGraphics(graphics, webGLData, renderSession);
        if (this.stencilStack.length === 0) {
            gl.enable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            this.reverse = true;
            this.count = 0;
        }
        this.stencilStack.push(webGLData);
        var level = this.count;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.ALWAYS, 0, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
        if (webGLData.mode === 1) {
            gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
            if (this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            }
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
            if (this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
            } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
            }
            this.reverse = !this.reverse;
        } else {
            if (!this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            } else {
                gl.stencilFunc(gl.EQUAL, level, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
            }
            gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
            if (!this.reverse) {
                gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
            } else {
                gl.stencilFunc(gl.EQUAL, level + 1, 255);
            }
        }
        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        this.count++;
    };
    PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession) {
        this._currentGraphics = graphics;
        var gl = this.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader;
        if (webGLData.mode === 1) {
            shader = renderSession.shaderManager.complexPrimitiveShader;
            renderSession.shaderManager.setShader(shader);
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
            gl.uniform3fv(shader.color, webGLData.color);
            gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        } else {
            shader = renderSession.shaderManager.primitiveShader;
            renderSession.shaderManager.setShader(shader);
            gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));
            gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
            gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
            gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));
            gl.uniform1f(shader.alpha, graphics.worldAlpha);
            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false, 4 * 6, 2 * 4);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
        }
    };
    PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession) {
        var gl = this.gl;
        this.stencilStack.pop();
        this.count--;
        if (this.stencilStack.length === 0) {
            gl.disable(gl.STENCIL_TEST);
        } else {
            var level = this.count;
            this.bindGraphics(graphics, webGLData, renderSession);
            gl.colorMask(false, false, false, false);
            if (webGLData.mode === 1) {
                this.reverse = !this.reverse;
                if (this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                } else {
                    gl.stencilFunc(gl.EQUAL, level + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);
                gl.stencilFunc(gl.ALWAYS, 0, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
                gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, level, 255);
                }
            } else {
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - (level + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                } else {
                    gl.stencilFunc(gl.EQUAL, level + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);
                if (!this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - level, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, level, 255);
                }
            }
            gl.colorMask(true, true, true, true);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        }
    };
    PIXI.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null;
        this.gl = null;
    };
    PIXI.WebGLShaderManager = function(gl) {
        this.maxAttibs = 10;
        this.attribState = [];
        this.tempAttribState = [];
        for (var i = 0; i < this.maxAttibs; i++) {
            this.attribState[i] = false;
        }
        this.setContext(gl);
    };
    PIXI.WebGLShaderManager.prototype.setContext = function(gl) {
        this.gl = gl;
        this.primitiveShader = new PIXI.PrimitiveShader(gl);
        this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl);
        this.defaultShader = new PIXI.PixiShader(gl);
        this.fastShader = new PIXI.PixiFastShader(gl);
        this.stripShader = new PIXI.StripShader(gl);
        this.setShader(this.defaultShader);
    };
    PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs) {
        var i;
        for (i = 0; i < this.tempAttribState.length; i++) {
            this.tempAttribState[i] = false;
        }
        for (i = 0; i < attribs.length; i++) {
            var attribId = attribs[i];
            this.tempAttribState[attribId] = true;
        }
        var gl = this.gl;
        for (i = 0; i < this.attribState.length; i++) {
            if (this.attribState[i] !== this.tempAttribState[i]) {
                this.attribState[i] = this.tempAttribState[i];
                if (this.tempAttribState[i]) {
                    gl.enableVertexAttribArray(i);
                } else {
                    gl.disableVertexAttribArray(i);
                }
            }
        }
    };
    PIXI.WebGLShaderManager.prototype.setShader = function(shader) {
        if (this._currentId === shader._UID) return false;
        this._currentId = shader._UID;
        this.currentShader = shader;
        this.gl.useProgram(shader.program);
        this.setAttribs(shader.attributes);
        return true;
    };
    PIXI.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null;
        this.tempAttribState = null;
        this.primitiveShader.destroy();
        this.complexPrimitiveShader.destroy();
        this.defaultShader.destroy();
        this.fastShader.destroy();
        this.stripShader.destroy();
        this.gl = null;
    };
    PIXI.WebGLSpriteBatch = function(gl) {
        this.vertSize = 6;
        this.size = 2e3;
        var numVerts = this.size * 4 * this.vertSize;
        var numIndices = this.size * 6;
        this.vertices = new Float32Array(numVerts);
        this.indices = new Uint16Array(numIndices);
        this.lastIndexCount = 0;
        for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
            this.indices[i + 0] = j + 0;
            this.indices[i + 1] = j + 1;
            this.indices[i + 2] = j + 2;
            this.indices[i + 3] = j + 0;
            this.indices[i + 4] = j + 2;
            this.indices[i + 5] = j + 3;
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.setContext(gl);
        this.dirty = true;
        this.textures = [];
        this.blendModes = [];
    };
    PIXI.WebGLSpriteBatch.prototype.setContext = function(gl) {
        this.gl = gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
        this.currentBlendMode = 99999;
    };
    PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession) {
        this.renderSession = renderSession;
        this.shader = this.renderSession.shaderManager.defaultShader;
        this.start();
    };
    PIXI.WebGLSpriteBatch.prototype.end = function() {
        this.flush();
    };
    PIXI.WebGLSpriteBatch.prototype.render = function(sprite) {
        var texture = sprite.texture;
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = texture.baseTexture;
        }
        var uvs = texture._uvs;
        if (!uvs) return;
        var alpha = sprite.worldAlpha;
        var tint = sprite.tint;
        var verticies = this.vertices;
        var aX = sprite.anchor.x;
        var aY = sprite.anchor.y;
        var w0, w1, h0, h1;
        if (texture.trim) {
            var trim = texture.trim;
            w1 = trim.x - aX * trim.width;
            w0 = w1 + texture.crop.width;
            h1 = trim.y - aY * trim.height;
            h0 = h1 + texture.crop.height;
        } else {
            w0 = texture.frame.width * (1 - aX);
            w1 = texture.frame.width * -aX;
            h0 = texture.frame.height * (1 - aY);
            h1 = texture.frame.height * -aY;
        }
        var index = this.currentBatchSize * 4 * this.vertSize;
        var worldTransform = sprite.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        verticies[index++] = a * w1 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w1 + ty;
        verticies[index++] = uvs.x0;
        verticies[index++] = uvs.y0;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w0 + ty;
        verticies[index++] = uvs.x1;
        verticies[index++] = uvs.y1;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w0 + ty;
        verticies[index++] = uvs.x2;
        verticies[index++] = uvs.y2;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w1 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w1 + ty;
        verticies[index++] = uvs.x3;
        verticies[index++] = uvs.y3;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        this.textures[this.currentBatchSize] = sprite.texture.baseTexture;
        this.blendModes[this.currentBatchSize] = sprite.blendMode;
        this.currentBatchSize++;
    };
    PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite) {
        var texture = tilingSprite.tilingTexture;
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = texture.baseTexture;
        }
        if (!tilingSprite._uvs) tilingSprite._uvs = new PIXI.TextureUvs();
        var uvs = tilingSprite._uvs;
        tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x;
        tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;
        var offsetX = tilingSprite.tilePosition.x / (texture.baseTexture.width * tilingSprite.tileScaleOffset.x);
        var offsetY = tilingSprite.tilePosition.y / (texture.baseTexture.height * tilingSprite.tileScaleOffset.y);
        var scaleX = tilingSprite.width / texture.baseTexture.width / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);
        var scaleY = tilingSprite.height / texture.baseTexture.height / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);
        uvs.x0 = 0 - offsetX;
        uvs.y0 = 0 - offsetY;
        uvs.x1 = 1 * scaleX - offsetX;
        uvs.y1 = 0 - offsetY;
        uvs.x2 = 1 * scaleX - offsetX;
        uvs.y2 = 1 * scaleY - offsetY;
        uvs.x3 = 0 - offsetX;
        uvs.y3 = 1 * scaleY - offsetY;
        var alpha = tilingSprite.worldAlpha;
        var tint = tilingSprite.tint;
        var verticies = this.vertices;
        var width = tilingSprite.width;
        var height = tilingSprite.height;
        var aX = tilingSprite.anchor.x;
        var aY = tilingSprite.anchor.y;
        var w0 = width * (1 - aX);
        var w1 = width * -aX;
        var h0 = height * (1 - aY);
        var h1 = height * -aY;
        var index = this.currentBatchSize * 4 * this.vertSize;
        var worldTransform = tilingSprite.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        verticies[index++] = a * w1 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w1 + ty;
        verticies[index++] = uvs.x0;
        verticies[index++] = uvs.y0;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h1 + tx;
        verticies[index++] = d * h1 + b * w0 + ty;
        verticies[index++] = uvs.x1;
        verticies[index++] = uvs.y1;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w0 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w0 + ty;
        verticies[index++] = uvs.x2;
        verticies[index++] = uvs.y2;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        verticies[index++] = a * w1 + c * h0 + tx;
        verticies[index++] = d * h0 + b * w1 + ty;
        verticies[index++] = uvs.x3;
        verticies[index++] = uvs.y3;
        verticies[index++] = alpha;
        verticies[index++] = tint;
        this.textures[this.currentBatchSize] = texture.baseTexture;
        this.blendModes[this.currentBatchSize] = tilingSprite.blendMode;
        this.currentBatchSize++;
    };
    PIXI.WebGLSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) return;
        var gl = this.gl;
        this.renderSession.shaderManager.setShader(this.renderSession.shaderManager.defaultShader);
        if (this.dirty) {
            this.dirty = false;
            gl.activeTexture(gl.TEXTURE0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var projection = this.renderSession.projection;
            gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);
            var stride = this.vertSize * 4;
            gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
            gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);
            gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);
        }
        if (this.currentBatchSize > this.size * .5) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        } else {
            var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
        }
        var nextTexture, nextBlendMode;
        var batchSize = 0;
        var start = 0;
        var currentBaseTexture = null;
        var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;
        for (var i = 0, j = this.currentBatchSize; i < j; i++) {
            nextTexture = this.textures[i];
            nextBlendMode = this.blendModes[i];
            if (currentBaseTexture !== nextTexture || currentBlendMode !== nextBlendMode) {
                this.renderBatch(currentBaseTexture, batchSize, start);
                start = i;
                batchSize = 0;
                currentBaseTexture = nextTexture;
                currentBlendMode = nextBlendMode;
                this.renderSession.blendModeManager.setBlendMode(currentBlendMode);
            }
            batchSize++;
        }
        this.renderBatch(currentBaseTexture, batchSize, start);
        this.currentBatchSize = 0;
    };
    PIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex) {
        if (size === 0) return;
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id] || PIXI.createWebGLTexture(texture, gl));
        if (texture._dirty[gl.id]) {
            PIXI.updateWebGLTexture(this.currentBaseTexture, gl);
        }
        gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
        this.renderSession.drawCount++;
    };
    PIXI.WebGLSpriteBatch.prototype.stop = function() {
        this.flush();
    };
    PIXI.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = true;
    };
    PIXI.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null;
        this.indices = null;
        this.gl.deleteBuffer(this.vertexBuffer);
        this.gl.deleteBuffer(this.indexBuffer);
        this.currentBaseTexture = null;
        this.gl = null;
    };
    PIXI.WebGLFastSpriteBatch = function(gl) {
        this.vertSize = 10;
        this.maxSize = 6e3;
        this.size = this.maxSize;
        var numVerts = this.size * 4 * this.vertSize;
        var numIndices = this.maxSize * 6;
        this.vertices = new Float32Array(numVerts);
        this.indices = new Uint16Array(numIndices);
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.lastIndexCount = 0;
        for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
            this.indices[i + 0] = j + 0;
            this.indices[i + 1] = j + 1;
            this.indices[i + 2] = j + 2;
            this.indices[i + 3] = j + 0;
            this.indices[i + 4] = j + 2;
            this.indices[i + 5] = j + 3;
        }
        this.drawing = false;
        this.currentBatchSize = 0;
        this.currentBaseTexture = null;
        this.currentBlendMode = 0;
        this.renderSession = null;
        this.shader = null;
        this.matrix = null;
        this.setContext(gl);
    };
    PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl) {
        this.gl = gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
    };
    PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession) {
        this.renderSession = renderSession;
        this.shader = this.renderSession.shaderManager.fastShader;
        this.matrix = spriteBatch.worldTransform.toArray(true);
        this.start();
    };
    PIXI.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch) {
        var children = spriteBatch.children;
        var sprite = children[0];
        if (!sprite.texture._uvs) return;
        this.currentBaseTexture = sprite.texture.baseTexture;
        if (sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode) {
            this.flush();
            this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);
        }
        for (var i = 0, j = children.length; i < j; i++) {
            this.renderSprite(children[i]);
        }
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite) {
        if (!sprite.visible) return;
        if (sprite.texture.baseTexture !== this.currentBaseTexture) {
            this.flush();
            this.currentBaseTexture = sprite.texture.baseTexture;
            if (!sprite.texture._uvs) return;
        }
        var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;
        uvs = sprite.texture._uvs;
        width = sprite.texture.frame.width;
        height = sprite.texture.frame.height;
        if (sprite.texture.trim) {
            var trim = sprite.texture.trim;
            w1 = trim.x - sprite.anchor.x * trim.width;
            w0 = w1 + sprite.texture.crop.width;
            h1 = trim.y - sprite.anchor.y * trim.height;
            h0 = h1 + sprite.texture.crop.height;
        } else {
            w0 = sprite.texture.frame.width * (1 - sprite.anchor.x);
            w1 = sprite.texture.frame.width * -sprite.anchor.x;
            h0 = sprite.texture.frame.height * (1 - sprite.anchor.y);
            h1 = sprite.texture.frame.height * -sprite.anchor.y;
        }
        index = this.currentBatchSize * 4 * this.vertSize;
        verticies[index++] = w1;
        verticies[index++] = h1;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x0;
        verticies[index++] = uvs.y1;
        verticies[index++] = sprite.alpha;
        verticies[index++] = w0;
        verticies[index++] = h1;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x1;
        verticies[index++] = uvs.y1;
        verticies[index++] = sprite.alpha;
        verticies[index++] = w0;
        verticies[index++] = h0;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x2;
        verticies[index++] = uvs.y2;
        verticies[index++] = sprite.alpha;
        verticies[index++] = w1;
        verticies[index++] = h0;
        verticies[index++] = sprite.position.x;
        verticies[index++] = sprite.position.y;
        verticies[index++] = sprite.scale.x;
        verticies[index++] = sprite.scale.y;
        verticies[index++] = sprite.rotation;
        verticies[index++] = uvs.x3;
        verticies[index++] = uvs.y3;
        verticies[index++] = sprite.alpha;
        this.currentBatchSize++;
        if (this.currentBatchSize >= this.size) {
            this.flush();
        }
    };
    PIXI.WebGLFastSpriteBatch.prototype.flush = function() {
        if (this.currentBatchSize === 0) return;
        var gl = this.gl;
        if (!this.currentBaseTexture._glTextures[gl.id]) PIXI.createWebGLTexture(this.currentBaseTexture, gl);
        gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);
        if (this.currentBatchSize > this.size * .5) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        } else {
            var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
        }
        gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
        this.currentBatchSize = 0;
        this.renderSession.drawCount++;
    };
    PIXI.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush();
    };
    PIXI.WebGLFastSpriteBatch.prototype.start = function() {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var projection = this.renderSession.projection;
        gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);
        gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);
        var stride = this.vertSize * 4;
        gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);
        gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);
        gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);
        gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);
        gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);
    };
    PIXI.WebGLFilterManager = function(gl, transparent) {
        this.transparent = transparent;
        this.filterStack = [];
        this.offsetX = 0;
        this.offsetY = 0;
        this.setContext(gl);
    };
    PIXI.WebGLFilterManager.prototype.setContext = function(gl) {
        this.gl = gl;
        this.texturePool = [];
        this.initShaderBuffers();
    };
    PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer) {
        this.renderSession = renderSession;
        this.defaultShader = renderSession.shaderManager.defaultShader;
        var projection = this.renderSession.projection;
        this.width = projection.x * 2;
        this.height = -projection.y * 2;
        this.buffer = buffer;
    };
    PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock) {
        var gl = this.gl;
        var projection = this.renderSession.projection;
        var offset = this.renderSession.offset;
        filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();
        this.filterStack.push(filterBlock);
        var filter = filterBlock.filterPasses[0];
        this.offsetX += filterBlock._filterArea.x;
        this.offsetY += filterBlock._filterArea.y;
        var texture = this.texturePool.pop();
        if (!texture) {
            texture = new PIXI.FilterTexture(this.gl, this.width, this.height);
        } else {
            texture.resize(this.width, this.height);
        }
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        var filterArea = filterBlock._filterArea;
        var padding = filter.padding;
        filterArea.x -= padding;
        filterArea.y -= padding;
        filterArea.width += padding * 2;
        filterArea.height += padding * 2;
        if (filterArea.x < 0) filterArea.x = 0;
        if (filterArea.width > this.width) filterArea.width = this.width;
        if (filterArea.y < 0) filterArea.y = 0;
        if (filterArea.height > this.height) filterArea.height = this.height;
        gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);
        gl.viewport(0, 0, filterArea.width, filterArea.height);
        projection.x = filterArea.width / 2;
        projection.y = -filterArea.height / 2;
        offset.x = -filterArea.x;
        offset.y = -filterArea.y;
        this.renderSession.shaderManager.setShader(this.defaultShader);
        gl.uniform2f(this.defaultShader.projectionVector, filterArea.width / 2, -filterArea.height / 2);
        gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        filterBlock._glFilterTexture = texture;
    };
    PIXI.WebGLFilterManager.prototype.popFilter = function() {
        var gl = this.gl;
        var filterBlock = this.filterStack.pop();
        var filterArea = filterBlock._filterArea;
        var texture = filterBlock._glFilterTexture;
        var projection = this.renderSession.projection;
        var offset = this.renderSession.offset;
        if (filterBlock.filterPasses.length > 1) {
            gl.viewport(0, 0, filterArea.width, filterArea.height);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            this.vertexArray[0] = 0;
            this.vertexArray[1] = filterArea.height;
            this.vertexArray[2] = filterArea.width;
            this.vertexArray[3] = filterArea.height;
            this.vertexArray[4] = 0;
            this.vertexArray[5] = 0;
            this.vertexArray[6] = filterArea.width;
            this.vertexArray[7] = 0;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
            this.uvArray[2] = filterArea.width / this.width;
            this.uvArray[5] = filterArea.height / this.height;
            this.uvArray[6] = filterArea.width / this.width;
            this.uvArray[7] = filterArea.height / this.height;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
            var inputTexture = texture;
            var outputTexture = this.texturePool.pop();
            if (!outputTexture) outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);
            outputTexture.resize(this.width, this.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.BLEND);
            for (var i = 0; i < filterBlock.filterPasses.length - 1; i++) {
                var filterPass = filterBlock.filterPasses[i];
                gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);
                this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);
                var temp = inputTexture;
                inputTexture = outputTexture;
                outputTexture = temp;
            }
            gl.enable(gl.BLEND);
            texture = inputTexture;
            this.texturePool.push(outputTexture);
        }
        var filter = filterBlock.filterPasses[filterBlock.filterPasses.length - 1];
        this.offsetX -= filterArea.x;
        this.offsetY -= filterArea.y;
        var sizeX = this.width;
        var sizeY = this.height;
        var offsetX = 0;
        var offsetY = 0;
        var buffer = this.buffer;
        if (this.filterStack.length === 0) {
            gl.colorMask(true, true, true, true);
        } else {
            var currentFilter = this.filterStack[this.filterStack.length - 1];
            filterArea = currentFilter._filterArea;
            sizeX = filterArea.width;
            sizeY = filterArea.height;
            offsetX = filterArea.x;
            offsetY = filterArea.y;
            buffer = currentFilter._glFilterTexture.frameBuffer;
        }
        projection.x = sizeX / 2;
        projection.y = -sizeY / 2;
        offset.x = offsetX;
        offset.y = offsetY;
        filterArea = filterBlock._filterArea;
        var x = filterArea.x - offsetX;
        var y = filterArea.y - offsetY;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        this.vertexArray[0] = x;
        this.vertexArray[1] = y + filterArea.height;
        this.vertexArray[2] = x + filterArea.width;
        this.vertexArray[3] = y + filterArea.height;
        this.vertexArray[4] = x;
        this.vertexArray[5] = y;
        this.vertexArray[6] = x + filterArea.width;
        this.vertexArray[7] = y;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        this.uvArray[2] = filterArea.width / this.width;
        this.uvArray[5] = filterArea.height / this.height;
        this.uvArray[6] = filterArea.width / this.width;
        this.uvArray[7] = filterArea.height / this.height;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
        gl.viewport(0, 0, sizeX, sizeY);
        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        this.applyFilterPass(filter, filterArea, sizeX, sizeY);
        this.renderSession.shaderManager.setShader(this.defaultShader);
        gl.uniform2f(this.defaultShader.projectionVector, sizeX / 2, -sizeY / 2);
        gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);
        this.texturePool.push(texture);
        filterBlock._glFilterTexture = null;
    };
    PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height) {
        var gl = this.gl;
        var shader = filter.shaders[gl.id];
        if (!shader) {
            shader = new PIXI.PixiShader(gl);
            shader.fragmentSrc = filter.fragmentSrc;
            shader.uniforms = filter.uniforms;
            shader.init();
            filter.shaders[gl.id] = shader;
        }
        this.renderSession.shaderManager.setShader(shader);
        gl.uniform2f(shader.projectionVector, width / 2, -height / 2);
        gl.uniform2f(shader.offsetVector, 0, 0);
        if (filter.uniforms.dimensions) {
            filter.uniforms.dimensions.value[0] = this.width;
            filter.uniforms.dimensions.value[1] = this.height;
            filter.uniforms.dimensions.value[2] = this.vertexArray[0];
            filter.uniforms.dimensions.value[3] = this.vertexArray[5];
        }
        shader.syncUniforms();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        this.renderSession.drawCount++;
    };
    PIXI.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var gl = this.gl;
        this.vertexBuffer = gl.createBuffer();
        this.uvBuffer = gl.createBuffer();
        this.colorBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.vertexArray = new Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW);
        this.uvArray = new Float32Array([ 0, 0, 1, 0, 0, 1, 1, 1 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW);
        this.colorArray = new Float32Array([ 1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215 ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([ 0, 1, 2, 1, 3, 2 ]), gl.STATIC_DRAW);
    };
    PIXI.WebGLFilterManager.prototype.destroy = function() {
        var gl = this.gl;
        this.filterStack = null;
        this.offsetX = 0;
        this.offsetY = 0;
        for (var i = 0; i < this.texturePool.length; i++) {
            this.texturePool[i].destroy();
        }
        this.texturePool = null;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.uvBuffer);
        gl.deleteBuffer(this.colorBuffer);
        gl.deleteBuffer(this.indexBuffer);
    };
    PIXI.FilterTexture = function(gl, width, height, scaleMode) {
        this.gl = gl;
        this.frameBuffer = gl.createFramebuffer();
        this.texture = gl.createTexture();
        scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
        this.renderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
        this.resize(width, height);
    };
    PIXI.FilterTexture.prototype.clear = function() {
        var gl = this.gl;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    };
    PIXI.FilterTexture.prototype.resize = function(width, height) {
        if (this.width === width && this.height === height) return;
        this.width = width;
        this.height = height;
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    };
    PIXI.FilterTexture.prototype.destroy = function() {
        var gl = this.gl;
        gl.deleteFramebuffer(this.frameBuffer);
        gl.deleteTexture(this.texture);
        this.frameBuffer = null;
        this.texture = null;
    };
    PIXI.CanvasMaskManager = function() {};
    PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, context) {
        context.save();
        var cacheAlpha = maskData.alpha;
        var transform = maskData.worldTransform;
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);
        context.clip();
        maskData.worldAlpha = cacheAlpha;
    };
    PIXI.CanvasMaskManager.prototype.popMask = function(context) {
        context.restore();
    };
    PIXI.CanvasTinter = function() {};
    PIXI.CanvasTinter.getTintedTexture = function(sprite, color) {
        var texture = sprite.texture;
        color = PIXI.CanvasTinter.roundColor(color);
        var stringColor = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
        texture.tintCache = texture.tintCache || {};
        if (texture.tintCache[stringColor]) return texture.tintCache[stringColor];
        var canvas = PIXI.CanvasTinter.canvas || document.createElement("canvas");
        PIXI.CanvasTinter.tintMethod(texture, color, canvas);
        if (PIXI.CanvasTinter.convertTintToImage) {
            var tintImage = new Image();
            tintImage.src = canvas.toDataURL();
            texture.tintCache[stringColor] = tintImage;
        } else {
            texture.tintCache[stringColor] = canvas;
            PIXI.CanvasTinter.canvas = null;
        }
        return canvas;
    };
    PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var frame = texture.frame;
        canvas.width = frame.width;
        canvas.height = frame.height;
        context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, frame.width, frame.height);
        context.globalCompositeOperation = "multiply";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
        context.globalCompositeOperation = "destination-atop";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
    };
    PIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var frame = texture.frame;
        canvas.width = frame.width;
        canvas.height = frame.height;
        context.globalCompositeOperation = "copy";
        context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
        context.fillRect(0, 0, frame.width, frame.height);
        context.globalCompositeOperation = "destination-atop";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
    };
    PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas) {
        var context = canvas.getContext("2d");
        var frame = texture.frame;
        canvas.width = frame.width;
        canvas.height = frame.height;
        context.globalCompositeOperation = "copy";
        context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, 0, 0, frame.width, frame.height);
        var rgbValues = PIXI.hex2rgb(color);
        var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];
        var pixelData = context.getImageData(0, 0, frame.width, frame.height);
        var pixels = pixelData.data;
        for (var i = 0; i < pixels.length; i += 4) {
            pixels[i + 0] *= r;
            pixels[i + 1] *= g;
            pixels[i + 2] *= b;
        }
        context.putImageData(pixelData, 0, 0);
    };
    PIXI.CanvasTinter.roundColor = function(color) {
        var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;
        var rgbValues = PIXI.hex2rgb(color);
        rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
        rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
        rgbValues[2] = Math.min(255, rgbValues[2] / step * step);
        return PIXI.rgb2hex(rgbValues);
    };
    PIXI.CanvasTinter.cacheStepsPerColorChannel = 8;
    PIXI.CanvasTinter.convertTintToImage = false;
    PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();
    PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel;
    PIXI.CanvasRenderer = function(width, height, view, transparent) {
        if (!PIXI.defaultRenderer) {
            PIXI.sayHello("Canvas");
            PIXI.defaultRenderer = this;
        }
        this.type = PIXI.CANVAS_RENDERER;
        this.clearBeforeRender = true;
        this.transparent = !!transparent;
        if (!PIXI.blendModesCanvas) {
            PIXI.blendModesCanvas = [];
            if (PIXI.canUseNewCanvasBlendModes()) {
                PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter";
                PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "multiply";
                PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "screen";
                PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "overlay";
                PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "darken";
                PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "lighten";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "color-dodge";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "color-burn";
                PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "hard-light";
                PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "soft-light";
                PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "difference";
                PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "exclusion";
                PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "hue";
                PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "saturation";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "color";
                PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "luminosity";
            } else {
                PIXI.blendModesCanvas[PIXI.blendModes.NORMAL] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.ADD] = "lighter";
                PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SCREEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.DARKEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.HUE] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.COLOR] = "source-over";
                PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = "source-over";
            }
        }
        this.width = width || 800;
        this.height = height || 600;
        this.view = view || document.createElement("canvas");
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        });
        this.refresh = true;
        this.view.width = this.width;
        this.view.height = this.height;
        this.count = 0;
        this.maskManager = new PIXI.CanvasMaskManager();
        this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: null,
            roundPixels: false
        };
        if ("imageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "imageSmoothingEnabled"; else if ("webkitImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "webkitImageSmoothingEnabled"; else if ("mozImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "mozImageSmoothingEnabled"; else if ("oImageSmoothingEnabled" in this.context) this.renderSession.smoothProperty = "oImageSmoothingEnabled";
    };
    PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;
    PIXI.CanvasRenderer.prototype.render = function(stage) {
        PIXI.texturesToUpdate.length = 0;
        PIXI.texturesToDestroy.length = 0;
        stage.updateTransform();
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.globalAlpha = 1;
        if (navigator.isCocoonJS && this.view.screencanvas) {
            this.context.fillStyle = "black";
            this.context.clear();
        }
        if (!this.transparent && this.clearBeforeRender) {
            this.context.fillStyle = stage.backgroundColorString;
            this.context.fillRect(0, 0, this.width, this.height);
        } else if (this.transparent && this.clearBeforeRender) {
            this.context.clearRect(0, 0, this.width, this.height);
        }
        this.renderDisplayObject(stage);
        if (stage.interactive) {
            if (!stage._interactiveEventsAdded) {
                stage._interactiveEventsAdded = true;
                stage.interactionManager.setTarget(this);
            }
        }
        if (PIXI.Texture.frameUpdates.length > 0) {
            PIXI.Texture.frameUpdates.length = 0;
        }
    };
    PIXI.CanvasRenderer.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        this.view.width = width;
        this.view.height = height;
    };
    PIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context) {
        this.renderSession.context = context || this.context;
        displayObject._renderCanvas(this.renderSession);
    };
    PIXI.CanvasRenderer.prototype.renderStripFlat = function(strip) {
        var context = this.context;
        var verticies = strip.verticies;
        var length = verticies.length / 2;
        this.count++;
        context.beginPath();
        for (var i = 1; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
        }
        context.fillStyle = "#FF0000";
        context.fill();
        context.closePath();
    };
    PIXI.CanvasRenderer.prototype.renderStrip = function(strip) {
        var context = this.context;
        var verticies = strip.verticies;
        var uvs = strip.uvs;
        var length = verticies.length / 2;
        this.count++;
        for (var i = 1; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            var u0 = uvs[index] * strip.texture.width, u1 = uvs[index + 2] * strip.texture.width, u2 = uvs[index + 4] * strip.texture.width;
            var v0 = uvs[index + 1] * strip.texture.height, v1 = uvs[index + 3] * strip.texture.height, v2 = uvs[index + 5] * strip.texture.height;
            context.save();
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.clip();
            var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
            var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
            var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
            var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
            var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
            var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
            var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
            context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
            context.drawImage(strip.texture.baseTexture.source, 0, 0);
            context.restore();
        }
    };
    PIXI.CanvasBuffer = function(width, height) {
        this.width = width;
        this.height = height;
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.canvas.width = width;
        this.canvas.height = height;
    };
    PIXI.CanvasBuffer.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height);
    };
    PIXI.CanvasBuffer.prototype.resize = function(width, height) {
        this.width = this.canvas.width = width;
        this.height = this.canvas.height = height;
    };
    PIXI.CanvasGraphics = function() {};
    PIXI.CanvasGraphics.renderGraphics = function(graphics, context) {
        var worldAlpha = graphics.worldAlpha;
        var color = "";
        for (var i = 0; i < graphics.graphicsData.length; i++) {
            var data = graphics.graphicsData[i];
            var points = data.points;
            context.strokeStyle = color = "#" + ("00000" + (data.lineColor | 0).toString(16)).substr(-6);
            context.lineWidth = data.lineWidth;
            if (data.type === PIXI.Graphics.POLY) {
                context.beginPath();
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.RECT) {
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fillRect(points[0], points[1], points[2], points[3]);
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.strokeRect(points[0], points[1], points[2], points[3]);
                }
            } else if (data.type === PIXI.Graphics.CIRC) {
                context.beginPath();
                context.arc(points[0], points[1], points[2], 0, 2 * Math.PI);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.ELIP) {
                var ellipseData = data.points;
                var w = ellipseData[2] * 2;
                var h = ellipseData[3] * 2;
                var x = ellipseData[0] - w / 2;
                var y = ellipseData[1] - h / 2;
                context.beginPath();
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
                if (data.fill) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            } else if (data.type === PIXI.Graphics.RREC) {
                var rx = points[0];
                var ry = points[1];
                var width = points[2];
                var height = points[3];
                var radius = points[4];
                var maxRadius = Math.min(width, height) / 2 | 0;
                radius = radius > maxRadius ? maxRadius : radius;
                context.beginPath();
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
                if (data.fillColor || data.fillColor === 0) {
                    context.globalAlpha = data.fillAlpha * worldAlpha;
                    context.fillStyle = color = "#" + ("00000" + (data.fillColor | 0).toString(16)).substr(-6);
                    context.fill();
                }
                if (data.lineWidth) {
                    context.globalAlpha = data.lineAlpha * worldAlpha;
                    context.stroke();
                }
            }
        }
    };
    PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context) {
        var len = graphics.graphicsData.length;
        if (len === 0) return;
        if (len > 1) {
            len = 1;
            window.console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object");
        }
        for (var i = 0; i < 1; i++) {
            var data = graphics.graphicsData[i];
            var points = data.points;
            if (data.type === PIXI.Graphics.POLY) {
                context.beginPath();
                context.moveTo(points[0], points[1]);
                for (var j = 1; j < points.length / 2; j++) {
                    context.lineTo(points[j * 2], points[j * 2 + 1]);
                }
                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                    context.closePath();
                }
            } else if (data.type === PIXI.Graphics.RECT) {
                context.beginPath();
                context.rect(points[0], points[1], points[2], points[3]);
                context.closePath();
            } else if (data.type === PIXI.Graphics.CIRC) {
                context.beginPath();
                context.arc(points[0], points[1], points[2], 0, 2 * Math.PI);
                context.closePath();
            } else if (data.type === PIXI.Graphics.ELIP) {
                var ellipseData = data.points;
                var w = ellipseData[2] * 2;
                var h = ellipseData[3] * 2;
                var x = ellipseData[0] - w / 2;
                var y = ellipseData[1] - h / 2;
                context.beginPath();
                var kappa = .5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                context.moveTo(x, ym);
                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                context.closePath();
            } else if (data.type === PIXI.Graphics.RREC) {
                var rx = points[0];
                var ry = points[1];
                var width = points[2];
                var height = points[3];
                var radius = points[4];
                var maxRadius = Math.min(width, height) / 2 | 0;
                radius = radius > maxRadius ? maxRadius : radius;
                context.beginPath();
                context.moveTo(rx, ry + radius);
                context.lineTo(rx, ry + height - radius);
                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                context.lineTo(rx + width - radius, ry + height);
                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                context.lineTo(rx + width, ry + radius);
                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                context.lineTo(rx + radius, ry);
                context.quadraticCurveTo(rx, ry, rx, ry + radius);
                context.closePath();
            }
        }
    };
    PIXI.Graphics = function() {
        PIXI.DisplayObjectContainer.call(this);
        this.renderable = true;
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = "black";
        this.graphicsData = [];
        this.tint = 16777215;
        this.blendMode = PIXI.blendModes.NORMAL;
        this.currentPath = {
            points: []
        };
        this._webGL = [];
        this.isMask = false;
        this.bounds = null;
        this.boundsPadding = 10;
        this.dirty = true;
    };
    PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Graphics.prototype.constructor = PIXI.Graphics;
    Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap;
        },
        set: function(value) {
            this._cacheAsBitmap = value;
            if (this._cacheAsBitmap) {
                this._generateCachedSprite();
            } else {
                this.destroyCachedSprite();
                this.dirty = true;
            }
        }
    });
    PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.lineWidth = lineWidth || 0;
        this.lineColor = color || 0;
        this.lineAlpha = arguments.length < 3 ? 1 : alpha;
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath);
        return this;
    };
    PIXI.Graphics.prototype.moveTo = function(x, y) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.currentPath.points.push(x, y);
        this.graphicsData.push(this.currentPath);
        return this;
    };
    PIXI.Graphics.prototype.lineTo = function(x, y) {
        this.currentPath.points.push(x, y);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        if (this.currentPath.points.length === 0) this.moveTo(0, 0);
        var xa, ya, n = 20, points = this.currentPath.points;
        if (points.length === 0) this.moveTo(0, 0);
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i <= n; i++) {
            j = i / n;
            xa = fromX + (cpX - fromX) * j;
            ya = fromY + (cpY - fromY) * j;
            points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        if (this.currentPath.points.length === 0) this.moveTo(0, 0);
        var n = 20, dt, dt2, dt3, t2, t3, points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var j = 0;
        for (var i = 1; i < n; i++) {
            j = i / n;
            dt = 1 - j;
            dt2 = dt * dt;
            dt3 = dt2 * dt;
            t2 = j * j;
            t3 = t2 * j;
            points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        if (this.currentPath.points.length === 0) this.moveTo(x1, y1);
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
            points.push(x1, y1);
        } else {
            var dd = a1 * a1 + b1 * b1;
            var cc = a2 * a2 + b2 * b2;
            var tt = a1 * a2 + b1 * b2;
            var k1 = radius * Math.sqrt(dd) / mm;
            var k2 = radius * Math.sqrt(cc) / mm;
            var j1 = k1 * tt / dd;
            var j2 = k2 * tt / cc;
            var cx = k1 * b2 + k2 * b1;
            var cy = k1 * a2 + k2 * a1;
            var px = b1 * (k2 + j1);
            var py = a1 * (k2 + j1);
            var qx = b2 * (k1 + j2);
            var qy = a2 * (k1 + j2);
            var startAngle = Math.atan2(py - cy, px - cx);
            var endAngle = Math.atan2(qy - cy, qx - cx);
            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        var points = this.currentPath.points;
        if (points.length !== 0 && points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
            this.moveTo(startX, startY);
            points = this.currentPath.points;
        }
        if (startAngle === endAngle) return this;
        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += Math.PI * 2;
        } else if (anticlockwise && startAngle <= endAngle) {
            startAngle += Math.PI * 2;
        }
        var sweep = anticlockwise ? (startAngle - endAngle) * -1 : endAngle - startAngle;
        var segs = Math.abs(sweep) / (Math.PI * 2) * 40;
        if (sweep === 0) return this;
        var theta = sweep / (segs * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = segs - 1;
        var remainder = segMinus % 1 / segMinus;
        for (var i = 0; i <= segMinus; i++) {
            var real = i + remainder * i;
            var angle = theta + startAngle + theta2 * real;
            var c = Math.cos(angle);
            var s = -Math.sin(angle);
            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawPath = function(path) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: PIXI.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath);
        this.currentPath.points = this.currentPath.points.concat(path);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.beginFill = function(color, alpha) {
        this.filling = true;
        this.fillColor = color || 0;
        this.fillAlpha = arguments.length < 2 ? 1 : alpha;
        return this;
    };
    PIXI.Graphics.prototype.endFill = function() {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1;
        return this;
    };
    PIXI.Graphics.prototype.drawRect = function(x, y, width, height) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height ],
            type: PIXI.Graphics.RECT
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawRoundedRect = function(x, y, width, height, radius) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height, radius ],
            type: PIXI.Graphics.RREC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawCircle = function(x, y, radius) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, radius, radius ],
            type: PIXI.Graphics.CIRC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.drawEllipse = function(x, y, width, height) {
        if (!this.currentPath.points.length) this.graphicsData.pop();
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [ x, y, width, height ],
            type: PIXI.Graphics.ELIP
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true;
        return this;
    };
    PIXI.Graphics.prototype.clear = function() {
        this.lineWidth = 0;
        this.filling = false;
        this.dirty = true;
        this.clearDirty = true;
        this.graphicsData = [];
        this.bounds = null;
        return this;
    };
    PIXI.Graphics.prototype.generateTexture = function() {
        var bounds = this.getBounds();
        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
        canvasBuffer.context.translate(-bounds.x, -bounds.y);
        PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);
        return texture;
    };
    PIXI.Graphics.prototype._renderWebGL = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        if (this._cacheAsBitmap) {
            if (this.dirty) {
                this._generateCachedSprite();
                PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl);
                this.dirty = false;
            }
            this._cachedSprite.alpha = this.alpha;
            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
            return;
        } else {
            renderSession.spriteBatch.stop();
            renderSession.blendModeManager.setBlendMode(this.blendMode);
            if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession);
            if (this._filters) renderSession.filterManager.pushFilter(this._filterBlock);
            if (this.blendMode !== renderSession.spriteBatch.currentBlendMode) {
                renderSession.spriteBatch.currentBlendMode = this.blendMode;
                var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];
                renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
            }
            PIXI.WebGLGraphics.renderGraphics(this, renderSession);
            if (this.children.length) {
                renderSession.spriteBatch.start();
                for (var i = 0, j = this.children.length; i < j; i++) {
                    this.children[i]._renderWebGL(renderSession);
                }
                renderSession.spriteBatch.stop();
            }
            if (this._filters) renderSession.filterManager.popFilter();
            if (this._mask) renderSession.maskManager.popMask(this.mask, renderSession);
            renderSession.drawCount++;
            renderSession.spriteBatch.start();
        }
    };
    PIXI.Graphics.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0 || this.isMask === true) return;
        var context = renderSession.context;
        var transform = this.worldTransform;
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, renderSession.context);
        }
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        PIXI.CanvasGraphics.renderGraphics(this, context);
        for (var i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
    };
    PIXI.Graphics.prototype.getBounds = function(matrix) {
        if (!this.bounds) this.updateBounds();
        var w0 = this.bounds.x;
        var w1 = this.bounds.width + this.bounds.x;
        var h0 = this.bounds.y;
        var h1 = this.bounds.height + this.bounds.y;
        var worldTransform = matrix || this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var maxX = x1;
        var maxY = y1;
        var minX = x1;
        var minY = y1;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        return bounds;
    };
    PIXI.Graphics.prototype.updateBounds = function() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var points, x, y, w, h;
        for (var i = 0; i < this.graphicsData.length; i++) {
            var data = this.graphicsData[i];
            var type = data.type;
            var lineWidth = data.lineWidth;
            points = data.points;
            if (type === PIXI.Graphics.RECT) {
                x = points[0] - lineWidth / 2;
                y = points[1] - lineWidth / 2;
                w = points[2] + lineWidth;
                h = points[3] + lineWidth;
                minX = x < minX ? x : minX;
                maxX = x + w > maxX ? x + w : maxX;
                minY = y < minY ? x : minY;
                maxY = y + h > maxY ? y + h : maxY;
            } else if (type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP) {
                x = points[0];
                y = points[1];
                w = points[2] + lineWidth / 2;
                h = points[3] + lineWidth / 2;
                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;
                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            } else {
                for (var j = 0; j < points.length; j += 2) {
                    x = points[j];
                    y = points[j + 1];
                    minX = x - lineWidth < minX ? x - lineWidth : minX;
                    maxX = x + lineWidth > maxX ? x + lineWidth : maxX;
                    minY = y - lineWidth < minY ? y - lineWidth : minY;
                    maxY = y + lineWidth > maxY ? y + lineWidth : maxY;
                }
            }
        }
        var padding = this.boundsPadding;
        this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, maxX - minX + padding * 2, maxY - minY + padding * 2);
    };
    PIXI.Graphics.prototype._generateCachedSprite = function() {
        var bounds = this.getLocalBounds();
        if (!this._cachedSprite) {
            var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);
            var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
            this._cachedSprite = new PIXI.Sprite(texture);
            this._cachedSprite.buffer = canvasBuffer;
            this._cachedSprite.worldTransform = this.worldTransform;
        } else {
            this._cachedSprite.buffer.resize(bounds.width, bounds.height);
        }
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);
        this._cachedSprite.buffer.context.translate(-bounds.x, -bounds.y);
        PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
        this._cachedSprite.alpha = this.alpha;
    };
    PIXI.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(true);
        this._cachedSprite = null;
    };
    PIXI.Graphics.POLY = 0;
    PIXI.Graphics.RECT = 1;
    PIXI.Graphics.CIRC = 2;
    PIXI.Graphics.ELIP = 3;
    PIXI.Graphics.RREC = 4;
    PIXI.Strip = function(texture) {
        PIXI.DisplayObjectContainer.call(this);
        this.texture = texture;
        this.uvs = new PIXI.Float32Array([ 0, 1, 1, 1, 1, 0, 0, 1 ]);
        this.verticies = new PIXI.Float32Array([ 0, 0, 100, 0, 100, 100, 0, 100 ]);
        this.colors = new PIXI.Float32Array([ 1, 1, 1, 1 ]);
        this.indices = new PIXI.Uint16Array([ 0, 1, 2, 3 ]);
        this.dirty = true;
        this.padding = 0;
    };
    PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Strip.prototype.constructor = PIXI.Strip;
    PIXI.Strip.prototype._renderWebGL = function(renderSession) {
        if (!this.visible || this.alpha <= 0) return;
        renderSession.spriteBatch.stop();
        if (!this._vertexBuffer) this._initWebGL(renderSession);
        renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader);
        this._renderStrip(renderSession);
        renderSession.spriteBatch.start();
    };
    PIXI.Strip.prototype._initWebGL = function(renderSession) {
        var gl = renderSession.gl;
        this._vertexBuffer = gl.createBuffer();
        this._indexBuffer = gl.createBuffer();
        this._uvBuffer = gl.createBuffer();
        this._colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
    };
    PIXI.Strip.prototype._renderStrip = function(renderSession) {
        var gl = renderSession.gl;
        var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.stripShader;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true));
        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);
        gl.uniform1f(shader.alpha, 1);
        if (!this.dirty) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.verticies);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        } else {
            this.dirty = false;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.verticies, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW);
            gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.texture.baseTexture, gl));
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
        }
        gl.drawElements(gl.TRIANGLE_STRIP, this.indices.length, gl.UNSIGNED_SHORT, 0);
    };
    PIXI.Strip.prototype._renderCanvas = function(renderSession) {
        var context = renderSession.context;
        var transform = this.worldTransform;
        if (renderSession.roundPixels) {
            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx | 0, transform.ty | 0);
        } else {
            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        }
        var strip = this;
        var verticies = strip.verticies;
        var uvs = strip.uvs;
        var length = verticies.length / 2;
        this.count++;
        for (var i = 0; i < length - 2; i++) {
            var index = i * 2;
            var x0 = verticies[index], x1 = verticies[index + 2], x2 = verticies[index + 4];
            var y0 = verticies[index + 1], y1 = verticies[index + 3], y2 = verticies[index + 5];
            if (this.padding === 0) {
                var centerX = (x0 + x1 + x2) / 3;
                var centerY = (y0 + y1 + y2) / 3;
                var normX = x0 - centerX;
                var normY = y0 - centerY;
                var dist = Math.sqrt(normX * normX + normY * normY);
                x0 = centerX + normX / dist * (dist + 3);
                y0 = centerY + normY / dist * (dist + 3);
                normX = x1 - centerX;
                normY = y1 - centerY;
                dist = Math.sqrt(normX * normX + normY * normY);
                x1 = centerX + normX / dist * (dist + 3);
                y1 = centerY + normY / dist * (dist + 3);
                normX = x2 - centerX;
                normY = y2 - centerY;
                dist = Math.sqrt(normX * normX + normY * normY);
                x2 = centerX + normX / dist * (dist + 3);
                y2 = centerY + normY / dist * (dist + 3);
            }
            var u0 = uvs[index] * strip.texture.width, u1 = uvs[index + 2] * strip.texture.width, u2 = uvs[index + 4] * strip.texture.width;
            var v0 = uvs[index + 1] * strip.texture.height, v1 = uvs[index + 3] * strip.texture.height, v2 = uvs[index + 5] * strip.texture.height;
            context.save();
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.clip();
            var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
            var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
            var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
            var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
            var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
            var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
            var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
            context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
            context.drawImage(strip.texture.baseTexture.source, 0, 0);
            context.restore();
        }
    };
    PIXI.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = true;
    };
    PIXI.Rope = function(texture, points) {
        PIXI.Strip.call(this, texture);
        this.points = points;
        this.verticies = new PIXI.Float32Array(points.length * 4);
        this.uvs = new PIXI.Float32Array(points.length * 4);
        this.colors = new PIXI.Float32Array(points.length * 2);
        this.indices = new PIXI.Uint16Array(points.length * 2);
        this.refresh();
    };
    PIXI.Rope.prototype = Object.create(PIXI.Strip.prototype);
    PIXI.Rope.prototype.constructor = PIXI.Rope;
    PIXI.Rope.prototype.refresh = function() {
        var points = this.points;
        if (points.length < 1) return;
        var uvs = this.uvs;
        var lastPoint = points[0];
        var indices = this.indices;
        var colors = this.colors;
        this.count -= .2;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        colors[0] = 1;
        colors[1] = 1;
        indices[0] = 0;
        indices[1] = 1;
        var total = points.length, point, index, amount;
        for (var i = 1; i < total; i++) {
            point = points[i];
            index = i * 4;
            amount = i / (total - 1);
            if (i % 2) {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            } else {
                uvs[index] = amount;
                uvs[index + 1] = 0;
                uvs[index + 2] = amount;
                uvs[index + 3] = 1;
            }
            index = i * 2;
            colors[index] = 1;
            colors[index + 1] = 1;
            index = i * 2;
            indices[index] = index;
            indices[index + 1] = index + 1;
            lastPoint = point;
        }
    };
    PIXI.Rope.prototype.updateTransform = function() {
        var points = this.points;
        if (points.length < 1) return;
        var lastPoint = points[0];
        var nextPoint;
        var perp = {
            x: 0,
            y: 0
        };
        this.count -= .2;
        var verticies = this.verticies;
        var total = points.length, point, index, ratio, perpLength, num;
        for (var i = 0; i < total; i++) {
            point = points[i];
            index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            } else {
                nextPoint = point;
            }
            perp.y = -(nextPoint.x - lastPoint.x);
            perp.x = nextPoint.y - lastPoint.y;
            ratio = (1 - i / (total - 1)) * 10;
            if (ratio > 1) ratio = 1;
            perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y);
            num = this.texture.height / 2;
            perp.x /= perpLength;
            perp.y /= perpLength;
            perp.x *= num;
            perp.y *= num;
            verticies[index] = point.x + perp.x;
            verticies[index + 1] = point.y + perp.y;
            verticies[index + 2] = point.x - perp.x;
            verticies[index + 3] = point.y - perp.y;
            lastPoint = point;
        }
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    PIXI.Rope.prototype.setTexture = function(texture) {
        this.texture = texture;
    };
    PIXI.TilingSprite = function(texture, width, height) {
        PIXI.Sprite.call(this, texture);
        this._width = width || 100;
        this._height = height || 100;
        this.tileScale = new PIXI.Point(1, 1);
        this.tileScaleOffset = new PIXI.Point(1, 1);
        this.tilePosition = new PIXI.Point(0, 0);
        this.renderable = true;
        this.tint = 16777215;
        this.blendMode = PIXI.blendModes.NORMAL;
    };
    PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);
    PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;
    Object.defineProperty(PIXI.TilingSprite.prototype, "width", {
        get: function() {
            return this._width;
        },
        set: function(value) {
            this._width = value;
        }
    });
    Object.defineProperty(PIXI.TilingSprite.prototype, "height", {
        get: function() {
            return this._height;
        },
        set: function(value) {
            this._height = value;
        }
    });
    PIXI.TilingSprite.prototype.setTexture = function(texture) {
        if (this.texture === texture) return;
        this.texture = texture;
        this.refreshTexture = true;
        this.cachedTint = 16777215;
    };
    PIXI.TilingSprite.prototype._renderWebGL = function(renderSession) {
        if (this.visible === false || this.alpha === 0) return;
        var i, j;
        if (this._mask) {
            renderSession.spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            renderSession.spriteBatch.start();
        }
        if (this._filters) {
            renderSession.spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }
        if (!this.tilingTexture || this.refreshTexture) {
            this.generateTilingTexture(true);
            if (this.tilingTexture && this.tilingTexture.needsUpdate) {
                PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl);
                this.tilingTexture.needsUpdate = false;
            }
        } else {
            renderSession.spriteBatch.renderTilingSprite(this);
        }
        for (i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderWebGL(renderSession);
        }
        renderSession.spriteBatch.stop();
        if (this._filters) renderSession.filterManager.popFilter();
        if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
        renderSession.spriteBatch.start();
    };
    PIXI.TilingSprite.prototype._renderCanvas = function(renderSession) {
        if (this.visible === false || this.alpha === 0) return;
        var context = renderSession.context;
        if (this._mask) {
            renderSession.maskManager.pushMask(this._mask, context);
        }
        context.globalAlpha = this.worldAlpha;
        var transform = this.worldTransform;
        var i, j;
        context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);
        if (!this.__tilePattern || this.refreshTexture) {
            this.generateTilingTexture(false);
            if (this.tilingTexture) {
                this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, "repeat");
            } else {
                return;
            }
        }
        if (this.blendMode !== renderSession.currentBlendMode) {
            renderSession.currentBlendMode = this.blendMode;
            context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
        }
        var tilePosition = this.tilePosition;
        var tileScale = this.tileScale;
        tilePosition.x %= this.tilingTexture.baseTexture.width;
        tilePosition.y %= this.tilingTexture.baseTexture.height;
        context.scale(tileScale.x, tileScale.y);
        context.translate(tilePosition.x, tilePosition.y);
        context.fillStyle = this.__tilePattern;
        context.fillRect(-tilePosition.x + this.anchor.x * -this._width, -tilePosition.y + this.anchor.y * -this._height, this._width / tileScale.x, this._height / tileScale.y);
        context.scale(1 / tileScale.x, 1 / tileScale.y);
        context.translate(-tilePosition.x, -tilePosition.y);
        if (this._mask) {
            renderSession.maskManager.popMask(renderSession.context);
        }
        for (i = 0, j = this.children.length; i < j; i++) {
            this.children[i]._renderCanvas(renderSession);
        }
    };
    PIXI.TilingSprite.prototype.getBounds = function() {
        var width = this._width;
        var height = this._height;
        var w0 = width * (1 - this.anchor.x);
        var w1 = width * -this.anchor.x;
        var h0 = height * (1 - this.anchor.y);
        var h1 = height * -this.anchor.y;
        var worldTransform = this.worldTransform;
        var a = worldTransform.a;
        var b = worldTransform.c;
        var c = worldTransform.b;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;
        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;
        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;
        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        minX = x1 < minX ? x1 : minX;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;
        minY = y1 < minY ? y1 : minY;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;
        maxX = x1 > maxX ? x1 : maxX;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;
        maxY = y1 > maxY ? y1 : maxY;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
        var bounds = this._bounds;
        bounds.x = minX;
        bounds.width = maxX - minX;
        bounds.y = minY;
        bounds.height = maxY - minY;
        this._currentBounds = bounds;
        return bounds;
    };
    PIXI.TilingSprite.prototype.onTextureUpdate = function() {};
    PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo) {
        if (!this.texture.baseTexture.hasLoaded) return;
        var texture = this.texture;
        var frame = texture.frame;
        var targetWidth, targetHeight;
        var isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height;
        var newTextureRequired = false;
        if (!forcePowerOfTwo) {
            if (isFrame) {
                targetWidth = frame.width;
                targetHeight = frame.height;
                newTextureRequired = true;
            }
        } else {
            targetWidth = PIXI.getNextPowerOfTwo(frame.width);
            targetHeight = PIXI.getNextPowerOfTwo(frame.height);
            if (frame.width !== targetWidth || frame.height !== targetHeight) newTextureRequired = true;
        }
        if (newTextureRequired) {
            var canvasBuffer;
            if (this.tilingTexture && this.tilingTexture.isTiling) {
                canvasBuffer = this.tilingTexture.canvasBuffer;
                canvasBuffer.resize(targetWidth, targetHeight);
                this.tilingTexture.baseTexture.width = targetWidth;
                this.tilingTexture.baseTexture.height = targetHeight;
                this.tilingTexture.needsUpdate = true;
            } else {
                canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);
                this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);
                this.tilingTexture.canvasBuffer = canvasBuffer;
                this.tilingTexture.isTiling = true;
            }
            canvasBuffer.context.drawImage(texture.baseTexture.source, texture.crop.x, texture.crop.y, texture.crop.width, texture.crop.height, 0, 0, targetWidth, targetHeight);
            this.tileScaleOffset.x = frame.width / targetWidth;
            this.tileScaleOffset.y = frame.height / targetHeight;
        } else {
            if (this.tilingTexture && this.tilingTexture.isTiling) {
                this.tilingTexture.destroy(true);
            }
            this.tileScaleOffset.x = 1;
            this.tileScaleOffset.y = 1;
            this.tilingTexture = texture;
        }
        this.refreshTexture = false;
        this.tilingTexture.baseTexture._powerOf2 = true;
    };
    PIXI.BaseTextureCache = {};
    PIXI.texturesToUpdate = [];
    PIXI.texturesToDestroy = [];
    PIXI.BaseTextureCacheIdGenerator = 0;
    PIXI.BaseTexture = function(source, scaleMode) {
        PIXI.EventTarget.call(this);
        this.width = 100;
        this.height = 100;
        this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        this.hasLoaded = false;
        this.source = source;
        this.id = PIXI.BaseTextureCacheIdGenerator++;
        this.premultipliedAlpha = true;
        this._glTextures = [];
        this._dirty = [];
        if (!source) return;
        if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {
            this.hasLoaded = true;
            this.width = this.source.width;
            this.height = this.source.height;
            PIXI.texturesToUpdate.push(this);
        } else {
            var scope = this;
            this.source.onload = function() {
                scope.hasLoaded = true;
                scope.width = scope.source.width;
                scope.height = scope.source.height;
                for (var i = 0; i < scope._glTextures.length; i++) {
                    scope._dirty[i] = true;
                }
                scope.dispatchEvent({
                    type: "loaded",
                    content: scope
                });
            };
            this.source.onerror = function() {
                scope.dispatchEvent({
                    type: "error",
                    content: scope
                });
            };
        }
        this.imageUrl = null;
        this._powerOf2 = false;
    };
    PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;
    PIXI.BaseTexture.prototype.destroy = function() {
        if (this.imageUrl) {
            delete PIXI.BaseTextureCache[this.imageUrl];
            delete PIXI.TextureCache[this.imageUrl];
            this.imageUrl = null;
            this.source.src = null;
        } else if (this.source && this.source._pixiId) {
            delete PIXI.BaseTextureCache[this.source._pixiId];
        }
        this.source = null;
        PIXI.texturesToDestroy.push(this);
    };
    PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc) {
        this.hasLoaded = false;
        this.source.src = null;
        this.source.src = newSrc;
    };
    PIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var baseTexture = PIXI.BaseTextureCache[imageUrl];
        if (crossorigin === undefined && imageUrl.indexOf("data:") === -1) crossorigin = true;
        if (!baseTexture) {
            var image = new Image();
            if (crossorigin) {
                image.crossOrigin = "";
            }
            image.src = imageUrl;
            baseTexture = new PIXI.BaseTexture(image, scaleMode);
            baseTexture.imageUrl = imageUrl;
            PIXI.BaseTextureCache[imageUrl] = baseTexture;
        }
        return baseTexture;
    };
    PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode) {
        if (!canvas._pixiId) {
            canvas._pixiId = "canvas_" + PIXI.TextureCacheIdGenerator++;
        }
        var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];
        if (!baseTexture) {
            baseTexture = new PIXI.BaseTexture(canvas, scaleMode);
            PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;
        }
        return baseTexture;
    };
    PIXI.TextureCache = {};
    PIXI.FrameCache = {};
    PIXI.TextureCacheIdGenerator = 0;
    PIXI.Texture = function(baseTexture, frame) {
        PIXI.EventTarget.call(this);
        this.noFrame = false;
        if (!frame) {
            this.noFrame = true;
            frame = new PIXI.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof PIXI.Texture) {
            baseTexture = baseTexture.baseTexture;
        }
        this.baseTexture = baseTexture;
        this.frame = frame;
        this.trim = null;
        this.valid = false;
        this._uvs = null;
        this.width = 0;
        this.height = 0;
        this.crop = new PIXI.Rectangle(0, 0, 1, 1);
        if (baseTexture.hasLoaded) {
            if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            this.setFrame(frame);
        } else {
            baseTexture.addEventListener("loaded", this.onBaseTextureLoaded.bind(this));
        }
    };
    PIXI.Texture.prototype.constructor = PIXI.Texture;
    PIXI.Texture.prototype.onBaseTextureLoaded = function() {
        var baseTexture = this.baseTexture;
        baseTexture.removeEventListener("loaded", this.onLoaded);
        if (this.noFrame) this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        this.setFrame(this.frame);
        this.dispatchEvent({
            type: "update",
            content: this
        });
    };
    PIXI.Texture.prototype.destroy = function(destroyBase) {
        if (destroyBase) this.baseTexture.destroy();
        this.valid = false;
    };
    PIXI.Texture.prototype.setFrame = function(frame) {
        this.noFrame = false;
        this.frame = frame;
        this.width = frame.width;
        this.height = frame.height;
        this.crop.x = frame.x;
        this.crop.y = frame.y;
        this.crop.width = frame.width;
        this.crop.height = frame.height;
        if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) {
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
        }
        this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
        if (this.trim) {
            this.width = this.trim.width;
            this.height = this.trim.height;
            this.frame.width = this.trim.width;
            this.frame.height = this.trim.height;
        }
        if (this.valid) PIXI.Texture.frameUpdates.push(this);
    };
    PIXI.Texture.prototype._updateWebGLuvs = function() {
        if (!this._uvs) this._uvs = new PIXI.TextureUvs();
        var frame = this.crop;
        var tw = this.baseTexture.width;
        var th = this.baseTexture.height;
        this._uvs.x0 = frame.x / tw;
        this._uvs.y0 = frame.y / th;
        this._uvs.x1 = (frame.x + frame.width) / tw;
        this._uvs.y1 = frame.y / th;
        this._uvs.x2 = (frame.x + frame.width) / tw;
        this._uvs.y2 = (frame.y + frame.height) / th;
        this._uvs.x3 = frame.x / tw;
        this._uvs.y3 = (frame.y + frame.height) / th;
    };
    PIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode) {
        var texture = PIXI.TextureCache[imageUrl];
        if (!texture) {
            texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
            PIXI.TextureCache[imageUrl] = texture;
        }
        return texture;
    };
    PIXI.Texture.fromFrame = function(frameId) {
        var texture = PIXI.TextureCache[frameId];
        if (!texture) throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ');
        return texture;
    };
    PIXI.Texture.fromCanvas = function(canvas, scaleMode) {
        var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);
        return new PIXI.Texture(baseTexture);
    };
    PIXI.Texture.addTextureToCache = function(texture, id) {
        PIXI.TextureCache[id] = texture;
    };
    PIXI.Texture.removeTextureFromCache = function(id) {
        var texture = PIXI.TextureCache[id];
        delete PIXI.TextureCache[id];
        delete PIXI.BaseTextureCache[id];
        return texture;
    };
    PIXI.Texture.frameUpdates = [];
    PIXI.TextureUvs = function() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.x3 = 0;
        this.y3 = 0;
    };
    PIXI.RenderTexture = function(width, height, renderer, scaleMode) {
        PIXI.EventTarget.call(this);
        this.width = width || 100;
        this.height = height || 100;
        this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);
        this.crop = new PIXI.Rectangle(0, 0, this.width, this.height);
        this.baseTexture = new PIXI.BaseTexture();
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
        this.baseTexture._glTextures = [];
        this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;
        this.baseTexture.hasLoaded = true;
        this.renderer = renderer || PIXI.defaultRenderer;
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            var gl = this.renderer.gl;
            this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode);
            this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture;
            this.render = this.renderWebGL;
            this.projection = new PIXI.Point(this.width / 2, -this.height / 2);
        } else {
            this.render = this.renderCanvas;
            this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height);
            this.baseTexture.source = this.textureBuffer.canvas;
        }
        this.valid = true;
        PIXI.Texture.frameUpdates.push(this);
    };
    PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);
    PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;
    PIXI.RenderTexture.prototype.resize = function(width, height, updateBase) {
        if (width === this.width && height === this.height) {
            return;
        }
        this.valid = width > 0 && height > 0;
        this.width = this.frame.width = this.crop.width = width;
        this.height = this.frame.height = this.crop.height = height;
        if (updateBase) {
            this.baseTexture.width = this.width;
            this.baseTexture.height = this.height;
        }
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.projection.x = this.width / 2;
            this.projection.y = -this.height / 2;
        }
        if (!this.valid) return;
        this.textureBuffer.resize(this.width, this.height);
    };
    PIXI.RenderTexture.prototype.clear = function() {
        if (!this.valid) return;
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        }
        this.textureBuffer.clear();
    };
    PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear) {
        if (!this.valid) return;
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.viewport(0, 0, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        if (clear) this.textureBuffer.clear();
        var children = displayObject.children;
        var originalWorldTransform = displayObject.worldTransform;
        displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
        displayObject.worldTransform.d = -1;
        displayObject.worldTransform.ty = this.projection.y * -2;
        if (position) {
            displayObject.worldTransform.tx = position.x;
            displayObject.worldTransform.ty -= position.y;
        }
        for (var i = 0, j = children.length; i < j; i++) {
            children[i].updateTransform();
        }
        PIXI.WebGLRenderer.updateTextures();
        this.renderer.spriteBatch.dirty = true;
        this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);
        displayObject.worldTransform = originalWorldTransform;
        this.renderer.spriteBatch.dirty = true;
    };
    PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear) {
        if (!this.valid) return;
        var children = displayObject.children;
        var originalWorldTransform = displayObject.worldTransform;
        displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;
        if (position) {
            displayObject.worldTransform.tx = position.x;
            displayObject.worldTransform.ty = position.y;
        } else {
            displayObject.worldTransform.tx = 0;
            displayObject.worldTransform.ty = 0;
        }
        for (var i = 0, j = children.length; i < j; i++) {
            children[i].updateTransform();
        }
        if (clear) this.textureBuffer.clear();
        var context = this.textureBuffer.context;
        this.renderer.renderDisplayObject(displayObject, context);
        context.setTransform(1, 0, 0, 1, 0, 0);
        displayObject.worldTransform = originalWorldTransform;
    };
    PIXI.RenderTexture.prototype.getImage = function() {
        var image = new Image();
        image.src = this.getBase64();
        return image;
    };
    PIXI.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL();
    };
    PIXI.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === PIXI.WEBGL_RENDERER) {
            var gl = this.renderer.gl;
            var width = this.textureBuffer.width;
            var height = this.textureBuffer.height;
            var webGLPixels = new Uint8Array(4 * width * height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
            gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            var tempCanvas = new PIXI.CanvasBuffer(width, height);
            var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
            var canvasPixels = canvasData.data;
            for (var i = 0; i < webGLPixels.length; i += 4) {
                var alpha = webGLPixels[i + 3];
                canvasPixels[i] = webGLPixels[i] * alpha;
                canvasPixels[i + 1] = webGLPixels[i + 1] * alpha;
                canvasPixels[i + 2] = webGLPixels[i + 2] * alpha;
                canvasPixels[i + 3] = alpha;
            }
            tempCanvas.context.putImageData(canvasData, 0, 0);
            return tempCanvas.canvas;
        } else {
            return this.textureBuffer.canvas;
        }
    };
    PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else if (typeof define !== "undefined" && define.amd) {
        define("PIXI", function() {
            return root.PIXI = PIXI;
        }());
    } else {
        root.PIXI = PIXI;
    }
}).call(this);

(function() {
    var root = this;
    var Phaser = Phaser || {
        VERSION: "2.1.1",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        }
    };
    PIXI.InteractionManager = PIXI.InteractionManager || function() {};
    PIXI.dontSayHello = true;
    Phaser.Utils = {
        getProperty: function(obj, prop) {
            var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0];
            while (i < l && (obj = obj[current])) {
                current = parts[i];
                i++;
            }
            if (obj) {
                return obj[last];
            } else {
                return null;
            }
        },
        setProperty: function(obj, prop, value) {
            var parts = prop.split("."), last = parts.pop(), l = parts.length, i = 1, current = parts[0];
            while (i < l && (obj = obj[current])) {
                current = parts[i];
                i++;
            }
            if (obj) {
                obj[last] = value;
            }
            return obj;
        },
        transposeArray: function(array) {
            var result = new Array(array[0].length);
            for (var i = 0; i < array[0].length; i++) {
                result[i] = new Array(array.length - 1);
                for (var j = array.length - 1; j > -1; j--) {
                    result[i][j] = array[j][i];
                }
            }
            return result;
        },
        rotateArray: function(matrix, direction) {
            if (typeof direction !== "string") {
                direction = (direction % 360 + 360) % 360;
            }
            if (direction === 90 || direction === -270 || direction === "rotateLeft") {
                matrix = Phaser.Utils.transposeArray(matrix);
                matrix = matrix.reverse();
            } else if (direction === -90 || direction === 270 || direction === "rotateRight") {
                matrix = matrix.reverse();
                matrix = Phaser.Utils.transposeArray(matrix);
            } else if (Math.abs(direction) === 180 || direction === "rotate180") {
                for (var i = 0; i < matrix.length; i++) {
                    matrix[i].reverse();
                }
                matrix = matrix.reverse();
            }
            return matrix;
        },
        parseDimension: function(size, dimension) {
            var f = 0;
            var px = 0;
            if (typeof size === "string") {
                if (size.substr(-1) === "%") {
                    f = parseInt(size, 10) / 100;
                    if (dimension === 0) {
                        px = window.innerWidth * f;
                    } else {
                        px = window.innerHeight * f;
                    }
                } else {
                    px = parseInt(size, 10);
                }
            } else {
                px = size;
            }
            return px;
        },
        shuffle: function(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        },
        pad: function(str, len, pad, dir) {
            if (typeof len == "undefined") {
                var len = 0;
            }
            if (typeof pad == "undefined") {
                var pad = " ";
            }
            if (typeof dir == "undefined") {
                var dir = 3;
            }
            var padlen = 0;
            if (len + 1 >= str.length) {
                switch (dir) {
                  case 1:
                    str = new Array(len + 1 - str.length).join(pad) + str;
                    break;

                  case 3:
                    var right = Math.ceil((padlen = len - str.length) / 2);
                    var left = padlen - right;
                    str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);
                    break;

                  default:
                    str = str + new Array(len + 1 - str.length).join(pad);
                    break;
                }
            }
            return str;
        },
        isPlainObject: function(obj) {
            if (typeof obj !== "object" || obj.nodeType || obj === obj.window) {
                return false;
            }
            try {
                if (obj.constructor && !{}.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            return true;
        },
        extend: function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                i = 2;
            }
            if (length === i) {
                target = this;
                --i;
            }
            for (;i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
                        if (target === copy) {
                            continue;
                        }
                        if (deep && copy && (Phaser.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && Array.isArray(src) ? src : [];
                            } else {
                                clone = src && Phaser.Utils.isPlainObject(src) ? src : {};
                            }
                            target[name] = Phaser.Utils.extend(deep, clone, copy);
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
            return target;
        },
        mixin: function(from, to) {
            if (!from || typeof from !== "object") {
                return to;
            }
            for (var key in from) {
                var o = from[key];
                if (o.childNodes || o.cloneNode) {
                    continue;
                }
                var type = typeof from[key];
                if (!from[key] || type !== "object") {
                    to[key] = from[key];
                } else {
                    if (typeof to[key] === type) {
                        to[key] = Phaser.Utils.mixin(from[key], to[key]);
                    } else {
                        to[key] = Phaser.Utils.mixin(from[key], new o.constructor());
                    }
                }
            }
            return to;
        }
    };
    if (typeof Function.prototype.bind != "function") {
        Function.prototype.bind = function() {
            var slice = Array.prototype.slice;
            return function(thisArg) {
                var target = this, boundArgs = slice.call(arguments, 1);
                if (typeof target != "function") {
                    throw new TypeError();
                }
                function bound() {
                    var args = boundArgs.concat(slice.call(arguments));
                    target.apply(this instanceof bound ? this : thisArg, args);
                }
                bound.prototype = function F(proto) {
                    if (proto) {
                        F.prototype = proto;
                    }
                    if (!(this instanceof F)) {
                        return new F();
                    }
                }(target.prototype);
                return bound;
            };
        }();
    }
    if (!Array.isArray) {
        Array.isArray = function(arg) {
            return Object.prototype.toString.call(arg) == "[object Array]";
        };
    }
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(fun) {
            "use strict";
            if (this === void 0 || this === null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function") {
                throw new TypeError();
            }
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
                if (i in t) {
                    fun.call(thisArg, t[i], i, t);
                }
            }
        };
    }
    if (typeof window.Uint32Array !== "function") {
        var CheapArray = function(type) {
            var proto = new Array();
            window[type] = function(arg) {
                if (typeof arg === "number") {
                    Array.call(this, arg);
                    this.length = arg;
                    for (var i = 0; i < this.length; i++) {
                        this[i] = 0;
                    }
                } else {
                    Array.call(this, arg.length);
                    this.length = arg.length;
                    for (var i = 0; i < this.length; i++) {
                        this[i] = arg[i];
                    }
                }
            };
            window[type].prototype = proto;
            window[type].constructor = window[type];
        };
        CheapArray("Uint32Array");
        CheapArray("Int16Array");
    }
    if (!window.console) {
        window.console = {};
        window.console.log = window.console.assert = function() {};
        window.console.warn = window.console.assert = function() {};
    }
    Phaser.Circle = function(x, y, diameter) {
        x = x || 0;
        y = y || 0;
        diameter = diameter || 0;
        this.x = x;
        this.y = y;
        this._diameter = diameter;
        if (diameter > 0) {
            this._radius = diameter * .5;
        } else {
            this._radius = 0;
        }
    };
    Phaser.Circle.prototype = {
        circumference: function() {
            return 2 * (Math.PI * this._radius);
        },
        setTo: function(x, y, diameter) {
            this.x = x;
            this.y = y;
            this._diameter = diameter;
            this._radius = diameter * .5;
            return this;
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.diameter);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.diameter = this._diameter;
            return dest;
        },
        distance: function(dest, round) {
            if (typeof round === "undefined") {
                round = false;
            }
            if (round) {
                return Phaser.Math.distanceRounded(this.x, this.y, dest.x, dest.y);
            } else {
                return Phaser.Math.distance(this.x, this.y, dest.x, dest.y);
            }
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Circle(this.x, this.y, this.diameter);
            } else {
                output.setTo(this.x, this.y, this.diameter);
            }
            return output;
        },
        contains: function(x, y) {
            return Phaser.Circle.contains(this, x, y);
        },
        circumferencePoint: function(angle, asDegrees, out) {
            return Phaser.Circle.circumferencePoint(this, angle, asDegrees, out);
        },
        offset: function(dx, dy) {
            this.x += dx;
            this.y += dy;
            return this;
        },
        offsetPoint: function(point) {
            return this.offset(point.x, point.y);
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
        }
    };
    Phaser.Circle.prototype.constructor = Phaser.Circle;
    Object.defineProperty(Phaser.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter;
        },
        set: function(value) {
            if (value > 0) {
                this._diameter = value;
                this._radius = value * .5;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "radius", {
        get: function() {
            return this._radius;
        },
        set: function(value) {
            if (value > 0) {
                this._radius = value;
                this._diameter = value * 2;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius;
        },
        set: function(value) {
            if (value > this.x) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = this.x - value;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius;
        },
        set: function(value) {
            if (value < this.x) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = value - this.x;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius;
        },
        set: function(value) {
            if (value > this.y) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = this.y - value;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius;
        },
        set: function(value) {
            if (value < this.y) {
                this._radius = 0;
                this._diameter = 0;
            } else {
                this.radius = value - this.y;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "area", {
        get: function() {
            if (this._radius > 0) {
                return Math.PI * this._radius * this._radius;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Circle.prototype, "empty", {
        get: function() {
            return this._diameter === 0;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0);
            }
        }
    });
    Phaser.Circle.contains = function(a, x, y) {
        if (a.radius > 0 && x >= a.left && x <= a.right && y >= a.top && y <= a.bottom) {
            var dx = (a.x - x) * (a.x - x);
            var dy = (a.y - y) * (a.y - y);
            return dx + dy <= a.radius * a.radius;
        } else {
            return false;
        }
    };
    Phaser.Circle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.diameter == b.diameter;
    };
    Phaser.Circle.intersects = function(a, b) {
        return Phaser.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius;
    };
    Phaser.Circle.circumferencePoint = function(a, angle, asDegrees, out) {
        if (typeof asDegrees === "undefined") {
            asDegrees = false;
        }
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        if (asDegrees === true) {
            angle = Phaser.Math.degToRad(angle);
        }
        out.x = a.x + a.radius * Math.cos(angle);
        out.y = a.y + a.radius * Math.sin(angle);
        return out;
    };
    Phaser.Circle.intersectsRectangle = function(c, r) {
        var cx = Math.abs(c.x - r.x - r.halfWidth);
        var xDist = r.halfWidth + c.radius;
        if (cx > xDist) {
            return false;
        }
        var cy = Math.abs(c.y - r.y - r.halfHeight);
        var yDist = r.halfHeight + c.radius;
        if (cy > yDist) {
            return false;
        }
        if (cx <= r.halfWidth || cy <= r.halfHeight) {
            return true;
        }
        var xCornerDist = cx - r.halfWidth;
        var yCornerDist = cy - r.halfHeight;
        var xCornerDistSq = xCornerDist * xCornerDist;
        var yCornerDistSq = yCornerDist * yCornerDist;
        var maxCornerDistSq = c.radius * c.radius;
        return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;
    };
    PIXI.Circle = Phaser.Circle;
    Phaser.Point = function(x, y) {
        x = x || 0;
        y = y || 0;
        this.x = x;
        this.y = y;
    };
    Phaser.Point.prototype = {
        copyFrom: function(source) {
            return this.setTo(source.x, source.y);
        },
        invert: function() {
            return this.setTo(this.y, this.x);
        },
        setTo: function(x, y) {
            this.x = x || 0;
            this.y = y || (y !== 0 ? this.x : 0);
            return this;
        },
        set: function(x, y) {
            this.x = x || 0;
            this.y = y || (y !== 0 ? this.x : 0);
            return this;
        },
        add: function(x, y) {
            this.x += x;
            this.y += y;
            return this;
        },
        subtract: function(x, y) {
            this.x -= x;
            this.y -= y;
            return this;
        },
        multiply: function(x, y) {
            this.x *= x;
            this.y *= y;
            return this;
        },
        divide: function(x, y) {
            this.x /= x;
            this.y /= y;
            return this;
        },
        clampX: function(min, max) {
            this.x = Phaser.Math.clamp(this.x, min, max);
            return this;
        },
        clampY: function(min, max) {
            this.y = Phaser.Math.clamp(this.y, min, max);
            return this;
        },
        clamp: function(min, max) {
            this.x = Phaser.Math.clamp(this.x, min, max);
            this.y = Phaser.Math.clamp(this.y, min, max);
            return this;
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Point(this.x, this.y);
            } else {
                output.setTo(this.x, this.y);
            }
            return output;
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            return dest;
        },
        distance: function(dest, round) {
            return Phaser.Point.distance(this, dest, round);
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y;
        },
        angle: function(a, asDegrees) {
            if (typeof asDegrees === "undefined") {
                asDegrees = false;
            }
            if (asDegrees) {
                return Phaser.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x));
            } else {
                return Math.atan2(a.y - this.y, a.x - this.x);
            }
        },
        angleSq: function(a) {
            return this.subtract(a).angle(a.subtract(this));
        },
        rotate: function(x, y, angle, asDegrees, distance) {
            return Phaser.Point.rotate(this, x, y, angle, asDegrees, distance);
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        setMagnitude: function(magnitude) {
            return this.normalize().multiply(magnitude, magnitude);
        },
        normalize: function() {
            if (!this.isZero()) {
                var m = this.getMagnitude();
                this.x /= m;
                this.y /= m;
            }
            return this;
        },
        isZero: function() {
            return this.x === 0 && this.y === 0;
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y;
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x;
        },
        perp: function() {
            return this.setTo(-this.y, this.x);
        },
        rperp: function() {
            return this.setTo(this.y, -this.x);
        },
        normalRightHand: function() {
            return this.setTo(this.y * -1, this.x);
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
        }
    };
    Phaser.Point.prototype.constructor = Phaser.Point;
    Phaser.Point.add = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        return out;
    };
    Phaser.Point.subtract = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        return out;
    };
    Phaser.Point.multiply = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        return out;
    };
    Phaser.Point.divide = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        return out;
    };
    Phaser.Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    };
    Phaser.Point.angle = function(a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x);
    };
    Phaser.Point.angleSq = function(a, b) {
        return a.subtract(b).angle(b.subtract(a));
    };
    Phaser.Point.negative = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(-a.x, -a.y);
    };
    Phaser.Point.multiplyAdd = function(a, b, s, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.x + b.x * s, a.y + b.y * s);
    };
    Phaser.Point.interpolate = function(a, b, f, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.x + (b.x - a.x) * f, a.y + (b.y - a.y) * f);
    };
    Phaser.Point.perp = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(-a.y, a.x);
    };
    Phaser.Point.rperp = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.y, -a.x);
    };
    Phaser.Point.distance = function(a, b, round) {
        if (typeof round === "undefined") {
            round = false;
        }
        if (round) {
            return Phaser.Math.distanceRounded(a.x, a.y, b.x, b.y);
        } else {
            return Phaser.Math.distance(a.x, a.y, b.x, b.y);
        }
    };
    Phaser.Point.project = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        var amt = a.dot(b) / b.getMagnitudeSq();
        if (amt !== 0) {
            out.setTo(amt * b.x, amt * b.y);
        }
        return out;
    };
    Phaser.Point.projectUnit = function(a, b, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        var amt = a.dot(b);
        if (amt !== 0) {
            out.setTo(amt * b.x, amt * b.y);
        }
        return out;
    };
    Phaser.Point.normalRightHand = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        return out.setTo(a.y * -1, a.x);
    };
    Phaser.Point.normalize = function(a, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        var m = a.getMagnitude();
        if (m !== 0) {
            out.setTo(a.x / m, a.y / m);
        }
        return out;
    };
    Phaser.Point.rotate = function(a, x, y, angle, asDegrees, distance) {
        asDegrees = asDegrees || false;
        distance = distance || null;
        if (asDegrees) {
            angle = Phaser.Math.degToRad(angle);
        }
        if (distance === null) {
            distance = Math.sqrt((x - a.x) * (x - a.x) + (y - a.y) * (y - a.y));
        }
        var requiredAngle = angle + Math.atan2(a.y - y, a.x - x);
        return a.setTo(x + distance * Math.cos(requiredAngle), y + distance * Math.sin(requiredAngle));
    };
    Phaser.Point.centroid = function(points, out) {
        if (typeof out === "undefined") {
            out = new Phaser.Point();
        }
        if (Object.prototype.toString.call(points) !== "[object Array]") {
            throw new Error("Phaser.Point. Parameter 'points' must be an array");
        }
        var pointslength = points.length;
        if (pointslength < 1) {
            throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        }
        if (pointslength === 1) {
            out.copyFrom(points[0]);
            return out;
        }
        for (var i = 0; i < pointslength; i++) {
            Phaser.Point.add(out, points[i], out);
        }
        out.divide(pointslength, pointslength);
        return out;
    };
    PIXI.Point = Phaser.Point;
    Phaser.Rectangle = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        width = width || 0;
        height = height || 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    };
    Phaser.Rectangle.prototype = {
        offset: function(dx, dy) {
            this.x += dx;
            this.y += dy;
            return this;
        },
        offsetPoint: function(point) {
            return this.offset(point.x, point.y);
        },
        setTo: function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        },
        centerOn: function(x, y) {
            this.centerX = x;
            this.centerY = y;
            return this;
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
        },
        floorAll: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.width = Math.floor(this.width);
            this.height = Math.floor(this.height);
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.width, source.height);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.width = this.width;
            dest.height = this.height;
            return dest;
        },
        inflate: function(dx, dy) {
            return Phaser.Rectangle.inflate(this, dx, dy);
        },
        size: function(output) {
            return Phaser.Rectangle.size(this, output);
        },
        clone: function(output) {
            return Phaser.Rectangle.clone(this, output);
        },
        contains: function(x, y) {
            return Phaser.Rectangle.contains(this, x, y);
        },
        containsRect: function(b) {
            return Phaser.Rectangle.containsRect(b, this);
        },
        equals: function(b) {
            return Phaser.Rectangle.equals(this, b);
        },
        intersection: function(b, out) {
            return Phaser.Rectangle.intersection(this, b, out);
        },
        intersects: function(b, tolerance) {
            return Phaser.Rectangle.intersects(this, b, tolerance);
        },
        intersectsRaw: function(left, right, top, bottom, tolerance) {
            return Phaser.Rectangle.intersectsRaw(this, left, right, top, bottom, tolerance);
        },
        union: function(b, out) {
            return Phaser.Rectangle.union(this, b, out);
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
        }
    };
    Object.defineProperty(Phaser.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2);
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2);
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(value) {
            if (value <= this.y) {
                this.height = 0;
            } else {
                this.height = value - this.y;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new Phaser.Point(this.right, this.bottom);
        },
        set: function(value) {
            this.right = value.x;
            this.bottom = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(value) {
            if (value >= this.right) {
                this.width = 0;
            } else {
                this.width = this.right - value;
            }
            this.x = value;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(value) {
            if (value <= this.x) {
                this.width = 0;
            } else {
                this.width = value - this.x;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "perimeter", {
        get: function() {
            return this.width * 2 + this.height * 2;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth;
        },
        set: function(value) {
            this.x = value - this.halfWidth;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight;
        },
        set: function(value) {
            this.y = value - this.halfHeight;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "randomX", {
        get: function() {
            return this.x + Math.random() * this.width;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "randomY", {
        get: function() {
            return this.y + Math.random() * this.height;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(value) {
            if (value >= this.bottom) {
                this.height = 0;
                this.y = value;
            } else {
                this.height = this.bottom - value;
            }
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "topLeft", {
        get: function() {
            return new Phaser.Point(this.x, this.y);
        },
        set: function(value) {
            this.x = value.x;
            this.y = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "topRight", {
        get: function() {
            return new Phaser.Point(this.x + this.width, this.y);
        },
        set: function(value) {
            this.right = value.x;
            this.y = value.y;
        }
    });
    Object.defineProperty(Phaser.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0, 0);
            }
        }
    });
    Phaser.Rectangle.prototype.constructor = Phaser.Rectangle;
    Phaser.Rectangle.inflate = function(a, dx, dy) {
        a.x -= dx;
        a.width += 2 * dx;
        a.y -= dy;
        a.height += 2 * dy;
        return a;
    };
    Phaser.Rectangle.inflatePoint = function(a, point) {
        return Phaser.Rectangle.inflate(a, point.x, point.y);
    };
    Phaser.Rectangle.size = function(a, output) {
        if (typeof output === "undefined" || output === null) {
            output = new Phaser.Point(a.width, a.height);
        } else {
            output.setTo(a.width, a.height);
        }
        return output;
    };
    Phaser.Rectangle.clone = function(a, output) {
        if (typeof output === "undefined" || output === null) {
            output = new Phaser.Rectangle(a.x, a.y, a.width, a.height);
        } else {
            output.setTo(a.x, a.y, a.width, a.height);
        }
        return output;
    };
    Phaser.Rectangle.contains = function(a, x, y) {
        if (a.width <= 0 || a.height <= 0) {
            return false;
        }
        return x >= a.x && x <= a.right && y >= a.y && y <= a.bottom;
    };
    Phaser.Rectangle.containsRaw = function(rx, ry, rw, rh, x, y) {
        return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
    };
    Phaser.Rectangle.containsPoint = function(a, point) {
        return Phaser.Rectangle.contains(a, point.x, point.y);
    };
    Phaser.Rectangle.containsRect = function(a, b) {
        if (a.volume > b.volume) {
            return false;
        }
        return a.x >= b.x && a.y >= b.y && a.right <= b.right && a.bottom <= b.bottom;
    };
    Phaser.Rectangle.equals = function(a, b) {
        return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
    };
    Phaser.Rectangle.intersection = function(a, b, output) {
        if (typeof output === "undefined") {
            output = new Phaser.Rectangle();
        }
        if (Phaser.Rectangle.intersects(a, b)) {
            output.x = Math.max(a.x, b.x);
            output.y = Math.max(a.y, b.y);
            output.width = Math.min(a.right, b.right) - output.x;
            output.height = Math.min(a.bottom, b.bottom) - output.y;
        }
        return output;
    };
    Phaser.Rectangle.intersects = function(a, b) {
        if (a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) {
            return false;
        }
        return !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
    };
    Phaser.Rectangle.intersectsRaw = function(a, left, right, top, bottom, tolerance) {
        if (typeof tolerance === "undefined") {
            tolerance = 0;
        }
        return !(left > a.right + tolerance || right < a.left - tolerance || top > a.bottom + tolerance || bottom < a.top - tolerance);
    };
    Phaser.Rectangle.union = function(a, b, output) {
        if (typeof output === "undefined") {
            output = new Phaser.Rectangle();
        }
        return output.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));
    };
    PIXI.Rectangle = Phaser.Rectangle;
    PIXI.EmptyRectangle = new Phaser.Rectangle(0, 0, 0, 0);
    Phaser.Line = function(x1, y1, x2, y2) {
        x1 = x1 || 0;
        y1 = y1 || 0;
        x2 = x2 || 0;
        y2 = y2 || 0;
        this.start = new Phaser.Point(x1, y1);
        this.end = new Phaser.Point(x2, y2);
    };
    Phaser.Line.prototype = {
        setTo: function(x1, y1, x2, y2) {
            this.start.setTo(x1, y1);
            this.end.setTo(x2, y2);
            return this;
        },
        fromSprite: function(startSprite, endSprite, useCenter) {
            if (typeof useCenter === "undefined") {
                useCenter = false;
            }
            if (useCenter) {
                return this.setTo(startSprite.center.x, startSprite.center.y, endSprite.center.x, endSprite.center.y);
            } else {
                return this.setTo(startSprite.x, startSprite.y, endSprite.x, endSprite.y);
            }
        },
        intersects: function(line, asSegment, result) {
            return Phaser.Line.intersectsPoints(this.start, this.end, line.start, line.end, asSegment, result);
        },
        pointOnLine: function(x, y) {
            return (x - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (y - this.start.y);
        },
        pointOnSegment: function(x, y) {
            var xMin = Math.min(this.start.x, this.end.x);
            var xMax = Math.max(this.start.x, this.end.x);
            var yMin = Math.min(this.start.y, this.end.y);
            var yMax = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax);
        },
        coordinatesOnLine: function(stepRate, results) {
            if (typeof stepRate === "undefined") {
                stepRate = 1;
            }
            if (typeof results === "undefined") {
                results = [];
            }
            var x1 = Math.round(this.start.x);
            var y1 = Math.round(this.start.y);
            var x2 = Math.round(this.end.x);
            var y2 = Math.round(this.end.y);
            var dx = Math.abs(x2 - x1);
            var dy = Math.abs(y2 - y1);
            var sx = x1 < x2 ? 1 : -1;
            var sy = y1 < y2 ? 1 : -1;
            var err = dx - dy;
            results.push([ x1, y1 ]);
            var i = 1;
            while (!(x1 == x2 && y1 == y2)) {
                var e2 = err << 1;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
                if (i % stepRate === 0) {
                    results.push([ x1, y1 ]);
                }
                i++;
            }
            return results;
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Line(this.start.x, this.start.y, this.end.x, this.end.y);
            } else {
                output.setTo(this.start.x, this.start.y, this.end.x, this.end.y);
            }
            return output;
        }
    };
    Object.defineProperty(Phaser.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "perpSlope", {
        get: function() {
            return -((this.end.x - this.start.x) / (this.end.y - this.start.y));
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x);
        }
    });
    Object.defineProperty(Phaser.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y);
        }
    });
    Phaser.Line.intersectsPoints = function(a, b, e, f, asSegment, result) {
        if (typeof asSegment === "undefined") {
            asSegment = true;
        }
        if (typeof result === "undefined") {
            result = new Phaser.Point();
        }
        var a1 = b.y - a.y;
        var a2 = f.y - e.y;
        var b1 = a.x - b.x;
        var b2 = e.x - f.x;
        var c1 = b.x * a.y - a.x * b.y;
        var c2 = f.x * e.y - e.x * f.y;
        var denom = a1 * b2 - a2 * b1;
        if (denom === 0) {
            return null;
        }
        result.x = (b1 * c2 - b2 * c1) / denom;
        result.y = (a2 * c1 - a1 * c2) / denom;
        if (asSegment) {
            var uc = (f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y);
            var ua = ((f.x - e.x) * (a.y - e.y) - (f.y - e.y) * (a.x - e.x)) / uc;
            var ub = ((b.x - a.x) * (a.y - e.y) - (b.y - a.y) * (a.x - e.x)) / uc;
            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return result;
            } else {
                return null;
            }
        }
        return result;
    };
    Phaser.Line.intersects = function(a, b, asSegment, result) {
        return Phaser.Line.intersectsPoints(a.start, a.end, b.start, b.end, asSegment, result);
    };
    Phaser.Ellipse = function(x, y, width, height) {
        this.type = Phaser.ELLIPSE;
        x = x || 0;
        y = y || 0;
        width = width || 0;
        height = height || 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    };
    Phaser.Ellipse.prototype = {
        setTo: function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        },
        copyFrom: function(source) {
            return this.setTo(source.x, source.y, source.width, source.height);
        },
        copyTo: function(dest) {
            dest.x = this.x;
            dest.y = this.y;
            dest.width = this.width;
            dest.height = this.height;
            return dest;
        },
        clone: function(output) {
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Ellipse(this.x, this.y, this.width, this.height);
            } else {
                output.setTo(this.x, this.y, this.width, this.height);
            }
            return output;
        },
        contains: function(x, y) {
            return Phaser.Ellipse.contains(this, x, y);
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
        }
    };
    Phaser.Ellipse.prototype.constructor = Phaser.Ellipse;
    Object.defineProperty(Phaser.Ellipse.prototype, "left", {
        get: function() {
            return this.x;
        },
        set: function(value) {
            this.x = value;
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width;
        },
        set: function(value) {
            if (value < this.x) {
                this.width = 0;
            } else {
                this.width = this.x + value;
            }
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "top", {
        get: function() {
            return this.y;
        },
        set: function(value) {
            this.y = value;
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height;
        },
        set: function(value) {
            if (value < this.y) {
                this.height = 0;
            } else {
                this.height = this.y + value;
            }
        }
    });
    Object.defineProperty(Phaser.Ellipse.prototype, "empty", {
        get: function() {
            return this.width === 0 || this.height === 0;
        },
        set: function(value) {
            if (value === true) {
                this.setTo(0, 0, 0, 0);
            }
        }
    });
    Phaser.Ellipse.contains = function(a, x, y) {
        if (a.width <= 0 || a.height <= 0) {
            return false;
        }
        var normx = (x - a.x) / a.width - .5;
        var normy = (y - a.y) / a.height - .5;
        normx *= normx;
        normy *= normy;
        return normx + normy < .25;
    };
    Phaser.Ellipse.prototype.getBounds = function() {
        return new Phaser.Rectangle(this.x, this.y, this.width, this.height);
    };
    PIXI.Ellipse = Phaser.Ellipse;
    Phaser.Polygon = function(points) {
        this.type = Phaser.POLYGON;
        this.points = points;
    };
    Phaser.Polygon.prototype = {
        clone: function(output) {
            var points = [];
            for (var i = 0; i < this.points.length; i++) {
                points.push(this.points[i].clone());
            }
            if (typeof output === "undefined" || output === null) {
                output = new Phaser.Polygon(points);
            } else {
                output.setTo(points);
            }
            return output;
        },
        contains: function(x, y) {
            var inside = false;
            for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
                var xi = this.points[i].x;
                var yi = this.points[i].y;
                var xj = this.points[j].x;
                var yj = this.points[j].y;
                var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                if (intersect) {
                    inside = !inside;
                }
            }
            return inside;
        },
        setTo: function(points) {
            this.points = points;
            return this;
        }
    };
    Phaser.Polygon.prototype.constructor = Phaser.Polygon;
    Object.defineProperty(Phaser.Polygon.prototype, "points", {
        get: function() {
            return this._points;
        },
        set: function(points) {
            if (!(points instanceof Array)) {
                points = Array.prototype.slice.call(arguments);
            }
            if (typeof points[0] === "number") {
                var p = [];
                for (var i = 0, len = points.length; i < len; i += 2) {
                    p.push(new Phaser.Point(points[i], points[i + 1]));
                }
                points = p;
            }
            this._points = points;
        }
    });
    Object.defineProperty(Phaser.Polygon.prototype, "area", {
        get: function() {
            var p1;
            var p2;
            var avgHeight;
            var width;
            var i;
            var y0 = Number.MAX_VALUE;
            var area = 0;
            for (i = 0; i < this.points.length; i++) {
                if (this.points[i].y < y0) {
                    y0 = this.points[i].y;
                }
            }
            for (i = 0; i < this.points.length; i++) {
                p1 = this.points[i];
                if (i === this.points.length - 1) {
                    p2 = this.points[0];
                } else {
                    p2 = this.points[i + 1];
                }
                avgHeight = (p1.y - y0 + (p2.y - y0)) / 2;
                width = p1.x - p2.x;
                area += avgHeight * width;
            }
            return area;
        }
    });
    PIXI.Polygon = Phaser.Polygon;
    Phaser.Camera = function(game, id, x, y, width, height) {
        this.game = game;
        this.world = game.world;
        this.id = 0;
        this.view = new Phaser.Rectangle(x, y, width, height);
        this.screenView = new Phaser.Rectangle(x, y, width, height);
        this.bounds = new Phaser.Rectangle(x, y, width, height);
        this.deadzone = null;
        this.visible = true;
        this.roundPx = true;
        this.atLimit = {
            x: false,
            y: false
        };
        this.target = null;
        this._edge = 0;
        this._position = new Phaser.Point();
        this.displayObject = null;
        this.scale = null;
    };
    Phaser.Camera.FOLLOW_LOCKON = 0;
    Phaser.Camera.FOLLOW_PLATFORMER = 1;
    Phaser.Camera.FOLLOW_TOPDOWN = 2;
    Phaser.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
    Phaser.Camera.prototype = {
        follow: function(target, style) {
            if (typeof style === "undefined") {
                style = Phaser.Camera.FOLLOW_LOCKON;
            }
            this.target = target;
            var helper;
            switch (style) {
              case Phaser.Camera.FOLLOW_PLATFORMER:
                var w = this.width / 8;
                var h = this.height / 3;
                this.deadzone = new Phaser.Rectangle((this.width - w) / 2, (this.height - h) / 2 - h * .25, w, h);
                break;

              case Phaser.Camera.FOLLOW_TOPDOWN:
                helper = Math.max(this.width, this.height) / 4;
                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                break;

              case Phaser.Camera.FOLLOW_TOPDOWN_TIGHT:
                helper = Math.max(this.width, this.height) / 8;
                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);
                break;

              case Phaser.Camera.FOLLOW_LOCKON:
                this.deadzone = null;
                break;

              default:
                this.deadzone = null;
                break;
            }
        },
        unfollow: function() {
            this.target = null;
        },
        focusOn: function(displayObject) {
            this.setPosition(Math.round(displayObject.x - this.view.halfWidth), Math.round(displayObject.y - this.view.halfHeight));
        },
        focusOnXY: function(x, y) {
            this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight));
        },
        update: function() {
            if (this.target) {
                this.updateTarget();
            }
            if (this.bounds) {
                this.checkBounds();
            }
            if (this.roundPx) {
                this.view.floor();
            }
            this.displayObject.position.x = -this.view.x;
            this.displayObject.position.y = -this.view.y;
        },
        updateTarget: function() {
            if (this.deadzone) {
                this._edge = this.target.x - this.view.x;
                if (this._edge < this.deadzone.left) {
                    this.view.x = this.target.x - this.deadzone.left;
                } else if (this._edge > this.deadzone.right) {
                    this.view.x = this.target.x - this.deadzone.right;
                }
                this._edge = this.target.y - this.view.y;
                if (this._edge < this.deadzone.top) {
                    this.view.y = this.target.y - this.deadzone.top;
                } else if (this._edge > this.deadzone.bottom) {
                    this.view.y = this.target.y - this.deadzone.bottom;
                }
            } else {
                this.view.x = this.target.x - this.view.halfWidth;
                this.view.y = this.target.y - this.view.halfHeight;
            }
        },
        setBoundsToWorld: function() {
            if (this.bounds) {
                this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);
            }
        },
        checkBounds: function() {
            this.atLimit.x = false;
            this.atLimit.y = false;
            if (this.view.x <= this.bounds.x) {
                this.atLimit.x = true;
                this.view.x = this.bounds.x;
            }
            if (this.view.right >= this.bounds.right) {
                this.atLimit.x = true;
                this.view.x = this.bounds.right - this.width;
            }
            if (this.view.y <= this.bounds.top) {
                this.atLimit.y = true;
                this.view.y = this.bounds.top;
            }
            if (this.view.bottom >= this.bounds.bottom) {
                this.atLimit.y = true;
                this.view.y = this.bounds.bottom - this.height;
            }
        },
        setPosition: function(x, y) {
            this.view.x = x;
            this.view.y = y;
            if (this.bounds) {
                this.checkBounds();
            }
        },
        setSize: function(width, height) {
            this.view.width = width;
            this.view.height = height;
        },
        reset: function() {
            this.target = null;
            this.view.x = 0;
            this.view.y = 0;
        }
    };
    Phaser.Camera.prototype.constructor = Phaser.Camera;
    Object.defineProperty(Phaser.Camera.prototype, "x", {
        get: function() {
            return this.view.x;
        },
        set: function(value) {
            this.view.x = value;
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "y", {
        get: function() {
            return this.view.y;
        },
        set: function(value) {
            this.view.y = value;
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "position", {
        get: function() {
            this._position.set(this.view.centerX, this.view.centerY);
            return this._position;
        },
        set: function(value) {
            if (typeof value.x !== "undefined") {
                this.view.x = value.x;
            }
            if (typeof value.y !== "undefined") {
                this.view.y = value.y;
            }
            if (this.bounds) {
                this.checkBounds();
            }
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "width", {
        get: function() {
            return this.view.width;
        },
        set: function(value) {
            this.view.width = value;
        }
    });
    Object.defineProperty(Phaser.Camera.prototype, "height", {
        get: function() {
            return this.view.height;
        },
        set: function(value) {
            this.view.height = value;
        }
    });
    Phaser.State = function() {
        this.game = null;
        this.add = null;
        this.make = null;
        this.camera = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.sound = null;
        this.scale = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.particles = null;
        this.physics = null;
        this.rnd = null;
    };
    Phaser.State.prototype = {
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        render: function() {},
        resize: function() {},
        paused: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    };
    Phaser.State.prototype.constructor = Phaser.State;
    Phaser.StateManager = function(game, pendingState) {
        this.game = game;
        this.states = {};
        this._pendingState = null;
        if (typeof pendingState !== "undefined" && pendingState !== null) {
            this._pendingState = pendingState;
        }
        this._clearWorld = false;
        this._clearCache = false;
        this._created = false;
        this._args = [];
        this.current = "";
        this.onInitCallback = null;
        this.onPreloadCallback = null;
        this.onCreateCallback = null;
        this.onUpdateCallback = null;
        this.onRenderCallback = null;
        this.onResizeCallback = null;
        this.onPreRenderCallback = null;
        this.onLoadUpdateCallback = null;
        this.onLoadRenderCallback = null;
        this.onPausedCallback = null;
        this.onResumedCallback = null;
        this.onPauseUpdateCallback = null;
        this.onShutDownCallback = null;
    };
    Phaser.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this);
            this.game.onResume.add(this.resume, this);
            this.game.load.onLoadComplete.add(this.loadComplete, this);
            if (this._pendingState !== null) {
                if (typeof this._pendingState === "string") {
                    this.start(this._pendingState, false, false);
                } else {
                    this.add("default", this._pendingState, true);
                }
            }
        },
        add: function(key, state, autoStart) {
            if (typeof autoStart === "undefined") {
                autoStart = false;
            }
            var newState;
            if (state instanceof Phaser.State) {
                newState = state;
            } else if (typeof state === "object") {
                newState = state;
                newState.game = this.game;
            } else if (typeof state === "function") {
                newState = new state(this.game);
            }
            this.states[key] = newState;
            if (autoStart) {
                if (this.game.isBooted) {
                    this.start(key);
                } else {
                    this._pendingState = key;
                }
            }
            return newState;
        },
        remove: function(key) {
            if (this.current === key) {
                this.callbackContext = null;
                this.onInitCallback = null;
                this.onShutDownCallback = null;
                this.onPreloadCallback = null;
                this.onLoadRenderCallback = null;
                this.onLoadUpdateCallback = null;
                this.onCreateCallback = null;
                this.onUpdateCallback = null;
                this.onRenderCallback = null;
                this.onResizeCallback = null;
                this.onPausedCallback = null;
                this.onResumedCallback = null;
                this.onPauseUpdateCallback = null;
            }
            delete this.states[key];
        },
        start: function(key, clearWorld, clearCache) {
            if (typeof clearWorld === "undefined") {
                clearWorld = true;
            }
            if (typeof clearCache === "undefined") {
                clearCache = false;
            }
            if (this.checkState(key)) {
                this._pendingState = key;
                this._clearWorld = clearWorld;
                this._clearCache = clearCache;
                if (arguments.length > 3) {
                    this._args = Array.prototype.splice.call(arguments, 3);
                }
            }
        },
        restart: function(clearWorld, clearCache) {
            if (typeof clearWorld === "undefined") {
                clearWorld = true;
            }
            if (typeof clearCache === "undefined") {
                clearCache = false;
            }
            this._pendingState = this.current;
            this._clearWorld = clearWorld;
            this._clearCache = clearCache;
            if (arguments.length > 2) {
                this._args = Array.prototype.splice.call(arguments, 2);
            }
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                this.clearCurrentState();
                this.setCurrentState(this._pendingState);
                this._pendingState = null;
                if (this.onPreloadCallback) {
                    this.game.load.reset();
                    this.onPreloadCallback.call(this.callbackContext, this.game);
                    if (this.game.load.totalQueuedFiles() === 0 && this.game.load.totalQueuedPacks() === 0) {
                        this.loadComplete();
                    } else {
                        this.game.load.start();
                    }
                } else {
                    this.loadComplete();
                }
            }
        },
        clearCurrentState: function() {
            if (this.current) {
                if (this.onShutDownCallback) {
                    this.onShutDownCallback.call(this.callbackContext, this.game);
                }
                this.game.tweens.removeAll();
                this.game.camera.reset();
                this.game.input.reset(true);
                this.game.physics.clear();
                this.game.time.removeAll();
                this.game.scale.reset(this._clearWorld);
                if (this.game.debug) {
                    this.game.debug.reset();
                }
                if (this._clearWorld) {
                    this.game.world.shutdown();
                    if (this._clearCache === true) {
                        this.game.cache.destroy();
                    }
                }
            }
        },
        checkState: function(key) {
            if (this.states[key]) {
                var valid = false;
                if (this.states[key]["preload"]) {
                    valid = true;
                }
                if (this.states[key]["create"]) {
                    valid = true;
                }
                if (this.states[key]["update"]) {
                    valid = true;
                }
                if (this.states[key]["render"]) {
                    valid = true;
                }
                if (valid === false) {
                    console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render");
                    return false;
                }
                return true;
            } else {
                console.warn("Phaser.StateManager - No state found with the key: " + key);
                return false;
            }
        },
        link: function(key) {
            this.states[key].game = this.game;
            this.states[key].add = this.game.add;
            this.states[key].make = this.game.make;
            this.states[key].camera = this.game.camera;
            this.states[key].cache = this.game.cache;
            this.states[key].input = this.game.input;
            this.states[key].load = this.game.load;
            this.states[key].math = this.game.math;
            this.states[key].sound = this.game.sound;
            this.states[key].scale = this.game.scale;
            this.states[key].state = this;
            this.states[key].stage = this.game.stage;
            this.states[key].time = this.game.time;
            this.states[key].tweens = this.game.tweens;
            this.states[key].world = this.game.world;
            this.states[key].particles = this.game.particles;
            this.states[key].rnd = this.game.rnd;
            this.states[key].physics = this.game.physics;
        },
        setCurrentState: function(key) {
            this.callbackContext = this.states[key];
            this.link(key);
            this.onInitCallback = this.states[key]["init"] || this.dummy;
            this.onPreloadCallback = this.states[key]["preload"] || null;
            this.onLoadRenderCallback = this.states[key]["loadRender"] || null;
            this.onLoadUpdateCallback = this.states[key]["loadUpdate"] || null;
            this.onCreateCallback = this.states[key]["create"] || null;
            this.onUpdateCallback = this.states[key]["update"] || null;
            this.onPreRenderCallback = this.states[key]["preRender"] || null;
            this.onRenderCallback = this.states[key]["render"] || null;
            this.onResizeCallback = this.states[key]["resize"] || null;
            this.onPausedCallback = this.states[key]["paused"] || null;
            this.onResumedCallback = this.states[key]["resumed"] || null;
            this.onPauseUpdateCallback = this.states[key]["pauseUpdate"] || null;
            this.onShutDownCallback = this.states[key]["shutdown"] || this.dummy;
            this.current = key;
            this._created = false;
            this.onInitCallback.apply(this.callbackContext, this._args);
            this._args = [];
        },
        getCurrentState: function() {
            return this.states[this.current];
        },
        loadComplete: function() {
            if (this._created === false && this.onCreateCallback) {
                this._created = true;
                this.onCreateCallback.call(this.callbackContext, this.game);
            } else {
                this._created = true;
            }
        },
        pause: function() {
            if (this._created && this.onPausedCallback) {
                this.onPausedCallback.call(this.callbackContext, this.game);
            }
        },
        resume: function() {
            if (this._created && this.onResumedCallback) {
                this.onResumedCallback.call(this.callbackContext, this.game);
            }
        },
        update: function() {
            if (this._created && this.onUpdateCallback) {
                this.onUpdateCallback.call(this.callbackContext, this.game);
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                }
            }
        },
        pauseUpdate: function() {
            if (this._created && this.onPauseUpdateCallback) {
                this.onPauseUpdateCallback.call(this.callbackContext, this.game);
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                }
            }
        },
        preRender: function() {
            if (this.onPreRenderCallback) {
                this.onPreRenderCallback.call(this.callbackContext, this.game);
            }
        },
        resize: function(width, height) {
            if (this.onResizeCallback) {
                this.onResizeCallback.call(this.callbackContext, width, height);
            }
        },
        render: function() {
            if (this._created && this.onRenderCallback) {
                if (this.game.renderType === Phaser.CANVAS) {
                    this.game.context.save();
                    this.game.context.setTransform(1, 0, 0, 1, 0, 0);
                }
                this.onRenderCallback.call(this.callbackContext, this.game);
                if (this.game.renderType === Phaser.CANVAS) {
                    this.game.context.restore();
                }
            } else {
                if (this.onLoadRenderCallback) {
                    this.onLoadRenderCallback.call(this.callbackContext, this.game);
                }
            }
        },
        destroy: function() {
            this.clearCurrentState();
            this.callbackContext = null;
            this.onInitCallback = null;
            this.onShutDownCallback = null;
            this.onPreloadCallback = null;
            this.onLoadRenderCallback = null;
            this.onLoadUpdateCallback = null;
            this.onCreateCallback = null;
            this.onUpdateCallback = null;
            this.onRenderCallback = null;
            this.onPausedCallback = null;
            this.onResumedCallback = null;
            this.onPauseUpdateCallback = null;
            this.game = null;
            this.states = {};
            this._pendingState = null;
        }
    };
    Phaser.StateManager.prototype.constructor = Phaser.StateManager;
    Phaser.LinkedList = function() {
        this.next = null;
        this.prev = null;
        this.first = null;
        this.last = null;
        this.total = 0;
    };
    Phaser.LinkedList.prototype = {
        add: function(child) {
            if (this.total === 0 && this.first === null && this.last === null) {
                this.first = child;
                this.last = child;
                this.next = child;
                child.prev = this;
                this.total++;
                return child;
            }
            this.last.next = child;
            child.prev = this.last;
            this.last = child;
            this.total++;
            return child;
        },
        reset: function() {
            this.first = null;
            this.last = null;
            this.next = null;
            this.prev = null;
            this.total = 0;
        },
        remove: function(child) {
            if (this.total === 1) {
                this.reset();
                child.next = child.prev = null;
                return;
            }
            if (child === this.first) {
                this.first = this.first.next;
            } else if (child === this.last) {
                this.last = this.last.prev;
            }
            if (child.prev) {
                child.prev.next = child.next;
            }
            if (child.next) {
                child.next.prev = child.prev;
            }
            child.next = child.prev = null;
            if (this.first === null) {
                this.last = null;
            }
            this.total--;
        },
        callAll: function(callback) {
            if (!this.first || !this.last) {
                return;
            }
            var entity = this.first;
            do {
                if (entity && entity[callback]) {
                    entity[callback].call(entity);
                }
                entity = entity.next;
            } while (entity != this.last.next);
        }
    };
    Phaser.LinkedList.prototype.constructor = Phaser.LinkedList;
    Phaser.ArrayList = function() {
        this.total = 0;
        this.position = 0;
        this.list = [];
    };
    Phaser.ArrayList.prototype = {
        add: function(child) {
            if (!this.exists(child)) {
                this.list.push(child);
                this.total++;
            }
            return child;
        },
        getIndex: function(child) {
            return this.list.indexOf(child);
        },
        exists: function(child) {
            return this.list.indexOf(child) > -1;
        },
        reset: function() {
            this.list.length = 0;
            this.total = 0;
        },
        remove: function(child) {
            var idx = this.list.indexOf(child);
            if (idx > -1) {
                this.list.splice(idx, 1);
                this.total--;
                return child;
            }
        },
        setAll: function(key, value) {
            var i = this.list.length;
            while (i--) {
                if (this.list[i] && this.list[i][key]) {
                    this.list[i][key] = value;
                }
            }
        },
        callAll: function(callback) {
            var args = Array.prototype.splice.call(arguments, 1);
            var i = this.list.length;
            while (i--) {
                if (this.list[i] && this.list[i][callback]) {
                    this.list[i][callback].apply(this.list[i], args);
                }
            }
        }
    };
    Object.defineProperty(Phaser.ArrayList.prototype, "first", {
        get: function() {
            this.position = 0;
            if (this.total > 0) {
                return this.list[0];
            } else {
                return null;
            }
        }
    });
    Object.defineProperty(Phaser.ArrayList.prototype, "next", {
        get: function() {
            if (this.position < this.total) {
                this.position++;
                return this.list[this.position];
            } else {
                return null;
            }
        }
    });
    Phaser.ArrayList.prototype.constructor = Phaser.ArrayList;
    Phaser.Signal = function() {
        this._bindings = [];
        this._prevParams = null;
        var self = this;
        this.dispatch = function() {
            Phaser.Signal.prototype.dispatch.apply(self, arguments);
        };
    };
    Phaser.Signal.prototype = {
        memorize: false,
        _shouldPropagate: true,
        active: true,
        validateListener: function(listener, fnName) {
            if (typeof listener !== "function") {
                throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", fnName));
            }
        },
        _registerListener: function(listener, isOnce, listenerContext, priority) {
            var prevIndex = this._indexOfListener(listener, listenerContext);
            var binding;
            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error("You cannot add" + (isOnce ? "" : "Once") + "() then add" + (!isOnce ? "" : "Once") + "() the same listener without removing the relationship first.");
                }
            } else {
                binding = new Phaser.SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }
            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }
            return binding;
        },
        _addBinding: function(binding) {
            var n = this._bindings.length;
            do {
                n--;
            } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },
        _indexOfListener: function(listener, context) {
            var n = this._bindings.length;
            var cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },
        has: function(listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },
        add: function(listener, listenerContext, priority) {
            this.validateListener(listener, "add");
            return this._registerListener(listener, false, listenerContext, priority);
        },
        addOnce: function(listener, listenerContext, priority) {
            this.validateListener(listener, "addOnce");
            return this._registerListener(listener, true, listenerContext, priority);
        },
        remove: function(listener, context) {
            this.validateListener(listener, "remove");
            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy();
                this._bindings.splice(i, 1);
            }
            return listener;
        },
        removeAll: function(context) {
            if (typeof context === "undefined") {
                context = null;
            }
            var n = this._bindings.length;
            while (n--) {
                if (context) {
                    if (this._bindings[n].context === context) {
                        this._bindings[n]._destroy();
                        this._bindings.splice(n, 1);
                    }
                } else {
                    this._bindings[n]._destroy();
                }
            }
            if (!context) {
                this._bindings.length = 0;
            }
        },
        getNumListeners: function() {
            return this._bindings.length;
        },
        halt: function() {
            this._shouldPropagate = false;
        },
        dispatch: function() {
            if (!this.active) {
                return;
            }
            var paramsArr = Array.prototype.slice.call(arguments);
            var n = this._bindings.length;
            var bindings;
            if (this.memorize) {
                this._prevParams = paramsArr;
            }
            if (!n) {
                return;
            }
            bindings = this._bindings.slice();
            this._shouldPropagate = true;
            do {
                n--;
            } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },
        forget: function() {
            this._prevParams = null;
        },
        dispose: function() {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        }
    };
    Phaser.Signal.prototype.constructor = Phaser.Signal;
    Phaser.SignalBinding = function(signal, listener, isOnce, listenerContext, priority) {
        this._listener = listener;
        this._isOnce = isOnce;
        this.context = listenerContext;
        this._signal = signal;
        this._priority = priority || 0;
    };
    Phaser.SignalBinding.prototype = {
        active: true,
        params: null,
        execute: function(paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function() {
            return !!this._signal && !!this._listener;
        },
        isOnce: function() {
            return this._isOnce;
        },
        getListener: function() {
            return this._listener;
        },
        getSignal: function() {
            return this._signal;
        },
        _destroy: function() {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        }
    };
    Phaser.SignalBinding.prototype.constructor = Phaser.SignalBinding;
    Phaser.Filter = function(game, uniforms, fragmentSrc) {
        this.game = game;
        this.type = Phaser.WEBGL_FILTER;
        this.passes = [ this ];
        this.shaders = [];
        this.dirty = true;
        this.padding = 0;
        this.uniforms = {
            time: {
                type: "1f",
                value: 0
            },
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            }
        };
        this.fragmentSrc = fragmentSrc || [];
    };
    Phaser.Filter.prototype = {
        init: function() {},
        setResolution: function(width, height) {
            this.uniforms.resolution.value.x = width;
            this.uniforms.resolution.value.y = height;
        },
        update: function(pointer) {
            if (typeof pointer !== "undefined") {
                if (pointer.x > 0) {
                    this.uniforms.mouse.x = pointer.x.toFixed(2);
                }
                if (pointer.y > 0) {
                    this.uniforms.mouse.y = pointer.y.toFixed(2);
                }
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds();
        },
        destroy: function() {
            this.game = null;
        }
    };
    Phaser.Filter.prototype.constructor = Phaser.Filter;
    Object.defineProperty(Phaser.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x;
        },
        set: function(value) {
            this.uniforms.resolution.value.x = value;
        }
    });
    Object.defineProperty(Phaser.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y;
        },
        set: function(value) {
            this.uniforms.resolution.value.y = value;
        }
    });
    Phaser.Plugin = function(game, parent) {
        if (typeof parent === "undefined") {
            parent = null;
        }
        this.game = game;
        this.parent = parent;
        this.active = false;
        this.visible = false;
        this.hasPreUpdate = false;
        this.hasUpdate = false;
        this.hasPostUpdate = false;
        this.hasRender = false;
        this.hasPostRender = false;
    };
    Phaser.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null;
            this.parent = null;
            this.active = false;
            this.visible = false;
        }
    };
    Phaser.Plugin.prototype.constructor = Phaser.Plugin;
    Phaser.PluginManager = function(game) {
        this.game = game;
        this.plugins = [];
        this._len = 0;
        this._i = 0;
    };
    Phaser.PluginManager.prototype = {
        add: function(plugin) {
            var args = Array.prototype.splice.call(arguments, 1);
            var result = false;
            if (typeof plugin === "function") {
                plugin = new plugin(this.game, this);
            } else {
                plugin.game = this.game;
                plugin.parent = this;
            }
            if (typeof plugin["preUpdate"] === "function") {
                plugin.hasPreUpdate = true;
                result = true;
            }
            if (typeof plugin["update"] === "function") {
                plugin.hasUpdate = true;
                result = true;
            }
            if (typeof plugin["postUpdate"] === "function") {
                plugin.hasPostUpdate = true;
                result = true;
            }
            if (typeof plugin["render"] === "function") {
                plugin.hasRender = true;
                result = true;
            }
            if (typeof plugin["postRender"] === "function") {
                plugin.hasPostRender = true;
                result = true;
            }
            if (result) {
                if (plugin.hasPreUpdate || plugin.hasUpdate || plugin.hasPostUpdate) {
                    plugin.active = true;
                }
                if (plugin.hasRender || plugin.hasPostRender) {
                    plugin.visible = true;
                }
                this._len = this.plugins.push(plugin);
                if (typeof plugin["init"] === "function") {
                    plugin.init.apply(plugin, args);
                }
                return plugin;
            } else {
                return null;
            }
        },
        remove: function(plugin) {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i] === plugin) {
                    plugin.destroy();
                    this.plugins.splice(this._i, 1);
                    this._len--;
                    return;
                }
            }
        },
        removeAll: function() {
            this._i = this._len;
            while (this._i--) {
                this.plugins[this._i].destroy();
            }
            this.plugins.length = 0;
            this._len = 0;
        },
        preUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate) {
                    this.plugins[this._i].preUpdate();
                }
            }
        },
        update: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate) {
                    this.plugins[this._i].update();
                }
            }
        },
        postUpdate: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate) {
                    this.plugins[this._i].postUpdate();
                }
            }
        },
        render: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasRender) {
                    this.plugins[this._i].render();
                }
            }
        },
        postRender: function() {
            this._i = this._len;
            while (this._i--) {
                if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender) {
                    this.plugins[this._i].postRender();
                }
            }
        },
        destroy: function() {
            this.removeAll();
            this.game = null;
        }
    };
    Phaser.PluginManager.prototype.constructor = Phaser.PluginManager;
    Phaser.Stage = function(game) {
        this.game = game;
        PIXI.Stage.call(this, 0);
        this.name = "_stage_root";
        this.interactive = false;
        this.disableVisibilityChange = false;
        this.exists = true;
        this.currentRenderOrderID = 0;
        this._hiddenVar = "hidden";
        this._backgroundColor = 0;
        if (game.config) {
            this.parseConfig(game.config);
        }
    };
    Phaser.Stage.prototype = Object.create(PIXI.Stage.prototype);
    Phaser.Stage.prototype.constructor = Phaser.Stage;
    Phaser.Stage.prototype.parseConfig = function(config) {
        if (config["disableVisibilityChange"]) {
            this.disableVisibilityChange = config["disableVisibilityChange"];
        }
        if (config["backgroundColor"]) {
            this.backgroundColor = config["backgroundColor"];
        }
    };
    Phaser.Stage.prototype.boot = function() {
        Phaser.Canvas.getOffset(this.game.canvas, this.offset);
        var _this = this;
        this._onChange = function(event) {
            return _this.visibilityChange(event);
        };
        Phaser.Canvas.setUserSelect(this.game.canvas, "none");
        Phaser.Canvas.setTouchAction(this.game.canvas, "none");
        this.checkVisibility();
    };
    Phaser.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        var len = this.children.length;
        for (var i = 0; i < len; i++) {
            this.children[i].preUpdate();
        }
    };
    Phaser.Stage.prototype.update = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].update();
        }
    };
    Phaser.Stage.prototype.postUpdate = function() {
        if (this.game.world.camera.target) {
            this.game.world.camera.target.postUpdate();
            this.game.world.camera.update();
            var i = this.children.length;
            while (i--) {
                if (this.children[i] !== this.game.world.camera.target) {
                    this.children[i].postUpdate();
                }
            }
        } else {
            this.game.world.camera.update();
            var i = this.children.length;
            while (i--) {
                this.children[i].postUpdate();
            }
        }
    };
    Phaser.Stage.prototype.checkVisibility = function() {
        if (document.webkitHidden !== undefined) {
            this._hiddenVar = "webkitvisibilitychange";
        } else if (document.mozHidden !== undefined) {
            this._hiddenVar = "mozvisibilitychange";
        } else if (document.msHidden !== undefined) {
            this._hiddenVar = "msvisibilitychange";
        } else if (document.hidden !== undefined) {
            this._hiddenVar = "visibilitychange";
        } else {
            this._hiddenVar = null;
        }
        if (this._hiddenVar) {
            document.addEventListener(this._hiddenVar, this._onChange, false);
        }
        window.onpagehide = this._onChange;
        window.onpageshow = this._onChange;
        window.onblur = this._onChange;
        window.onfocus = this._onChange;
        var _this = this;
        if (this.game.device.cocoonJSApp) {
            CocoonJS.App.onSuspended.addEventListener(function() {
                Phaser.Stage.prototype.visibilityChange.call(_this, {
                    type: "pause"
                });
            });
            CocoonJS.App.onActivated.addEventListener(function() {
                Phaser.Stage.prototype.visibilityChange.call(_this, {
                    type: "resume"
                });
            });
        }
    };
    Phaser.Stage.prototype.visibilityChange = function(event) {
        if (event.type === "pagehide" || event.type === "blur" || event.type === "pageshow" || event.type === "focus") {
            if (event.type === "pagehide" || event.type === "blur") {
                this.game.focusLoss(event);
            } else if (event.type === "pageshow" || event.type === "focus") {
                this.game.focusGain(event);
            }
            return;
        }
        if (this.disableVisibilityChange) {
            return;
        }
        if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || event.type === "pause") {
            this.game.gamePaused(event);
        } else {
            this.game.gameResumed(event);
        }
    };
    Phaser.Stage.prototype.setBackgroundColor = function(backgroundColor) {
        if (typeof backgroundColor === "string") {
            var rgb = Phaser.Color.hexToColor(backgroundColor);
            this._backgroundColor = Phaser.Color.getColor(rgb.r, rgb.g, rgb.b);
        } else {
            var rgb = Phaser.Color.getRGB(backgroundColor);
            this._backgroundColor = backgroundColor;
        }
        this.backgroundColorSplit = [ rgb.r / 255, rgb.g / 255, rgb.b / 255 ];
        this.backgroundColorString = Phaser.Color.RGBtoString(rgb.r, rgb.g, rgb.b, 255, "#");
    };
    Phaser.Stage.prototype.destroy = function() {
        if (this._hiddenVar) {
            document.removeEventListener(this._hiddenVar, this._onChange, false);
        }
        window.onpagehide = null;
        window.onpageshow = null;
        window.onblur = null;
        window.onfocus = null;
    };
    Object.defineProperty(Phaser.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._backgroundColor;
        },
        set: function(color) {
            if (!this.game.transparent) {
                this.setBackgroundColor(color);
            }
        }
    });
    Object.defineProperty(Phaser.Stage.prototype, "smoothed", {
        get: function() {
            return !PIXI.scaleModes.LINEAR;
        },
        set: function(value) {
            if (value) {
                PIXI.scaleModes.LINEAR = 0;
            } else {
                PIXI.scaleModes.LINEAR = 1;
            }
        }
    });
    Phaser.Group = function(game, parent, name, addToStage, enableBody, physicsBodyType) {
        if (typeof addToStage === "undefined") {
            addToStage = false;
        }
        if (typeof enableBody === "undefined") {
            enableBody = false;
        }
        if (typeof physicsBodyType === "undefined") {
            physicsBodyType = Phaser.Physics.ARCADE;
        }
        this.game = game;
        if (typeof parent === "undefined") {
            parent = game.world;
        }
        this.name = name || "group";
        PIXI.DisplayObjectContainer.call(this);
        if (addToStage) {
            this.game.stage.addChild(this);
        } else {
            if (parent) {
                parent.addChild(this);
            }
        }
        this.z = 0;
        this.type = Phaser.GROUP;
        this.alive = true;
        this.exists = true;
        this.classType = Phaser.Sprite;
        this.scale = new Phaser.Point(1, 1);
        this.cursor = null;
        this.cameraOffset = new Phaser.Point();
        this.enableBody = enableBody;
        this.enableBodyDebug = false;
        this.physicsBodyType = physicsBodyType;
        this.onDestroy = new Phaser.Signal();
        this._sortProperty = "z";
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 ];
    };
    Phaser.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    Phaser.Group.prototype.constructor = Phaser.Group;
    Phaser.Group.RETURN_NONE = 0;
    Phaser.Group.RETURN_TOTAL = 1;
    Phaser.Group.RETURN_CHILD = 2;
    Phaser.Group.SORT_ASCENDING = -1;
    Phaser.Group.SORT_DESCENDING = 1;
    Phaser.Group.prototype.add = function(child, silent) {
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (child.parent !== this) {
            if (this.enableBody) {
                this.game.physics.enable(child, this.physicsBodyType);
            }
            this.addChild(child);
            child.z = this.children.length;
            if (!silent && child.events) {
                child.events.onAddedToGroup.dispatch(child, this);
            }
            if (this.cursor === null) {
                this.cursor = child;
            }
        }
        return child;
    };
    Phaser.Group.prototype.addMultiple = function(children, silent) {
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
                this.add(children[i], silent);
            }
        }
        return children;
    };
    Phaser.Group.prototype.addAt = function(child, index, silent) {
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (child.parent !== this) {
            if (this.enableBody) {
                this.game.physics.enable(child, this.physicsBodyType);
            }
            this.addChildAt(child, index);
            this.updateZ();
            if (!silent && child.events) {
                child.events.onAddedToGroup.dispatch(child, this);
            }
            if (this.cursor === null) {
                this.cursor = child;
            }
        }
        return child;
    };
    Phaser.Group.prototype.getAt = function(index) {
        if (index < 0 || index >= this.children.length) {
            return -1;
        } else {
            return this.getChildAt(index);
        }
    };
    Phaser.Group.prototype.create = function(x, y, key, frame, exists) {
        if (typeof exists === "undefined") {
            exists = true;
        }
        var child = new this.classType(this.game, x, y, key, frame);
        if (this.enableBody) {
            this.game.physics.enable(child, this.physicsBodyType, this.enableBodyDebug);
        }
        child.exists = exists;
        child.visible = exists;
        child.alive = exists;
        this.addChild(child);
        child.z = this.children.length;
        if (child.events) {
            child.events.onAddedToGroup.dispatch(child, this);
        }
        if (this.cursor === null) {
            this.cursor = child;
        }
        return child;
    };
    Phaser.Group.prototype.createMultiple = function(quantity, key, frame, exists) {
        if (typeof exists === "undefined") {
            exists = false;
        }
        for (var i = 0; i < quantity; i++) {
            this.create(0, 0, key, frame, exists);
        }
    };
    Phaser.Group.prototype.updateZ = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].z = i;
        }
    };
    Phaser.Group.prototype.resetCursor = function(index) {
        if (typeof index === "undefined") {
            index = 0;
        }
        if (index > this.children.length - 1) {
            index = 0;
        }
        if (this.cursor) {
            this._cache[8] = index;
            this.cursor = this.children[this._cache[8]];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.next = function() {
        if (this.cursor) {
            if (this._cache[8] >= this.children.length - 1) {
                this._cache[8] = 0;
            } else {
                this._cache[8]++;
            }
            this.cursor = this.children[this._cache[8]];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.previous = function() {
        if (this.cursor) {
            if (this._cache[8] === 0) {
                this._cache[8] = this.children.length - 1;
            } else {
                this._cache[8]--;
            }
            this.cursor = this.children[this._cache[8]];
            return this.cursor;
        }
    };
    Phaser.Group.prototype.swap = function(child1, child2) {
        this.swapChildren(child1, child2);
        this.updateZ();
    };
    Phaser.Group.prototype.bringToTop = function(child) {
        if (child.parent === this && this.getIndex(child) < this.children.length) {
            this.remove(child, false, true);
            this.add(child, true);
        }
        return child;
    };
    Phaser.Group.prototype.sendToBack = function(child) {
        if (child.parent === this && this.getIndex(child) > 0) {
            this.remove(child, false, true);
            this.addAt(child, 0, true);
        }
        return child;
    };
    Phaser.Group.prototype.moveUp = function(child) {
        if (child.parent === this && this.getIndex(child) < this.children.length - 1) {
            var a = this.getIndex(child);
            var b = this.getAt(a + 1);
            if (b) {
                this.swap(child, b);
            }
        }
        return child;
    };
    Phaser.Group.prototype.moveDown = function(child) {
        if (child.parent === this && this.getIndex(child) > 0) {
            var a = this.getIndex(child);
            var b = this.getAt(a - 1);
            if (b) {
                this.swap(child, b);
            }
        }
        return child;
    };
    Phaser.Group.prototype.xy = function(index, x, y) {
        if (index < 0 || index > this.children.length) {
            return -1;
        } else {
            this.getChildAt(index).x = x;
            this.getChildAt(index).y = y;
        }
    };
    Phaser.Group.prototype.reverse = function() {
        this.children.reverse();
        this.updateZ();
    };
    Phaser.Group.prototype.getIndex = function(child) {
        return this.children.indexOf(child);
    };
    Phaser.Group.prototype.replace = function(oldChild, newChild) {
        var index = this.getIndex(oldChild);
        if (index !== -1) {
            if (newChild.parent !== undefined) {
                newChild.events.onRemovedFromGroup.dispatch(newChild, this);
                newChild.parent.removeChild(newChild);
                if (newChild.parent instanceof Phaser.Group) {
                    newChild.parent.updateZ();
                }
            }
            var temp = oldChild;
            this.remove(temp);
            this.addAt(newChild, index);
            return temp;
        }
    };
    Phaser.Group.prototype.hasProperty = function(child, key) {
        var len = key.length;
        if (len === 1 && key[0] in child) {
            return true;
        } else if (len === 2 && key[0] in child && key[1] in child[key[0]]) {
            return true;
        } else if (len === 3 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]]) {
            return true;
        } else if (len === 4 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]] && key[3] in child[key[0]][key[1]][key[2]]) {
            return true;
        }
        return false;
    };
    Phaser.Group.prototype.setProperty = function(child, key, value, operation, force) {
        if (typeof force === "undefined") {
            force = false;
        }
        operation = operation || 0;
        if (!this.hasProperty(child, key) && (!force || operation > 0)) {
            return false;
        }
        var len = key.length;
        if (len === 1) {
            if (operation === 0) {
                child[key[0]] = value;
            } else if (operation == 1) {
                child[key[0]] += value;
            } else if (operation == 2) {
                child[key[0]] -= value;
            } else if (operation == 3) {
                child[key[0]] *= value;
            } else if (operation == 4) {
                child[key[0]] /= value;
            }
        } else if (len === 2) {
            if (operation === 0) {
                child[key[0]][key[1]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]] /= value;
            }
        } else if (len === 3) {
            if (operation === 0) {
                child[key[0]][key[1]][key[2]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]][key[2]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]][key[2]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]][key[2]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]][key[2]] /= value;
            }
        } else if (len === 4) {
            if (operation === 0) {
                child[key[0]][key[1]][key[2]][key[3]] = value;
            } else if (operation == 1) {
                child[key[0]][key[1]][key[2]][key[3]] += value;
            } else if (operation == 2) {
                child[key[0]][key[1]][key[2]][key[3]] -= value;
            } else if (operation == 3) {
                child[key[0]][key[1]][key[2]][key[3]] *= value;
            } else if (operation == 4) {
                child[key[0]][key[1]][key[2]][key[3]] /= value;
            }
        }
        return true;
    };
    Phaser.Group.prototype.checkProperty = function(child, key, value, force) {
        if (typeof force === "undefined") {
            force = false;
        }
        if (!Phaser.Utils.getProperty(child, key) && force) {
            return false;
        }
        if (Phaser.Utils.getProperty(child, key) !== value) {
            return false;
        }
        return true;
    };
    Phaser.Group.prototype.set = function(child, key, value, checkAlive, checkVisible, operation, force) {
        if (typeof force === "undefined") {
            force = false;
        }
        key = key.split(".");
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if ((checkAlive === false || checkAlive && child.alive) && (checkVisible === false || checkVisible && child.visible)) {
            return this.setProperty(child, key, value, operation, force);
        }
    };
    Phaser.Group.prototype.setAll = function(key, value, checkAlive, checkVisible, operation, force) {
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if (typeof force === "undefined") {
            force = false;
        }
        key = key.split(".");
        operation = operation || 0;
        for (var i = 0, len = this.children.length; i < len; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                this.setProperty(this.children[i], key, value, operation, force);
            }
        }
    };
    Phaser.Group.prototype.setAllChildren = function(key, value, checkAlive, checkVisible, operation, force) {
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if (typeof force === "undefined") {
            force = false;
        }
        operation = operation || 0;
        for (var i = 0, len = this.children.length; i < len; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                if (this.children[i] instanceof Phaser.Group) {
                    this.children[i].setAllChildren(key, value, checkAlive, checkVisible, operation, force);
                } else {
                    this.setProperty(this.children[i], key.split("."), value, operation, force);
                }
            }
        }
    };
    Phaser.Group.prototype.checkAll = function(key, value, checkAlive, checkVisible, force) {
        if (typeof checkAlive === "undefined") {
            checkAlive = false;
        }
        if (typeof checkVisible === "undefined") {
            checkVisible = false;
        }
        if (typeof force === "undefined") {
            force = false;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            if ((!checkAlive || checkAlive && this.children[i].alive) && (!checkVisible || checkVisible && this.children[i].visible)) {
                if (!this.checkProperty(this.children[i], key, value, force)) {
                    return false;
                }
            }
        }
        return true;
    };
    Phaser.Group.prototype.addAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 1);
    };
    Phaser.Group.prototype.subAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 2);
    };
    Phaser.Group.prototype.multiplyAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 3);
    };
    Phaser.Group.prototype.divideAll = function(property, amount, checkAlive, checkVisible) {
        this.setAll(property, amount, checkAlive, checkVisible, 4);
    };
    Phaser.Group.prototype.callAllExists = function(callback, existsValue) {
        var args = Array.prototype.splice.call(arguments, 2);
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i].exists === existsValue && this.children[i][callback]) {
                this.children[i][callback].apply(this.children[i], args);
            }
        }
    };
    Phaser.Group.prototype.callbackFromArray = function(child, callback, length) {
        if (length == 1) {
            if (child[callback[0]]) {
                return child[callback[0]];
            }
        } else if (length == 2) {
            if (child[callback[0]][callback[1]]) {
                return child[callback[0]][callback[1]];
            }
        } else if (length == 3) {
            if (child[callback[0]][callback[1]][callback[2]]) {
                return child[callback[0]][callback[1]][callback[2]];
            }
        } else if (length == 4) {
            if (child[callback[0]][callback[1]][callback[2]][callback[3]]) {
                return child[callback[0]][callback[1]][callback[2]][callback[3]];
            }
        } else {
            if (child[callback]) {
                return child[callback];
            }
        }
        return false;
    };
    Phaser.Group.prototype.callAll = function(method, context) {
        if (typeof method === "undefined") {
            return;
        }
        method = method.split(".");
        var methodLength = method.length;
        if (typeof context === "undefined" || context === null || context === "") {
            context = null;
        } else {
            if (typeof context === "string") {
                context = context.split(".");
                var contextLength = context.length;
            }
        }
        var args = Array.prototype.splice.call(arguments, 2);
        var callback = null;
        var callbackContext = null;
        for (var i = 0, len = this.children.length; i < len; i++) {
            callback = this.callbackFromArray(this.children[i], method, methodLength);
            if (context && callback) {
                callbackContext = this.callbackFromArray(this.children[i], context, contextLength);
                if (callback) {
                    callback.apply(callbackContext, args);
                }
            } else if (callback) {
                callback.apply(this.children[i], args);
            }
        }
    };
    Phaser.Group.prototype.preUpdate = function() {
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        var i = this.children.length;
        while (i--) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Group.prototype.update = function() {
        var i = this.children.length;
        while (i--) {
            this.children[i].update();
        }
    };
    Phaser.Group.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.x = this.game.camera.view.x + this.cameraOffset.x;
            this.y = this.game.camera.view.y + this.cameraOffset.y;
        }
        var i = this.children.length;
        while (i--) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Group.prototype.forEach = function(callback, callbackContext, checkExists) {
        if (typeof checkExists === "undefined") {
            checkExists = false;
        }
        var args = Array.prototype.splice.call(arguments, 3);
        args.unshift(null);
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (!checkExists || checkExists && this.children[i].exists) {
                args[0] = this.children[i];
                callback.apply(callbackContext, args);
            }
        }
    };
    Phaser.Group.prototype.forEachExists = function(callback, callbackContext) {
        var args = Array.prototype.splice.call(arguments, 2);
        args.unshift(null);
        this.iterate("exists", true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.forEachAlive = function(callback, callbackContext) {
        var args = Array.prototype.splice.call(arguments, 2);
        args.unshift(null);
        this.iterate("alive", true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.forEachDead = function(callback, callbackContext) {
        var args = Array.prototype.splice.call(arguments, 2);
        args.unshift(null);
        this.iterate("alive", false, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);
    };
    Phaser.Group.prototype.sort = function(index, order) {
        if (this.children.length < 2) {
            return;
        }
        if (typeof index === "undefined") {
            index = "z";
        }
        if (typeof order === "undefined") {
            order = Phaser.Group.SORT_ASCENDING;
        }
        this._sortProperty = index;
        if (order === Phaser.Group.SORT_ASCENDING) {
            this.children.sort(this.ascendingSortHandler.bind(this));
        } else {
            this.children.sort(this.descendingSortHandler.bind(this));
        }
        this.updateZ();
    };
    Phaser.Group.prototype.customSort = function(sortHandler, context) {
        if (this.children.length < 2) {
            return;
        }
        this.children.sort(sortHandler.bind(context));
        this.updateZ();
    };
    Phaser.Group.prototype.ascendingSortHandler = function(a, b) {
        if (a[this._sortProperty] < b[this._sortProperty]) {
            return -1;
        } else if (a[this._sortProperty] > b[this._sortProperty]) {
            return 1;
        } else {
            if (a.z < b.z) {
                return -1;
            } else {
                return 1;
            }
        }
    };
    Phaser.Group.prototype.descendingSortHandler = function(a, b) {
        if (a[this._sortProperty] < b[this._sortProperty]) {
            return 1;
        } else if (a[this._sortProperty] > b[this._sortProperty]) {
            return -1;
        } else {
            return 0;
        }
    };
    Phaser.Group.prototype.iterate = function(key, value, returnType, callback, callbackContext, args) {
        if (returnType === Phaser.Group.RETURN_TOTAL && this.children.length === 0) {
            return 0;
        }
        if (typeof callback === "undefined") {
            callback = false;
        }
        var total = 0;
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i][key] === value) {
                total++;
                if (callback) {
                    args[0] = this.children[i];
                    callback.apply(callbackContext, args);
                }
                if (returnType === Phaser.Group.RETURN_CHILD) {
                    return this.children[i];
                }
            }
        }
        if (returnType === Phaser.Group.RETURN_TOTAL) {
            return total;
        } else if (returnType === Phaser.Group.RETURN_CHILD) {
            return null;
        }
    };
    Phaser.Group.prototype.getFirstExists = function(state) {
        if (typeof state !== "boolean") {
            state = true;
        }
        return this.iterate("exists", state, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getFirstAlive = function() {
        return this.iterate("alive", true, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getFirstDead = function() {
        return this.iterate("alive", false, Phaser.Group.RETURN_CHILD);
    };
    Phaser.Group.prototype.getTop = function() {
        if (this.children.length > 0) {
            return this.children[this.children.length - 1];
        }
    };
    Phaser.Group.prototype.getBottom = function() {
        if (this.children.length > 0) {
            return this.children[0];
        }
    };
    Phaser.Group.prototype.countLiving = function() {
        return this.iterate("alive", true, Phaser.Group.RETURN_TOTAL);
    };
    Phaser.Group.prototype.countDead = function() {
        return this.iterate("alive", false, Phaser.Group.RETURN_TOTAL);
    };
    Phaser.Group.prototype.getRandom = function(startIndex, length) {
        if (this.children.length === 0) {
            return null;
        }
        startIndex = startIndex || 0;
        length = length || this.children.length;
        return this.game.math.getRandom(this.children, startIndex, length);
    };
    Phaser.Group.prototype.remove = function(child, destroy, silent) {
        if (typeof destroy === "undefined") {
            destroy = false;
        }
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (this.children.length === 0 || this.children.indexOf(child) === -1) {
            return false;
        }
        if (!silent && child.events && !child.destroyPhase) {
            child.events.onRemovedFromGroup.dispatch(child, this);
        }
        var removed = this.removeChild(child);
        this.updateZ();
        if (this.cursor === child) {
            this.next();
        }
        if (destroy && removed) {
            removed.destroy(true);
        }
        return true;
    };
    Phaser.Group.prototype.removeAll = function(destroy, silent) {
        if (typeof destroy === "undefined") {
            destroy = false;
        }
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (this.children.length === 0) {
            return;
        }
        do {
            if (!silent && this.children[0].events) {
                this.children[0].events.onRemovedFromGroup.dispatch(this.children[0], this);
            }
            var removed = this.removeChild(this.children[0]);
            if (destroy && removed) {
                removed.destroy(true);
            }
        } while (this.children.length > 0);
        this.cursor = null;
    };
    Phaser.Group.prototype.removeBetween = function(startIndex, endIndex, destroy, silent) {
        if (typeof endIndex === "undefined") {
            endIndex = this.children.length - 1;
        }
        if (typeof destroy === "undefined") {
            destroy = false;
        }
        if (typeof silent === "undefined") {
            silent = false;
        }
        if (this.children.length === 0) {
            return;
        }
        if (startIndex > endIndex || startIndex < 0 || endIndex > this.children.length) {
            return false;
        }
        var i = endIndex;
        while (i >= startIndex) {
            if (!silent && this.children[i].events) {
                this.children[i].events.onRemovedFromGroup.dispatch(this.children[i], this);
            }
            var removed = this.removeChild(this.children[i]);
            if (destroy && removed) {
                removed.destroy(true);
            }
            if (this.cursor === this.children[i]) {
                this.cursor = null;
            }
            i--;
        }
        this.updateZ();
    };
    Phaser.Group.prototype.destroy = function(destroyChildren, soft) {
        if (this.game === null) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        if (typeof soft === "undefined") {
            soft = false;
        }
        this.onDestroy.dispatch(this, destroyChildren, soft);
        this.removeAll(destroyChildren);
        this.cursor = null;
        this.filters = null;
        if (!soft) {
            if (this.parent) {
                this.parent.removeChild(this);
            }
            this.game = null;
            this.exists = false;
        }
    };
    Object.defineProperty(Phaser.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", true, Phaser.Group.RETURN_TOTAL);
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "length", {
        get: function() {
            return this.children.length;
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.Group.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Phaser.World = function(game) {
        Phaser.Group.call(this, game, null, "__world", false);
        this.bounds = new Phaser.Rectangle(0, 0, game.width, game.height);
        this.camera = null;
        this._definedSize = false;
        this._width = game.width;
        this._height = game.height;
    };
    Phaser.World.prototype = Object.create(Phaser.Group.prototype);
    Phaser.World.prototype.constructor = Phaser.World;
    Phaser.World.prototype.boot = function() {
        this.camera = new Phaser.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
        this.camera.displayObject = this;
        this.camera.scale = this.scale;
        this.game.camera = this.camera;
        this.game.stage.addChild(this);
    };
    Phaser.World.prototype.setBounds = function(x, y, width, height) {
        this._definedSize = true;
        this._width = width;
        this._height = height;
        this.bounds.setTo(x, y, width, height);
        if (this.camera.bounds) {
            this.camera.bounds.setTo(x, y, Math.max(width, this.game.width), Math.max(height, this.game.height));
        }
        this.game.physics.setBoundsToWorld();
    };
    Phaser.World.prototype.resize = function(width, height) {
        if (this._definedSize) {
            if (width < this._width) {
                width = this._width;
            }
            if (height < this._height) {
                height = this._height;
            }
        }
        this.bounds.width = width;
        this.bounds.height = height;
        this.game.camera.setBoundsToWorld();
        this.game.physics.setBoundsToWorld();
    };
    Phaser.World.prototype.shutdown = function() {
        this.destroy(true, true);
    };
    Phaser.World.prototype.wrap = function(sprite, padding, useBounds, horizontal, vertical) {
        if (typeof padding === "undefined") {
            padding = 0;
        }
        if (typeof useBounds === "undefined") {
            useBounds = false;
        }
        if (typeof horizontal === "undefined") {
            horizontal = true;
        }
        if (typeof vertical === "undefined") {
            vertical = true;
        }
        if (!useBounds) {
            if (horizontal && sprite.x + padding < this.bounds.x) {
                sprite.x = this.bounds.right + padding;
            } else if (horizontal && sprite.x - padding > this.bounds.right) {
                sprite.x = this.bounds.left - padding;
            }
            if (vertical && sprite.y + padding < this.bounds.top) {
                sprite.y = this.bounds.bottom + padding;
            } else if (vertical && sprite.y - padding > this.bounds.bottom) {
                sprite.y = this.bounds.top - padding;
            }
        } else {
            sprite.getBounds();
            if (horizontal) {
                if (sprite.x + sprite._currentBounds.width < this.bounds.x) {
                    sprite.x = this.bounds.right;
                } else if (sprite.x > this.bounds.right) {
                    sprite.x = this.bounds.left;
                }
            }
            if (vertical) {
                if (sprite.y + sprite._currentBounds.height < this.bounds.top) {
                    sprite.y = this.bounds.bottom;
                } else if (sprite.y > this.bounds.bottom) {
                    sprite.y = this.bounds.top;
                }
            }
        }
    };
    Object.defineProperty(Phaser.World.prototype, "width", {
        get: function() {
            return this.bounds.width;
        },
        set: function(value) {
            if (value < this.game.width) {
                value = this.game.width;
            }
            this.bounds.width = value;
            this._width = value;
            this._definedSize = true;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "height", {
        get: function() {
            return this.bounds.height;
        },
        set: function(value) {
            if (value < this.game.height) {
                value = this.game.height;
            }
            this.bounds.height = value;
            this._height = value;
            this._definedSize = true;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight;
        }
    });
    Object.defineProperty(Phaser.World.prototype, "randomX", {
        get: function() {
            if (this.bounds.x < 0) {
                return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x));
            } else {
                return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width);
            }
        }
    });
    Object.defineProperty(Phaser.World.prototype, "randomY", {
        get: function() {
            if (this.bounds.y < 0) {
                return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y));
            } else {
                return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height);
            }
        }
    });
    Phaser.FlexGrid = function(manager, width, height) {
        this.game = manager.game;
        this.manager = manager;
        this.width = width;
        this.height = height;
        this.boundsFluid = new Phaser.Rectangle(0, 0, width, height);
        this.boundsFull = new Phaser.Rectangle(0, 0, width, height);
        this.boundsNone = new Phaser.Rectangle(0, 0, width, height);
        this.positionFluid = new Phaser.Point(0, 0);
        this.positionFull = new Phaser.Point(0, 0);
        this.positionNone = new Phaser.Point(0, 0);
        this.scaleFluid = new Phaser.Point(1, 1);
        this.scaleFluidInversed = new Phaser.Point(1, 1);
        this.scaleFull = new Phaser.Point(1, 1);
        this.scaleNone = new Phaser.Point(1, 1);
        this.ratioH = width / height;
        this.ratioV = height / width;
        this.multiplier = 0;
        this.layers = [];
    };
    Phaser.FlexGrid.prototype = {
        setSize: function(width, height) {
            this.width = width;
            this.height = height;
            this.ratioH = width / height;
            this.ratioV = height / width;
            this.scaleNone = new Phaser.Point(1, 1);
            this.boundsNone.width = this.width;
            this.boundsNone.height = this.height;
            this.refresh();
        },
        createFluidLayer: function(children, addToWorld) {
            if (typeof addToWorld === "undefined") {
                addToWorld = true;
            }
            var layer = new Phaser.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
            if (addToWorld) {
                this.game.world.add(layer);
            }
            this.layers.push(layer);
            if (typeof children !== "undefined" && typeof children !== null) {
                layer.addMultiple(children);
            }
            return layer;
        },
        createFullLayer: function(children) {
            var layer = new Phaser.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
            this.game.world.add(layer);
            this.layers.push(layer);
            if (typeof children !== "undefined") {
                layer.addMultiple(children);
            }
            return layer;
        },
        createFixedLayer: function(children) {
            var layer = new Phaser.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
            this.game.world.add(layer);
            this.layers.push(layer);
            if (typeof children !== "undefined") {
                layer.addMultiple(children);
            }
            return layer;
        },
        reset: function() {
            var i = this.layers.length;
            while (i--) {
                if (!this.layers[i].persist) {
                    this.layers[i].position = null;
                    this.layers[i].scale = null;
                    this.layers.slice(i, 1);
                }
            }
        },
        onResize: function(width, height) {
            this.refresh(width, height);
        },
        refresh: function() {
            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width);
            this.boundsFluid.width = Math.round(this.width * this.multiplier);
            this.boundsFluid.height = Math.round(this.height * this.multiplier);
            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height);
            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height);
            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height);
            this.boundsFull.width = this.manager.width * this.scaleFluidInversed.x;
            this.boundsFull.height = this.manager.height * this.scaleFluidInversed.y;
            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y);
            this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
        },
        debug: function() {
            this.game.debug.text(this.boundsFull.width + " x " + this.boundsFull.height, this.boundsFull.x + 4, this.boundsFull.y + 16);
            this.game.debug.geom(this.boundsFull, "rgba(0,0,255,0.9", false);
            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16);
            this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", false);
            this.game.debug.text(this.boundsNone.width + " x " + this.boundsNone.height, this.boundsNone.x + 4, this.boundsNone.y + 16);
            this.game.debug.geom(this.boundsNone, "rgba(0,255,0,0.9", false);
        }
    };
    Phaser.FlexGrid.prototype.constructor = Phaser.FlexGrid;
    Phaser.FlexLayer = function(manager, position, bounds, scale) {
        Phaser.Group.call(this, manager.game, null, "__flexLayer" + manager.game.rnd.uuid(), false);
        this.manager = manager.manager;
        this.grid = manager;
        this.persist = false;
        this.position = position;
        this.bounds = bounds;
        this.scale = scale;
        this.topLeft = bounds.topLeft;
        this.topMiddle = new Phaser.Point(bounds.halfWidth, 0);
        this.topRight = bounds.topRight;
        this.bottomLeft = bounds.bottomLeft;
        this.bottomMiddle = new Phaser.Point(bounds.halfWidth, bounds.bottom);
        this.bottomRight = bounds.bottomRight;
    };
    Phaser.FlexLayer.prototype = Object.create(Phaser.Group.prototype);
    Phaser.FlexLayer.prototype.constructor = Phaser.FlexLayer;
    Phaser.FlexLayer.prototype.resize = function() {};
    Phaser.FlexLayer.prototype.debug = function() {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16);
        this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", false);
        this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9");
        this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9");
        this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
    };
    Phaser.ScaleManager = function(game, width, height) {
        this.game = game;
        this.grid = null;
        this.width = 0;
        this.height = 0;
        this.minWidth = null;
        this.maxWidth = null;
        this.minHeight = null;
        this.maxHeight = null;
        this.offset = new Phaser.Point();
        this.forceLandscape = false;
        this.forcePortrait = false;
        this.incorrectOrientation = false;
        this.pageAlignHorizontally = false;
        this.pageAlignVertically = false;
        this.maxIterations = 5;
        this.enterLandscape = new Phaser.Signal();
        this.enterPortrait = new Phaser.Signal();
        this.enterIncorrectOrientation = new Phaser.Signal();
        this.leaveIncorrectOrientation = new Phaser.Signal();
        this.fullScreenTarget = null;
        this.enterFullScreen = new Phaser.Signal();
        this.leaveFullScreen = new Phaser.Signal();
        this.orientation = 0;
        if (window["orientation"]) {
            this.orientation = window["orientation"];
        } else {
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90;
            }
        }
        this.scaleFactor = new Phaser.Point(1, 1);
        this.scaleFactorInversed = new Phaser.Point(1, 1);
        this.margin = new Phaser.Point(0, 0);
        this.bounds = new Phaser.Rectangle();
        this.aspectRatio = 0;
        this.sourceAspectRatio = 0;
        this.event = null;
        this.fullScreenScaleMode = Phaser.ScaleManager.NO_SCALE;
        this.parentIsWindow = false;
        this.parentNode = null;
        this.parentScaleFactor = new Phaser.Point(1, 1);
        this.trackParentInterval = 2e3;
        this.onResize = null;
        this.onResizeContext = null;
        this._scaleMode = Phaser.ScaleManager.NO_SCALE;
        this._width = 0;
        this._height = 0;
        this._check = null;
        this._nextParentCheck = 0;
        this._parentBounds = null;
        if (game.config) {
            this.parseConfig(game.config);
        }
        this.setupScale(width, height);
    };
    Phaser.ScaleManager.EXACT_FIT = 0;
    Phaser.ScaleManager.NO_SCALE = 1;
    Phaser.ScaleManager.SHOW_ALL = 2;
    Phaser.ScaleManager.RESIZE = 3;
    Phaser.ScaleManager.prototype = {
        parseConfig: function(config) {
            if (config["scaleMode"]) {
                this.scaleMode = config["scaleMode"];
            }
            if (config["fullScreenScaleMode"]) {
                this.fullScreenScaleMode = config["fullScreenScaleMode"];
            }
            if (config["fullScreenTarget"]) {
                this.fullScreenTarget = config["fullScreenTarget"];
            }
        },
        setupScale: function(width, height) {
            var target;
            var rect = new Phaser.Rectangle();
            if (this.game.parent !== "") {
                if (typeof this.game.parent === "string") {
                    target = document.getElementById(this.game.parent);
                } else if (typeof this.game.parent === "object" && this.game.parent.nodeType === 1) {
                    target = this.game.parent;
                }
            }
            if (!target) {
                this.parentNode = null;
                this.parentIsWindow = true;
                rect.width = window.innerWidth;
                rect.height = window.innerHeight;
            } else {
                this.parentNode = target;
                this.parentIsWindow = false;
                this._parentBounds = this.parentNode.getBoundingClientRect();
                rect.width = this._parentBounds.width;
                rect.height = this._parentBounds.height;
                this.offset.set(this._parentBounds.left, this._parentBounds.top);
            }
            var newWidth = 0;
            var newHeight = 0;
            if (typeof width === "number") {
                newWidth = width;
            } else {
                this.parentScaleFactor.x = parseInt(width, 10) / 100;
                newWidth = rect.width * this.parentScaleFactor.x;
            }
            if (typeof height === "number") {
                newHeight = height;
            } else {
                this.parentScaleFactor.y = parseInt(height, 10) / 100;
                newHeight = rect.height * this.parentScaleFactor.y;
            }
            this.grid = new Phaser.FlexGrid(this, newWidth, newHeight);
            this.updateDimensions(newWidth, newHeight, false);
        },
        boot: function() {
            this.fullScreenTarget = this.game.canvas;
            var _this = this;
            this._checkOrientation = function(event) {
                return _this.checkOrientation(event);
            };
            this._checkResize = function(event) {
                return _this.checkResize(event);
            };
            this._fullScreenChange = function(event) {
                return _this.fullScreenChange(event);
            };
            window.addEventListener("orientationchange", this._checkOrientation, false);
            window.addEventListener("resize", this._checkResize, false);
            if (!this.game.device.cocoonJS) {
                document.addEventListener("webkitfullscreenchange", this._fullScreenChange, false);
                document.addEventListener("mozfullscreenchange", this._fullScreenChange, false);
                document.addEventListener("fullscreenchange", this._fullScreenChange, false);
            }
            this.updateDimensions(this.width, this.height, true);
            Phaser.Canvas.getOffset(this.game.canvas, this.offset);
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
        },
        setResizeCallback: function(callback, context) {
            this.onResize = callback;
            this.onResizeContext = context;
        },
        setMinMax: function(minWidth, minHeight, maxWidth, maxHeight) {
            this.minWidth = minWidth;
            this.minHeight = minHeight;
            if (typeof maxWidth !== "undefined") {
                this.maxWidth = maxWidth;
            }
            if (typeof maxHeight !== "undefined") {
                this.maxHeight = maxHeight;
            }
        },
        preUpdate: function() {
            if (this.game.time.now < this._nextParentCheck) {
                return;
            }
            if (!this.parentIsWindow) {
                Phaser.Canvas.getOffset(this.game.canvas, this.offset);
                if (this._scaleMode === Phaser.ScaleManager.RESIZE) {
                    this._parentBounds = this.parentNode.getBoundingClientRect();
                    if (this._parentBounds.width !== this.width || this._parentBounds.height !== this.height) {
                        this.updateDimensions(this._parentBounds.width, this._parentBounds.height, true);
                    }
                }
            }
            this._nextParentCheck = this.game.time.now + this.trackParentInterval;
        },
        updateDimensions: function(width, height, resize) {
            this.width = width * this.parentScaleFactor.x;
            this.height = height * this.parentScaleFactor.y;
            this.game.width = this.width;
            this.game.height = this.height;
            this.sourceAspectRatio = this.width / this.height;
            this.bounds.width = this.width;
            this.bounds.height = this.height;
            if (resize) {
                this.game.renderer.resize(this.width, this.height);
                this.game.camera.setSize(this.width, this.height);
                this.game.world.resize(this.width, this.height);
            }
            this.grid.onResize(width, height);
            if (this.onResize) {
                this.onResize.call(this.onResizeContext, this.width, this.height);
            }
            this.game.state.resize(width, height);
        },
        forceOrientation: function(forceLandscape, forcePortrait) {
            if (typeof forcePortrait === "undefined") {
                forcePortrait = false;
            }
            this.forceLandscape = forceLandscape;
            this.forcePortrait = forcePortrait;
        },
        checkOrientationState: function() {
            if (this.incorrectOrientation) {
                if (this.forceLandscape && window.innerWidth > window.innerHeight || this.forcePortrait && window.innerHeight > window.innerWidth) {
                    this.incorrectOrientation = false;
                    this.leaveIncorrectOrientation.dispatch();
                    if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE) {
                        this.refresh();
                    }
                }
            } else {
                if (this.forceLandscape && window.innerWidth < window.innerHeight || this.forcePortrait && window.innerHeight < window.innerWidth) {
                    this.incorrectOrientation = true;
                    this.enterIncorrectOrientation.dispatch();
                    if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE) {
                        this.refresh();
                    }
                }
            }
        },
        checkOrientation: function(event) {
            this.event = event;
            this.orientation = window["orientation"];
            if (this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false);
            } else {
                this.enterPortrait.dispatch(this.orientation, false, true);
            }
            if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE) {
                this.refresh();
            }
        },
        checkResize: function(event) {
            this.event = event;
            var wasLandscape = this.isLandscape;
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90;
            } else {
                this.orientation = 0;
            }
            if (wasLandscape && this.isPortrait) {
                this.enterPortrait.dispatch(this.orientation, false, true);
                if (this.forceLandscape) {
                    this.enterIncorrectOrientation.dispatch();
                } else if (this.forcePortrait) {
                    this.leaveIncorrectOrientation.dispatch();
                }
            } else if (!wasLandscape && this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false);
                if (this.forceLandscape) {
                    this.leaveIncorrectOrientation.dispatch();
                } else if (this.forcePortrait) {
                    this.enterIncorrectOrientation.dispatch();
                }
            }
            if (this._scaleMode === Phaser.ScaleManager.RESIZE && this.parentIsWindow) {
                this.updateDimensions(window.innerWidth, window.innerHeight, true);
            } else if (this._scaleMode === Phaser.ScaleManager.EXACT_FIT || this._scaleMode === Phaser.ScaleManager.SHOW_ALL) {
                this.refresh();
                this.checkOrientationState();
                if (this.onResize) {
                    this.onResize.call(this.onResizeContext, this.width, this.height);
                }
            }
        },
        refresh: function() {
            if (this.scaleMode === Phaser.ScaleManager.RESIZE) {
                return;
            }
            if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop) {
                if (this.game.device.android && !this.game.device.chrome) {
                    window.scrollTo(0, 1);
                } else {
                    window.scrollTo(0, 0);
                }
            }
            if (this._check === null && this.maxIterations > 0) {
                this._iterations = this.maxIterations;
                var _this = this;
                this._check = window.setInterval(function() {
                    return _this.setScreenSize();
                }, 10);
                this.setScreenSize();
            }
        },
        setScreenSize: function(force) {
            if (this.scaleMode === Phaser.ScaleManager.RESIZE) {
                return;
            }
            if (typeof force === "undefined") {
                force = false;
            }
            if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop) {
                if (this.game.device.android && !this.game.device.chrome) {
                    window.scrollTo(0, 1);
                } else {
                    window.scrollTo(0, 0);
                }
            }
            this._iterations--;
            if (force || this._iterations < 0) {
                document.documentElement["style"].minHeight = window.innerHeight + "px";
                if (this.incorrectOrientation) {
                    this.setMaximum();
                } else if (!this.isFullScreen) {
                    if (this.scaleMode === Phaser.ScaleManager.EXACT_FIT) {
                        this.setExactFit();
                    } else if (this.scaleMode === Phaser.ScaleManager.SHOW_ALL) {
                        this.setShowAll();
                    }
                } else {
                    if (this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT) {
                        this.setExactFit();
                    } else if (this.fullScreenScaleMode === Phaser.ScaleManager.SHOW_ALL) {
                        this.setShowAll();
                    }
                }
                this.setSize();
                clearInterval(this._check);
                this._check = null;
            }
        },
        setSize: function() {
            if (!this.incorrectOrientation) {
                if (this.maxWidth && this.width > this.maxWidth) {
                    this.width = this.maxWidth;
                }
                if (this.maxHeight && this.height > this.maxHeight) {
                    this.height = this.maxHeight;
                }
                if (this.minWidth && this.width < this.minWidth) {
                    this.width = this.minWidth;
                }
                if (this.minHeight && this.height < this.minHeight) {
                    this.height = this.minHeight;
                }
            }
            this.game.canvas.style.width = this.width + "px";
            this.game.canvas.style.height = this.height + "px";
            this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
            if (this.pageAlignHorizontally) {
                if (this.width < window.innerWidth && !this.incorrectOrientation) {
                    this.margin.x = Math.round((window.innerWidth - this.width) / 2);
                    this.game.canvas.style.marginLeft = this.margin.x + "px";
                } else {
                    this.margin.x = 0;
                    this.game.canvas.style.marginLeft = "0px";
                }
            }
            if (this.pageAlignVertically) {
                if (this.height < window.innerHeight && !this.incorrectOrientation) {
                    this.margin.y = Math.round((window.innerHeight - this.height) / 2);
                    this.game.canvas.style.marginTop = this.margin.y + "px";
                } else {
                    this.margin.y = 0;
                    this.game.canvas.style.marginTop = "0px";
                }
            }
            Phaser.Canvas.getOffset(this.game.canvas, this.offset);
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
            this.aspectRatio = this.width / this.height;
            this.scaleFactor.x = this.game.width / this.width;
            this.scaleFactor.y = this.game.height / this.height;
            this.scaleFactorInversed.x = this.width / this.game.width;
            this.scaleFactorInversed.y = this.height / this.game.height;
            this.checkOrientationState();
        },
        reset: function(clearWorld) {
            if (clearWorld) {
                this.grid.reset();
            }
        },
        setMaximum: function() {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
        },
        setShowAll: function() {
            var multiplier = Math.min(window.innerHeight / this.game.height, window.innerWidth / this.game.width);
            this.width = Math.round(this.game.width * multiplier);
            this.height = Math.round(this.game.height * multiplier);
        },
        setExactFit: function() {
            var availableWidth = window.innerWidth;
            var availableHeight = window.innerHeight;
            if (this.maxWidth && availableWidth > this.maxWidth) {
                this.width = this.maxWidth;
            } else {
                this.width = availableWidth;
            }
            if (this.maxHeight && availableHeight > this.maxHeight) {
                this.height = this.maxHeight;
            } else {
                this.height = availableHeight;
            }
        },
        startFullScreen: function(antialias) {
            if (this.isFullScreen || !this.game.device.fullscreen) {
                return;
            }
            if (typeof antialias !== "undefined" && this.game.renderType === Phaser.CANVAS) {
                this.game.stage.smoothed = antialias;
            }
            this._width = this.width;
            this._height = this.height;
            if (this.game.device.fullscreenKeyboard) {
                this.fullScreenTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);
            } else {
                this.fullScreenTarget[this.game.device.requestFullscreen]();
            }
        },
        stopFullScreen: function() {
            document[this.game.device.cancelFullscreen]();
        },
        fullScreenChange: function(event) {
            this.event = event;
            if (this.isFullScreen) {
                if (this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT) {
                    this.fullScreenTarget.style["width"] = "100%";
                    this.fullScreenTarget.style["height"] = "100%";
                    this.width = window.outerWidth;
                    this.height = window.outerHeight;
                    this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                    this.aspectRatio = this.width / this.height;
                    this.scaleFactor.x = this.game.width / this.width;
                    this.scaleFactor.y = this.game.height / this.height;
                    this.checkResize();
                } else if (this.fullScreenScaleMode === Phaser.ScaleManager.SHOW_ALL) {
                    this.setShowAll();
                    this.refresh();
                }
                this.enterFullScreen.dispatch(this.width, this.height);
            } else {
                this.fullScreenTarget.style["width"] = this.game.width + "px";
                this.fullScreenTarget.style["height"] = this.game.height + "px";
                this.width = this._width;
                this.height = this._height;
                this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                this.aspectRatio = this.width / this.height;
                this.scaleFactor.x = this.game.width / this.width;
                this.scaleFactor.y = this.game.height / this.height;
                this.leaveFullScreen.dispatch(this.width, this.height);
            }
        },
        destroy: function() {
            window.removeEventListener("orientationchange", this._checkOrientation, false);
            window.removeEventListener("resize", this._checkResize, false);
            if (!this.game.device.cocoonJS) {
                document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, false);
                document.removeEventListener("mozfullscreenchange", this._fullScreenChange, false);
                document.removeEventListener("fullscreenchange", this._fullScreenChange, false);
            }
        }
    };
    Phaser.ScaleManager.prototype.constructor = Phaser.ScaleManager;
    Object.defineProperty(Phaser.ScaleManager.prototype, "scaleMode", {
        get: function() {
            return this._scaleMode;
        },
        set: function(value) {
            if (value !== this._scaleMode) {
                this._scaleMode = value;
            }
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return document["fullscreenElement"] || document["mozFullScreenElement"] || document["webkitFullscreenElement"];
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return this.orientation === 0 || this.orientation === 180;
        }
    });
    Object.defineProperty(Phaser.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return this.orientation === 90 || this.orientation === -90;
        }
    });
    Phaser.Game = function(width, height, renderer, parent, state, transparent, antialias, physicsConfig) {
        this.id = Phaser.GAMES.push(this) - 1;
        this.config = null;
        this.physicsConfig = physicsConfig;
        this.parent = "";
        this.width = 800;
        this.height = 600;
        this.transparent = false;
        this.antialias = true;
        this.preserveDrawingBuffer = false;
        this.renderer = null;
        this.renderType = Phaser.AUTO;
        this.state = null;
        this.isBooted = false;
        this.isRunning = false;
        this.raf = null;
        this.add = null;
        this.make = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.net = null;
        this.scale = null;
        this.sound = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.physics = null;
        this.rnd = null;
        this.device = null;
        this.camera = null;
        this.canvas = null;
        this.context = null;
        this.debug = null;
        this.particles = null;
        this.stepping = false;
        this.pendingStep = false;
        this.stepCount = 0;
        this.onPause = null;
        this.onResume = null;
        this.onBlur = null;
        this.onFocus = null;
        this._paused = false;
        this._codePaused = false;
        this._width = 800;
        this._height = 600;
        if (arguments.length === 1 && typeof arguments[0] === "object") {
            this.parseConfig(arguments[0]);
        } else {
            this.config = {
                enableDebug: true
            };
            if (typeof width !== "undefined") {
                this._width = width;
            }
            if (typeof height !== "undefined") {
                this._height = height;
            }
            if (typeof renderer !== "undefined") {
                this.renderType = renderer;
            }
            if (typeof parent !== "undefined") {
                this.parent = parent;
            }
            if (typeof transparent !== "undefined") {
                this.transparent = transparent;
            }
            if (typeof antialias !== "undefined") {
                this.antialias = antialias;
            }
            this.rnd = new Phaser.RandomDataGenerator([ (Date.now() * Math.random()).toString() ]);
            this.state = new Phaser.StateManager(this, state);
        }
        var _this = this;
        this._onBoot = function() {
            return _this.boot();
        };
        if (document.readyState === "complete" || document.readyState === "interactive") {
            window.setTimeout(this._onBoot, 0);
        } else if (typeof window.cordova !== "undefined") {
            document.addEventListener("deviceready", this._onBoot, false);
        } else {
            document.addEventListener("DOMContentLoaded", this._onBoot, false);
            window.addEventListener("load", this._onBoot, false);
        }
        return this;
    };
    Phaser.Game.prototype = {
        parseConfig: function(config) {
            this.config = config;
            if (typeof config["enableDebug"] === "undefined") {
                this.config.enableDebug = true;
            }
            if (config["width"]) {
                this._width = config["width"];
            }
            if (config["height"]) {
                this._height = config["height"];
            }
            if (config["renderer"]) {
                this.renderType = config["renderer"];
            }
            if (config["parent"]) {
                this.parent = config["parent"];
            }
            if (config["transparent"]) {
                this.transparent = config["transparent"];
            }
            if (config["antialias"]) {
                this.antialias = config["antialias"];
            }
            if (config["preserveDrawingBuffer"]) {
                this.preserveDrawingBuffer = config["preserveDrawingBuffer"];
            }
            if (config["physicsConfig"]) {
                this.physicsConfig = config["physicsConfig"];
            }
            var seed = [ (Date.now() * Math.random()).toString() ];
            if (config["seed"]) {
                seed = config["seed"];
            }
            this.rnd = new Phaser.RandomDataGenerator(seed);
            var state = null;
            if (config["state"]) {
                state = config["state"];
            }
            this.state = new Phaser.StateManager(this, state);
        },
        boot: function() {
            if (this.isBooted) {
                return;
            }
            if (!document.body) {
                window.setTimeout(this._onBoot, 20);
            } else {
                document.removeEventListener("DOMContentLoaded", this._onBoot);
                window.removeEventListener("load", this._onBoot);
                this.onPause = new Phaser.Signal();
                this.onResume = new Phaser.Signal();
                this.onBlur = new Phaser.Signal();
                this.onFocus = new Phaser.Signal();
                this.isBooted = true;
                this.device = new Phaser.Device(this);
                this.math = Phaser.Math;
                this.scale = new Phaser.ScaleManager(this, this._width, this._height);
                this.stage = new Phaser.Stage(this);
                this.setUpRenderer();
                this.device.checkFullScreenSupport();
                this.world = new Phaser.World(this);
                this.add = new Phaser.GameObjectFactory(this);
                this.make = new Phaser.GameObjectCreator(this);
                this.cache = new Phaser.Cache(this);
                this.load = new Phaser.Loader(this);
                this.time = new Phaser.Time(this);
                this.tweens = new Phaser.TweenManager(this);
                this.input = new Phaser.Input(this);
                this.sound = new Phaser.SoundManager(this);
                this.physics = new Phaser.Physics(this, this.physicsConfig);
                this.particles = new Phaser.Particles(this);
                this.plugins = new Phaser.PluginManager(this);
                this.net = new Phaser.Net(this);
                this.time.boot();
                this.stage.boot();
                this.world.boot();
                this.scale.boot();
                this.input.boot();
                this.sound.boot();
                this.state.boot();
                if (this.config["enableDebug"]) {
                    this.debug = new Phaser.Utils.Debug(this);
                    this.debug.boot();
                }
                this.showDebugHeader();
                this.isRunning = true;
                if (this.config && this.config["forceSetTimeOut"]) {
                    this.raf = new Phaser.RequestAnimationFrame(this, this.config["forceSetTimeOut"]);
                } else {
                    this.raf = new Phaser.RequestAnimationFrame(this, false);
                }
                this.raf.start();
            }
        },
        showDebugHeader: function() {
            var v = Phaser.VERSION;
            var r = "Canvas";
            var a = "HTML Audio";
            var c = 1;
            if (this.renderType === Phaser.WEBGL) {
                r = "WebGL";
                c++;
            } else if (this.renderType == Phaser.HEADLESS) {
                r = "Headless";
            }
            if (this.device.webAudio) {
                a = "WebAudio";
                c++;
            }
            if (this.device.chrome) {
                var args = [ "%c %c %c Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + "  %c %c " + " http://phaser.io  %c %c ♥%c♥%c♥ ", "background: #7a66a3", "background: #625186", "color: #ffffff; background: #43375b;", "background: #625186", "background: #ccb9f2", "background: #625186" ];
                for (var i = 0; i < 3; i++) {
                    if (i < c) {
                        args.push("color: #ff2424; background: #fff");
                    } else {
                        args.push("color: #959595; background: #fff");
                    }
                }
                console.log.apply(console, args);
            } else if (window["console"]) {
                console.log("Phaser v" + v + " | Pixi.js " + PIXI.VERSION + " | " + r + " | " + a + " | http://phaser.io");
            }
        },
        setUpRenderer: function() {
            if (this.device.trident) {
                this.renderType = Phaser.CANVAS;
            }
            if (this.config["canvasID"]) {
                this.canvas = Phaser.Canvas.create(this.width, this.height, this.config["canvasID"]);
            } else {
                this.canvas = Phaser.Canvas.create(this.width, this.height);
            }
            if (this.config["canvasStyle"]) {
                this.canvas.style = this.config["canvasStyle"];
            } else {
                this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%";
            }
            if (this.device.cocoonJS) {
                if (this.renderType === Phaser.CANVAS) {
                    this.canvas.screencanvas = true;
                } else {
                    this.canvas.screencanvas = false;
                }
            }
            if (this.renderType === Phaser.HEADLESS || this.renderType === Phaser.CANVAS || this.renderType === Phaser.AUTO && this.device.webGL === false) {
                if (this.device.canvas) {
                    if (this.renderType === Phaser.AUTO) {
                        this.renderType = Phaser.CANVAS;
                    }
                    this.renderer = new PIXI.CanvasRenderer(this.width, this.height, this.canvas, this.transparent);
                    this.context = this.renderer.context;
                } else {
                    throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.");
                }
            } else {
                this.renderType = Phaser.WEBGL;
                this.renderer = new PIXI.WebGLRenderer(this.width, this.height, this.canvas, this.transparent, this.antialias, this.preserveDrawingBuffer);
                this.context = null;
            }
            if (this.renderType !== Phaser.HEADLESS) {
                this.stage.smoothed = this.antialias;
                Phaser.Canvas.addToDOM(this.canvas, this.parent, false);
                Phaser.Canvas.setTouchAction(this.canvas);
            }
        },
        update: function(time) {
            this.time.update(time);
            if (!this._paused && !this.pendingStep) {
                if (this.stepping) {
                    this.pendingStep = true;
                }
                this.scale.preUpdate();
                if (this.config["enableDebug"]) {
                    this.debug.preUpdate();
                }
                this.physics.preUpdate();
                this.state.preUpdate();
                this.plugins.preUpdate();
                this.stage.preUpdate();
                this.state.update();
                this.stage.update();
                this.tweens.update();
                this.sound.update();
                this.input.update();
                this.physics.update();
                this.particles.update();
                this.plugins.update();
                this.stage.postUpdate();
                this.plugins.postUpdate();
            } else {
                this.state.pauseUpdate();
                if (this.config["enableDebug"]) {
                    this.debug.preUpdate();
                }
            }
            if (this.renderType != Phaser.HEADLESS) {
                this.state.preRender();
                this.renderer.render(this.stage);
                this.plugins.render();
                this.state.render();
                this.plugins.postRender();
                if (this.device.cocoonJS && this.renderType === Phaser.CANVAS && this.stage.currentRenderOrderID === 1) {
                    this.context.fillRect(0, 0, 0, 0);
                }
            }
        },
        enableStep: function() {
            this.stepping = true;
            this.pendingStep = false;
            this.stepCount = 0;
        },
        disableStep: function() {
            this.stepping = false;
            this.pendingStep = false;
        },
        step: function() {
            this.pendingStep = false;
            this.stepCount++;
        },
        destroy: function() {
            this.raf.stop();
            this.state.destroy();
            this.sound.destroy();
            this.scale.destroy();
            this.stage.destroy();
            this.input.destroy();
            this.physics.destroy();
            this.state = null;
            this.cache = null;
            this.input = null;
            this.load = null;
            this.sound = null;
            this.stage = null;
            this.time = null;
            this.world = null;
            this.isBooted = false;
            Phaser.Canvas.removeFromDOM(this.canvas);
        },
        gamePaused: function(event) {
            if (!this._paused) {
                this._paused = true;
                this.time.gamePaused();
                this.sound.setMute();
                this.onPause.dispatch(event);
            }
        },
        gameResumed: function(event) {
            if (this._paused && !this._codePaused) {
                this._paused = false;
                this.time.gameResumed();
                this.input.reset();
                this.sound.unsetMute();
                this.onResume.dispatch(event);
            }
        },
        focusLoss: function(event) {
            this.onBlur.dispatch(event);
            if (!this.stage.disableVisibilityChange) {
                this.gamePaused(event);
            }
        },
        focusGain: function(event) {
            this.onFocus.dispatch(event);
            if (!this.stage.disableVisibilityChange) {
                this.gameResumed(event);
            }
        }
    };
    Phaser.Game.prototype.constructor = Phaser.Game;
    Object.defineProperty(Phaser.Game.prototype, "paused", {
        get: function() {
            return this._paused;
        },
        set: function(value) {
            if (value === true) {
                if (this._paused === false) {
                    this._paused = true;
                    this.sound.setMute();
                    this.time.gamePaused();
                    this.onPause.dispatch(this);
                }
                this._codePaused = true;
            } else {
                if (this._paused) {
                    this._paused = false;
                    this.input.reset();
                    this.sound.unsetMute();
                    this.time.gameResumed();
                    this.onResume.dispatch(this);
                }
                this._codePaused = false;
            }
        }
    });
    Phaser.Input = function(game) {
        this.game = game;
        this.hitCanvas = null;
        this.hitContext = null;
        this.moveCallbacks = [];
        this.moveCallback = null;
        this.moveCallbackContext = this;
        this.pollRate = 0;
        this.disabled = false;
        this.multiInputOverride = Phaser.Input.MOUSE_TOUCH_COMBINE;
        this.position = null;
        this.speed = null;
        this.circle = null;
        this.scale = null;
        this.maxPointers = 10;
        this.currentPointers = 0;
        this.tapRate = 200;
        this.doubleTapRate = 300;
        this.holdRate = 2e3;
        this.justPressedRate = 200;
        this.justReleasedRate = 200;
        this.recordPointerHistory = false;
        this.recordRate = 100;
        this.recordLimit = 100;
        this.pointer1 = null;
        this.pointer2 = null;
        this.pointer3 = null;
        this.pointer4 = null;
        this.pointer5 = null;
        this.pointer6 = null;
        this.pointer7 = null;
        this.pointer8 = null;
        this.pointer9 = null;
        this.pointer10 = null;
        this.activePointer = null;
        this.mousePointer = null;
        this.mouse = null;
        this.keyboard = null;
        this.touch = null;
        this.mspointer = null;
        this.gamepad = null;
        this.resetLocked = false;
        this.onDown = null;
        this.onUp = null;
        this.onTap = null;
        this.onHold = null;
        this.minPriorityID = 0;
        this.interactiveItems = new Phaser.ArrayList();
        this._localPoint = new Phaser.Point();
        this._pollCounter = 0;
        this._oldPosition = null;
        this._x = 0;
        this._y = 0;
    };
    Phaser.Input.MOUSE_OVERRIDES_TOUCH = 0;
    Phaser.Input.TOUCH_OVERRIDES_MOUSE = 1;
    Phaser.Input.MOUSE_TOUCH_COMBINE = 2;
    Phaser.Input.prototype = {
        boot: function() {
            this.mousePointer = new Phaser.Pointer(this.game, 0);
            this.pointer1 = new Phaser.Pointer(this.game, 1);
            this.pointer2 = new Phaser.Pointer(this.game, 2);
            this.mouse = new Phaser.Mouse(this.game);
            this.keyboard = new Phaser.Keyboard(this.game);
            this.touch = new Phaser.Touch(this.game);
            this.mspointer = new Phaser.MSPointer(this.game);
            this.gamepad = new Phaser.Gamepad(this.game);
            this.onDown = new Phaser.Signal();
            this.onUp = new Phaser.Signal();
            this.onTap = new Phaser.Signal();
            this.onHold = new Phaser.Signal();
            this.scale = new Phaser.Point(1, 1);
            this.speed = new Phaser.Point();
            this.position = new Phaser.Point();
            this._oldPosition = new Phaser.Point();
            this.circle = new Phaser.Circle(0, 0, 44);
            this.activePointer = this.mousePointer;
            this.currentPointers = 0;
            this.hitCanvas = document.createElement("canvas");
            this.hitCanvas.width = 1;
            this.hitCanvas.height = 1;
            this.hitContext = this.hitCanvas.getContext("2d");
            this.mouse.start();
            this.keyboard.start();
            this.touch.start();
            this.mspointer.start();
            this.mousePointer.active = true;
        },
        destroy: function() {
            this.mouse.stop();
            this.keyboard.stop();
            this.touch.stop();
            this.mspointer.stop();
            this.gamepad.stop();
            this.moveCallbacks = [];
        },
        addMoveCallback: function(callback, context) {
            return this.moveCallbacks.push({
                callback: callback,
                context: context
            }) - 1;
        },
        deleteMoveCallback: function(index) {
            if (this.moveCallbacks[index]) {
                this.moveCallbacks.splice(index, 1);
            }
        },
        addPointer: function() {
            var next = 0;
            for (var i = 10; i > 0; i--) {
                if (this["pointer" + i] === null) {
                    next = i;
                }
            }
            if (next === 0) {
                console.warn("You can only have 10 Pointer objects");
                return null;
            } else {
                this["pointer" + next] = new Phaser.Pointer(this.game, next);
                return this["pointer" + next];
            }
        },
        update: function() {
            this.keyboard.update();
            if (this.pollRate > 0 && this._pollCounter < this.pollRate) {
                this._pollCounter++;
                return;
            }
            this.speed.x = this.position.x - this._oldPosition.x;
            this.speed.y = this.position.y - this._oldPosition.y;
            this._oldPosition.copyFrom(this.position);
            this.mousePointer.update();
            if (this.gamepad.active) {
                this.gamepad.update();
            }
            this.pointer1.update();
            this.pointer2.update();
            if (this.pointer3) {
                this.pointer3.update();
            }
            if (this.pointer4) {
                this.pointer4.update();
            }
            if (this.pointer5) {
                this.pointer5.update();
            }
            if (this.pointer6) {
                this.pointer6.update();
            }
            if (this.pointer7) {
                this.pointer7.update();
            }
            if (this.pointer8) {
                this.pointer8.update();
            }
            if (this.pointer9) {
                this.pointer9.update();
            }
            if (this.pointer10) {
                this.pointer10.update();
            }
            this._pollCounter = 0;
        },
        reset: function(hard) {
            if (!this.game.isBooted || this.resetLocked) {
                return;
            }
            if (typeof hard === "undefined") {
                hard = false;
            }
            this.keyboard.reset(hard);
            this.mousePointer.reset();
            this.gamepad.reset();
            for (var i = 1; i <= 10; i++) {
                if (this["pointer" + i]) {
                    this["pointer" + i].reset();
                }
            }
            this.currentPointers = 0;
            if (this.game.canvas.style.cursor !== "none") {
                this.game.canvas.style.cursor = "inherit";
            }
            if (hard) {
                this.onDown.dispose();
                this.onUp.dispose();
                this.onTap.dispose();
                this.onHold.dispose();
                this.onDown = new Phaser.Signal();
                this.onUp = new Phaser.Signal();
                this.onTap = new Phaser.Signal();
                this.onHold = new Phaser.Signal();
                this.moveCallbacks = [];
            }
            this._pollCounter = 0;
        },
        resetSpeed: function(x, y) {
            this._oldPosition.setTo(x, y);
            this.speed.setTo(0, 0);
        },
        startPointer: function(event) {
            if (this.maxPointers < 10 && this.totalActivePointers == this.maxPointers) {
                return null;
            }
            if (this.pointer1.active === false) {
                return this.pointer1.start(event);
            } else if (this.pointer2.active === false) {
                return this.pointer2.start(event);
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active === false) {
                        return this["pointer" + i].start(event);
                    }
                }
            }
            return null;
        },
        updatePointer: function(event) {
            if (this.pointer1.active && this.pointer1.identifier == event.identifier) {
                return this.pointer1.move(event);
            } else if (this.pointer2.active && this.pointer2.identifier == event.identifier) {
                return this.pointer2.move(event);
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active && this["pointer" + i].identifier == event.identifier) {
                        return this["pointer" + i].move(event);
                    }
                }
            }
            return null;
        },
        stopPointer: function(event) {
            if (this.pointer1.active && this.pointer1.identifier == event.identifier) {
                return this.pointer1.stop(event);
            } else if (this.pointer2.active && this.pointer2.identifier == event.identifier) {
                return this.pointer2.stop(event);
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active && this["pointer" + i].identifier == event.identifier) {
                        return this["pointer" + i].stop(event);
                    }
                }
            }
            return null;
        },
        getPointer: function(state) {
            state = state || false;
            if (this.pointer1.active == state) {
                return this.pointer1;
            } else if (this.pointer2.active == state) {
                return this.pointer2;
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].active == state) {
                        return this["pointer" + i];
                    }
                }
            }
            return null;
        },
        getPointerFromIdentifier: function(identifier) {
            if (this.pointer1.identifier === identifier) {
                return this.pointer1;
            } else if (this.pointer2.identifier === identifier) {
                return this.pointer2;
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].identifier === identifier) {
                        return this["pointer" + i];
                    }
                }
            }
            return null;
        },
        getPointerFromId: function(pointerId) {
            if (this.pointer1.pointerId === pointerId) {
                return this.pointer1;
            } else if (this.pointer2.pointerId === pointerId) {
                return this.pointer2;
            } else {
                for (var i = 3; i <= 10; i++) {
                    if (this["pointer" + i] && this["pointer" + i].pointerId === pointerId) {
                        return this["pointer" + i];
                    }
                }
            }
            return null;
        },
        getLocalPosition: function(displayObject, pointer, output) {
            if (typeof output === "undefined") {
                output = new Phaser.Point();
            }
            var wt = displayObject.worldTransform;
            var id = 1 / (wt.a * wt.d + wt.b * -wt.c);
            return output.setTo(wt.d * id * pointer.x + -wt.b * id * pointer.y + (wt.ty * wt.b - wt.tx * wt.d) * id, wt.a * id * pointer.y + -wt.c * id * pointer.x + (-wt.ty * wt.a + wt.tx * wt.c) * id);
        },
        hitTest: function(displayObject, pointer, localPoint) {
            if (!displayObject.worldVisible) {
                return false;
            }
            this.getLocalPosition(displayObject, pointer, this._localPoint);
            localPoint.copyFrom(this._localPoint);
            if (displayObject.hitArea && displayObject.hitArea.contains) {
                if (displayObject.hitArea.contains(this._localPoint.x, this._localPoint.y)) {
                    return true;
                }
                return false;
            } else if (displayObject instanceof Phaser.TileSprite) {
                var width = displayObject.width;
                var height = displayObject.height;
                var x1 = -width * displayObject.anchor.x;
                if (this._localPoint.x > x1 && this._localPoint.x < x1 + width) {
                    var y1 = -height * displayObject.anchor.y;
                    if (this._localPoint.y > y1 && this._localPoint.y < y1 + height) {
                        return true;
                    }
                }
            } else if (displayObject instanceof PIXI.Sprite) {
                var width = displayObject.texture.frame.width;
                var height = displayObject.texture.frame.height;
                var x1 = -width * displayObject.anchor.x;
                if (this._localPoint.x > x1 && this._localPoint.x < x1 + width) {
                    var y1 = -height * displayObject.anchor.y;
                    if (this._localPoint.y > y1 && this._localPoint.y < y1 + height) {
                        return true;
                    }
                }
            }
            for (var i = 0, len = displayObject.children.length; i < len; i++) {
                if (this.hitTest(displayObject.children[i], pointer, localPoint)) {
                    return true;
                }
            }
            return false;
        }
    };
    Phaser.Input.prototype.constructor = Phaser.Input;
    Object.defineProperty(Phaser.Input.prototype, "x", {
        get: function() {
            return this._x;
        },
        set: function(value) {
            this._x = Math.floor(value);
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "y", {
        get: function() {
            return this._y;
        },
        set: function(value) {
            this._y = Math.floor(value);
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "totalInactivePointers", {
        get: function() {
            return 10 - this.currentPointers;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "totalActivePointers", {
        get: function() {
            this.currentPointers = 0;
            for (var i = 1; i <= 10; i++) {
                if (this["pointer" + i] && this["pointer" + i].active) {
                    this.currentPointers++;
                }
            }
            return this.currentPointers;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x;
        }
    });
    Object.defineProperty(Phaser.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y;
        }
    });
    Phaser.Key = function(game, keycode) {
        this.game = game;
        this.enabled = true;
        this.event = null;
        this.isDown = false;
        this.isUp = true;
        this.altKey = false;
        this.ctrlKey = false;
        this.shiftKey = false;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = -2500;
        this.repeats = 0;
        this.keyCode = keycode;
        this.onDown = new Phaser.Signal();
        this.onHoldCallback = null;
        this.onHoldContext = null;
        this.onUp = new Phaser.Signal();
    };
    Phaser.Key.prototype = {
        update: function() {
            if (!this.enabled) {
                return;
            }
            if (this.isDown) {
                this.duration = this.game.time.now - this.timeDown;
                this.repeats++;
                if (this.onHoldCallback) {
                    this.onHoldCallback.call(this.onHoldContext, this);
                }
            }
        },
        processKeyDown: function(event) {
            if (!this.enabled) {
                return;
            }
            this.event = event;
            if (this.isDown) {
                return;
            }
            this.altKey = event.altKey;
            this.ctrlKey = event.ctrlKey;
            this.shiftKey = event.shiftKey;
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.now;
            this.duration = 0;
            this.repeats = 0;
            this.onDown.dispatch(this);
        },
        processKeyUp: function(event) {
            if (!this.enabled) {
                return;
            }
            this.event = event;
            if (this.isUp) {
                return;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.duration = this.game.time.now - this.timeDown;
            this.onUp.dispatch(this);
        },
        reset: function(hard) {
            if (typeof hard === "undefined") {
                hard = true;
            }
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.duration = 0;
            this.enabled = true;
            if (hard) {
                this.onDown.removeAll();
                this.onUp.removeAll();
                this.onHoldCallback = null;
                this.onHoldContext = null;
            }
        },
        justPressed: function(duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            return this.isDown && this.duration < duration;
        },
        justReleased: function(duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            return !this.isDown && this.game.time.now - this.timeUp < duration;
        }
    };
    Phaser.Key.prototype.constructor = Phaser.Key;
    Phaser.Keyboard = function(game) {
        this.game = game;
        this.disabled = false;
        this.event = null;
        this.pressEvent = null;
        this.callbackContext = this;
        this.onDownCallback = null;
        this.onPressCallback = null;
        this.onUpCallback = null;
        this._keys = [];
        this._capture = [];
        this._onKeyDown = null;
        this._onKeyPress = null;
        this._onKeyUp = null;
        this._i = 0;
        this._k = 0;
    };
    Phaser.Keyboard.prototype = {
        addCallbacks: function(context, onDown, onUp, onPress) {
            this.callbackContext = context;
            if (typeof onDown !== "undefined") {
                this.onDownCallback = onDown;
            }
            if (typeof onUp !== "undefined") {
                this.onUpCallback = onUp;
            }
            if (typeof onPress !== "undefined") {
                this.onPressCallback = onPress;
            }
        },
        addKey: function(keycode) {
            if (!this._keys[keycode]) {
                this._keys[keycode] = new Phaser.Key(this.game, keycode);
                this.addKeyCapture(keycode);
            }
            return this._keys[keycode];
        },
        removeKey: function(keycode) {
            if (this._keys[keycode]) {
                this._keys[keycode] = null;
                this.removeKeyCapture(keycode);
            }
        },
        createCursorKeys: function() {
            return {
                up: this.addKey(Phaser.Keyboard.UP),
                down: this.addKey(Phaser.Keyboard.DOWN),
                left: this.addKey(Phaser.Keyboard.LEFT),
                right: this.addKey(Phaser.Keyboard.RIGHT)
            };
        },
        start: function() {
            if (this.game.device.cocoonJS) {
                return;
            }
            if (this._onKeyDown !== null) {
                return;
            }
            var _this = this;
            this._onKeyDown = function(event) {
                return _this.processKeyDown(event);
            };
            this._onKeyUp = function(event) {
                return _this.processKeyUp(event);
            };
            this._onKeyPress = function(event) {
                return _this.processKeyPress(event);
            };
            window.addEventListener("keydown", this._onKeyDown, false);
            window.addEventListener("keyup", this._onKeyUp, false);
            window.addEventListener("keypress", this._onKeyPress, false);
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown);
            window.removeEventListener("keyup", this._onKeyUp);
            window.removeEventListener("keypress", this._onKeyPress);
            this._onKeyDown = null;
            this._onKeyUp = null;
            this._onKeyPress = null;
        },
        destroy: function() {
            this.stop();
            this.clearCaptures();
            this._keys.length = 0;
            this._i = 0;
        },
        addKeyCapture: function(keycode) {
            if (typeof keycode === "object") {
                for (var key in keycode) {
                    this._capture[keycode[key]] = true;
                }
            } else {
                this._capture[keycode] = true;
            }
        },
        removeKeyCapture: function(keycode) {
            delete this._capture[keycode];
        },
        clearCaptures: function() {
            this._capture = {};
        },
        update: function() {
            this._i = this._keys.length;
            while (this._i--) {
                if (this._keys[this._i]) {
                    this._keys[this._i].update();
                }
            }
        },
        processKeyDown: function(event) {
            this.event = event;
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this._capture[event.keyCode]) {
                event.preventDefault();
            }
            if (!this._keys[event.keyCode]) {
                this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);
            }
            this._keys[event.keyCode].processKeyDown(event);
            this._k = event.keyCode;
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, event);
            }
        },
        processKeyPress: function(event) {
            this.pressEvent = event;
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.onPressCallback) {
                this.onPressCallback.call(this.callbackContext, String.fromCharCode(event.charCode), event);
            }
        },
        processKeyUp: function(event) {
            this.event = event;
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this._capture[event.keyCode]) {
                event.preventDefault();
            }
            if (!this._keys[event.keyCode]) {
                this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);
            }
            this._keys[event.keyCode].processKeyUp(event);
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, event);
            }
        },
        reset: function(hard) {
            if (typeof hard === "undefined") {
                hard = true;
            }
            this.event = null;
            var i = this._keys.length;
            while (i--) {
                if (this._keys[i]) {
                    this._keys[i].reset(hard);
                }
            }
        },
        justPressed: function(keycode, duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            if (this._keys[keycode]) {
                return this._keys[keycode].justPressed(duration);
            } else {
                return false;
            }
        },
        justReleased: function(keycode, duration) {
            if (typeof duration === "undefined") {
                duration = 50;
            }
            if (this._keys[keycode]) {
                return this._keys[keycode].justReleased(duration);
            } else {
                return false;
            }
        },
        isDown: function(keycode) {
            if (this._keys[keycode]) {
                return this._keys[keycode].isDown;
            }
            return false;
        }
    };
    Object.defineProperty(Phaser.Keyboard.prototype, "lastChar", {
        get: function() {
            if (this.event.charCode === 32) {
                return "";
            } else {
                return String.fromCharCode(this.pressEvent.charCode);
            }
        }
    });
    Object.defineProperty(Phaser.Keyboard.prototype, "lastKey", {
        get: function() {
            return this._keys[this._k];
        }
    });
    Phaser.Keyboard.prototype.constructor = Phaser.Keyboard;
    Phaser.Keyboard.A = "A".charCodeAt(0);
    Phaser.Keyboard.B = "B".charCodeAt(0);
    Phaser.Keyboard.C = "C".charCodeAt(0);
    Phaser.Keyboard.D = "D".charCodeAt(0);
    Phaser.Keyboard.E = "E".charCodeAt(0);
    Phaser.Keyboard.F = "F".charCodeAt(0);
    Phaser.Keyboard.G = "G".charCodeAt(0);
    Phaser.Keyboard.H = "H".charCodeAt(0);
    Phaser.Keyboard.I = "I".charCodeAt(0);
    Phaser.Keyboard.J = "J".charCodeAt(0);
    Phaser.Keyboard.K = "K".charCodeAt(0);
    Phaser.Keyboard.L = "L".charCodeAt(0);
    Phaser.Keyboard.M = "M".charCodeAt(0);
    Phaser.Keyboard.N = "N".charCodeAt(0);
    Phaser.Keyboard.O = "O".charCodeAt(0);
    Phaser.Keyboard.P = "P".charCodeAt(0);
    Phaser.Keyboard.Q = "Q".charCodeAt(0);
    Phaser.Keyboard.R = "R".charCodeAt(0);
    Phaser.Keyboard.S = "S".charCodeAt(0);
    Phaser.Keyboard.T = "T".charCodeAt(0);
    Phaser.Keyboard.U = "U".charCodeAt(0);
    Phaser.Keyboard.V = "V".charCodeAt(0);
    Phaser.Keyboard.W = "W".charCodeAt(0);
    Phaser.Keyboard.X = "X".charCodeAt(0);
    Phaser.Keyboard.Y = "Y".charCodeAt(0);
    Phaser.Keyboard.Z = "Z".charCodeAt(0);
    Phaser.Keyboard.ZERO = "0".charCodeAt(0);
    Phaser.Keyboard.ONE = "1".charCodeAt(0);
    Phaser.Keyboard.TWO = "2".charCodeAt(0);
    Phaser.Keyboard.THREE = "3".charCodeAt(0);
    Phaser.Keyboard.FOUR = "4".charCodeAt(0);
    Phaser.Keyboard.FIVE = "5".charCodeAt(0);
    Phaser.Keyboard.SIX = "6".charCodeAt(0);
    Phaser.Keyboard.SEVEN = "7".charCodeAt(0);
    Phaser.Keyboard.EIGHT = "8".charCodeAt(0);
    Phaser.Keyboard.NINE = "9".charCodeAt(0);
    Phaser.Keyboard.NUMPAD_0 = 96;
    Phaser.Keyboard.NUMPAD_1 = 97;
    Phaser.Keyboard.NUMPAD_2 = 98;
    Phaser.Keyboard.NUMPAD_3 = 99;
    Phaser.Keyboard.NUMPAD_4 = 100;
    Phaser.Keyboard.NUMPAD_5 = 101;
    Phaser.Keyboard.NUMPAD_6 = 102;
    Phaser.Keyboard.NUMPAD_7 = 103;
    Phaser.Keyboard.NUMPAD_8 = 104;
    Phaser.Keyboard.NUMPAD_9 = 105;
    Phaser.Keyboard.NUMPAD_MULTIPLY = 106;
    Phaser.Keyboard.NUMPAD_ADD = 107;
    Phaser.Keyboard.NUMPAD_ENTER = 108;
    Phaser.Keyboard.NUMPAD_SUBTRACT = 109;
    Phaser.Keyboard.NUMPAD_DECIMAL = 110;
    Phaser.Keyboard.NUMPAD_DIVIDE = 111;
    Phaser.Keyboard.F1 = 112;
    Phaser.Keyboard.F2 = 113;
    Phaser.Keyboard.F3 = 114;
    Phaser.Keyboard.F4 = 115;
    Phaser.Keyboard.F5 = 116;
    Phaser.Keyboard.F6 = 117;
    Phaser.Keyboard.F7 = 118;
    Phaser.Keyboard.F8 = 119;
    Phaser.Keyboard.F9 = 120;
    Phaser.Keyboard.F10 = 121;
    Phaser.Keyboard.F11 = 122;
    Phaser.Keyboard.F12 = 123;
    Phaser.Keyboard.F13 = 124;
    Phaser.Keyboard.F14 = 125;
    Phaser.Keyboard.F15 = 126;
    Phaser.Keyboard.COLON = 186;
    Phaser.Keyboard.EQUALS = 187;
    Phaser.Keyboard.UNDERSCORE = 189;
    Phaser.Keyboard.QUESTION_MARK = 191;
    Phaser.Keyboard.TILDE = 192;
    Phaser.Keyboard.OPEN_BRACKET = 219;
    Phaser.Keyboard.BACKWARD_SLASH = 220;
    Phaser.Keyboard.CLOSED_BRACKET = 221;
    Phaser.Keyboard.QUOTES = 222;
    Phaser.Keyboard.BACKSPACE = 8;
    Phaser.Keyboard.TAB = 9;
    Phaser.Keyboard.CLEAR = 12;
    Phaser.Keyboard.ENTER = 13;
    Phaser.Keyboard.SHIFT = 16;
    Phaser.Keyboard.CONTROL = 17;
    Phaser.Keyboard.ALT = 18;
    Phaser.Keyboard.CAPS_LOCK = 20;
    Phaser.Keyboard.ESC = 27;
    Phaser.Keyboard.SPACEBAR = 32;
    Phaser.Keyboard.PAGE_UP = 33;
    Phaser.Keyboard.PAGE_DOWN = 34;
    Phaser.Keyboard.END = 35;
    Phaser.Keyboard.HOME = 36;
    Phaser.Keyboard.LEFT = 37;
    Phaser.Keyboard.UP = 38;
    Phaser.Keyboard.RIGHT = 39;
    Phaser.Keyboard.DOWN = 40;
    Phaser.Keyboard.INSERT = 45;
    Phaser.Keyboard.DELETE = 46;
    Phaser.Keyboard.HELP = 47;
    Phaser.Keyboard.NUM_LOCK = 144;
    Phaser.Mouse = function(game) {
        this.game = game;
        this.callbackContext = this.game;
        this.mouseDownCallback = null;
        this.mouseMoveCallback = null;
        this.mouseUpCallback = null;
        this.mouseOutCallback = null;
        this.mouseOverCallback = null;
        this.mouseWheelCallback = null;
        this.capture = false;
        this.button = -1;
        this.wheelDelta = 0;
        this.disabled = false;
        this.locked = false;
        this.stopOnGameOut = false;
        this.pointerLock = new Phaser.Signal();
        this.event = null;
        this._onMouseDown = null;
        this._onMouseMove = null;
        this._onMouseUp = null;
        this._onMouseOut = null;
        this._onMouseOver = null;
        this._onMouseWheel = null;
    };
    Phaser.Mouse.NO_BUTTON = -1;
    Phaser.Mouse.LEFT_BUTTON = 0;
    Phaser.Mouse.MIDDLE_BUTTON = 1;
    Phaser.Mouse.RIGHT_BUTTON = 2;
    Phaser.Mouse.WHEEL_UP = 1;
    Phaser.Mouse.WHEEL_DOWN = -1;
    Phaser.Mouse.prototype = {
        start: function() {
            if (this.game.device.android && this.game.device.chrome === false) {
                return;
            }
            if (this._onMouseDown !== null) {
                return;
            }
            var _this = this;
            this._onMouseDown = function(event) {
                return _this.onMouseDown(event);
            };
            this._onMouseMove = function(event) {
                return _this.onMouseMove(event);
            };
            this._onMouseUp = function(event) {
                return _this.onMouseUp(event);
            };
            this._onMouseUpGlobal = function(event) {
                return _this.onMouseUpGlobal(event);
            };
            this._onMouseOut = function(event) {
                return _this.onMouseOut(event);
            };
            this._onMouseOver = function(event) {
                return _this.onMouseOver(event);
            };
            this._onMouseWheel = function(event) {
                return _this.onMouseWheel(event);
            };
            this.game.canvas.addEventListener("mousedown", this._onMouseDown, true);
            this.game.canvas.addEventListener("mousemove", this._onMouseMove, true);
            this.game.canvas.addEventListener("mouseup", this._onMouseUp, true);
            if (!this.game.device.cocoonJS) {
                window.addEventListener("mouseup", this._onMouseUpGlobal, true);
                this.game.canvas.addEventListener("mouseover", this._onMouseOver, true);
                this.game.canvas.addEventListener("mouseout", this._onMouseOut, true);
                this.game.canvas.addEventListener("mousewheel", this._onMouseWheel, true);
                this.game.canvas.addEventListener("DOMMouseScroll", this._onMouseWheel, true);
            }
        },
        onMouseDown: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.button = event.button;
            if (this.mouseDownCallback) {
                this.mouseDownCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event["identifier"] = 0;
            this.game.input.mousePointer.start(event);
        },
        onMouseMove: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            if (this.mouseMoveCallback) {
                this.mouseMoveCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event["identifier"] = 0;
            this.game.input.mousePointer.move(event);
        },
        onMouseUp: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.button = Phaser.Mouse.NO_BUTTON;
            if (this.mouseUpCallback) {
                this.mouseUpCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event["identifier"] = 0;
            this.game.input.mousePointer.stop(event);
        },
        onMouseUpGlobal: function(event) {
            if (!this.game.input.mousePointer.withinGame) {
                this.button = Phaser.Mouse.NO_BUTTON;
                if (this.mouseUpCallback) {
                    this.mouseUpCallback.call(this.callbackContext, event);
                }
                event["identifier"] = 0;
                this.game.input.mousePointer.stop(event);
            }
        },
        onMouseOut: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.game.input.mousePointer.withinGame = false;
            if (this.mouseOutCallback) {
                this.mouseOutCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.stopOnGameOut) {
                event["identifier"] = 0;
                this.game.input.mousePointer.stop(event);
            }
        },
        onMouseWheel: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
            if (this.mouseWheelCallback) {
                this.mouseWheelCallback.call(this.callbackContext, event);
            }
        },
        onMouseOver: function(event) {
            this.event = event;
            if (this.capture) {
                event.preventDefault();
            }
            this.game.input.mousePointer.withinGame = true;
            if (this.mouseOverCallback) {
                this.mouseOverCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var element = this.game.canvas;
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();
                var _this = this;
                this._pointerLockChange = function(event) {
                    return _this.pointerLockChange(event);
                };
                document.addEventListener("pointerlockchange", this._pointerLockChange, true);
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, true);
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, true);
            }
        },
        pointerLockChange: function(event) {
            var element = this.game.canvas;
            if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                this.locked = true;
                this.pointerLock.dispatch(true, event);
            } else {
                this.locked = false;
                this.pointerLock.dispatch(false, event);
            }
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
            document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
        },
        stop: function() {
            this.game.canvas.removeEventListener("mousedown", this._onMouseDown, true);
            this.game.canvas.removeEventListener("mousemove", this._onMouseMove, true);
            this.game.canvas.removeEventListener("mouseup", this._onMouseUp, true);
            this.game.canvas.removeEventListener("mouseover", this._onMouseOver, true);
            this.game.canvas.removeEventListener("mouseout", this._onMouseOut, true);
            this.game.canvas.removeEventListener("mousewheel", this._onMouseWheel, true);
            this.game.canvas.removeEventListener("DOMMouseScroll", this._onMouseWheel, true);
            window.removeEventListener("mouseup", this._onMouseUpGlobal, true);
            document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
        }
    };
    Phaser.Mouse.prototype.constructor = Phaser.Mouse;
    Phaser.MSPointer = function(game) {
        this.game = game;
        this.callbackContext = this.game;
        this.disabled = false;
        this._onMSPointerDown = null;
        this._onMSPointerMove = null;
        this._onMSPointerUp = null;
    };
    Phaser.MSPointer.prototype = {
        start: function() {
            if (this._onMSPointerDown !== null) {
                return;
            }
            var _this = this;
            if (this.game.device.mspointer) {
                this._onMSPointerDown = function(event) {
                    return _this.onPointerDown(event);
                };
                this._onMSPointerMove = function(event) {
                    return _this.onPointerMove(event);
                };
                this._onMSPointerUp = function(event) {
                    return _this.onPointerUp(event);
                };
                this.game.canvas.addEventListener("MSPointerDown", this._onMSPointerDown, false);
                this.game.canvas.addEventListener("MSPointerMove", this._onMSPointerMove, false);
                this.game.canvas.addEventListener("MSPointerUp", this._onMSPointerUp, false);
                this.game.canvas.addEventListener("pointerDown", this._onMSPointerDown, false);
                this.game.canvas.addEventListener("pointerMove", this._onMSPointerMove, false);
                this.game.canvas.addEventListener("pointerUp", this._onMSPointerUp, false);
                this.game.canvas.style["-ms-content-zooming"] = "none";
                this.game.canvas.style["-ms-touch-action"] = "none";
            }
        },
        onPointerDown: function(event) {
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event.preventDefault();
            event.identifier = event.pointerId;
            this.game.input.startPointer(event);
        },
        onPointerMove: function(event) {
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event.preventDefault();
            event.identifier = event.pointerId;
            this.game.input.updatePointer(event);
        },
        onPointerUp: function(event) {
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            event.preventDefault();
            event.identifier = event.pointerId;
            this.game.input.stopPointer(event);
        },
        stop: function() {
            this.game.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("MSPointerMove", this._onMSPointerMove);
            this.game.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp);
            this.game.canvas.removeEventListener("pointerDown", this._onMSPointerDown);
            this.game.canvas.removeEventListener("pointerMove", this._onMSPointerMove);
            this.game.canvas.removeEventListener("pointerUp", this._onMSPointerUp);
        }
    };
    Phaser.MSPointer.prototype.constructor = Phaser.MSPointer;
    Phaser.Pointer = function(game, id) {
        this.game = game;
        this.id = id;
        this.type = Phaser.POINTER;
        this.exists = true;
        this.identifier = 0;
        this.pointerId = null;
        this.target = null;
        this.button = null;
        this._holdSent = false;
        this._history = [];
        this._nextDrop = 0;
        this._stateReset = false;
        this.withinGame = false;
        this.clientX = -1;
        this.clientY = -1;
        this.pageX = -1;
        this.pageY = -1;
        this.screenX = -1;
        this.screenY = -1;
        this.rawMovementX = 0;
        this.rawMovementY = 0;
        this.movementX = 0;
        this.movementY = 0;
        this.x = -1;
        this.y = -1;
        this.isMouse = false;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.timeUp = 0;
        this.previousTapTime = 0;
        this.totalTouches = 0;
        this.msSinceLastClick = Number.MAX_VALUE;
        this.targetObject = null;
        this.active = false;
        this.dirty = false;
        this.position = new Phaser.Point();
        this.positionDown = new Phaser.Point();
        this.positionUp = new Phaser.Point();
        this.circle = new Phaser.Circle(0, 0, 44);
        if (id === 0) {
            this.isMouse = true;
        }
    };
    Phaser.Pointer.prototype = {
        start: function(event) {
            if (event["pointerId"]) {
                this.pointerId = event.pointerId;
            }
            this.identifier = event.identifier;
            this.target = event.target;
            if (typeof event.button !== "undefined") {
                this.button = event.button;
            }
            this._history = [];
            this.active = true;
            this.withinGame = true;
            this.isDown = true;
            this.isUp = false;
            this.dirty = false;
            this.msSinceLastClick = this.game.time.now - this.timeDown;
            this.timeDown = this.game.time.now;
            this._holdSent = false;
            this.move(event, true);
            this.positionDown.setTo(this.x, this.y);
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.x, this.y);
                this.game.input.onDown.dispatch(this, event);
                this.game.input.resetSpeed(this.x, this.y);
            }
            this._stateReset = false;
            this.totalTouches++;
            if (!this.isMouse) {
                this.game.input.currentPointers++;
            }
            if (this.targetObject !== null) {
                this.targetObject._touchedHandler(this);
            }
            return this;
        },
        update: function() {
            if (this.active) {
                if (this.dirty) {
                    if (this.game.input.interactiveItems.total > 0) {
                        this.processInteractiveObjects(true);
                    }
                    this.dirty = false;
                }
                if (this._holdSent === false && this.duration >= this.game.input.holdRate) {
                    if (this.game.input.multiInputOverride == Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride == Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                        this.game.input.onHold.dispatch(this);
                    }
                    this._holdSent = true;
                }
                if (this.game.input.recordPointerHistory && this.game.time.now >= this._nextDrop) {
                    this._nextDrop = this.game.time.now + this.game.input.recordRate;
                    this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    });
                    if (this._history.length > this.game.input.recordLimit) {
                        this._history.shift();
                    }
                }
            }
        },
        move: function(event, fromClick) {
            if (this.game.input.pollLocked) {
                return;
            }
            if (typeof fromClick === "undefined") {
                fromClick = false;
            }
            if (typeof event.button !== "undefined") {
                this.button = event.button;
            }
            this.clientX = event.clientX;
            this.clientY = event.clientY;
            this.pageX = event.pageX;
            this.pageY = event.pageY;
            this.screenX = event.screenX;
            this.screenY = event.screenY;
            if (this.isMouse && this.game.input.mouse.locked && !fromClick) {
                this.rawMovementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                this.rawMovementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                this.movementX += this.rawMovementX;
                this.movementY += this.rawMovementY;
            }
            this.x = (this.pageX - this.game.scale.offset.x) * this.game.input.scale.x;
            this.y = (this.pageY - this.game.scale.offset.y) * this.game.input.scale.y;
            this.position.setTo(this.x, this.y);
            this.circle.x = this.x;
            this.circle.y = this.y;
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.activePointer = this;
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.game.input.x, this.game.input.y);
                this.game.input.circle.x = this.game.input.x;
                this.game.input.circle.y = this.game.input.y;
            }
            this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
            if (this.game.paused) {
                return this;
            }
            var i = this.game.input.moveCallbacks.length;
            while (i--) {
                this.game.input.moveCallbacks[i].callback.call(this.game.input.moveCallbacks[i].context, this, this.x, this.y, fromClick);
            }
            if (this.targetObject !== null && this.targetObject.isDragged === true) {
                if (this.targetObject.update(this) === false) {
                    this.targetObject = null;
                }
            } else if (this.game.input.interactiveItems.total > 0) {
                this.processInteractiveObjects(fromClick);
            }
            return this;
        },
        processInteractiveObjects: function(fromClick) {
            this.game.input.interactiveItems.setAll("checked", false);
            this._highestRenderOrderID = Number.MAX_SAFE_INTEGER;
            this._highestRenderObject = null;
            this._highestInputPriorityID = -1;
            var currentNode = this.game.input.interactiveItems.first;
            do {
                if (currentNode && currentNode.validForInput(this._highestInputPriorityID, this._highestRenderOrderID, false)) {
                    currentNode.checked = true;
                    if (fromClick && currentNode.checkPointerDown(this, true) || !fromClick && currentNode.checkPointerOver(this, true)) {
                        this._highestRenderOrderID = currentNode.sprite._cache[3];
                        this._highestInputPriorityID = currentNode.priorityID;
                        this._highestRenderObject = currentNode;
                    }
                }
                currentNode = this.game.input.interactiveItems.next;
            } while (currentNode !== null);
            var currentNode = this.game.input.interactiveItems.first;
            do {
                if (currentNode && !currentNode.checked && currentNode.validForInput(this._highestInputPriorityID, this._highestRenderOrderID, true)) {
                    if (fromClick && currentNode.checkPointerDown(this, false) || !fromClick && currentNode.checkPointerOver(this, false)) {
                        this._highestRenderOrderID = currentNode.sprite._cache[3];
                        this._highestInputPriorityID = currentNode.priorityID;
                        this._highestRenderObject = currentNode;
                    }
                }
                currentNode = this.game.input.interactiveItems.next;
            } while (currentNode !== null);
            if (this._highestRenderObject === null) {
                if (this.targetObject) {
                    this.targetObject._pointerOutHandler(this);
                    this.targetObject = null;
                }
            } else {
                if (this.targetObject === null) {
                    this.targetObject = this._highestRenderObject;
                    this._highestRenderObject._pointerOverHandler(this);
                } else {
                    if (this.targetObject === this._highestRenderObject) {
                        if (this._highestRenderObject.update(this) === false) {
                            this.targetObject = null;
                        }
                    } else {
                        this.targetObject._pointerOutHandler(this);
                        this.targetObject = this._highestRenderObject;
                        this.targetObject._pointerOverHandler(this);
                    }
                }
            }
            return this.targetObject !== null;
        },
        leave: function(event) {
            this.withinGame = false;
            this.move(event, false);
        },
        stop: function(event) {
            if (this._stateReset) {
                event.preventDefault();
                return;
            }
            this.timeUp = this.game.time.now;
            if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0) {
                this.game.input.onUp.dispatch(this, event);
                if (this.duration >= 0 && this.duration <= this.game.input.tapRate) {
                    if (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate) {
                        this.game.input.onTap.dispatch(this, true);
                    } else {
                        this.game.input.onTap.dispatch(this, false);
                    }
                    this.previousTapTime = this.timeUp;
                }
            }
            if (this.id > 0) {
                this.active = false;
            }
            this.withinGame = false;
            this.isDown = false;
            this.isUp = true;
            this.pointerId = null;
            this.identifier = null;
            this.positionUp.setTo(this.x, this.y);
            if (this.isMouse === false) {
                this.game.input.currentPointers--;
            }
            this.game.input.interactiveItems.callAll("_releasedHandler", this);
            this.targetObject = null;
            return this;
        },
        justPressed: function(duration) {
            duration = duration || this.game.input.justPressedRate;
            return this.isDown === true && this.timeDown + duration > this.game.time.now;
        },
        justReleased: function(duration) {
            duration = duration || this.game.input.justReleasedRate;
            return this.isUp === true && this.timeUp + duration > this.game.time.now;
        },
        reset: function() {
            if (this.isMouse === false) {
                this.active = false;
            }
            this.pointerId = null;
            this.identifier = null;
            this.dirty = false;
            this.isDown = false;
            this.isUp = true;
            this.totalTouches = 0;
            this._holdSent = false;
            this._history.length = 0;
            this._stateReset = true;
            if (this.targetObject) {
                this.targetObject._releasedHandler(this);
            }
            this.targetObject = null;
        },
        resetMovement: function() {
            this.movementX = 0;
            this.movementY = 0;
        }
    };
    Phaser.Pointer.prototype.constructor = Phaser.Pointer;
    Object.defineProperty(Phaser.Pointer.prototype, "duration", {
        get: function() {
            if (this.isUp) {
                return -1;
            }
            return this.game.time.now - this.timeDown;
        }
    });
    Object.defineProperty(Phaser.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x;
        }
    });
    Object.defineProperty(Phaser.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y;
        }
    });
    Phaser.Touch = function(game) {
        this.game = game;
        this.disabled = false;
        this.callbackContext = this.game;
        this.touchStartCallback = null;
        this.touchMoveCallback = null;
        this.touchEndCallback = null;
        this.touchEnterCallback = null;
        this.touchLeaveCallback = null;
        this.touchCancelCallback = null;
        this.preventDefault = true;
        this.event = null;
        this._onTouchStart = null;
        this._onTouchMove = null;
        this._onTouchEnd = null;
        this._onTouchEnter = null;
        this._onTouchLeave = null;
        this._onTouchCancel = null;
        this._onTouchMove = null;
    };
    Phaser.Touch.prototype = {
        start: function() {
            if (this._onTouchStart !== null) {
                return;
            }
            var _this = this;
            if (this.game.device.touch) {
                this._onTouchStart = function(event) {
                    return _this.onTouchStart(event);
                };
                this._onTouchMove = function(event) {
                    return _this.onTouchMove(event);
                };
                this._onTouchEnd = function(event) {
                    return _this.onTouchEnd(event);
                };
                this._onTouchEnter = function(event) {
                    return _this.onTouchEnter(event);
                };
                this._onTouchLeave = function(event) {
                    return _this.onTouchLeave(event);
                };
                this._onTouchCancel = function(event) {
                    return _this.onTouchCancel(event);
                };
                this.game.canvas.addEventListener("touchstart", this._onTouchStart, false);
                this.game.canvas.addEventListener("touchmove", this._onTouchMove, false);
                this.game.canvas.addEventListener("touchend", this._onTouchEnd, false);
                this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, false);
                if (!this.game.device.cocoonJS) {
                    this.game.canvas.addEventListener("touchenter", this._onTouchEnter, false);
                    this.game.canvas.addEventListener("touchleave", this._onTouchLeave, false);
                }
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(event) {
                event.preventDefault();
            };
            document.addEventListener("touchmove", this._documentTouchMove, false);
        },
        onTouchStart: function(event) {
            this.event = event;
            if (this.touchStartCallback) {
                this.touchStartCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.startPointer(event.changedTouches[i]);
            }
        },
        onTouchCancel: function(event) {
            this.event = event;
            if (this.touchCancelCallback) {
                this.touchCancelCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.stopPointer(event.changedTouches[i]);
            }
        },
        onTouchEnter: function(event) {
            this.event = event;
            if (this.touchEnterCallback) {
                this.touchEnterCallback.call(this.callbackContext, event);
            }
            if (this.game.input.disabled || this.disabled) {
                return;
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
        },
        onTouchLeave: function(event) {
            this.event = event;
            if (this.touchLeaveCallback) {
                this.touchLeaveCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
        },
        onTouchMove: function(event) {
            this.event = event;
            if (this.touchMoveCallback) {
                this.touchMoveCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.updatePointer(event.changedTouches[i]);
            }
        },
        onTouchEnd: function(event) {
            this.event = event;
            if (this.touchEndCallback) {
                this.touchEndCallback.call(this.callbackContext, event);
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                this.game.input.stopPointer(event.changedTouches[i]);
            }
        },
        stop: function() {
            if (this.game.device.touch) {
                this.game.canvas.removeEventListener("touchstart", this._onTouchStart);
                this.game.canvas.removeEventListener("touchmove", this._onTouchMove);
                this.game.canvas.removeEventListener("touchend", this._onTouchEnd);
                this.game.canvas.removeEventListener("touchenter", this._onTouchEnter);
                this.game.canvas.removeEventListener("touchleave", this._onTouchLeave);
                this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel);
            }
        }
    };
    Phaser.Touch.prototype.constructor = Phaser.Touch;
    Phaser.Gamepad = function(game) {
        this.game = game;
        this._gamepadIndexMap = {};
        this._rawPads = [];
        this._active = false;
        this.disabled = false;
        this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") != -1 || !!navigator.getGamepads;
        this._prevRawGamepadTypes = [];
        this._prevTimestamps = [];
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this._ongamepadconnected = null;
        this._gamepaddisconnected = null;
        this._gamepads = [ new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this) ];
    };
    Phaser.Gamepad.prototype = {
        addCallbacks: function(context, callbacks) {
            if (typeof callbacks !== "undefined") {
                this.onConnectCallback = typeof callbacks.onConnect === "function" ? callbacks.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof callbacks.onDisconnect === "function" ? callbacks.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof callbacks.onDown === "function" ? callbacks.onDown : this.onDownCallback;
                this.onUpCallback = typeof callbacks.onUp === "function" ? callbacks.onUp : this.onUpCallback;
                this.onAxisCallback = typeof callbacks.onAxis === "function" ? callbacks.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof callbacks.onFloat === "function" ? callbacks.onFloat : this.onFloatCallback;
            }
        },
        start: function() {
            if (this._active) {
                return;
            }
            this._active = true;
            var _this = this;
            this._onGamepadConnected = function(event) {
                return _this.onGamepadConnected(event);
            };
            this._onGamepadDisconnected = function(event) {
                return _this.onGamepadDisconnected(event);
            };
            window.addEventListener("gamepadconnected", this._onGamepadConnected, false);
            window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, false);
        },
        onGamepadConnected: function(event) {
            var newPad = event.gamepad;
            this._rawPads.push(newPad);
            this._gamepads[newPad.index].connect(newPad);
        },
        onGamepadDisconnected: function(event) {
            var removedPad = event.gamepad;
            for (var i in this._rawPads) {
                if (this._rawPads[i].index === removedPad.index) {
                    this._rawPads.splice(i, 1);
                }
            }
            this._gamepads[removedPad.index].disconnect();
        },
        update: function() {
            this._pollGamepads();
            this.pad1.pollStatus();
            this.pad2.pollStatus();
            this.pad3.pollStatus();
            this.pad4.pollStatus();
        },
        _pollGamepads: function() {
            if (navigator["getGamepads"]) {
                var rawGamepads = navigator.getGamepads();
            } else if (navigator["webkitGetGamepads"]) {
                var rawGamepads = navigator.webkitGetGamepads();
            } else if (navigator["webkitGamepads"]) {
                var rawGamepads = navigator.webkitGamepads();
            }
            if (rawGamepads) {
                this._rawPads = [];
                var gamepadsChanged = false;
                for (var i = 0; i < rawGamepads.length; i++) {
                    if (typeof rawGamepads[i] !== this._prevRawGamepadTypes[i]) {
                        gamepadsChanged = true;
                        this._prevRawGamepadTypes[i] = typeof rawGamepads[i];
                    }
                    if (rawGamepads[i]) {
                        this._rawPads.push(rawGamepads[i]);
                    }
                    if (i === 3) {
                        break;
                    }
                }
                if (gamepadsChanged) {
                    var validConnections = {
                        rawIndices: {},
                        padIndices: {}
                    };
                    var singlePad;
                    for (var j = 0; j < this._gamepads.length; j++) {
                        singlePad = this._gamepads[j];
                        if (singlePad.connected) {
                            for (var k = 0; k < this._rawPads.length; k++) {
                                if (this._rawPads[k].index === singlePad.index) {
                                    validConnections.rawIndices[singlePad.index] = true;
                                    validConnections.padIndices[j] = true;
                                }
                            }
                        }
                    }
                    for (var l = 0; l < this._gamepads.length; l++) {
                        singlePad = this._gamepads[l];
                        if (validConnections.padIndices[l]) {
                            continue;
                        }
                        if (this._rawPads.length < 1) {
                            singlePad.disconnect();
                        }
                        for (var m = 0; m < this._rawPads.length; m++) {
                            if (validConnections.padIndices[l]) {
                                break;
                            }
                            var rawPad = this._rawPads[m];
                            if (rawPad) {
                                if (validConnections.rawIndices[rawPad.index]) {
                                    singlePad.disconnect();
                                    continue;
                                } else {
                                    singlePad.connect(rawPad);
                                    validConnections.rawIndices[rawPad.index] = true;
                                    validConnections.padIndices[l] = true;
                                }
                            } else {
                                singlePad.disconnect();
                            }
                        }
                    }
                }
            }
        },
        setDeadZones: function(value) {
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].deadZone = value;
            }
        },
        stop: function() {
            this._active = false;
            window.removeEventListener("gamepadconnected", this._onGamepadConnected);
            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
        },
        reset: function() {
            this.update();
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].reset();
            }
        },
        justPressed: function(buttonCode, duration) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].justPressed(buttonCode, duration) === true) {
                    return true;
                }
            }
            return false;
        },
        justReleased: function(buttonCode, duration) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].justReleased(buttonCode, duration) === true) {
                    return true;
                }
            }
            return false;
        },
        isDown: function(buttonCode) {
            for (var i = 0; i < this._gamepads.length; i++) {
                if (this._gamepads[i].isDown(buttonCode) === true) {
                    return true;
                }
            }
            return false;
        },
        destroy: function() {
            this.stop();
            for (var i = 0; i < this._gamepads.length; i++) {
                this._gamepads[i].destroy();
            }
        }
    };
    Phaser.Gamepad.prototype.constructor = Phaser.Gamepad;
    Object.defineProperty(Phaser.Gamepad.prototype, "active", {
        get: function() {
            return this._active;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length;
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2];
        }
    });
    Object.defineProperty(Phaser.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3];
        }
    });
    Phaser.Gamepad.BUTTON_0 = 0;
    Phaser.Gamepad.BUTTON_1 = 1;
    Phaser.Gamepad.BUTTON_2 = 2;
    Phaser.Gamepad.BUTTON_3 = 3;
    Phaser.Gamepad.BUTTON_4 = 4;
    Phaser.Gamepad.BUTTON_5 = 5;
    Phaser.Gamepad.BUTTON_6 = 6;
    Phaser.Gamepad.BUTTON_7 = 7;
    Phaser.Gamepad.BUTTON_8 = 8;
    Phaser.Gamepad.BUTTON_9 = 9;
    Phaser.Gamepad.BUTTON_10 = 10;
    Phaser.Gamepad.BUTTON_11 = 11;
    Phaser.Gamepad.BUTTON_12 = 12;
    Phaser.Gamepad.BUTTON_13 = 13;
    Phaser.Gamepad.BUTTON_14 = 14;
    Phaser.Gamepad.BUTTON_15 = 15;
    Phaser.Gamepad.AXIS_0 = 0;
    Phaser.Gamepad.AXIS_1 = 1;
    Phaser.Gamepad.AXIS_2 = 2;
    Phaser.Gamepad.AXIS_3 = 3;
    Phaser.Gamepad.AXIS_4 = 4;
    Phaser.Gamepad.AXIS_5 = 5;
    Phaser.Gamepad.AXIS_6 = 6;
    Phaser.Gamepad.AXIS_7 = 7;
    Phaser.Gamepad.AXIS_8 = 8;
    Phaser.Gamepad.AXIS_9 = 9;
    Phaser.Gamepad.XBOX360_A = 0;
    Phaser.Gamepad.XBOX360_B = 1;
    Phaser.Gamepad.XBOX360_X = 2;
    Phaser.Gamepad.XBOX360_Y = 3;
    Phaser.Gamepad.XBOX360_LEFT_BUMPER = 4;
    Phaser.Gamepad.XBOX360_RIGHT_BUMPER = 5;
    Phaser.Gamepad.XBOX360_LEFT_TRIGGER = 6;
    Phaser.Gamepad.XBOX360_RIGHT_TRIGGER = 7;
    Phaser.Gamepad.XBOX360_BACK = 8;
    Phaser.Gamepad.XBOX360_START = 9;
    Phaser.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;
    Phaser.Gamepad.XBOX360_DPAD_LEFT = 14;
    Phaser.Gamepad.XBOX360_DPAD_RIGHT = 15;
    Phaser.Gamepad.XBOX360_DPAD_UP = 12;
    Phaser.Gamepad.XBOX360_DPAD_DOWN = 13;
    Phaser.Gamepad.XBOX360_STICK_LEFT_X = 0;
    Phaser.Gamepad.XBOX360_STICK_LEFT_Y = 1;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_X = 2;
    Phaser.Gamepad.XBOX360_STICK_RIGHT_Y = 3;
    Phaser.Gamepad.PS3XC_X = 0;
    Phaser.Gamepad.PS3XC_CIRCLE = 1;
    Phaser.Gamepad.PS3XC_SQUARE = 2;
    Phaser.Gamepad.PS3XC_TRIANGLE = 3;
    Phaser.Gamepad.PS3XC_L1 = 4;
    Phaser.Gamepad.PS3XC_R1 = 5;
    Phaser.Gamepad.PS3XC_L2 = 6;
    Phaser.Gamepad.PS3XC_R2 = 7;
    Phaser.Gamepad.PS3XC_SELECT = 8;
    Phaser.Gamepad.PS3XC_START = 9;
    Phaser.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11;
    Phaser.Gamepad.PS3XC_DPAD_UP = 12;
    Phaser.Gamepad.PS3XC_DPAD_DOWN = 13;
    Phaser.Gamepad.PS3XC_DPAD_LEFT = 14;
    Phaser.Gamepad.PS3XC_DPAD_RIGHT = 15;
    Phaser.Gamepad.PS3XC_STICK_LEFT_X = 0;
    Phaser.Gamepad.PS3XC_STICK_LEFT_Y = 1;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_X = 2;
    Phaser.Gamepad.PS3XC_STICK_RIGHT_Y = 3;
    Phaser.SinglePad = function(game, padParent) {
        this.game = game;
        this.index = null;
        this.connected = false;
        this.callbackContext = this;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
        this.deadZone = .26;
        this._padParent = padParent;
        this._rawPad = null;
        this._prevTimestamp = null;
        this._buttons = [];
        this._buttonsLen = 0;
        this._axes = [];
        this._axesLen = 0;
    };
    Phaser.SinglePad.prototype = {
        addCallbacks: function(context, callbacks) {
            if (typeof callbacks !== "undefined") {
                this.onConnectCallback = typeof callbacks.onConnect === "function" ? callbacks.onConnect : this.onConnectCallback;
                this.onDisconnectCallback = typeof callbacks.onDisconnect === "function" ? callbacks.onDisconnect : this.onDisconnectCallback;
                this.onDownCallback = typeof callbacks.onDown === "function" ? callbacks.onDown : this.onDownCallback;
                this.onUpCallback = typeof callbacks.onUp === "function" ? callbacks.onUp : this.onUpCallback;
                this.onAxisCallback = typeof callbacks.onAxis === "function" ? callbacks.onAxis : this.onAxisCallback;
                this.onFloatCallback = typeof callbacks.onFloat === "function" ? callbacks.onFloat : this.onFloatCallback;
            }
        },
        getButton: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode];
            } else {
                return null;
            }
        },
        pollStatus: function() {
            if (!this.connected || this.game.input.disabled || this.game.input.gamepad.disabled || this._rawPad.timestamp && this._rawPad.timestamp === this._prevTimestamp) {
                return;
            }
            for (var i = 0; i < this._buttonsLen; i++) {
                var rawButtonVal = isNaN(this._rawPad.buttons[i]) ? this._rawPad.buttons[i].value : this._rawPad.buttons[i];
                if (rawButtonVal !== this._buttons[i].value) {
                    if (rawButtonVal === 1) {
                        this.processButtonDown(i, rawButtonVal);
                    } else if (rawButtonVal === 0) {
                        this.processButtonUp(i, rawButtonVal);
                    } else {
                        this.processButtonFloat(i, rawButtonVal);
                    }
                }
            }
            for (var index = 0; index < this._axesLen; index++) {
                var value = this._rawPad.axes[index];
                if (value > 0 && value > this.deadZone || value < 0 && value < -this.deadZone) {
                    this.processAxisChange(index, value);
                } else {
                    this.processAxisChange(index, 0);
                }
            }
            this._prevTimestamp = this._rawPad.timestamp;
        },
        connect: function(rawPad) {
            var triggerCallback = !this.connected;
            this.connected = true;
            this.index = rawPad.index;
            this._rawPad = rawPad;
            this._buttons = [];
            this._buttonsLen = rawPad.buttons.length;
            this._axes = [];
            this._axesLen = rawPad.axes.length;
            for (var a = 0; a < this._axesLen; a++) {
                this._axes[a] = rawPad.axes[a];
            }
            for (var buttonCode in rawPad.buttons) {
                buttonCode = parseInt(buttonCode, 10);
                this._buttons[buttonCode] = new Phaser.GamepadButton(this, buttonCode);
            }
            if (triggerCallback && this._padParent.onConnectCallback) {
                this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index);
            }
            if (triggerCallback && this.onConnectCallback) {
                this.onConnectCallback.call(this.callbackContext);
            }
        },
        disconnect: function() {
            var triggerCallback = this.connected;
            var disconnectingIndex = this.index;
            this.connected = false;
            this.index = null;
            this._rawPad = undefined;
            for (var i = 0; i < this._buttonsLen; i++) {
                this._buttons[i].destroy();
            }
            this._buttons = [];
            this._buttonsLen = 0;
            this._axes = [];
            this._axesLen = 0;
            if (triggerCallback && this._padParent.onDisconnectCallback) {
                this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, disconnectingIndex);
            }
            if (triggerCallback && this.onDisconnectCallback) {
                this.onDisconnectCallback.call(this.callbackContext);
            }
        },
        destroy: function() {
            this._rawPad = undefined;
            for (var i = 0; i < this._buttonsLen; i++) {
                this._buttons[i].destroy();
            }
            this._buttons = [];
            this._buttonsLen = 0;
            this._axes = [];
            this._axesLen = 0;
            this.onConnectCallback = null;
            this.onDisconnectCallback = null;
            this.onDownCallback = null;
            this.onUpCallback = null;
            this.onAxisCallback = null;
            this.onFloatCallback = null;
        },
        processAxisChange: function(index, value) {
            if (this._axes[index] === value) {
                return;
            }
            this._axes[index] = value;
            if (this._padParent.onAxisCallback) {
                this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, index, value);
            }
            if (this.onAxisCallback) {
                this.onAxisCallback.call(this.callbackContext, this, index, value);
            }
        },
        processButtonDown: function(buttonCode, value) {
            if (this._padParent.onDownCallback) {
                this._padParent.onDownCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].processButtonDown(value);
            }
        },
        processButtonUp: function(buttonCode, value) {
            if (this._padParent.onUpCallback) {
                this._padParent.onUpCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].processButtonUp(value);
            }
        },
        processButtonFloat: function(buttonCode, value) {
            if (this._padParent.onFloatCallback) {
                this._padParent.onFloatCallback.call(this._padParent.callbackContext, buttonCode, value, this.index);
            }
            if (this.onFloatCallback) {
                this.onFloatCallback.call(this.callbackContext, buttonCode, value);
            }
            if (this._buttons[buttonCode]) {
                this._buttons[buttonCode].processButtonFloat(value);
            }
        },
        axis: function(axisCode) {
            if (this._axes[axisCode]) {
                return this._axes[axisCode];
            }
            return false;
        },
        isDown: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].isDown;
            }
            return false;
        },
        isUp: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].isUp;
            }
            return false;
        },
        justReleased: function(buttonCode, duration) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].justReleased(duration);
            }
        },
        justPressed: function(buttonCode, duration) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].justPressed(duration);
            }
        },
        buttonValue: function(buttonCode) {
            if (this._buttons[buttonCode]) {
                return this._buttons[buttonCode].value;
            }
            return null;
        },
        reset: function() {
            for (var j = 0; j < this._axes.length; j++) {
                this._axes[j] = 0;
            }
        }
    };
    Phaser.SinglePad.prototype.constructor = Phaser.SinglePad;
    Phaser.GamepadButton = function(pad, buttonCode) {
        this.pad = pad;
        this.game = pad.game;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = 0;
        this.repeats = 0;
        this.value = 0;
        this.buttonCode = buttonCode;
        this.onDown = new Phaser.Signal();
        this.onUp = new Phaser.Signal();
        this.onFloat = new Phaser.Signal();
    };
    Phaser.GamepadButton.prototype = {
        processButtonDown: function(value) {
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.now;
            this.duration = 0;
            this.repeats = 0;
            this.value = value;
            this.onDown.dispatch(this, value);
        },
        processButtonUp: function(value) {
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.now;
            this.value = value;
            this.onUp.dispatch(this, value);
        },
        processButtonFloat: function(value) {
            this.value = value;
            this.onFloat.dispatch(this, value);
        },
        justPressed: function(duration) {
            duration = duration || 250;
            return this.isDown === true && this.timeDown + duration > this.game.time.now;
        },
        justReleased: function(duration) {
            duration = duration || 250;
            return this.isUp === true && this.timeUp + duration > this.game.time.now;
        },
        reset: function() {
            this.isDown = false;
            this.isUp = true;
            this.timeDown = this.game.time.now;
            this.duration = 0;
            this.repeats = 0;
        },
        destroy: function() {
            this.onDown.dispose();
            this.onUp.dispose();
            this.onFloat.dispose();
            this.pad = null;
            this.game = null;
        }
    };
    Phaser.GamepadButton.prototype.constructor = Phaser.GamepadButton;
    Phaser.InputHandler = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.enabled = false;
        this.checked = false;
        this.priorityID = 0;
        this.useHandCursor = false;
        this._setHandCursor = false;
        this.isDragged = false;
        this.allowHorizontalDrag = true;
        this.allowVerticalDrag = true;
        this.bringToTop = false;
        this.snapOffset = null;
        this.snapOnDrag = false;
        this.snapOnRelease = false;
        this.snapX = 0;
        this.snapY = 0;
        this.snapOffsetX = 0;
        this.snapOffsetY = 0;
        this.pixelPerfectOver = false;
        this.pixelPerfectClick = false;
        this.pixelPerfectAlpha = 255;
        this.draggable = false;
        this.boundsRect = null;
        this.boundsSprite = null;
        this.consumePointerEvent = false;
        this._dragPhase = false;
        this._wasEnabled = false;
        this._tempPoint = new Phaser.Point();
        this._pointerData = [];
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            isDown: false,
            isUp: false,
            isOver: false,
            isOut: false,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: false
        });
    };
    Phaser.InputHandler.prototype = {
        start: function(priority, useHandCursor) {
            priority = priority || 0;
            if (typeof useHandCursor === "undefined") {
                useHandCursor = false;
            }
            if (this.enabled === false) {
                this.game.input.interactiveItems.add(this);
                this.useHandCursor = useHandCursor;
                this.priorityID = priority;
                for (var i = 0; i < 10; i++) {
                    this._pointerData[i] = {
                        id: i,
                        x: 0,
                        y: 0,
                        isDown: false,
                        isUp: false,
                        isOver: false,
                        isOut: false,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: false
                    };
                }
                this.snapOffset = new Phaser.Point();
                this.enabled = true;
                this._wasEnabled = true;
                if (this.sprite.events && this.sprite.events.onInputOver === null) {
                    this.sprite.events.onInputOver = new Phaser.Signal();
                    this.sprite.events.onInputOut = new Phaser.Signal();
                    this.sprite.events.onInputDown = new Phaser.Signal();
                    this.sprite.events.onInputUp = new Phaser.Signal();
                    this.sprite.events.onDragStart = new Phaser.Signal();
                    this.sprite.events.onDragStop = new Phaser.Signal();
                }
            }
            this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);
            this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this);
            this.flagged = false;
            return this.sprite;
        },
        addedToGroup: function() {
            if (this._dragPhase) {
                return;
            }
            if (this._wasEnabled && !this.enabled) {
                this.start();
            }
        },
        removedFromGroup: function() {
            if (this._dragPhase) {
                return;
            }
            if (this.enabled) {
                this._wasEnabled = true;
                this.stop();
            } else {
                this._wasEnabled = false;
            }
        },
        reset: function() {
            this.enabled = false;
            this.flagged = false;
            for (var i = 0; i < 10; i++) {
                this._pointerData[i] = {
                    id: i,
                    x: 0,
                    y: 0,
                    isDown: false,
                    isUp: false,
                    isOver: false,
                    isOut: false,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: false
                };
            }
        },
        stop: function() {
            if (this.enabled === false) {
                return;
            } else {
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
            }
        },
        destroy: function() {
            if (this.sprite) {
                if (this._setHandCursor) {
                    this.game.canvas.style.cursor = "default";
                    this._setHandCursor = false;
                }
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
                this._pointerData.length = 0;
                this.boundsRect = null;
                this.boundsSprite = null;
                this.sprite = null;
            }
        },
        validForInput: function(highestID, highestRenderID, includePixelPerfect) {
            if (typeof includePixelPerfect === "undefined") {
                includePixelPerfect = true;
            }
            if (this.sprite.scale.x === 0 || this.sprite.scale.y === 0 || this.priorityID < this.game.input.minPriorityID) {
                return false;
            }
            if (!includePixelPerfect && (this.pixelPerfectClick || this.pixelPerfectOver)) {
                return false;
            }
            if (this.priorityID > highestID || this.priorityID === highestID && this.sprite._cache[3] < highestRenderID) {
                return true;
            }
            return false;
        },
        isPixelPerfect: function() {
            return this.pixelPerfectClick || this.pixelPerfectOver;
        },
        pointerX: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].x;
        },
        pointerY: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].y;
        },
        pointerDown: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isDown;
        },
        pointerUp: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isUp;
        },
        pointerTimeDown: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeDown;
        },
        pointerTimeUp: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeUp;
        },
        pointerOver: function(index) {
            if (this.enabled) {
                if (typeof index === "undefined") {
                    for (var i = 0; i < 10; i++) {
                        if (this._pointerData[i].isOver) {
                            return true;
                        }
                    }
                } else {
                    return this._pointerData[index].isOver;
                }
            }
            return false;
        },
        pointerOut: function(index) {
            if (this.enabled) {
                if (typeof index === "undefined") {
                    for (var i = 0; i < 10; i++) {
                        if (this._pointerData[i].isOut) {
                            return true;
                        }
                    }
                } else {
                    return this._pointerData[index].isOut;
                }
            }
            return false;
        },
        pointerTimeOver: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeOver;
        },
        pointerTimeOut: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].timeOut;
        },
        pointerDragged: function(pointer) {
            pointer = pointer || 0;
            return this._pointerData[pointer].isDragged;
        },
        checkPointerDown: function(pointer, fastTest) {
            if (!pointer.isDown || !this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false;
            }
            if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) {
                if (typeof fastTest === "undefined") {
                    fastTest = false;
                }
                if (!fastTest && this.pixelPerfectClick) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y);
                } else {
                    return true;
                }
            }
            return false;
        },
        checkPointerOver: function(pointer, fastTest) {
            if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible) {
                return false;
            }
            if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) {
                if (typeof fastTest === "undefined") {
                    fastTest = false;
                }
                if (!fastTest && this.pixelPerfectOver) {
                    return this.checkPixel(this._tempPoint.x, this._tempPoint.y);
                } else {
                    return true;
                }
            }
            return false;
        },
        checkPixel: function(x, y, pointer) {
            if (this.sprite.texture.baseTexture.source) {
                if (x === null && y === null) {
                    this.game.input.getLocalPosition(this.sprite, pointer, this._tempPoint);
                    var x = this._tempPoint.x;
                    var y = this._tempPoint.y;
                }
                if (this.sprite.anchor.x !== 0) {
                    x -= -this.sprite.texture.frame.width * this.sprite.anchor.x;
                }
                if (this.sprite.anchor.y !== 0) {
                    y -= -this.sprite.texture.frame.height * this.sprite.anchor.y;
                }
                x += this.sprite.texture.frame.x;
                y += this.sprite.texture.frame.y;
                if (this.sprite.texture.trim) {
                    x -= this.sprite.texture.trim.x;
                    y -= this.sprite.texture.trim.y;
                    if (x < this.sprite.texture.crop.x || x > this.sprite.texture.crop.right || y < this.sprite.texture.crop.y || y > this.sprite.texture.crop.bottom) {
                        this._dx = x;
                        this._dy = y;
                        return false;
                    }
                }
                this._dx = x;
                this._dy = y;
                this.game.input.hitContext.clearRect(0, 0, 1, 1);
                this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1);
                var rgb = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                if (rgb.data[3] >= this.pixelPerfectAlpha) {
                    return true;
                }
            }
            return false;
        },
        update: function(pointer) {
            if (this.sprite === null || this.sprite.parent === undefined) {
                return;
            }
            if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible) {
                this._pointerOutHandler(pointer);
                return false;
            }
            if (this.draggable && this._draggedPointerID == pointer.id) {
                return this.updateDrag(pointer);
            } else if (this._pointerData[pointer.id].isOver === true) {
                if (this.checkPointerOver(pointer)) {
                    this._pointerData[pointer.id].x = pointer.x - this.sprite.x;
                    this._pointerData[pointer.id].y = pointer.y - this.sprite.y;
                    return true;
                } else {
                    this._pointerOutHandler(pointer);
                    return false;
                }
            }
        },
        _pointerOverHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            if (this._pointerData[pointer.id].isOver === false || pointer.dirty) {
                this._pointerData[pointer.id].isOver = true;
                this._pointerData[pointer.id].isOut = false;
                this._pointerData[pointer.id].timeOver = this.game.time.now;
                this._pointerData[pointer.id].x = pointer.x - this.sprite.x;
                this._pointerData[pointer.id].y = pointer.y - this.sprite.y;
                if (this.useHandCursor && this._pointerData[pointer.id].isDragged === false) {
                    this.game.canvas.style.cursor = "pointer";
                    this._setHandCursor = true;
                }
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputOver.dispatch(this.sprite, pointer);
                }
            }
        },
        _pointerOutHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            this._pointerData[pointer.id].isOver = false;
            this._pointerData[pointer.id].isOut = true;
            this._pointerData[pointer.id].timeOut = this.game.time.now;
            if (this.useHandCursor && this._pointerData[pointer.id].isDragged === false) {
                this.game.canvas.style.cursor = "default";
                this._setHandCursor = false;
            }
            if (this.sprite && this.sprite.events) {
                this.sprite.events.onInputOut.dispatch(this.sprite, pointer);
            }
        },
        _touchedHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            if (this._pointerData[pointer.id].isDown === false && this._pointerData[pointer.id].isOver === true) {
                if (this.pixelPerfectClick && !this.checkPixel(null, null, pointer)) {
                    return;
                }
                this._pointerData[pointer.id].isDown = true;
                this._pointerData[pointer.id].isUp = false;
                this._pointerData[pointer.id].timeDown = this.game.time.now;
                if (this.sprite && this.sprite.events) {
                    this.sprite.events.onInputDown.dispatch(this.sprite, pointer);
                }
                pointer.dirty = true;
                if (this.draggable && this.isDragged === false) {
                    this.startDrag(pointer);
                }
                if (this.bringToTop) {
                    this.sprite.bringToTop();
                }
            }
            return this.consumePointerEvent;
        },
        _releasedHandler: function(pointer) {
            if (this.sprite === null) {
                return;
            }
            if (this._pointerData[pointer.id].isDown && pointer.isUp) {
                this._pointerData[pointer.id].isDown = false;
                this._pointerData[pointer.id].isUp = true;
                this._pointerData[pointer.id].timeUp = this.game.time.now;
                this._pointerData[pointer.id].downDuration = this._pointerData[pointer.id].timeUp - this._pointerData[pointer.id].timeDown;
                if (this.checkPointerOver(pointer)) {
                    if (this.sprite && this.sprite.events) {
                        this.sprite.events.onInputUp.dispatch(this.sprite, pointer, true);
                    }
                } else {
                    if (this.sprite && this.sprite.events) {
                        this.sprite.events.onInputUp.dispatch(this.sprite, pointer, false);
                    }
                    if (this.useHandCursor) {
                        this.game.canvas.style.cursor = "default";
                        this._setHandCursor = false;
                    }
                }
                pointer.dirty = true;
                if (this.draggable && this.isDragged && this._draggedPointerID === pointer.id) {
                    this.stopDrag(pointer);
                }
            }
        },
        updateDrag: function(pointer) {
            if (pointer.isUp) {
                this.stopDrag(pointer);
                return false;
            }
            if (this.sprite.fixedToCamera) {
                if (this.allowHorizontalDrag) {
                    this.sprite.cameraOffset.x = pointer.x + this._dragPoint.x + this.dragOffset.x;
                }
                if (this.allowVerticalDrag) {
                    this.sprite.cameraOffset.y = pointer.y + this._dragPoint.y + this.dragOffset.y;
                }
                if (this.boundsRect) {
                    this.checkBoundsRect();
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite();
                }
                if (this.snapOnDrag) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                }
            } else {
                if (this.allowHorizontalDrag) {
                    this.sprite.x = pointer.x + this._dragPoint.x + this.dragOffset.x;
                }
                if (this.allowVerticalDrag) {
                    this.sprite.y = pointer.y + this._dragPoint.y + this.dragOffset.y;
                }
                if (this.boundsRect) {
                    this.checkBoundsRect();
                }
                if (this.boundsSprite) {
                    this.checkBoundsSprite();
                }
                if (this.snapOnDrag) {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                }
            }
            return true;
        },
        justOver: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isOver && this.overDuration(pointer) < delay;
        },
        justOut: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isOut && this.game.time.now - this._pointerData[pointer].timeOut < delay;
        },
        justPressed: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isDown && this.downDuration(pointer) < delay;
        },
        justReleased: function(pointer, delay) {
            pointer = pointer || 0;
            delay = delay || 500;
            return this._pointerData[pointer].isUp && this.game.time.now - this._pointerData[pointer].timeUp < delay;
        },
        overDuration: function(pointer) {
            pointer = pointer || 0;
            if (this._pointerData[pointer].isOver) {
                return this.game.time.now - this._pointerData[pointer].timeOver;
            }
            return -1;
        },
        downDuration: function(pointer) {
            pointer = pointer || 0;
            if (this._pointerData[pointer].isDown) {
                return this.game.time.now - this._pointerData[pointer].timeDown;
            }
            return -1;
        },
        enableDrag: function(lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {
            if (typeof lockCenter == "undefined") {
                lockCenter = false;
            }
            if (typeof bringToTop == "undefined") {
                bringToTop = false;
            }
            if (typeof pixelPerfect == "undefined") {
                pixelPerfect = false;
            }
            if (typeof alphaThreshold == "undefined") {
                alphaThreshold = 255;
            }
            if (typeof boundsRect == "undefined") {
                boundsRect = null;
            }
            if (typeof boundsSprite == "undefined") {
                boundsSprite = null;
            }
            this._dragPoint = new Phaser.Point();
            this.draggable = true;
            this.bringToTop = bringToTop;
            this.dragOffset = new Phaser.Point();
            this.dragFromCenter = lockCenter;
            this.pixelPerfectClick = pixelPerfect;
            this.pixelPerfectAlpha = alphaThreshold;
            if (boundsRect) {
                this.boundsRect = boundsRect;
            }
            if (boundsSprite) {
                this.boundsSprite = boundsSprite;
            }
        },
        disableDrag: function() {
            if (this._pointerData) {
                for (var i = 0; i < 10; i++) {
                    this._pointerData[i].isDragged = false;
                }
            }
            this.draggable = false;
            this.isDragged = false;
            this._draggedPointerID = -1;
        },
        startDrag: function(pointer) {
            this.isDragged = true;
            this._draggedPointerID = pointer.id;
            this._pointerData[pointer.id].isDragged = true;
            if (this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    this.sprite.centerOn(pointer.x, pointer.y);
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);
                } else {
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);
                }
            } else {
                if (this.dragFromCenter) {
                    var bounds = this.sprite.getBounds();
                    this.sprite.x = pointer.x + (this.sprite.x - bounds.centerX);
                    this.sprite.y = pointer.y + (this.sprite.y - bounds.centerY);
                    this._dragPoint.setTo(this.sprite.x - pointer.x, this.sprite.y - pointer.y);
                } else {
                    this._dragPoint.setTo(this.sprite.x - pointer.x, this.sprite.y - pointer.y);
                }
            }
            this.updateDrag(pointer);
            if (this.bringToTop) {
                this._dragPhase = true;
                this.sprite.bringToTop();
            }
            this.sprite.events.onDragStart.dispatch(this.sprite, pointer);
        },
        stopDrag: function(pointer) {
            this.isDragged = false;
            this._draggedPointerID = -1;
            this._pointerData[pointer.id].isDragged = false;
            this._dragPhase = false;
            if (this.snapOnRelease) {
                if (this.sprite.fixedToCamera) {
                    this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                } else {
                    this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
                    this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                }
            }
            this.sprite.events.onDragStop.dispatch(this.sprite, pointer);
            if (this.checkPointerOver(pointer) === false) {
                this._pointerOutHandler(pointer);
            }
        },
        setDragLock: function(allowHorizontal, allowVertical) {
            if (typeof allowHorizontal == "undefined") {
                allowHorizontal = true;
            }
            if (typeof allowVertical == "undefined") {
                allowVertical = true;
            }
            this.allowHorizontalDrag = allowHorizontal;
            this.allowVerticalDrag = allowVertical;
        },
        enableSnap: function(snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {
            if (typeof onDrag == "undefined") {
                onDrag = true;
            }
            if (typeof onRelease == "undefined") {
                onRelease = false;
            }
            if (typeof snapOffsetX == "undefined") {
                snapOffsetX = 0;
            }
            if (typeof snapOffsetY == "undefined") {
                snapOffsetY = 0;
            }
            this.snapX = snapX;
            this.snapY = snapY;
            this.snapOffsetX = snapOffsetX;
            this.snapOffsetY = snapOffsetY;
            this.snapOnDrag = onDrag;
            this.snapOnRelease = onRelease;
        },
        disableSnap: function() {
            this.snapOnDrag = false;
            this.snapOnRelease = false;
        },
        checkBoundsRect: function() {
            if (this.sprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsRect.left) {
                    this.sprite.cameraOffset.x = this.boundsRect.left;
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right) {
                    this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width;
                }
                if (this.sprite.cameraOffset.y < this.boundsRect.top) {
                    this.sprite.cameraOffset.y = this.boundsRect.top;
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom) {
                    this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height;
                }
            } else {
                if (this.sprite.x < this.boundsRect.left) {
                    this.sprite.x = this.boundsRect.x;
                } else if (this.sprite.x + this.sprite.width > this.boundsRect.right) {
                    this.sprite.x = this.boundsRect.right - this.sprite.width;
                }
                if (this.sprite.y < this.boundsRect.top) {
                    this.sprite.y = this.boundsRect.top;
                } else if (this.sprite.y + this.sprite.height > this.boundsRect.bottom) {
                    this.sprite.y = this.boundsRect.bottom - this.sprite.height;
                }
            }
        },
        checkBoundsSprite: function() {
            if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera) {
                if (this.sprite.cameraOffset.x < this.boundsSprite.camerOffset.x) {
                    this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x;
                } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.camerOffset.x + this.boundsSprite.width) {
                    this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x + this.boundsSprite.width - this.sprite.width;
                }
                if (this.sprite.cameraOffset.y < this.boundsSprite.camerOffset.y) {
                    this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y;
                } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.camerOffset.y + this.boundsSprite.height) {
                    this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y + this.boundsSprite.height - this.sprite.height;
                }
            } else {
                if (this.sprite.x < this.boundsSprite.x) {
                    this.sprite.x = this.boundsSprite.x;
                } else if (this.sprite.x + this.sprite.width > this.boundsSprite.x + this.boundsSprite.width) {
                    this.sprite.x = this.boundsSprite.x + this.boundsSprite.width - this.sprite.width;
                }
                if (this.sprite.y < this.boundsSprite.y) {
                    this.sprite.y = this.boundsSprite.y;
                } else if (this.sprite.y + this.sprite.height > this.boundsSprite.y + this.boundsSprite.height) {
                    this.sprite.y = this.boundsSprite.y + this.boundsSprite.height - this.sprite.height;
                }
            }
        }
    };
    Phaser.InputHandler.prototype.constructor = Phaser.InputHandler;
    Phaser.Events = function(sprite) {
        this.parent = sprite;
        this.onAddedToGroup = new Phaser.Signal();
        this.onRemovedFromGroup = new Phaser.Signal();
        this.onDestroy = new Phaser.Signal();
        this.onKilled = new Phaser.Signal();
        this.onRevived = new Phaser.Signal();
        this.onOutOfBounds = new Phaser.Signal();
        this.onEnterBounds = new Phaser.Signal();
        this.onInputOver = null;
        this.onInputOut = null;
        this.onInputDown = null;
        this.onInputUp = null;
        this.onDragStart = null;
        this.onDragStop = null;
        this.onAnimationStart = null;
        this.onAnimationComplete = null;
        this.onAnimationLoop = null;
    };
    Phaser.Events.prototype = {
        destroy: function() {
            this.parent = null;
            this.onDestroy.dispose();
            this.onAddedToGroup.dispose();
            this.onRemovedFromGroup.dispose();
            this.onKilled.dispose();
            this.onRevived.dispose();
            this.onOutOfBounds.dispose();
            if (this.onInputOver) {
                this.onInputOver.dispose();
                this.onInputOut.dispose();
                this.onInputDown.dispose();
                this.onInputUp.dispose();
                this.onDragStart.dispose();
                this.onDragStop.dispose();
            }
            if (this.onAnimationStart) {
                this.onAnimationStart.dispose();
                this.onAnimationComplete.dispose();
                this.onAnimationLoop.dispose();
            }
        }
    };
    Phaser.Events.prototype.constructor = Phaser.Events;
    Phaser.GameObjectFactory = function(game) {
        this.game = game;
        this.world = this.game.world;
    };
    Phaser.GameObjectFactory.prototype = {
        existing: function(object) {
            return this.world.add(object);
        },
        image: function(x, y, key, frame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Image(this.game, x, y, key, frame));
        },
        sprite: function(x, y, key, frame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.create(x, y, key, frame);
        },
        tween: function(obj) {
            return this.game.tweens.create(obj);
        },
        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
            return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);
        },
        physicsGroup: function(physicsBodyType, parent, name, addToStage) {
            return new Phaser.Group(this.game, parent, name, addToStage, true, physicsBodyType);
        },
        spriteBatch: function(parent, name, addToStage) {
            if (typeof parent === "undefined") {
                parent = null;
            }
            if (typeof name === "undefined") {
                name = "group";
            }
            if (typeof addToStage === "undefined") {
                addToStage = false;
            }
            return new Phaser.SpriteBatch(this.game, parent, name, addToStage);
        },
        audio: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        sound: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        tileSprite: function(x, y, width, height, key, frame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.TileSprite(this.game, x, y, width, height, key, frame));
        },
        rope: function(x, y, key, frame, points, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Rope(this.game, x, y, key, frame, points));
        },
        text: function(x, y, text, style, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Text(this.game, x, y, text, style));
        },
        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame));
        },
        graphics: function(x, y, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.Graphics(this.game, x, y));
        },
        emitter: function(x, y, maxParticles) {
            return this.game.particles.add(new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles));
        },
        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        },
        bitmapText: function(x, y, font, text, size, group) {
            if (typeof group === "undefined") {
                group = this.world;
            }
            return group.add(new Phaser.BitmapText(this.game, x, y, font, text, size));
        },
        tilemap: function(key, tileWidth, tileHeight, width, height) {
            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
        },
        renderTexture: function(width, height, key, addToCache) {
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            var texture = new Phaser.RenderTexture(this.game, width, height, key);
            if (addToCache) {
                this.game.cache.addRenderTexture(key, texture);
            }
            return texture;
        },
        bitmapData: function(width, height, key, addToCache) {
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            var texture = new Phaser.BitmapData(this.game, key, width, height);
            if (addToCache) {
                this.game.cache.addBitmapData(key, texture);
            }
            return texture;
        },
        filter: function(filter) {
            var args = Array.prototype.splice.call(arguments, 1);
            var filter = new Phaser.Filter[filter](this.game);
            filter.init.apply(filter, args);
            return filter;
        },
        plugin: function(plugin) {
            return this.game.plugins.add(plugin);
        }
    };
    Phaser.GameObjectFactory.prototype.constructor = Phaser.GameObjectFactory;
    Phaser.GameObjectCreator = function(game) {
        this.game = game;
        this.world = this.game.world;
    };
    Phaser.GameObjectCreator.prototype = {
        image: function(x, y, key, frame) {
            return new Phaser.Image(this.game, x, y, key, frame);
        },
        sprite: function(x, y, key, frame) {
            return new Phaser.Sprite(this.game, x, y, key, frame);
        },
        tween: function(obj) {
            return new Phaser.Tween(obj, this.game);
        },
        group: function(parent, name, addToStage, enableBody, physicsBodyType) {
            return new Phaser.Group(this.game, null, name, addToStage, enableBody, physicsBodyType);
        },
        spriteBatch: function(parent, name, addToStage) {
            if (typeof name === "undefined") {
                name = "group";
            }
            if (typeof addToStage === "undefined") {
                addToStage = false;
            }
            return new Phaser.SpriteBatch(this.game, parent, name, addToStage);
        },
        audio: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        sound: function(key, volume, loop, connect) {
            return this.game.sound.add(key, volume, loop, connect);
        },
        tileSprite: function(x, y, width, height, key, frame) {
            return new Phaser.TileSprite(this.game, x, y, width, height, key, frame);
        },
        rope: function(x, y, key, frame, points) {
            return new Phaser.Rope(this.game, x, y, key, frame, points);
        },
        text: function(x, y, text, style) {
            return new Phaser.Text(this.game, x, y, text, style);
        },
        button: function(x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
            return new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame);
        },
        graphics: function(x, y) {
            return new Phaser.Graphics(this.game, x, y);
        },
        emitter: function(x, y, maxParticles) {
            return new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles);
        },
        retroFont: function(font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
            return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);
        },
        bitmapText: function(x, y, font, text, size) {
            return new Phaser.BitmapText(this.game, x, y, font, text, size);
        },
        tilemap: function(key, tileWidth, tileHeight, width, height) {
            return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);
        },
        renderTexture: function(width, height, key, addToCache) {
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            var texture = new Phaser.RenderTexture(this.game, width, height, key);
            if (addToCache) {
                this.game.cache.addRenderTexture(key, texture);
            }
            return texture;
        },
        bitmapData: function(width, height, key, addToCache) {
            if (typeof addToCache === "undefined") {
                addToCache = false;
            }
            if (typeof key === "undefined" || key === "") {
                key = this.game.rnd.uuid();
            }
            var texture = new Phaser.BitmapData(this.game, key, width, height);
            if (addToCache) {
                this.game.cache.addBitmapData(key, texture);
            }
            return texture;
        },
        filter: function(filter) {
            var args = Array.prototype.splice.call(arguments, 1);
            var filter = new Phaser.Filter[filter](this.game);
            filter.init.apply(filter, args);
            return filter;
        }
    };
    Phaser.GameObjectCreator.prototype.constructor = Phaser.GameObjectCreator;
    Phaser.BitmapData = function(game, key, width, height) {
        if (typeof width === "undefined") {
            width = 256;
        }
        if (typeof height === "undefined") {
            height = 256;
        }
        this.game = game;
        this.key = key;
        this.width = width;
        this.height = height;
        this.canvas = Phaser.Canvas.create(width, height, "", true);
        this.context = this.canvas.getContext("2d");
        this.ctx = this.context;
        this.imageData = this.context.getImageData(0, 0, width, height);
        this.data = this.imageData.data;
        this.pixels = null;
        if (this.imageData.data.buffer) {
            this.buffer = this.imageData.data.buffer;
            this.pixels = new Uint32Array(this.buffer);
        } else {
            if (window["ArrayBuffer"]) {
                this.buffer = new ArrayBuffer(this.imageData.data.length);
                this.pixels = new Uint32Array(this.buffer);
            } else {
                this.pixels = this.imageData.data;
            }
        }
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, "bitmapData", game.rnd.uuid());
        this.texture.frame = this.textureFrame;
        this.type = Phaser.BITMAPDATA;
        this.disableTextureUpload = false;
        this.dirty = false;
        this.cls = this.clear;
        this._image = null;
        this._pos = new Phaser.Point();
        this._size = new Phaser.Point();
        this._scale = new Phaser.Point();
        this._rotate = 0;
        this._alpha = {
            prev: 1,
            current: 1
        };
        this._anchor = new Phaser.Point();
        this._tempR = 0;
        this._tempG = 0;
        this._tempB = 0;
    };
    Phaser.BitmapData.prototype = {
        add: function(object) {
            if (Array.isArray(object)) {
                for (var i = 0; i < object.length; i++) {
                    if (object[i]["loadTexture"]) {
                        object[i].loadTexture(this);
                    }
                }
            } else {
                object.loadTexture(this);
            }
            return this;
        },
        load: function(source) {
            if (typeof source === "string") {
                source = this.game.cache.getImage(source);
            }
            if (source) {
                this.resize(source.width, source.height);
                this.cls();
            } else {
                return;
            }
            this.draw(source);
            this.update();
            return this;
        },
        clear: function() {
            this.context.clearRect(0, 0, this.width, this.height);
            this.dirty = true;
            return this;
        },
        fill: function(r, g, b, a) {
            if (typeof a === "undefined") {
                a = 1;
            }
            this.context.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a + ")";
            this.context.fillRect(0, 0, this.width, this.height);
            this.dirty = true;
            return this;
        },
        resize: function(width, height) {
            if (width !== this.width || height !== this.height) {
                this.width = width;
                this.height = height;
                this.canvas.width = width;
                this.canvas.height = height;
                this.baseTexture.width = width;
                this.baseTexture.height = height;
                this.textureFrame.width = width;
                this.textureFrame.height = height;
                this.texture.width = width;
                this.texture.height = height;
                this.texture.crop.width = width;
                this.texture.crop.height = height;
                this.update();
                this.dirty = true;
            }
            return this;
        },
        update: function(x, y, width, height) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.width;
            }
            if (typeof height === "undefined") {
                height = this.height;
            }
            this.imageData = this.context.getImageData(x, y, width, height);
            this.data = this.imageData.data;
            if (this.imageData.data.buffer) {
                this.buffer = this.imageData.data.buffer;
                this.pixels = new Uint32Array(this.buffer);
            } else {
                if (window["ArrayBuffer"]) {
                    this.buffer = new ArrayBuffer(this.imageData.data.length);
                    this.pixels = new Uint32Array(this.buffer);
                } else {
                    this.pixels = this.imageData.data;
                }
            }
            return this;
        },
        processPixelRGB: function(callback, callbackContext, x, y, width, height) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.width;
            }
            if (typeof height === "undefined") {
                height = this.height;
            }
            var w = x + width;
            var h = y + height;
            var pixel = Phaser.Color.createColor();
            var result = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            var dirty = false;
            for (var ty = y; ty < h; ty++) {
                for (var tx = x; tx < w; tx++) {
                    Phaser.Color.unpackPixel(this.getPixel32(tx, ty), pixel);
                    result = callback.call(callbackContext, pixel, tx, ty);
                    if (result !== false && result !== null && result !== undefined) {
                        this.setPixel32(tx, ty, result.r, result.g, result.b, result.a, false);
                        dirty = true;
                    }
                }
            }
            if (dirty) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true;
            }
            return this;
        },
        processPixel: function(callback, callbackContext, x, y, width, height) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.width;
            }
            if (typeof height === "undefined") {
                height = this.height;
            }
            var w = x + width;
            var h = y + height;
            var pixel = 0;
            var result = 0;
            var dirty = false;
            for (var ty = y; ty < h; ty++) {
                for (var tx = x; tx < w; tx++) {
                    pixel = this.getPixel32(tx, ty);
                    result = callback.call(callbackContext, pixel, tx, ty);
                    if (result !== pixel) {
                        this.pixels[ty * this.width + tx] = result;
                        dirty = true;
                    }
                }
            }
            if (dirty) {
                this.context.putImageData(this.imageData, 0, 0);
                this.dirty = true;
            }
            return this;
        },
        replaceRGB: function(r1, g1, b1, a1, r2, g2, b2, a2, region) {
            var sx = 0;
            var sy = 0;
            var w = this.width;
            var h = this.height;
            var source = Phaser.Color.packPixel(r1, g1, b1, a1);
            if (region !== undefined && region instanceof Phaser.Rectangle) {
                sx = region.x;
                sy = region.y;
                w = region.width;
                h = region.height;
            }
            for (var y = 0; y < h; y++) {
                for (var x = 0; x < w; x++) {
                    if (this.getPixel32(sx + x, sy + y) === source) {
                        this.setPixel32(sx + x, sy + y, r2, g2, b2, a2, false);
                    }
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        setHSL: function(h, s, l, region) {
            if (typeof h === "undefined" || h === null) {
                h = false;
            }
            if (typeof s === "undefined" || s === null) {
                s = false;
            }
            if (typeof l === "undefined" || l === null) {
                l = false;
            }
            if (!h && !s && !l) {
                return;
            }
            if (typeof region === "undefined") {
                region = new Phaser.Rectangle(0, 0, this.width, this.height);
            }
            var pixel = Phaser.Color.createColor();
            for (var y = region.y; y < region.bottom; y++) {
                for (var x = region.x; x < region.right; x++) {
                    Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);
                    if (h) {
                        pixel.h = h;
                    }
                    if (s) {
                        pixel.s = s;
                    }
                    if (l) {
                        pixel.l = l;
                    }
                    Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
                    this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        shiftHSL: function(h, s, l, region) {
            if (typeof h === "undefined" || h === null) {
                h = false;
            }
            if (typeof s === "undefined" || s === null) {
                s = false;
            }
            if (typeof l === "undefined" || l === null) {
                l = false;
            }
            if (!h && !s && !l) {
                return;
            }
            if (typeof region === "undefined") {
                region = new Phaser.Rectangle(0, 0, this.width, this.height);
            }
            var pixel = Phaser.Color.createColor();
            for (var y = region.y; y < region.bottom; y++) {
                for (var x = region.x; x < region.right; x++) {
                    Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);
                    if (h) {
                        pixel.h = this.game.math.wrap(pixel.h + h, 0, 1);
                    }
                    if (s) {
                        pixel.s = this.game.math.limitValue(pixel.s + s, 0, 1);
                    }
                    if (l) {
                        pixel.l = this.game.math.limitValue(pixel.l + l, 0, 1);
                    }
                    Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);
                    this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);
                }
            }
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
            return this;
        },
        setPixel32: function(x, y, red, green, blue, alpha, immediate) {
            if (typeof immediate === "undefined") {
                immediate = true;
            }
            if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) {
                if (Phaser.Device.LITTLE_ENDIAN) {
                    this.pixels[y * this.width + x] = alpha << 24 | blue << 16 | green << 8 | red;
                } else {
                    this.pixels[y * this.width + x] = red << 24 | green << 16 | blue << 8 | alpha;
                }
                if (immediate) {
                    this.context.putImageData(this.imageData, 0, 0);
                    this.dirty = true;
                }
            }
            return this;
        },
        setPixel: function(x, y, red, green, blue, immediate) {
            return this.setPixel32(x, y, red, green, blue, 255, immediate);
        },
        getPixel: function(x, y, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            var index = ~~(x + y * this.width);
            index *= 4;
            out.r = this.data[index];
            out.g = this.data[++index];
            out.b = this.data[++index];
            out.a = this.data[++index];
            return out;
        },
        getPixel32: function(x, y) {
            if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) {
                return this.pixels[y * this.width + x];
            }
        },
        getPixelRGB: function(x, y, out, hsl, hsv) {
            return Phaser.Color.unpackPixel(this.getPixel32(x, y), out, hsl, hsv);
        },
        getPixels: function(rect) {
            return this.context.getImageData(rect.x, rect.y, rect.width, rect.height);
        },
        addToWorld: function(x, y, anchorX, anchorY, scaleX, scaleY) {
            scaleX = scaleX || 1;
            scaleY = scaleY || 1;
            var image = this.game.add.image(x, y, this);
            image.anchor.set(anchorX, anchorY);
            image.scale.set(scaleX, scaleY);
            return image;
        },
        copy: function(source, x, y, width, height, tx, ty, newWidth, newHeight, rotate, anchorX, anchorY, scaleX, scaleY, alpha, blendMode, roundPx) {
            if (typeof source === "undefined" || source === null) {
                source = this;
            }
            this._image = source;
            if (source instanceof Phaser.Sprite || source instanceof Phaser.Image || source instanceof Phaser.Text) {
                this._pos.set(source.texture.crop.x, source.texture.crop.y);
                this._size.set(source.texture.crop.width, source.texture.crop.height);
                this._scale.set(source.scale.x, source.scale.y);
                this._anchor.set(source.anchor.x, source.anchor.y);
                this._rotate = source.rotation;
                this._alpha.current = source.alpha;
                this._image = source.texture.baseTexture.source;
                if (source.texture.trim) {
                    tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width;
                    ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height;
                }
            } else {
                this._pos.set(0);
                this._scale.set(1);
                this._anchor.set(0);
                this._rotate = 0;
                this._alpha.current = 1;
                if (source instanceof Phaser.BitmapData) {
                    this._image = source.canvas;
                } else if (typeof source === "string") {
                    source = this.game.cache.getImage(source);
                    if (source === null) {
                        return;
                    } else {
                        this._image = source;
                    }
                }
                this._size.set(this._image.width, this._image.height);
            }
            if (typeof x === "undefined" || x === null) {
                x = 0;
            }
            if (typeof y === "undefined" || y === null) {
                y = 0;
            }
            if (width) {
                this._size.x = width;
            }
            if (height) {
                this._size.y = height;
            }
            if (typeof tx === "undefined" || tx === null) {
                tx = x;
            }
            if (typeof ty === "undefined" || ty === null) {
                ty = y;
            }
            if (typeof newWidth === "undefined" || newWidth === null) {
                newWidth = this._size.x;
            }
            if (typeof newHeight === "undefined" || newHeight === null) {
                newHeight = this._size.y;
            }
            if (typeof rotate === "number") {
                this._rotate = rotate;
            }
            if (typeof anchorX === "number") {
                this._anchor.x = anchorX;
            }
            if (typeof anchorY === "number") {
                this._anchor.y = anchorY;
            }
            if (typeof scaleX === "number") {
                this._scale.x = scaleX;
            }
            if (typeof scaleY === "number") {
                this._scale.y = scaleY;
            }
            if (typeof alpha === "number") {
                this._alpha.current = alpha;
            }
            if (typeof blendMode === "undefined") {
                blendMode = null;
            }
            if (typeof roundPx === "undefined") {
                roundPx = false;
            }
            if (this._alpha.current <= 0 || this._scale.x === 0 || this._scale.y === 0 || this._size.x === 0 || this._size.y === 0) {
                return;
            }
            this._alpha.prev = this.context.globalAlpha;
            this.context.save();
            this.context.globalAlpha = this._alpha.current;
            if (blendMode) {
                this.context.globalCompositeOperation = blendMode;
            }
            if (roundPx) {
                tx |= 0;
                ty |= 0;
            }
            this.context.translate(tx, ty);
            this.context.scale(this._scale.x, this._scale.y);
            this.context.rotate(this._rotate);
            this.context.drawImage(this._image, this._pos.x + x, this._pos.y + y, this._size.x, this._size.y, -newWidth * this._anchor.x, -newHeight * this._anchor.y, newWidth, newHeight);
            this.context.restore();
            this.context.globalAlpha = this._alpha.prev;
            this.dirty = true;
            return this;
        },
        copyRect: function(source, area, x, y, alpha, blendMode, roundPx) {
            return this.copy(source, area.x, area.y, area.width, area.height, x, y, area.width, area.height, 0, 0, 0, 1, 1, alpha, blendMode, roundPx);
        },
        draw: function(source, x, y, width, height, blendMode, roundPx) {
            return this.copy(source, null, null, null, null, x, y, width, height, null, null, null, null, null, null, blendMode, roundPx);
        },
        alphaMask: function(source, mask) {
            return this.draw(mask).blendSourceAtop().draw(source).blendReset();
        },
        extract: function(destination, r, g, b, a, resize, r2, g2, b2) {
            if (typeof a === "undefined") {
                a = 255;
            }
            if (typeof resize === "undefined") {
                resize = false;
            }
            if (typeof r2 === "undefined") {
                r2 = r;
            }
            if (typeof g2 === "undefined") {
                g2 = g;
            }
            if (typeof b2 === "undefined") {
                b2 = b;
            }
            if (resize) {
                destination.resize(this.width, this.height);
            }
            this.processPixelRGB(function(pixel, x, y) {
                if (pixel.r === r && pixel.g === g && pixel.b === b) {
                    destination.setPixel32(x, y, r2, g2, b2, a, false);
                }
                return false;
            }, this);
            destination.context.putImageData(destination.imageData, 0, 0);
            destination.dirty = true;
            return destination;
        },
        rect: function(x, y, width, height, fillStyle) {
            if (typeof fillStyle !== "undefined") {
                this.context.fillStyle = fillStyle;
            }
            this.context.fillRect(x, y, width, height);
            return this;
        },
        circle: function(x, y, radius, fillStyle) {
            if (typeof fillStyle !== "undefined") {
                this.context.fillStyle = fillStyle;
            }
            this.context.beginPath();
            this.context.arc(x, y, radius, 0, Math.PI * 2, false);
            this.context.closePath();
            this.context.fill();
            return this;
        },
        render: function() {
            if (!this.disableTextureUpload && this.game.renderType === Phaser.WEBGL && this.dirty) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
                this.dirty = false;
            }
            return this;
        },
        blendReset: function() {
            this.context.globalCompositeOperation = "source-over";
            return this;
        },
        blendSourceOver: function() {
            this.context.globalCompositeOperation = "source-over";
            return this;
        },
        blendSourceIn: function() {
            this.context.globalCompositeOperation = "source-in";
            return this;
        },
        blendSourceOut: function() {
            this.context.globalCompositeOperation = "source-out";
            return this;
        },
        blendSourceAtop: function() {
            this.context.globalCompositeOperation = "source-atop";
            return this;
        },
        blendDestinationOver: function() {
            this.context.globalCompositeOperation = "destination-over";
            return this;
        },
        blendDestinationIn: function() {
            this.context.globalCompositeOperation = "destination-in";
            return this;
        },
        blendDestinationOut: function() {
            this.context.globalCompositeOperation = "destination-out";
            return this;
        },
        blendDestinationAtop: function() {
            this.context.globalCompositeOperation = "destination-atop";
            return this;
        },
        blendXor: function() {
            this.context.globalCompositeOperation = "xor";
            return this;
        },
        blendAdd: function() {
            this.context.globalCompositeOperation = "lighter";
            return this;
        },
        blendMultiply: function() {
            this.context.globalCompositeOperation = "multiply";
            return this;
        },
        blendScreen: function() {
            this.context.globalCompositeOperation = "screen";
            return this;
        },
        blendOverlay: function() {
            this.context.globalCompositeOperation = "overlay";
            return this;
        },
        blendDarken: function() {
            this.context.globalCompositeOperation = "darken";
            return this;
        },
        blendLighten: function() {
            this.context.globalCompositeOperation = "lighten";
            return this;
        },
        blendColorDodge: function() {
            this.context.globalCompositeOperation = "color-dodge";
            return this;
        },
        blendColorBurn: function() {
            this.context.globalCompositeOperation = "color-burn";
            return this;
        },
        blendHardLight: function() {
            this.context.globalCompositeOperation = "hard-light";
            return this;
        },
        blendSoftLight: function() {
            this.context.globalCompositeOperation = "soft-light";
            return this;
        },
        blendDifference: function() {
            this.context.globalCompositeOperation = "difference";
            return this;
        },
        blendExclusion: function() {
            this.context.globalCompositeOperation = "exclusion";
            return this;
        },
        blendHue: function() {
            this.context.globalCompositeOperation = "hue";
            return this;
        },
        blendSaturation: function() {
            this.context.globalCompositeOperation = "saturation";
            return this;
        },
        blendColor: function() {
            this.context.globalCompositeOperation = "color";
            return this;
        },
        blendLuminosity: function() {
            this.context.globalCompositeOperation = "luminosity";
            return this;
        }
    };
    Object.defineProperty(Phaser.BitmapData.prototype, "smoothed", {
        get: function() {
            Phaser.Canvas.getSmoothingEnabled(this.context);
        },
        set: function(value) {
            Phaser.Canvas.setSmoothingEnabled(this.context, value);
        }
    });
    Phaser.BitmapData.getTransform = function(translateX, translateY, scaleX, scaleY, skewX, skewY) {
        if (typeof translateX !== "number") {
            translateX = 0;
        }
        if (typeof translateY !== "number") {
            translateY = 0;
        }
        if (typeof scaleX !== "number") {
            scaleX = 1;
        }
        if (typeof scaleY !== "number") {
            scaleY = 1;
        }
        if (typeof skewX !== "number") {
            skewX = 0;
        }
        if (typeof skewY !== "number") {
            skewY = 0;
        }
        return {
            sx: scaleX,
            sy: scaleY,
            scaleX: scaleX,
            scaleY: scaleY,
            skewX: skewX,
            skewY: skewY,
            translateX: translateX,
            translateY: translateY,
            tx: translateX,
            ty: translateY
        };
    };
    Phaser.BitmapData.prototype.constructor = Phaser.BitmapData;
    Phaser.Sprite = function(game, x, y, key, frame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.name = "";
        this.type = Phaser.SPRITE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        this.position.set(x, y);
        this.world = new Phaser.Point(x, y);
        this.autoCull = false;
        this.input = null;
        this.body = null;
        this.alive = true;
        this.health = 1;
        this.lifespan = 0;
        this.checkWorldBounds = false;
        this.outOfBoundsKill = false;
        this.debug = false;
        this.cameraOffset = new Phaser.Point();
        this.cropRect = null;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0 ];
        this._crop = null;
        this._frame = null;
        this._bounds = new Phaser.Rectangle();
        this.loadTexture(key, frame);
    };
    Phaser.Sprite.prototype = Object.create(PIXI.Sprite.prototype);
    Phaser.Sprite.prototype.constructor = Phaser.Sprite;
    Phaser.Sprite.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate();
            }
            this._cache[4] = 0;
            return false;
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.lifespan > 0) {
            this.lifespan -= this.game.time.elapsed;
            if (this.lifespan <= 0) {
                this.kill();
                return false;
            }
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds());
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this);
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this);
                if (this.outOfBoundsKill) {
                    this.kill();
                    return false;
                }
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        this.animations.update();
        if (this.body) {
            this.body.preUpdate();
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Sprite.prototype.update = function() {};
    Phaser.Sprite.prototype.postUpdate = function() {
        if (this.key instanceof Phaser.BitmapData) {
            this.key.render();
        }
        if (this.exists && this.body) {
            this.body.postUpdate();
        }
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Sprite.prototype.loadTexture = function(key, frame, stopAnimation) {
        frame = frame || 0;
        if (stopAnimation || typeof stopAnimation === "undefined") {
            this.animations.stop();
        }
        this.key = key;
        var setFrame = true;
        var smoothed = this.smoothed;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
        if (setFrame) {
            this._frame = Phaser.Rectangle.clone(this.texture.frame);
        }
        if (!smoothed) {
            this.smoothed = false;
        }
    };
    Phaser.Sprite.prototype.setFrame = function(frame) {
        this._frame = frame;
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.cropRect) {
            this.updateCrop();
        } else {
            if (this.game.renderType === Phaser.WEBGL) {
                PIXI.WebGLRenderer.updateTextureFrame(this.texture);
            }
        }
    };
    Phaser.Sprite.prototype.resetFrame = function() {
        if (this._frame) {
            this.setFrame(this._frame);
        }
    };
    Phaser.Sprite.prototype.crop = function(rect, copy) {
        if (typeof copy === "undefined") {
            copy = false;
        }
        if (rect) {
            if (copy && this.cropRect !== null) {
                this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height);
            } else if (copy && this.cropRect === null) {
                this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height);
            } else {
                this.cropRect = rect;
            }
            this.updateCrop();
        } else {
            this._crop = null;
            this.cropRect = null;
            this.resetFrame();
        }
    };
    Phaser.Sprite.prototype.updateCrop = function() {
        if (!this.cropRect) {
            return;
        }
        this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop);
        this._crop.x += this._frame.x;
        this._crop.y += this._frame.y;
        var cx = Math.max(this._frame.x, this._crop.x);
        var cy = Math.max(this._frame.y, this._crop.y);
        var cw = Math.min(this._frame.right, this._crop.right) - cx;
        var ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;
        this.texture.crop.x = cx;
        this.texture.crop.y = cy;
        this.texture.crop.width = cw;
        this.texture.crop.height = ch;
        this.texture.frame.width = Math.min(cw, this.cropRect.width);
        this.texture.frame.height = Math.min(ch, this.cropRect.height);
        this.texture.width = this.texture.frame.width;
        this.texture.height = this.texture.frame.height;
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.Sprite.prototype.revive = function(health) {
        if (typeof health === "undefined") {
            health = 1;
        }
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.health = health;
        if (this.events) {
            this.events.onRevived.dispatch(this);
        }
        return this;
    };
    Phaser.Sprite.prototype.kill = function() {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
            this.events.onKilled.dispatch(this);
        }
        return this;
    };
    Phaser.Sprite.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this._cache[8] === 1) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        if (this.input) {
            this.input.destroy();
        }
        if (this.animations) {
            this.animations.destroy();
        }
        if (this.body) {
            this.body.destroy();
        }
        if (this.events) {
            this.events.destroy();
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        if (this._crop) {
            this._crop = null;
        }
        if (this._frame) {
            this._frame = null;
        }
        this.alive = false;
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Sprite.prototype.damage = function(amount) {
        if (this.alive) {
            this.health -= amount;
            if (this.health <= 0) {
                this.kill();
            }
        }
        return this;
    };
    Phaser.Sprite.prototype.reset = function(x, y, health) {
        if (typeof health === "undefined") {
            health = 1;
        }
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.health = health;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        return this;
    };
    Phaser.Sprite.prototype.bringToTop = function() {
        if (this.parent) {
            this.parent.bringToTop(this);
        }
        return this;
    };
    Phaser.Sprite.prototype.play = function(name, frameRate, loop, killOnComplete) {
        if (this.animations) {
            return this.animations.play(name, frameRate, loop, killOnComplete);
        }
    };
    Phaser.Sprite.prototype.overlap = function(displayObject) {
        return Phaser.Rectangle.intersects(this.getBounds(), displayObject.getBounds());
    };
    Object.defineProperty(Phaser.Sprite.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "frame", {
        get: function() {
            return this.animations.frame;
        },
        set: function(value) {
            this.animations.frame = value;
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "frameName", {
        get: function() {
            return this.animations.frameName;
        },
        set: function(value) {
            this.animations.frameName = value;
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3];
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6];
        },
        set: function(value) {
            if (value) {
                this._cache[6] = 1;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.addToWorld();
                }
                this.visible = true;
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.removeFromWorld();
                }
                this.visible = false;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode;
        },
        set: function(value) {
            if (value) {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 0;
                }
            } else {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 1;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Sprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Image = function(game, x, y, key, frame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.IMAGE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        PIXI.Sprite.call(this, PIXI.TextureCache["__default"]);
        this.position.set(x, y);
        this.world = new Phaser.Point(x, y);
        this.alive = true;
        this.autoCull = false;
        this.input = null;
        this.debug = false;
        this.cameraOffset = new Phaser.Point();
        this.cropRect = null;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        this._crop = null;
        this._frame = null;
        this._bounds = new Phaser.Rectangle();
        this.loadTexture(key, frame);
    };
    Phaser.Image.prototype = Object.create(PIXI.Sprite.prototype);
    Phaser.Image.prototype.constructor = Phaser.Image;
    Phaser.Image.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.autoCull) {
            this._bounds.copyFrom(this.getBounds());
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Image.prototype.update = function() {};
    Phaser.Image.prototype.postUpdate = function() {
        if (this.key instanceof Phaser.BitmapData) {
            this.key.render();
        }
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Image.prototype.loadTexture = function(key, frame) {
        frame = frame || 0;
        this.key = key;
        var setFrame = true;
        var smoothed = this.smoothed;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                setFrame = !this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
        if (setFrame) {
            this._frame = Phaser.Rectangle.clone(this.texture.frame);
        }
        if (!smoothed) {
            this.smoothed = false;
        }
    };
    Phaser.Image.prototype.setFrame = function(frame) {
        this._frame = frame;
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.cropRect) {
            this.updateCrop();
        } else {
            if (this.game.renderType === Phaser.WEBGL) {
                PIXI.WebGLRenderer.updateTextureFrame(this.texture);
            }
        }
    };
    Phaser.Image.prototype.resetFrame = function() {
        if (this._frame) {
            this.setFrame(this._frame);
        }
    };
    Phaser.Image.prototype.crop = function(rect, copy) {
        if (typeof copy === "undefined") {
            copy = false;
        }
        if (rect) {
            if (copy && this.cropRect !== null) {
                this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height);
            } else if (copy && this.cropRect === null) {
                this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height);
            } else {
                this.cropRect = rect;
            }
            this.updateCrop();
        } else {
            this._crop = null;
            this.cropRect = null;
            this.resetFrame();
        }
    };
    Phaser.Image.prototype.updateCrop = function() {
        if (!this.cropRect) {
            return;
        }
        this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop);
        this._crop.x += this._frame.x;
        this._crop.y += this._frame.y;
        var cx = Math.max(this._frame.x, this._crop.x);
        var cy = Math.max(this._frame.y, this._crop.y);
        var cw = Math.min(this._frame.right, this._crop.right) - cx;
        var ch = Math.min(this._frame.bottom, this._crop.bottom) - cy;
        this.texture.crop.x = cx;
        this.texture.crop.y = cy;
        this.texture.crop.width = cw;
        this.texture.crop.height = ch;
        this.texture.frame.width = Math.min(cw, this.cropRect.width);
        this.texture.frame.height = Math.min(ch, this.cropRect.height);
        this.texture.width = this.texture.frame.width;
        this.texture.height = this.texture.frame.height;
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.Image.prototype.revive = function() {
        this.alive = true;
        this.exists = true;
        this.visible = true;
        if (this.events) {
            this.events.onRevived.dispatch(this);
        }
        return this;
    };
    Phaser.Image.prototype.kill = function() {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
            this.events.onKilled.dispatch(this);
        }
        return this;
    };
    Phaser.Image.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        if (this.events) {
            this.events.destroy();
        }
        if (this.input) {
            this.input.destroy();
        }
        if (this.animations) {
            this.animations.destroy();
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.alive = false;
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Image.prototype.reset = function(x, y) {
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        return this;
    };
    Phaser.Image.prototype.bringToTop = function() {
        if (this.parent) {
            this.parent.bringToTop(this);
        }
        return this;
    };
    Object.defineProperty(Phaser.Image.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "deltaX", {
        get: function() {
            return this.world.x - this._cache[0];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "deltaY", {
        get: function() {
            return this.world.y - this._cache[1];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "deltaZ", {
        get: function() {
            return this.rotation - this._cache[2];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "inWorld", {
        get: function() {
            return this.game.world.bounds.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "inCamera", {
        get: function() {
            return this.game.world.camera.screenView.intersects(this.getBounds());
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "frame", {
        get: function() {
            return this._frame;
        },
        set: function(value) {
            if (value !== this.frame) {
                var frameData = this.game.cache.getFrameData(this.key);
                if (frameData && value < frameData.total && frameData.getFrame(value)) {
                    this.setTexture(PIXI.TextureCache[frameData.getFrame(value).uuid]);
                    this._frame = value;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "frameName", {
        get: function() {
            return this._frameName;
        },
        set: function(value) {
            if (value !== this.frameName) {
                var frameData = this.game.cache.getFrameData(this.key);
                if (frameData && frameData.getFrameByName(value)) {
                    this.setTexture(PIXI.TextureCache[frameData.getFrameByName(value).uuid]);
                    this._frameName = value;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "renderOrderID", {
        get: function() {
            return this._cache[3];
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "smoothed", {
        get: function() {
            return !this.texture.baseTexture.scaleMode;
        },
        set: function(value) {
            if (value) {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 0;
                }
            } else {
                if (this.texture) {
                    this.texture.baseTexture.scaleMode = 1;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Image.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.TileSprite = function(game, x, y, width, height, key, frame) {
        x = x || 0;
        y = y || 0;
        width = width || 256;
        height = height || 256;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.name = "";
        this.type = Phaser.TILESPRITE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        this._frame = 0;
        this._frameName = "";
        this._scroll = new Phaser.Point();
        PIXI.TilingSprite.call(this, PIXI.TextureCache["__default"], width, height);
        this.position.set(x, y);
        this.input = null;
        this.world = new Phaser.Point(x, y);
        this.autoCull = false;
        this.checkWorldBounds = false;
        this.cameraOffset = new Phaser.Point();
        this.body = null;
        this.alive = true;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        this.loadTexture(key, frame);
    };
    Phaser.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype);
    Phaser.TileSprite.prototype.constructor = Phaser.TileSprite;
    Phaser.TileSprite.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate();
            }
            this._cache[4] = 0;
            return false;
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds());
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this);
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this);
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        this.animations.update();
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (this.body) {
            this.body.preUpdate();
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.TileSprite.prototype.update = function() {};
    Phaser.TileSprite.prototype.postUpdate = function() {
        if (this.exists && this.body) {
            this.body.postUpdate();
        }
        if (this._cache[7] === 1) {
            this.position.x = this.game.camera.view.x + this.cameraOffset.x;
            this.position.y = this.game.camera.view.y + this.cameraOffset.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.TileSprite.prototype.autoScroll = function(x, y) {
        this._scroll.set(x, y);
    };
    Phaser.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0);
    };
    Phaser.TileSprite.prototype.loadTexture = function(key, frame) {
        frame = frame || 0;
        this.key = key;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
    };
    Phaser.TileSprite.prototype.setFrame = function(frame) {
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.TileSprite.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.filters) {
            this.filters = null;
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        this.animations.destroy();
        this.events.destroy();
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.alive = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.TileSprite.prototype.play = function(name, frameRate, loop, killOnComplete) {
        return this.animations.play(name, frameRate, loop, killOnComplete);
    };
    Phaser.TileSprite.prototype.reset = function(x, y) {
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        return this;
    };
    Object.defineProperty(Phaser.TileSprite.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "frame", {
        get: function() {
            return this.animations.frame;
        },
        set: function(value) {
            if (value !== this.animations.frame) {
                this.animations.frame = value;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "frameName", {
        get: function() {
            return this.animations.frameName;
        },
        set: function(value) {
            if (value !== this.animations.frameName) {
                this.animations.frameName = value;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "exists", {
        get: function() {
            return !!this._cache[6];
        },
        set: function(value) {
            if (value) {
                this._cache[6] = 1;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.addToWorld();
                }
                this.visible = true;
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.safeRemove = true;
                }
                this.visible = false;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.TileSprite.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Rope = function(game, x, y, key, frame, points) {
        this.points = [];
        this.points = points;
        this._hasUpdateAnimation = false;
        this._updateAnimationCallback = null;
        x = x || 0;
        y = y || 0;
        key = key || null;
        frame = frame || null;
        this.game = game;
        this.name = "";
        this.type = Phaser.ROPE;
        this.z = 0;
        this.events = new Phaser.Events(this);
        this.animations = new Phaser.AnimationManager(this);
        this.key = key;
        this._frame = 0;
        this._frameName = "";
        this._scroll = new Phaser.Point();
        PIXI.Rope.call(this, key, this.points);
        this.position.set(x, y);
        this.input = null;
        this.world = new Phaser.Point(x, y);
        this.autoCull = false;
        this.checkWorldBounds = false;
        this.cameraOffset = new Phaser.Point();
        this.body = null;
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        this.loadTexture(key, frame);
    };
    Phaser.Rope.prototype = Object.create(PIXI.Rope.prototype);
    Phaser.Rope.prototype.constructor = Phaser.Rope;
    Phaser.Rope.prototype.preUpdate = function() {
        if (this._cache[4] === 1 && this.exists) {
            this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);
            this.worldTransform.tx = this.world.x;
            this.worldTransform.ty = this.world.y;
            this._cache[0] = this.world.x;
            this._cache[1] = this.world.y;
            this._cache[2] = this.rotation;
            if (this.body) {
                this.body.preUpdate();
            }
            this._cache[4] = 0;
            return false;
        }
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this._cache[3] = -1;
            return false;
        }
        if (this.autoCull || this.checkWorldBounds) {
            this._bounds.copyFrom(this.getBounds());
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this._bounds);
        }
        if (this.checkWorldBounds) {
            if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 0;
                this.events.onEnterBounds.dispatch(this);
            } else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds)) {
                this._cache[5] = 1;
                this.events.onOutOfBounds.dispatch(this);
            }
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        this.animations.update();
        if (this._scroll.x !== 0) {
            this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
        }
        if (this._scroll.y !== 0) {
            this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
        }
        if (this.body) {
            this.body.preUpdate();
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Rope.prototype.update = function() {
        if (this._hasUpdateAnimation) {
            this.updateAnimation.call(this);
        }
    };
    Phaser.Rope.prototype.postUpdate = function() {
        if (this.exists && this.body) {
            this.body.postUpdate();
        }
        if (this._cache[7] === 1) {
            this.position.x = this.game.camera.view.x + this.cameraOffset.x;
            this.position.y = this.game.camera.view.y + this.cameraOffset.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Rope.prototype.loadTexture = function(key, frame) {
        frame = frame || 0;
        this.key = key;
        if (key instanceof Phaser.RenderTexture) {
            this.key = key.key;
            this.setTexture(key);
        } else if (key instanceof Phaser.BitmapData) {
            this.setTexture(key.texture);
        } else if (key instanceof PIXI.Texture) {
            this.setTexture(key);
        } else {
            if (key === null || typeof key === "undefined") {
                this.key = "__default";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else if (typeof key === "string" && !this.game.cache.checkImageKey(key)) {
                console.warn("Texture with key '" + key + "' not found.");
                this.key = "__missing";
                this.setTexture(PIXI.TextureCache[this.key]);
            } else {
                this.setTexture(new PIXI.Texture(PIXI.BaseTextureCache[key]));
                this.animations.loadFrameData(this.game.cache.getFrameData(key), frame);
            }
        }
    };
    Phaser.Rope.prototype.setFrame = function(frame) {
        this.texture.frame.x = frame.x;
        this.texture.frame.y = frame.y;
        this.texture.frame.width = frame.width;
        this.texture.frame.height = frame.height;
        this.texture.crop.x = frame.x;
        this.texture.crop.y = frame.y;
        this.texture.crop.width = frame.width;
        this.texture.crop.height = frame.height;
        if (frame.trimmed) {
            if (this.texture.trim) {
                this.texture.trim.x = frame.spriteSourceSizeX;
                this.texture.trim.y = frame.spriteSourceSizeY;
                this.texture.trim.width = frame.sourceSizeW;
                this.texture.trim.height = frame.sourceSizeH;
            } else {
                this.texture.trim = {
                    x: frame.spriteSourceSizeX,
                    y: frame.spriteSourceSizeY,
                    width: frame.sourceSizeW,
                    height: frame.sourceSizeH
                };
            }
            this.texture.width = frame.sourceSizeW;
            this.texture.height = frame.sourceSizeH;
            this.texture.frame.width = frame.sourceSizeW;
            this.texture.frame.height = frame.sourceSizeH;
        }
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.WebGLRenderer.updateTextureFrame(this.texture);
        }
    };
    Phaser.Rope.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.filters) {
            this.filters = null;
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        this.animations.destroy();
        this.events.destroy();
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Rope.prototype.play = function(name, frameRate, loop, killOnComplete) {
        return this.animations.play(name, frameRate, loop, killOnComplete);
    };
    Phaser.Rope.prototype.reset = function(x, y) {
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.tilePosition.x = 0;
        this.tilePosition.y = 0;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        return this;
    };
    Object.defineProperty(Phaser.Rope.prototype, "angle", {
        get: function() {
            return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "frame", {
        get: function() {
            return this.animations.frame;
        },
        set: function(value) {
            if (value !== this.animations.frame) {
                this.animations.frame = value;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "frameName", {
        get: function() {
            return this.animations.frameName;
        },
        set: function(value) {
            if (value !== this.animations.frameName) {
                this.animations.frameName = value;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "exists", {
        get: function() {
            return !!this._cache[6];
        },
        set: function(value) {
            if (value) {
                this._cache[6] = 1;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.addToWorld();
                }
                this.visible = true;
            } else {
                this._cache[6] = 0;
                if (this.body && this.body.type === Phaser.Physics.P2JS) {
                    this.body.safeRemove = true;
                }
                this.visible = false;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
            if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2) {
                this.body._reset = 1;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation;
        },
        set: function(value) {
            if (value && typeof value === "function") {
                this._hasUpdateAnimation = true;
                this._updateAnimation = value;
            } else {
                this._hasUpdateAnimation = false;
                this._updateAnimation = null;
            }
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "segments", {
        get: function() {
            var segments = [];
            var index, x1, y1, x2, y2, width, height, rect;
            for (var i = 0; i < this.points.length; i++) {
                index = i * 4;
                x1 = this.verticies[index];
                y1 = this.verticies[index + 1];
                x2 = this.verticies[index + 4];
                y2 = this.verticies[index + 3];
                width = Phaser.Math.difference(x1, x2);
                height = Phaser.Math.difference(y1, y2);
                x1 += this.world.x;
                y1 += this.world.y;
                rect = new Phaser.Rectangle(x1, y1, width, height);
                segments.push(rect);
            }
            return segments;
        }
    });
    Object.defineProperty(Phaser.Rope.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Text = function(game, x, y, text, style) {
        x = x || 0;
        y = y || 0;
        text = text || " ";
        style = style || {};
        if (text.length === 0) {
            text = " ";
        } else {
            text = text.toString();
        }
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.TEXT;
        this.z = 0;
        this.world = new Phaser.Point(x, y);
        this._text = text;
        this._font = "";
        this._fontSize = 32;
        this._fontWeight = "normal";
        this._lineSpacing = 0;
        this.events = new Phaser.Events(this);
        this.input = null;
        this.cameraOffset = new Phaser.Point();
        this.setStyle(style);
        PIXI.Text.call(this, text, this.style);
        this.position.set(x, y);
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
        if (text !== " ") {
            this.updateText();
        }
    };
    Phaser.Text.prototype = Object.create(PIXI.Text.prototype);
    Phaser.Text.prototype.constructor = Phaser.Text;
    Phaser.Text.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].preUpdate();
        }
        return true;
    };
    Phaser.Text.prototype.update = function() {};
    Phaser.Text.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
        for (var i = 0, len = this.children.length; i < len; i++) {
            this.children[i].postUpdate();
        }
    };
    Phaser.Text.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.events) {
            this.events.onDestroy.dispatch(this);
        }
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        this.texture.destroy(true);
        if (this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        } else {
            this.canvas = null;
            this.context = null;
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Text.prototype.setShadow = function(x, y, color, blur) {
        this.style.shadowOffsetX = x || 0;
        this.style.shadowOffsetY = y || 0;
        this.style.shadowColor = color || "rgba(0,0,0,0)";
        this.style.shadowBlur = blur || 0;
        this.dirty = true;
    };
    Phaser.Text.prototype.setStyle = function(style) {
        style = style || {};
        style.font = style.font || "bold 20pt Arial";
        style.fill = style.fill || "black";
        style.align = style.align || "left";
        style.stroke = style.stroke || "black";
        style.strokeThickness = style.strokeThickness || 0;
        style.wordWrap = style.wordWrap || false;
        style.wordWrapWidth = style.wordWrapWidth || 100;
        style.shadowOffsetX = style.shadowOffsetX || 0;
        style.shadowOffsetY = style.shadowOffsetY || 0;
        style.shadowColor = style.shadowColor || "rgba(0,0,0,0)";
        style.shadowBlur = style.shadowBlur || 0;
        this.style = style;
        this.dirty = true;
    };
    Phaser.Text.prototype.updateText = function() {
        this.context.font = this.style.font;
        var outputText = this.text;
        if (this.style.wordWrap) {
            outputText = this.runWordWrap(this.text);
        }
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = [];
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = this.context.measureText(lines[i]).width;
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        this.canvas.width = maxLineWidth + this.style.strokeThickness;
        var lineHeight = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness + this._lineSpacing + this.style.shadowOffsetY;
        this.canvas.height = lineHeight * lines.length;
        if (navigator.isCocoonJS) {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        this.context.fillStyle = this.style.fill;
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.shadowOffsetX = this.style.shadowOffsetX;
        this.context.shadowOffsetY = this.style.shadowOffsetY;
        this.context.shadowColor = this.style.shadowColor;
        this.context.shadowBlur = this.style.shadowBlur;
        this.context.textBaseline = "top";
        this.context.lineCap = "round";
        this.context.lineJoin = "round";
        for (i = 0; i < lines.length; i++) {
            var linePosition = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + i * lineHeight);
            if (this.style.align === "right") {
                linePosition.x += maxLineWidth - lineWidths[i];
            } else if (this.style.align === "center") {
                linePosition.x += (maxLineWidth - lineWidths[i]) / 2;
            }
            linePosition.y += this._lineSpacing;
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(lines[i], linePosition.x, linePosition.y);
            }
            if (this.style.fill) {
                this.context.fillText(lines[i], linePosition.x, linePosition.y);
            }
        }
        this.updateTexture();
    };
    Phaser.Text.prototype.runWordWrap = function(text) {
        var result = "";
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var spaceLeft = this.style.wordWrapWidth;
            var words = lines[i].split(" ");
            for (var j = 0; j < words.length; j++) {
                var wordWidth = this.context.measureText(words[j]).width;
                var wordWidthWithSpace = wordWidth + this.context.measureText(" ").width;
                if (wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                        result += "\n";
                    }
                    result += words[j] + " ";
                    spaceLeft = this.style.wordWrapWidth - wordWidth;
                } else {
                    spaceLeft -= wordWidthWithSpace;
                    result += words[j] + " ";
                }
            }
            if (i < lines.length - 1) {
                result += "\n";
            }
        }
        return result;
    };
    Object.defineProperty(Phaser.Text.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            if (value !== this._text) {
                this._text = value.toString() || " ";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "font", {
        get: function() {
            return this._font;
        },
        set: function(value) {
            if (value !== this._font) {
                this._font = value.trim();
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontSize", {
        get: function() {
            return this._fontSize;
        },
        set: function(value) {
            value = parseInt(value, 10);
            if (value !== this._fontSize) {
                this._fontSize = value;
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontWeight;
        },
        set: function(value) {
            if (value !== this._fontWeight) {
                this._fontWeight = value;
                this.style.font = this._fontWeight + " " + this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fill", {
        get: function() {
            return this.style.fill;
        },
        set: function(value) {
            if (value !== this.style.fill) {
                this.style.fill = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "align", {
        get: function() {
            return this.style.align;
        },
        set: function(value) {
            if (value !== this.style.align) {
                this.style.align = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke;
        },
        set: function(value) {
            if (value !== this.style.stroke) {
                this.style.stroke = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness;
        },
        set: function(value) {
            if (value !== this.style.strokeThickness) {
                this.style.strokeThickness = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap;
        },
        set: function(value) {
            if (value !== this.style.wordWrap) {
                this.style.wordWrap = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth;
        },
        set: function(value) {
            if (value !== this.style.wordWrapWidth) {
                this.style.wordWrapWidth = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing;
        },
        set: function(value) {
            if (value !== this._lineSpacing) {
                this._lineSpacing = parseFloat(value);
                this.dirty = true;
                this.updateTransform();
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX;
        },
        set: function(value) {
            if (value !== this.style.shadowOffsetX) {
                this.style.shadowOffsetX = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY;
        },
        set: function(value) {
            if (value !== this.style.shadowOffsetY) {
                this.style.shadowOffsetY = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor;
        },
        set: function(value) {
            if (value !== this.style.shadowColor) {
                this.style.shadowColor = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur;
        },
        set: function(value) {
            if (value !== this.style.shadowBlur) {
                this.style.shadowBlur = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Text.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.BitmapText = function(game, x, y, font, text, size) {
        x = x || 0;
        y = y || 0;
        font = font || "";
        text = text || "";
        size = size || 32;
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.BITMAPTEXT;
        this.z = 0;
        this.world = new Phaser.Point(x, y);
        this._text = text;
        this._font = font;
        this._fontSize = size;
        this._align = "left";
        this._tint = 16777215;
        this.events = new Phaser.Events(this);
        this.input = null;
        this.cameraOffset = new Phaser.Point();
        PIXI.BitmapText.call(this, text);
        this.position.set(x, y);
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
    };
    Phaser.BitmapText.prototype = Object.create(PIXI.BitmapText.prototype);
    Phaser.BitmapText.prototype.constructor = Phaser.BitmapText;
    Phaser.BitmapText.prototype.setStyle = function() {
        this.style = {
            align: this._align
        };
        this.fontName = this._font;
        this.fontSize = this._fontSize;
        this.dirty = true;
    };
    Phaser.BitmapText.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        return true;
    };
    Phaser.BitmapText.prototype.update = function() {};
    Phaser.BitmapText.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
    };
    Phaser.BitmapText.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                if (this.children[i].destroy) {
                    this.children[i].destroy(destroyChildren);
                } else {
                    this.removeChild(this.children[i]);
                }
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.filters = null;
        this.mask = null;
        this.game = null;
        this._cache[8] = 0;
    };
    Object.defineProperty(Phaser.BitmapText.prototype, "align", {
        get: function() {
            return this._align;
        },
        set: function(value) {
            if (value !== this._align) {
                this._align = value;
                this.setStyle();
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint;
        },
        set: function(value) {
            if (value !== this._tint) {
                this._tint = value;
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "font", {
        get: function() {
            return this._font;
        },
        set: function(value) {
            if (value !== this._font) {
                this._font = value.trim();
                this.style.font = this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize;
        },
        set: function(value) {
            value = parseInt(value, 10);
            if (value !== this._fontSize) {
                this._fontSize = value;
                this.style.font = this._fontSize + "px '" + this._font + "'";
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            if (value !== this._text) {
                this._text = value.toString() || " ";
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "inputEnabled", {
        get: function() {
            return this.input && this.input.enabled;
        },
        set: function(value) {
            if (value) {
                if (this.input === null) {
                    this.input = new Phaser.InputHandler(this);
                    this.input.start();
                } else if (this.input && !this.input.enabled) {
                    this.input.start();
                }
            } else {
                if (this.input && this.input.enabled) {
                    this.input.stop();
                }
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.BitmapText.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.Button = function(game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {
        x = x || 0;
        y = y || 0;
        key = key || null;
        callback = callback || null;
        callbackContext = callbackContext || this;
        Phaser.Image.call(this, game, x, y, key, outFrame);
        this.type = Phaser.BUTTON;
        this._onOverFrameName = null;
        this._onOutFrameName = null;
        this._onDownFrameName = null;
        this._onUpFrameName = null;
        this._onOverFrameID = null;
        this._onOutFrameID = null;
        this._onDownFrameID = null;
        this._onUpFrameID = null;
        this.onOverMouseOnly = false;
        this.onOverSound = null;
        this.onOutSound = null;
        this.onDownSound = null;
        this.onUpSound = null;
        this.onOverSoundMarker = "";
        this.onOutSoundMarker = "";
        this.onDownSoundMarker = "";
        this.onUpSoundMarker = "";
        this.onInputOver = new Phaser.Signal();
        this.onInputOut = new Phaser.Signal();
        this.onInputDown = new Phaser.Signal();
        this.onInputUp = new Phaser.Signal();
        this.freezeFrames = false;
        this.forceOut = false;
        this.inputEnabled = true;
        this.input.start(0, true);
        this.setFrames(overFrame, outFrame, downFrame, upFrame);
        if (callback !== null) {
            this.onInputUp.add(callback, callbackContext);
        }
        this.events.onInputOver.add(this.onInputOverHandler, this);
        this.events.onInputOut.add(this.onInputOutHandler, this);
        this.events.onInputDown.add(this.onInputDownHandler, this);
        this.events.onInputUp.add(this.onInputUpHandler, this);
    };
    Phaser.Button.prototype = Object.create(Phaser.Image.prototype);
    Phaser.Button.prototype.constructor = Phaser.Button;
    Phaser.Button.prototype.clearFrames = function() {
        this._onOverFrameName = null;
        this._onOverFrameID = null;
        this._onOutFrameName = null;
        this._onOutFrameID = null;
        this._onDownFrameName = null;
        this._onDownFrameID = null;
        this._onUpFrameName = null;
        this._onUpFrameID = null;
    };
    Phaser.Button.prototype.setFrames = function(overFrame, outFrame, downFrame, upFrame) {
        this.clearFrames();
        if (overFrame !== null) {
            if (typeof overFrame === "string") {
                this._onOverFrameName = overFrame;
                if (this.input.pointerOver()) {
                    this.frameName = overFrame;
                }
            } else {
                this._onOverFrameID = overFrame;
                if (this.input.pointerOver()) {
                    this.frame = overFrame;
                }
            }
        }
        if (outFrame !== null) {
            if (typeof outFrame === "string") {
                this._onOutFrameName = outFrame;
                if (this.input.pointerOver() === false) {
                    this.frameName = outFrame;
                }
            } else {
                this._onOutFrameID = outFrame;
                if (this.input.pointerOver() === false) {
                    this.frame = outFrame;
                }
            }
        }
        if (downFrame !== null) {
            if (typeof downFrame === "string") {
                this._onDownFrameName = downFrame;
                if (this.input.pointerDown()) {
                    this.frameName = downFrame;
                }
            } else {
                this._onDownFrameID = downFrame;
                if (this.input.pointerDown()) {
                    this.frame = downFrame;
                }
            }
        }
        if (upFrame !== null) {
            if (typeof upFrame === "string") {
                this._onUpFrameName = upFrame;
                if (this.input.pointerUp()) {
                    this.frameName = upFrame;
                }
            } else {
                this._onUpFrameID = upFrame;
                if (this.input.pointerUp()) {
                    this.frame = upFrame;
                }
            }
        }
    };
    Phaser.Button.prototype.setSounds = function(overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {
        this.setOverSound(overSound, overMarker);
        this.setOutSound(outSound, outMarker);
        this.setDownSound(downSound, downMarker);
        this.setUpSound(upSound, upMarker);
    };
    Phaser.Button.prototype.setOverSound = function(sound, marker) {
        this.onOverSound = null;
        this.onOverSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onOverSound = sound;
        }
        if (typeof marker === "string") {
            this.onOverSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.setOutSound = function(sound, marker) {
        this.onOutSound = null;
        this.onOutSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onOutSound = sound;
        }
        if (typeof marker === "string") {
            this.onOutSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.setDownSound = function(sound, marker) {
        this.onDownSound = null;
        this.onDownSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onDownSound = sound;
        }
        if (typeof marker === "string") {
            this.onDownSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.setUpSound = function(sound, marker) {
        this.onUpSound = null;
        this.onUpSoundMarker = "";
        if (sound instanceof Phaser.Sound) {
            this.onUpSound = sound;
        }
        if (typeof marker === "string") {
            this.onUpSoundMarker = marker;
        }
    };
    Phaser.Button.prototype.onInputOverHandler = function(sprite, pointer) {
        if (this.freezeFrames === false) {
            this.setState(1);
        }
        if (this.onOverMouseOnly && !pointer.isMouse) {
            return;
        }
        if (this.onOverSound) {
            this.onOverSound.play(this.onOverSoundMarker);
        }
        if (this.onInputOver) {
            this.onInputOver.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputOutHandler = function(sprite, pointer) {
        if (this.freezeFrames === false) {
            this.setState(2);
        }
        if (this.onOutSound) {
            this.onOutSound.play(this.onOutSoundMarker);
        }
        if (this.onInputOut) {
            this.onInputOut.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputDownHandler = function(sprite, pointer) {
        if (this.freezeFrames === false) {
            this.setState(3);
        }
        if (this.onDownSound) {
            this.onDownSound.play(this.onDownSoundMarker);
        }
        if (this.onInputDown) {
            this.onInputDown.dispatch(this, pointer);
        }
    };
    Phaser.Button.prototype.onInputUpHandler = function(sprite, pointer, isOver) {
        if (this.onUpSound) {
            this.onUpSound.play(this.onUpSoundMarker);
        }
        if (this.onInputUp) {
            this.onInputUp.dispatch(this, pointer, isOver);
        }
        if (this.freezeFrames) {
            return;
        }
        if (this.forceOut) {
            this.setState(2);
        } else {
            if (this._onUpFrameName !== null || this._onUpFrameID !== null) {
                this.setState(4);
            } else {
                if (isOver) {
                    this.setState(1);
                } else {
                    this.setState(2);
                }
            }
        }
    };
    Phaser.Button.prototype.setState = function(newState) {
        if (newState === 1) {
            if (this._onOverFrameName != null) {
                this.frameName = this._onOverFrameName;
            } else if (this._onOverFrameID != null) {
                this.frame = this._onOverFrameID;
            }
        } else if (newState === 2) {
            if (this._onOutFrameName != null) {
                this.frameName = this._onOutFrameName;
            } else if (this._onOutFrameID != null) {
                this.frame = this._onOutFrameID;
            }
        } else if (newState === 3) {
            if (this._onDownFrameName != null) {
                this.frameName = this._onDownFrameName;
            } else if (this._onDownFrameID != null) {
                this.frame = this._onDownFrameID;
            }
        } else if (newState === 4) {
            if (this._onUpFrameName != null) {
                this.frameName = this._onUpFrameName;
            } else if (this._onUpFrameID != null) {
                this.frame = this._onUpFrameID;
            }
        }
    };
    Phaser.Graphics = function(game, x, y) {
        x = x || 0;
        y = y || 0;
        this.game = game;
        this.exists = true;
        this.name = "";
        this.type = Phaser.GRAPHICS;
        this.z = 0;
        this.world = new Phaser.Point(x, y);
        this.cameraOffset = new Phaser.Point();
        PIXI.Graphics.call(this);
        this.position.set(x, y);
        this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];
    };
    Phaser.Graphics.prototype = Object.create(PIXI.Graphics.prototype);
    Phaser.Graphics.prototype.constructor = Phaser.Graphics;
    Phaser.Graphics.prototype.preUpdate = function() {
        this._cache[0] = this.world.x;
        this._cache[1] = this.world.y;
        this._cache[2] = this.rotation;
        if (!this.exists || !this.parent.exists) {
            this.renderOrderID = -1;
            return false;
        }
        if (this.autoCull) {
            this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());
        }
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
        if (this.visible) {
            this._cache[3] = this.game.stage.currentRenderOrderID++;
        }
        return true;
    };
    Phaser.Graphics.prototype.update = function() {};
    Phaser.Graphics.prototype.postUpdate = function() {
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
    };
    Phaser.Graphics.prototype.destroy = function(destroyChildren) {
        if (this.game === null || this.destroyPhase) {
            return;
        }
        if (typeof destroyChildren === "undefined") {
            destroyChildren = true;
        }
        this._cache[8] = 1;
        this.clear();
        if (this.parent) {
            if (this.parent instanceof Phaser.Group) {
                this.parent.remove(this);
            } else {
                this.parent.removeChild(this);
            }
        }
        var i = this.children.length;
        if (destroyChildren) {
            while (i--) {
                this.children[i].destroy(destroyChildren);
            }
        } else {
            while (i--) {
                this.removeChild(this.children[i]);
            }
        }
        this.exists = false;
        this.visible = false;
        this.game = null;
        this._cache[8] = 0;
    };
    Phaser.Graphics.prototype.drawPolygon = function(poly) {
        this.moveTo(poly.points[0].x, poly.points[0].y);
        for (var i = 1; i < poly.points.length; i += 1) {
            this.lineTo(poly.points[i].x, poly.points[i].y);
        }
        this.lineTo(poly.points[0].x, poly.points[0].y);
    };
    Phaser.Graphics.prototype.drawTriangle = function(points, cull) {
        if (typeof cull === "undefined") {
            cull = false;
        }
        var triangle = new Phaser.Polygon(points);
        if (cull) {
            var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y);
            var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y);
            var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y);
            var faceNormal = cb.cross(ab);
            if (cameraToFace.dot(faceNormal) > 0) {
                this.drawPolygon(triangle);
            }
        } else {
            this.drawPolygon(triangle);
        }
    };
    Phaser.Graphics.prototype.drawTriangles = function(vertices, indices, cull) {
        if (typeof cull === "undefined") {
            cull = false;
        }
        var point1 = new Phaser.Point();
        var point2 = new Phaser.Point();
        var point3 = new Phaser.Point();
        var points = [];
        var i;
        if (!indices) {
            if (vertices[0] instanceof Phaser.Point) {
                for (i = 0; i < vertices.length / 3; i++) {
                    this.drawTriangle([ vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2] ], cull);
                }
            } else {
                for (i = 0; i < vertices.length / 6; i++) {
                    point1.x = vertices[i * 6 + 0];
                    point1.y = vertices[i * 6 + 1];
                    point2.x = vertices[i * 6 + 2];
                    point2.y = vertices[i * 6 + 3];
                    point3.x = vertices[i * 6 + 4];
                    point3.y = vertices[i * 6 + 5];
                    this.drawTriangle([ point1, point2, point3 ], cull);
                }
            }
        } else {
            if (vertices[0] instanceof Phaser.Point) {
                for (i = 0; i < indices.length / 3; i++) {
                    points.push(vertices[indices[i * 3]]);
                    points.push(vertices[indices[i * 3 + 1]]);
                    points.push(vertices[indices[i * 3 + 2]]);
                    if (points.length === 3) {
                        this.drawTriangle(points, cull);
                        points = [];
                    }
                }
            } else {
                for (i = 0; i < indices.length; i++) {
                    point1.x = vertices[indices[i] * 2];
                    point1.y = vertices[indices[i] * 2 + 1];
                    points.push(point1.copyTo({}));
                    if (points.length === 3) {
                        this.drawTriangle(points, cull);
                        points = [];
                    }
                }
            }
        }
    };
    Object.defineProperty(Phaser.Graphics.prototype, "angle", {
        get: function() {
            return Phaser.Math.radToDeg(this.rotation);
        },
        set: function(value) {
            this.rotation = Phaser.Math.degToRad(value);
        }
    });
    Object.defineProperty(Phaser.Graphics.prototype, "fixedToCamera", {
        get: function() {
            return !!this._cache[7];
        },
        set: function(value) {
            if (value) {
                this._cache[7] = 1;
                this.cameraOffset.set(this.x, this.y);
            } else {
                this._cache[7] = 0;
            }
        }
    });
    Object.defineProperty(Phaser.Graphics.prototype, "destroyPhase", {
        get: function() {
            return !!this._cache[8];
        }
    });
    Phaser.RenderTexture = function(game, width, height, key, scaleMode) {
        if (typeof key === "undefined") {
            key = "";
        }
        if (typeof scaleMode === "undefined") {
            scaleMode = Phaser.scaleModes.DEFAULT;
        }
        this.game = game;
        this.key = key;
        this.type = Phaser.RENDERTEXTURE;
        this._temp = new Phaser.Point();
        PIXI.RenderTexture.call(this, width, height, this.game.renderer, scaleMode);
    };
    Phaser.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);
    Phaser.RenderTexture.prototype.constructor = Phaser.RenderTexture;
    Phaser.RenderTexture.prototype.renderXY = function(displayObject, x, y, clear) {
        this._temp.set(x, y);
        this.render(displayObject, this._temp, clear);
    };
    Phaser.SpriteBatch = function(game, parent, name, addToStage) {
        if (typeof parent === "undefined" || parent === null) {
            parent = game.world;
        }
        PIXI.SpriteBatch.call(this);
        Phaser.Group.call(this, game, parent, name, addToStage);
        this.type = Phaser.SPRITEBATCH;
    };
    Phaser.SpriteBatch.prototype = Phaser.Utils.extend(true, Phaser.SpriteBatch.prototype, Phaser.Group.prototype, PIXI.SpriteBatch.prototype);
    Phaser.SpriteBatch.prototype.constructor = Phaser.SpriteBatch;
    Phaser.RetroFont = function(game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {
        if (!game.cache.checkImageKey(key)) {
            return false;
        }
        if (typeof charsPerRow === "undefined" || charsPerRow === null) {
            charsPerRow = game.cache.getImage(key).width / characterWidth;
        }
        this.characterWidth = characterWidth;
        this.characterHeight = characterHeight;
        this.characterSpacingX = xSpacing || 0;
        this.characterSpacingY = ySpacing || 0;
        this.characterPerRow = charsPerRow;
        this.offsetX = xOffset || 0;
        this.offsetY = yOffset || 0;
        this.align = "left";
        this.multiLine = false;
        this.autoUpperCase = true;
        this.customSpacingX = 0;
        this.customSpacingY = 0;
        this.fixedWidth = 0;
        this.fontSet = game.cache.getImage(key);
        this._text = "";
        this.grabData = [];
        this.frameData = new Phaser.FrameData();
        var currentX = this.offsetX;
        var currentY = this.offsetY;
        var r = 0;
        for (var c = 0; c < chars.length; c++) {
            var uuid = game.rnd.uuid();
            var frame = this.frameData.addFrame(new Phaser.Frame(c, currentX, currentY, this.characterWidth, this.characterHeight, "", uuid));
            this.grabData[chars.charCodeAt(c)] = frame.index;
            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {
                x: currentX,
                y: currentY,
                width: this.characterWidth,
                height: this.characterHeight
            });
            r++;
            if (r == this.characterPerRow) {
                r = 0;
                currentX = this.offsetX;
                currentY += this.characterHeight + this.characterSpacingY;
            } else {
                currentX += this.characterWidth + this.characterSpacingX;
            }
        }
        game.cache.updateFrameData(key, this.frameData);
        this.stamp = new Phaser.Image(game, 0, 0, key, 0);
        Phaser.RenderTexture.call(this, game, 100, 100, "", Phaser.scaleModes.NEAREST);
        this.type = Phaser.RETROFONT;
    };
    Phaser.RetroFont.prototype = Object.create(Phaser.RenderTexture.prototype);
    Phaser.RetroFont.prototype.constructor = Phaser.RetroFont;
    Phaser.RetroFont.ALIGN_LEFT = "left";
    Phaser.RetroFont.ALIGN_RIGHT = "right";
    Phaser.RetroFont.ALIGN_CENTER = "center";
    Phaser.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    Phaser.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    Phaser.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";
    Phaser.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";
    Phaser.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";
    Phaser.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";
    Phaser.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";
    Phaser.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Phaser.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";
    Phaser.RetroFont.prototype.setFixedWidth = function(width, lineAlignment) {
        if (typeof lineAlignment === "undefined") {
            lineAlignment = "left";
        }
        this.fixedWidth = width;
        this.align = lineAlignment;
    };
    Phaser.RetroFont.prototype.setText = function(content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) {
        this.multiLine = multiLine || false;
        this.customSpacingX = characterSpacing || 0;
        this.customSpacingY = lineSpacing || 0;
        this.align = lineAlignment || "left";
        if (allowLowerCase) {
            this.autoUpperCase = false;
        } else {
            this.autoUpperCase = true;
        }
        if (content.length > 0) {
            this.text = content;
        }
    };
    Phaser.RetroFont.prototype.buildRetroFontText = function() {
        var cx = 0;
        var cy = 0;
        this.clear();
        if (this.multiLine) {
            var lines = this._text.split("\n");
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
            } else {
                this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), lines.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
            }
            for (var i = 0; i < lines.length; i++) {
                switch (this.align) {
                  case Phaser.RetroFont.ALIGN_LEFT:
                    cx = 0;
                    break;

                  case Phaser.RetroFont.ALIGN_RIGHT:
                    cx = this.width - lines[i].length * (this.characterWidth + this.customSpacingX);
                    break;

                  case Phaser.RetroFont.ALIGN_CENTER:
                    cx = this.width / 2 - lines[i].length * (this.characterWidth + this.customSpacingX) / 2;
                    cx += this.customSpacingX / 2;
                    break;
                }
                if (cx < 0) {
                    cx = 0;
                }
                this.pasteLine(lines[i], cx, cy, this.customSpacingX);
                cy += this.characterHeight + this.customSpacingY;
            }
        } else {
            if (this.fixedWidth > 0) {
                this.resize(this.fixedWidth, this.characterHeight, true);
            } else {
                this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, true);
            }
            switch (this.align) {
              case Phaser.RetroFont.ALIGN_LEFT:
                cx = 0;
                break;

              case Phaser.RetroFont.ALIGN_RIGHT:
                cx = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
                break;

              case Phaser.RetroFont.ALIGN_CENTER:
                cx = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2;
                cx += this.customSpacingX / 2;
                break;
            }
            this.textureBuffer.clear();
            this.pasteLine(this._text, cx, 0, this.customSpacingX);
        }
    };
    Phaser.RetroFont.prototype.pasteLine = function(line, x, y, customSpacingX) {
        var p = new Phaser.Point();
        for (var c = 0; c < line.length; c++) {
            if (line.charAt(c) == " ") {
                x += this.characterWidth + customSpacingX;
            } else {
                if (this.grabData[line.charCodeAt(c)] >= 0) {
                    this.stamp.frame = this.grabData[line.charCodeAt(c)];
                    p.set(x, y);
                    this.render(this.stamp, p, false);
                    x += this.characterWidth + customSpacingX;
                    if (x > this.width) {
                        break;
                    }
                }
            }
        }
    };
    Phaser.RetroFont.prototype.getLongestLine = function() {
        var longestLine = 0;
        if (this._text.length > 0) {
            var lines = this._text.split("\n");
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].length > longestLine) {
                    longestLine = lines[i].length;
                }
            }
        }
        return longestLine;
    };
    Phaser.RetroFont.prototype.removeUnsupportedCharacters = function(stripCR) {
        var newString = "";
        for (var c = 0; c < this._text.length; c++) {
            var aChar = this._text[c];
            var code = aChar.charCodeAt(0);
            if (this.grabData[code] >= 0 || !stripCR && aChar === "\n") {
                newString = newString.concat(aChar);
            }
        }
        return newString;
    };
    Phaser.RetroFont.prototype.updateOffset = function(x, y) {
        if (this.offsetX === x && this.offsetY === y) {
            return;
        }
        var diffX = x - this.offsetX;
        var diffY = y - this.offsetY;
        var frames = this.game.cache.getFrameData(this.stamp.key).getFrames();
        var i = frames.length;
        while (i--) {
            frames[i].x += diffX;
            frames[i].y += diffY;
            PIXI.TextureCache[frames[i].uuid].frame.x = frames[i].x;
            PIXI.TextureCache[frames[i].uuid].frame.y = frames[i].y;
        }
        this.buildRetroFontText();
    };
    Object.defineProperty(Phaser.RetroFont.prototype, "text", {
        get: function() {
            return this._text;
        },
        set: function(value) {
            var newText;
            if (this.autoUpperCase) {
                newText = value.toUpperCase();
            } else {
                newText = value;
            }
            if (newText !== this._text) {
                this._text = newText;
                this.removeUnsupportedCharacters(this.multiLine);
                this.buildRetroFontText();
            }
        }
    });
    Object.defineProperty(Phaser.RetroFont.prototype, "smoothed", {
        get: function() {
            return this.stamp.smoothed;
        },
        set: function(value) {
            this.stamp.smoothed = value;
            this.buildRetroFontText();
        }
    });
    Phaser.Particle = function(game, x, y, key, frame) {
        Phaser.Sprite.call(this, game, x, y, key, frame);
        this.autoScale = false;
        this.scaleData = null;
        this._s = 0;
        this.autoAlpha = false;
        this.alphaData = null;
        this._a = 0;
    };
    Phaser.Particle.prototype = Object.create(Phaser.Sprite.prototype);
    Phaser.Particle.prototype.constructor = Phaser.Particle;
    Phaser.Particle.prototype.update = function() {
        if (this.autoScale) {
            this._s--;
            if (this._s) {
                this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
            } else {
                this.autoScale = false;
            }
        }
        if (this.autoAlpha) {
            this._a--;
            if (this._a) {
                this.alpha = this.alphaData[this._a].v;
            } else {
                this.autoAlpha = false;
            }
        }
    };
    Phaser.Particle.prototype.onEmit = function() {};
    Phaser.Particle.prototype.setAlphaData = function(data) {
        this.alphaData = data;
        this._a = data.length - 1;
        this.alpha = this.alphaData[this._a].v;
        this.autoAlpha = true;
    };
    Phaser.Particle.prototype.setScaleData = function(data) {
        this.scaleData = data;
        this._s = data.length - 1;
        this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
        this.autoScale = true;
    };
    Phaser.Particle.prototype.reset = function(x, y, health) {
        if (typeof health === "undefined") {
            health = 1;
        }
        this.world.setTo(x, y);
        this.position.x = x;
        this.position.y = y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.health = health;
        if (this.body) {
            this.body.reset(x, y, false, false);
        }
        this._cache[4] = 1;
        this.alpha = 1;
        this.scale.set(1);
        this.autoScale = false;
        this.autoAlpha = false;
        return this;
    };
    Phaser.Canvas = {
        create: function(width, height, id) {
            width = width || 256;
            height = height || 256;
            var canvas = document.createElement("canvas");
            if (typeof id === "string" && id !== "") {
                canvas.id = id;
            }
            canvas.width = width;
            canvas.height = height;
            canvas.style.display = "block";
            return canvas;
        },
        getOffset: function(element, point) {
            point = point || new Phaser.Point();
            var box = element.getBoundingClientRect();
            var clientTop = element.clientTop || document.body.clientTop || 0;
            var clientLeft = element.clientLeft || document.body.clientLeft || 0;
            var scrollTop = 0;
            var scrollLeft = 0;
            if (document.compatMode === "CSS1Compat") {
                scrollTop = window.pageYOffset || document.documentElement.scrollTop || element.scrollTop || 0;
                scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || element.scrollLeft || 0;
            } else {
                scrollTop = window.pageYOffset || document.body.scrollTop || element.scrollTop || 0;
                scrollLeft = window.pageXOffset || document.body.scrollLeft || element.scrollLeft || 0;
            }
            point.x = box.left + scrollLeft - clientLeft;
            point.y = box.top + scrollTop - clientTop;
            return point;
        },
        getAspectRatio: function(canvas) {
            return canvas.width / canvas.height;
        },
        setBackgroundColor: function(canvas, color) {
            color = color || "rgb(0,0,0)";
            canvas.style.backgroundColor = color;
            return canvas;
        },
        setTouchAction: function(canvas, value) {
            value = value || "none";
            canvas.style.msTouchAction = value;
            canvas.style["ms-touch-action"] = value;
            canvas.style["touch-action"] = value;
            return canvas;
        },
        setUserSelect: function(canvas, value) {
            value = value || "none";
            canvas.style["-webkit-touch-callout"] = value;
            canvas.style["-webkit-user-select"] = value;
            canvas.style["-khtml-user-select"] = value;
            canvas.style["-moz-user-select"] = value;
            canvas.style["-ms-user-select"] = value;
            canvas.style["user-select"] = value;
            canvas.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return canvas;
        },
        addToDOM: function(canvas, parent, overflowHidden) {
            var target;
            if (typeof overflowHidden === "undefined") {
                overflowHidden = true;
            }
            if (parent) {
                if (typeof parent === "string") {
                    target = document.getElementById(parent);
                } else if (typeof parent === "object" && parent.nodeType === 1) {
                    target = parent;
                }
            }
            if (!target) {
                target = document.body;
            }
            if (overflowHidden && target.style) {
                target.style.overflow = "hidden";
            }
            target.appendChild(canvas);
            return canvas;
        },
        removeFromDOM: function(canvas) {
            if (canvas.parentNode) {
                canvas.parentNode.removeChild(canvas);
            }
        },
        setTransform: function(context, translateX, translateY, scaleX, scaleY, skewX, skewY) {
            context.setTransform(scaleX, skewX, skewY, scaleY, translateX, translateY);
            return context;
        },
        setSmoothingEnabled: function(context, value) {
            context["imageSmoothingEnabled"] = value;
            context["mozImageSmoothingEnabled"] = value;
            context["oImageSmoothingEnabled"] = value;
            context["webkitImageSmoothingEnabled"] = value;
            context["msImageSmoothingEnabled"] = value;
            return context;
        },
        getSmoothingEnabled: function(context) {
            return context["imageSmoothingEnabled"] || context["mozImageSmoothingEnabled"] || context["oImageSmoothingEnabled"] || context["webkitImageSmoothingEnabled"] || context["msImageSmoothingEnabled"];
        },
        setImageRenderingCrisp: function(canvas) {
            canvas.style["image-rendering"] = "optimizeSpeed";
            canvas.style["image-rendering"] = "crisp-edges";
            canvas.style["image-rendering"] = "-moz-crisp-edges";
            canvas.style["image-rendering"] = "-webkit-optimize-contrast";
            canvas.style["image-rendering"] = "optimize-contrast";
            canvas.style["image-rendering"] = "pixelated";
            canvas.style.msInterpolationMode = "nearest-neighbor";
            return canvas;
        },
        setImageRenderingBicubic: function(canvas) {
            canvas.style["image-rendering"] = "auto";
            canvas.style.msInterpolationMode = "bicubic";
            return canvas;
        }
    };
    Phaser.Device = function(game) {
        this.game = game;
        this.desktop = false;
        this.iOS = false;
        this.cocoonJS = false;
        this.cocoonJSApp = false;
        this.cordova = false;
        this.node = false;
        this.nodeWebkit = false;
        this.ejecta = false;
        this.crosswalk = false;
        this.android = false;
        this.chromeOS = false;
        this.linux = false;
        this.macOS = false;
        this.windows = false;
        this.windowsPhone = false;
        this.canvas = false;
        this.file = false;
        this.fileSystem = false;
        this.localStorage = false;
        this.webGL = false;
        this.worker = false;
        this.touch = false;
        this.mspointer = false;
        this.css3D = false;
        this.pointerLock = false;
        this.typedArray = false;
        this.vibration = false;
        this.getUserMedia = false;
        this.quirksMode = false;
        this.arora = false;
        this.chrome = false;
        this.epiphany = false;
        this.firefox = false;
        this.ie = false;
        this.ieVersion = 0;
        this.trident = false;
        this.tridentVersion = 0;
        this.mobileSafari = false;
        this.midori = false;
        this.opera = false;
        this.safari = false;
        this.webApp = false;
        this.silk = false;
        this.audioData = false;
        this.webAudio = false;
        this.ogg = false;
        this.opus = false;
        this.mp3 = false;
        this.wav = false;
        this.m4a = false;
        this.webm = false;
        this.iPhone = false;
        this.iPhone4 = false;
        this.iPad = false;
        this.pixelRatio = 0;
        this.littleEndian = false;
        this.support32bit = false;
        this.fullscreen = false;
        this.requestFullscreen = "";
        this.cancelFullscreen = "";
        this.fullscreenKeyboard = false;
        this._checkOS();
        this._checkAudio();
        this._checkBrowser();
        this._checkCSS3D();
        this._checkDevice();
        this._checkFeatures();
    };
    Phaser.Device.LITTLE_ENDIAN = false;
    Phaser.Device.prototype = {
        _checkOS: function() {
            var ua = navigator.userAgent;
            if (/Playstation Vita/.test(ua)) {
                this.vita = true;
            } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
                this.kindle = true;
            } else if (/Android/.test(ua)) {
                this.android = true;
            } else if (/CrOS/.test(ua)) {
                this.chromeOS = true;
            } else if (/iP[ao]d|iPhone/i.test(ua)) {
                this.iOS = true;
            } else if (/Linux/.test(ua)) {
                this.linux = true;
            } else if (/Mac OS/.test(ua)) {
                this.macOS = true;
            } else if (/Windows/.test(ua)) {
                this.windows = true;
                if (/Windows Phone/i.test(ua)) {
                    this.windowsPhone = true;
                }
            }
            if (this.windows || this.macOS || this.linux && this.silk === false || this.chromeOS) {
                this.desktop = true;
            }
            if (this.windowsPhone || /Windows NT/i.test(ua) && /Touch/i.test(ua)) {
                this.desktop = false;
            }
        },
        _checkFeatures: function() {
            this.canvas = !!window["CanvasRenderingContext2D"] || this.cocoonJS;
            try {
                this.localStorage = !!localStorage.getItem;
            } catch (error) {
                this.localStorage = false;
            }
            this.file = !!window["File"] && !!window["FileReader"] && !!window["FileList"] && !!window["Blob"];
            this.fileSystem = !!window["requestFileSystem"];
            this.webGL = function() {
                try {
                    var canvas = document.createElement("canvas");
                    canvas.screencanvas = false;
                    return !!window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
                } catch (e) {
                    return false;
                }
            }();
            if (this.webGL === null || this.webGL === false) {
                this.webGL = false;
            } else {
                this.webGL = true;
            }
            this.worker = !!window["Worker"];
            if ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints > 1) {
                this.touch = true;
            }
            if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) {
                this.mspointer = true;
            }
            this.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
            this.quirksMode = document.compatMode === "CSS1Compat" ? false : true;
            this.getUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
        },
        checkFullScreenSupport: function() {
            var fs = [ "requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen" ];
            for (var i = 0; i < fs.length; i++) {
                if (this.game.canvas[fs[i]]) {
                    this.fullscreen = true;
                    this.requestFullscreen = fs[i];
                    break;
                }
            }
            var cfs = [ "cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen" ];
            if (this.fullscreen) {
                for (var i = 0; i < cfs.length; i++) {
                    if (document[cfs[i]]) {
                        this.cancelFullscreen = cfs[i];
                        break;
                    }
                }
            }
            if (window["Element"] && Element["ALLOW_KEYBOARD_INPUT"]) {
                this.fullscreenKeyboard = true;
            }
        },
        _checkBrowser: function() {
            var ua = navigator.userAgent;
            if (/Arora/.test(ua)) {
                this.arora = true;
            } else if (/Chrome/.test(ua)) {
                this.chrome = true;
            } else if (/Epiphany/.test(ua)) {
                this.epiphany = true;
            } else if (/Firefox/.test(ua)) {
                this.firefox = true;
            } else if (/AppleWebKit/.test(ua) && this.iOS) {
                this.mobileSafari = true;
            } else if (/MSIE (\d+\.\d+);/.test(ua)) {
                this.ie = true;
                this.ieVersion = parseInt(RegExp.$1, 10);
            } else if (/Midori/.test(ua)) {
                this.midori = true;
            } else if (/Opera/.test(ua)) {
                this.opera = true;
            } else if (/Safari/.test(ua)) {
                this.safari = true;
            } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
                this.ie = true;
                this.trident = true;
                this.tridentVersion = parseInt(RegExp.$1, 10);
                this.ieVersion = parseInt(RegExp.$3, 10);
            }
            if (/Silk/.test(ua)) {
                this.silk = true;
            }
            if (navigator["standalone"]) {
                this.webApp = true;
            }
            if (typeof window.cordova !== "undefined") {
                this.cordova = true;
            }
            if (typeof process !== "undefined" && typeof require !== "undefined") {
                this.node = true;
            }
            if (this.node) {
                try {
                    this.nodeWebkit = typeof require("nw.gui") !== "undefined";
                } catch (error) {
                    this.nodeWebkit = false;
                }
            }
            if (navigator["isCocoonJS"]) {
                this.cocoonJS = true;
            }
            if (this.cocoonJS) {
                try {
                    this.cocoonJSApp = typeof CocoonJS !== "undefined";
                } catch (error) {
                    this.cocoonJSApp = false;
                }
            }
            if (typeof window.ejecta !== "undefined") {
                this.ejecta = true;
            }
            if (/Crosswalk/.test(ua)) {
                this.crosswalk = true;
            }
        },
        _checkAudio: function() {
            this.audioData = !!window["Audio"];
            this.webAudio = !!(window["webkitAudioContext"] || window["AudioContext"]);
            var audioElement = document.createElement("audio");
            var result = false;
            try {
                if (result = !!audioElement.canPlayType) {
                    if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                        this.ogg = true;
                    }
                    if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "")) {
                        this.opus = true;
                    }
                    if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                        this.mp3 = true;
                    }
                    if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "")) {
                        this.wav = true;
                    }
                    if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, "")) {
                        this.m4a = true;
                    }
                    if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                        this.webm = true;
                    }
                }
            } catch (e) {}
        },
        _checkDevice: function() {
            this.pixelRatio = window["devicePixelRatio"] || 1;
            this.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") != -1;
            this.iPhone4 = this.pixelRatio == 2 && this.iPhone;
            this.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") != -1;
            if (typeof Int8Array !== "undefined") {
                this.typedArray = true;
            } else {
                this.typedArray = false;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint32Array !== "undefined") {
                this.littleEndian = this._checkIsLittleEndian();
                Phaser.Device.LITTLE_ENDIAN = this.littleEndian;
            }
            this.support32bit = typeof ArrayBuffer !== "undefined" && typeof Uint8ClampedArray !== "undefined" && typeof Int32Array !== "undefined" && this.littleEndian !== null && this._checkIsUint8ClampedImageData();
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
            if (navigator.vibrate) {
                this.vibration = true;
            }
        },
        _checkIsLittleEndian: function() {
            var a = new ArrayBuffer(4);
            var b = new Uint8Array(a);
            var c = new Uint32Array(a);
            b[0] = 161;
            b[1] = 178;
            b[2] = 195;
            b[3] = 212;
            if (c[0] == 3569595041) {
                return true;
            }
            if (c[0] == 2712847316) {
                return false;
            } else {
                return null;
            }
        },
        _checkIsUint8ClampedImageData: function() {
            if (typeof Uint8ClampedArray === "undefined") {
                return false;
            }
            var elem = document.createElement("canvas");
            var ctx = elem.getContext("2d");
            if (!ctx) {
                return false;
            }
            var image = ctx.createImageData(1, 1);
            return image.data instanceof Uint8ClampedArray;
        },
        _checkCSS3D: function() {
            var el = document.createElement("p");
            var has3d;
            var transforms = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(el, null);
            for (var t in transforms) {
                if (el.style[t] !== undefined) {
                    el.style[t] = "translate3d(1px,1px,1px)";
                    has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
                }
            }
            document.body.removeChild(el);
            this.css3D = has3d !== undefined && has3d.length > 0 && has3d !== "none";
        },
        canPlayAudio: function(type) {
            if (type == "mp3" && this.mp3) {
                return true;
            } else if (type == "ogg" && (this.ogg || this.opus)) {
                return true;
            } else if (type == "m4a" && this.m4a) {
                return true;
            } else if (type == "wav" && this.wav) {
                return true;
            } else if (type == "webm" && this.webm) {
                return true;
            }
            return false;
        },
        isConsoleOpen: function() {
            if (window.console && window.console["firebug"]) {
                return true;
            }
            if (window.console) {
                console.profile();
                console.profileEnd();
                if (console.clear) {
                    console.clear();
                }
                if (console["profiles"]) {
                    return console["profiles"].length > 0;
                }
            }
            return false;
        }
    };
    Phaser.Device.prototype.constructor = Phaser.Device;
    Phaser.Device.isAndroidStockBrowser = function() {
        var matches = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return matches && matches[1] < 537;
    };
    Phaser.RequestAnimationFrame = function(game, forceSetTimeOut) {
        if (typeof forceSetTimeOut === "undefined") {
            forceSetTimeOut = false;
        }
        this.game = game;
        this.isRunning = false;
        this.forceSetTimeOut = forceSetTimeOut;
        var vendors = [ "ms", "moz", "webkit", "o" ];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"];
        }
        this._isSetTimeOut = false;
        this._onLoop = null;
        this._timeOutID = null;
    };
    Phaser.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = true;
            var _this = this;
            if (!window.requestAnimationFrame || this.forceSetTimeOut) {
                this._isSetTimeOut = true;
                this._onLoop = function() {
                    return _this.updateSetTimeout();
                };
                this._timeOutID = window.setTimeout(this._onLoop, 0);
            } else {
                this._isSetTimeOut = false;
                this._onLoop = function(time) {
                    return _this.updateRAF(time);
                };
                this._timeOutID = window.requestAnimationFrame(this._onLoop);
            }
        },
        updateRAF: function() {
            this.game.update(Date.now());
            this._timeOutID = window.requestAnimationFrame(this._onLoop);
        },
        updateSetTimeout: function() {
            this.game.update(Date.now());
            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);
        },
        stop: function() {
            if (this._isSetTimeOut) {
                clearTimeout(this._timeOutID);
            } else {
                window.cancelAnimationFrame(this._timeOutID);
            }
            this.isRunning = false;
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut;
        },
        isRAF: function() {
            return this._isSetTimeOut === false;
        }
    };
    Phaser.RequestAnimationFrame.prototype.constructor = Phaser.RequestAnimationFrame;
    Phaser.Math = {
        PI2: Math.PI * 2,
        fuzzyEqual: function(a, b, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return Math.abs(a - b) < epsilon;
        },
        fuzzyLessThan: function(a, b, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return a < b + epsilon;
        },
        fuzzyGreaterThan: function(a, b, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return a > b - epsilon;
        },
        fuzzyCeil: function(val, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return Math.ceil(val - epsilon);
        },
        fuzzyFloor: function(val, epsilon) {
            if (typeof epsilon === "undefined") {
                epsilon = 1e-4;
            }
            return Math.floor(val + epsilon);
        },
        average: function() {
            var args = [];
            for (var _i = 0; _i < arguments.length - 0; _i++) {
                args[_i] = arguments[_i + 0];
            }
            var avg = 0;
            for (var i = 0; i < args.length; i++) {
                avg += args[i];
            }
            return avg / args.length;
        },
        truncate: function(n) {
            return n > 0 ? Math.floor(n) : Math.ceil(n);
        },
        shear: function(n) {
            return n % 1;
        },
        snapTo: function(input, gap, start) {
            if (typeof start === "undefined") {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.round(input / gap);
            return start + input;
        },
        snapToFloor: function(input, gap, start) {
            if (typeof start === "undefined") {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.floor(input / gap);
            return start + input;
        },
        snapToCeil: function(input, gap, start) {
            if (typeof start === "undefined") {
                start = 0;
            }
            if (gap === 0) {
                return input;
            }
            input -= start;
            input = gap * Math.ceil(input / gap);
            return start + input;
        },
        snapToInArray: function(input, arr, sort) {
            if (typeof sort === "undefined") {
                sort = true;
            }
            if (sort) {
                arr.sort();
            }
            if (input < arr[0]) {
                return arr[0];
            }
            var i = 1;
            while (arr[i] < input) {
                i++;
            }
            var low = arr[i - 1];
            var high = i < arr.length ? arr[i] : Number.POSITIVE_INFINITY;
            return high - input <= input - low ? high : low;
        },
        roundTo: function(value, place, base) {
            if (typeof place === "undefined") {
                place = 0;
            }
            if (typeof base === "undefined") {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.round(value * p) / p;
        },
        floorTo: function(value, place, base) {
            if (typeof place === "undefined") {
                place = 0;
            }
            if (typeof base === "undefined") {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.floor(value * p) / p;
        },
        ceilTo: function(value, place, base) {
            if (typeof place === "undefined") {
                place = 0;
            }
            if (typeof base === "undefined") {
                base = 10;
            }
            var p = Math.pow(base, -place);
            return Math.ceil(value * p) / p;
        },
        interpolateFloat: function(a, b, weight) {
            return (b - a) * weight + a;
        },
        angleBetween: function(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        },
        angleBetweenY: function(x1, y1, x2, y2) {
            return Math.atan2(x2 - x1, y2 - y1);
        },
        angleBetweenPoints: function(point1, point2) {
            return Math.atan2(point2.y - point1.y, point2.x - point1.x);
        },
        angleBetweenPointsY: function(point1, point2) {
            return Math.atan2(point2.x - point1.x, point2.y - point1.y);
        },
        reverseAngle: function(angleRad) {
            return this.normalizeAngle(angleRad + Math.PI, true);
        },
        normalizeAngle: function(angleRad) {
            angleRad = angleRad % (2 * Math.PI);
            return angleRad >= 0 ? angleRad : angleRad + 2 * Math.PI;
        },
        normalizeLatitude: function(lat) {
            return Math.max(-90, Math.min(90, lat));
        },
        normalizeLongitude: function(lng) {
            if (lng % 360 == 180) {
                return 180;
            }
            lng = lng % 360;
            return lng < -180 ? lng + 360 : lng > 180 ? lng - 360 : lng;
        },
        chanceRoll: function(chance) {
            if (typeof chance === "undefined") {
                chance = 50;
            }
            if (chance <= 0) {
                return false;
            } else if (chance >= 100) {
                return true;
            } else {
                if (Math.random() * 100 >= chance) {
                    return false;
                } else {
                    return true;
                }
            }
        },
        numberArray: function(min, max) {
            var result = [];
            for (var i = min; i <= max; i++) {
                result.push(i);
            }
            return result;
        },
        numberArrayStep: function(start, end, step) {
            start = +start || 0;
            var type = typeof end;
            if ((type === "number" || type === "string") && step && step[end] === start) {
                end = step = null;
            }
            step = step == null ? 1 : +step || 0;
            if (end === null) {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            var index = -1;
            var length = Phaser.Math.max(Phaser.Math.ceil((end - start) / (step || 1)), 0);
            var result = new Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        },
        maxAdd: function(value, amount, max) {
            value += amount;
            if (value > max) {
                value = max;
            }
            return value;
        },
        minSub: function(value, amount, min) {
            value -= amount;
            if (value < min) {
                value = min;
            }
            return value;
        },
        wrap: function(value, min, max) {
            var range = max - min;
            if (range <= 0) {
                return 0;
            }
            var result = (value - min) % range;
            if (result < 0) {
                result += range;
            }
            return result + min;
        },
        wrapValue: function(value, amount, max) {
            var diff;
            value = Math.abs(value);
            amount = Math.abs(amount);
            max = Math.abs(max);
            diff = (value + amount) % max;
            return diff;
        },
        limitValue: function(value, min, max) {
            return value < min ? min : value > max ? max : value;
        },
        randomSign: function() {
            return Math.random() > .5 ? 1 : -1;
        },
        isOdd: function(n) {
            return n & 1;
        },
        isEven: function(n) {
            if (n & 1) {
                return false;
            } else {
                return true;
            }
        },
        min: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var data = arguments[0];
            } else {
                var data = arguments;
            }
            for (var i = 1, min = 0, len = data.length; i < len; i++) {
                if (data[i] < data[min]) {
                    min = i;
                }
            }
            return data[min];
        },
        max: function() {
            if (arguments.length === 1 && typeof arguments[0] === "object") {
                var data = arguments[0];
            } else {
                var data = arguments;
            }
            for (var i = 1, max = 0, len = data.length; i < len; i++) {
                if (data[i] > data[max]) {
                    max = i;
                }
            }
            return data[max];
        },
        minProperty: function(property) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var data = arguments[1];
            } else {
                var data = arguments.slice(1);
            }
            for (var i = 1, min = 0, len = data.length; i < len; i++) {
                if (data[i][property] < data[min][property]) {
                    min = i;
                }
            }
            return data[min][property];
        },
        maxProperty: function(property) {
            if (arguments.length === 2 && typeof arguments[1] === "object") {
                var data = arguments[1];
            } else {
                var data = arguments.slice(1);
            }
            for (var i = 1, max = 0, len = data.length; i < len; i++) {
                if (data[i][property] > data[max][property]) {
                    max = i;
                }
            }
            return data[max][property];
        },
        wrapAngle: function(angle, radians) {
            var radianFactor = radians ? Math.PI / 180 : 1;
            return this.wrap(angle, -180 * radianFactor, 180 * radianFactor);
        },
        angleLimit: function(angle, min, max) {
            var result = angle;
            if (angle > max) {
                result = max;
            } else if (angle < min) {
                result = min;
            }
            return result;
        },
        linearInterpolation: function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (k < 0) {
                return this.linear(v[0], v[1], f);
            }
            if (k > 1) {
                return this.linear(v[m], v[m - 1], m - f);
            }
            return this.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
        },
        bezierInterpolation: function(v, k) {
            var b = 0;
            var n = v.length - 1;
            for (var i = 0; i <= n; i++) {
                b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * this.bernstein(n, i);
            }
            return b;
        },
        catmullRomInterpolation: function(v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            if (v[0] === v[m]) {
                if (k < 0) {
                    i = Math.floor(f = m * (1 + k));
                }
                return this.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            } else {
                if (k < 0) {
                    return v[0] - (this.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
                }
                if (k > 1) {
                    return v[m] - (this.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                }
                return this.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
        },
        linear: function(p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        bernstein: function(n, i) {
            return this.factorial(n) / this.factorial(i) / this.factorial(n - i);
        },
        factorial: function(value) {
            if (value === 0) {
                return 1;
            }
            var res = value;
            while (--value) {
                res *= value;
            }
            return res;
        },
        catmullRom: function(p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * .5, v1 = (p3 - p1) * .5, t2 = t * t, t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
        difference: function(a, b) {
            return Math.abs(a - b);
        },
        getRandom: function(objects, startIndex, length) {
            if (typeof startIndex === "undefined") {
                startIndex = 0;
            }
            if (typeof length === "undefined") {
                length = 0;
            }
            if (objects != null) {
                var l = length;
                if (l === 0 || l > objects.length - startIndex) {
                    l = objects.length - startIndex;
                }
                if (l > 0) {
                    return objects[startIndex + Math.floor(Math.random() * l)];
                }
            }
            return null;
        },
        removeRandom: function(objects, startIndex, length) {
            if (typeof startIndex === "undefined") {
                startIndex = 0;
            }
            if (typeof length === "undefined") {
                length = 0;
            }
            if (objects != null) {
                var l = length;
                if (l === 0 || l > objects.length - startIndex) {
                    l = objects.length - startIndex;
                }
                if (l > 0) {
                    var idx = startIndex + Math.floor(Math.random() * l);
                    var removed = objects.splice(idx, 1);
                    return removed[0];
                }
            }
            return null;
        },
        floor: function(value) {
            var n = value | 0;
            return value > 0 ? n : n != value ? n - 1 : n;
        },
        ceil: function(value) {
            var n = value | 0;
            return value > 0 ? n != value ? n + 1 : n : n;
        },
        sinCosGenerator: function(length, sinAmplitude, cosAmplitude, frequency) {
            if (typeof sinAmplitude === "undefined") {
                sinAmplitude = 1;
            }
            if (typeof cosAmplitude === "undefined") {
                cosAmplitude = 1;
            }
            if (typeof frequency === "undefined") {
                frequency = 1;
            }
            var sin = sinAmplitude;
            var cos = cosAmplitude;
            var frq = frequency * Math.PI / length;
            var cosTable = [];
            var sinTable = [];
            for (var c = 0; c < length; c++) {
                cos -= sin * frq;
                sin += cos * frq;
                cosTable[c] = cos;
                sinTable[c] = sin;
            }
            return {
                sin: sinTable,
                cos: cosTable,
                length: length
            };
        },
        shift: function(stack) {
            var s = stack.shift();
            stack.push(s);
            return s;
        },
        shuffleArray: function(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        },
        distance: function(x1, y1, x2, y2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
        },
        distancePow: function(x1, y1, x2, y2, pow) {
            if (typeof pow === "undefined") {
                pow = 2;
            }
            return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));
        },
        distanceRounded: function(x1, y1, x2, y2) {
            return Math.round(Phaser.Math.distance(x1, y1, x2, y2));
        },
        clamp: function(x, a, b) {
            return x < a ? a : x > b ? b : x;
        },
        clampBottom: function(x, a) {
            return x < a ? a : x;
        },
        within: function(a, b, tolerance) {
            return Math.abs(a - b) <= tolerance;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        smoothstep: function(x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * (3 - 2 * x);
        },
        smootherstep: function(x, min, max) {
            x = Math.max(0, Math.min(1, (x - min) / (max - min)));
            return x * x * x * (x * (x * 6 - 15) + 10);
        },
        sign: function(x) {
            return x < 0 ? -1 : x > 0 ? 1 : 0;
        },
        percent: function(a, b, base) {
            if (typeof base === "undefined") {
                base = 0;
            }
            if (a > b || base > b) {
                return 1;
            } else if (a < base || base > a) {
                return 0;
            } else {
                return (a - base) / b;
            }
        },
        degToRad: function() {
            var degreeToRadiansFactor = Math.PI / 180;
            return function(degrees) {
                return degrees * degreeToRadiansFactor;
            };
        }(),
        radToDeg: function() {
            var radianToDegreesFactor = 180 / Math.PI;
            return function(radians) {
                return radians * radianToDegreesFactor;
            };
        }()
    };
    Phaser.RandomDataGenerator = function(seeds) {
        if (typeof seeds === "undefined") {
            seeds = [];
        }
        this.c = 1;
        this.s0 = 0;
        this.s1 = 0;
        this.s2 = 0;
        this.sow(seeds);
    };
    Phaser.RandomDataGenerator.prototype = {
        rnd: function() {
            var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10;
            this.c = t | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            this.s2 = t - this.c;
            return this.s2;
        },
        sow: function(seeds) {
            if (typeof seeds === "undefined") {
                seeds = [];
            }
            this.s0 = this.hash(" ");
            this.s1 = this.hash(this.s0);
            this.s2 = this.hash(this.s1);
            this.c = 1;
            var seed;
            for (var i = 0; seed = seeds[i++]; ) {
                this.s0 -= this.hash(seed);
                this.s0 += ~~(this.s0 < 0);
                this.s1 -= this.hash(seed);
                this.s1 += ~~(this.s1 < 0);
                this.s2 -= this.hash(seed);
                this.s2 += ~~(this.s2 < 0);
            }
        },
        hash: function(data) {
            var h, i, n;
            n = 4022871197;
            data = data.toString();
            for (i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                h = .02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 4294967296;
            }
            return (n >>> 0) * 2.3283064365386963e-10;
        },
        integer: function() {
            return this.rnd.apply(this) * 4294967296;
        },
        frac: function() {
            return this.rnd.apply(this) + (this.rnd.apply(this) * 2097152 | 0) * 1.1102230246251565e-16;
        },
        real: function() {
            return this.integer() + this.frac();
        },
        integerInRange: function(min, max) {
            return Math.floor(this.realInRange(0, max - min + 1) + min);
        },
        between: function(min, max) {
            return this.integerInRange(min, max);
        },
        realInRange: function(min, max) {
            return this.frac() * (max - min) + min;
        },
        normal: function() {
            return 1 - 2 * this.frac();
        },
        uuid: function() {
            var a = "";
            var b = "";
            for (b = a = ""; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {}
            return b;
        },
        pick: function(ary) {
            return ary[this.integerInRange(0, ary.length - 1)];
        },
        weightedPick: function(ary) {
            return ary[~~(Math.pow(this.frac(), 2) * (ary.length - 1))];
        },
        timestamp: function(min, max) {
            return this.realInRange(min || 9466848e5, max || 1577862e6);
        },
        angle: function() {
            return this.integerInRange(-180, 180);
        }
    };
    Phaser.RandomDataGenerator.prototype.constructor = Phaser.RandomDataGenerator;
    Phaser.QuadTree = function(x, y, width, height, maxObjects, maxLevels, level) {
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.level = 0;
        this.bounds = {};
        this.objects = [];
        this.nodes = [];
        this._empty = [];
        this.reset(x, y, width, height, maxObjects, maxLevels, level);
    };
    Phaser.QuadTree.prototype = {
        reset: function(x, y, width, height, maxObjects, maxLevels, level) {
            this.maxObjects = maxObjects || 10;
            this.maxLevels = maxLevels || 4;
            this.level = level || 0;
            this.bounds = {
                x: Math.round(x),
                y: Math.round(y),
                width: width,
                height: height,
                subWidth: Math.floor(width / 2),
                subHeight: Math.floor(height / 2),
                right: Math.round(x) + Math.floor(width / 2),
                bottom: Math.round(y) + Math.floor(height / 2)
            };
            this.objects.length = 0;
            this.nodes.length = 0;
        },
        populate: function(group) {
            group.forEach(this.populateHandler, this, true);
        },
        populateHandler: function(sprite) {
            if (sprite.body && sprite.exists) {
                this.insert(sprite.body);
            }
        },
        split: function() {
            this.nodes[0] = new Phaser.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[1] = new Phaser.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[2] = new Phaser.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
            this.nodes[3] = new Phaser.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        },
        insert: function(body) {
            var i = 0;
            var index;
            if (this.nodes[0] != null) {
                index = this.getIndex(body);
                if (index !== -1) {
                    this.nodes[index].insert(body);
                    return;
                }
            }
            this.objects.push(body);
            if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                if (this.nodes[0] == null) {
                    this.split();
                }
                while (i < this.objects.length) {
                    index = this.getIndex(this.objects[i]);
                    if (index !== -1) {
                        this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                    } else {
                        i++;
                    }
                }
            }
        },
        getIndex: function(rect) {
            var index = -1;
            if (rect.x < this.bounds.right && rect.right < this.bounds.right) {
                if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) {
                    index = 1;
                } else if (rect.y > this.bounds.bottom) {
                    index = 2;
                }
            } else if (rect.x > this.bounds.right) {
                if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) {
                    index = 0;
                } else if (rect.y > this.bounds.bottom) {
                    index = 3;
                }
            }
            return index;
        },
        retrieve: function(source) {
            if (source instanceof Phaser.Rectangle) {
                var returnObjects = this.objects;
                var index = this.getIndex(source);
            } else {
                if (!source.body) {
                    return this._empty;
                }
                var returnObjects = this.objects;
                var index = this.getIndex(source.body);
            }
            if (this.nodes[0]) {
                if (index !== -1) {
                    returnObjects = returnObjects.concat(this.nodes[index].retrieve(source));
                } else {
                    returnObjects = returnObjects.concat(this.nodes[0].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[1].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[2].retrieve(source));
                    returnObjects = returnObjects.concat(this.nodes[3].retrieve(source));
                }
            }
            return returnObjects;
        },
        clear: function() {
            this.objects.length = 0;
            var i = this.nodes.length;
            while (i--) {
                this.nodes[i].clear();
                this.nodes.splice(i, 1);
            }
            this.nodes.length = 0;
        }
    };
    Phaser.QuadTree.prototype.constructor = Phaser.QuadTree;
    Phaser.Net = function(game) {
        this.game = game;
    };
    Phaser.Net.prototype = {
        getHostName: function() {
            if (window.location && window.location.hostname) {
                return window.location.hostname;
            }
            return null;
        },
        checkDomainName: function(domain) {
            return window.location.hostname.indexOf(domain) !== -1;
        },
        updateQueryString: function(key, value, redirect, url) {
            if (typeof redirect === "undefined") {
                redirect = false;
            }
            if (typeof url === "undefined" || url === "") {
                url = window.location.href;
            }
            var output = "";
            var re = new RegExp("([?|&])" + key + "=.*?(&|#|$)(.*)", "gi");
            if (re.test(url)) {
                if (typeof value !== "undefined" && value !== null) {
                    output = url.replace(re, "$1" + key + "=" + value + "$2$3");
                } else {
                    output = url.replace(re, "$1$3").replace(/(&|\?)$/, "");
                }
            } else {
                if (typeof value !== "undefined" && value !== null) {
                    var separator = url.indexOf("?") !== -1 ? "&" : "?";
                    var hash = url.split("#");
                    url = hash[0] + separator + key + "=" + value;
                    if (hash[1]) {
                        url += "#" + hash[1];
                    }
                    output = url;
                } else {
                    output = url;
                }
            }
            if (redirect) {
                window.location.href = output;
            } else {
                return output;
            }
        },
        getQueryString: function(parameter) {
            if (typeof parameter === "undefined") {
                parameter = "";
            }
            var output = {};
            var keyValues = location.search.substring(1).split("&");
            for (var i in keyValues) {
                var key = keyValues[i].split("=");
                if (key.length > 1) {
                    if (parameter && parameter == this.decodeURI(key[0])) {
                        return this.decodeURI(key[1]);
                    } else {
                        output[this.decodeURI(key[0])] = this.decodeURI(key[1]);
                    }
                }
            }
            return output;
        },
        decodeURI: function(value) {
            return decodeURIComponent(value.replace(/\+/g, " "));
        }
    };
    Phaser.Net.prototype.constructor = Phaser.Net;
    Phaser.TweenManager = function(game) {
        this.game = game;
        this._tweens = [];
        this._add = [];
        this.game.onPause.add(this._pauseAll, this);
        this.game.onResume.add(this._resumeAll, this);
    };
    Phaser.TweenManager.prototype = {
        getAll: function() {
            return this._tweens;
        },
        removeAll: function() {
            for (var i = 0; i < this._tweens.length; i++) {
                this._tweens[i].pendingDelete = true;
            }
            this._add = [];
        },
        add: function(tween) {
            tween._manager = this;
            this._add.push(tween);
        },
        create: function(object) {
            return new Phaser.Tween(object, this.game, this);
        },
        remove: function(tween) {
            var i = this._tweens.indexOf(tween);
            if (i !== -1) {
                this._tweens[i].pendingDelete = true;
            } else {
                i = this._add.indexOf(tween);
                if (i !== -1) {
                    this._add[i].pendingDelete = true;
                }
            }
        },
        update: function() {
            var addTweens = this._add.length;
            var numTweens = this._tweens.length;
            if (numTweens === 0 && addTweens === 0) {
                return false;
            }
            var i = 0;
            while (i < numTweens) {
                if (this._tweens[i].update(this.game.time.now)) {
                    i++;
                } else {
                    this._tweens.splice(i, 1);
                    numTweens--;
                }
            }
            if (addTweens > 0) {
                this._tweens = this._tweens.concat(this._add);
                this._add.length = 0;
            }
            return true;
        },
        isTweening: function(object) {
            return this._tweens.some(function(tween) {
                return tween._object === object;
            });
        },
        _pauseAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i]._pause();
            }
        },
        _resumeAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i]._resume();
            }
        },
        pauseAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i].pause();
            }
        },
        resumeAll: function() {
            for (var i = this._tweens.length - 1; i >= 0; i--) {
                this._tweens[i].resume(true);
            }
        }
    };
    Phaser.TweenManager.prototype.constructor = Phaser.TweenManager;
    Phaser.Tween = function(object, game, manager) {
        this._object = object;
        this.game = game;
        this._manager = manager;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1e3;
        this._repeat = 0;
        this._yoyo = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = null;
        this._easingFunction = Phaser.Easing.Default;
        this._interpolationFunction = Phaser.Math.linearInterpolation;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._onUpdateCallback = null;
        this._onUpdateCallbackContext = null;
        this._paused = false;
        this._pausedTime = 0;
        this._codePaused = false;
        this.pendingDelete = false;
        this.onStart = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.onComplete = new Phaser.Signal();
        this.isRunning = false;
    };
    Phaser.Tween.prototype = {
        to: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
            duration = duration || 1e3;
            ease = ease || null;
            autoStart = autoStart || false;
            delay = delay || 0;
            repeat = repeat || 0;
            yoyo = yoyo || false;
            if (yoyo && repeat === 0) {
                repeat = 1;
            }
            var self;
            if (this._parent) {
                self = this._manager.create(this._object);
                this._lastChild.chain(self);
                this._lastChild = self;
            } else {
                self = this;
                this._parent = this;
                this._lastChild = this;
            }
            self._repeat = repeat;
            self._duration = duration;
            self._valuesEnd = properties;
            if (ease !== null) {
                self._easingFunction = ease;
            }
            if (delay > 0) {
                self._delayTime = delay;
            }
            self._yoyo = yoyo;
            if (autoStart) {
                return this.start();
            } else {
                return this;
            }
        },
        from: function(properties, duration, ease, autoStart, delay, repeat, yoyo) {
            var _cache = {};
            for (var prop in properties) {
                _cache[prop] = this._object[prop];
                this._object[prop] = properties[prop];
            }
            return this.to(_cache, duration, ease, autoStart, delay, repeat, yoyo);
        },
        start: function() {
            if (this.game === null || this._object === null) {
                return;
            }
            this._manager.add(this);
            this.isRunning = true;
            this._onStartCallbackFired = false;
            this._startTime = this.game.time.now + this._delayTime;
            for (var property in this._valuesEnd) {
                if (Array.isArray(this._valuesEnd[property])) {
                    if (this._valuesEnd[property].length === 0) {
                        continue;
                    }
                    this._valuesEnd[property] = [ this._object[property] ].concat(this._valuesEnd[property]);
                }
                this._valuesStart[property] = this._object[property];
                if (!Array.isArray(this._valuesStart[property])) {
                    this._valuesStart[property] *= 1;
                }
                this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
            }
            return this;
        },
        generateData: function(frameRate, data) {
            if (this.game === null || this._object === null) {
                return null;
            }
            this._startTime = 0;
            for (var property in this._valuesEnd) {
                if (Array.isArray(this._valuesEnd[property])) {
                    if (this._valuesEnd[property].length === 0) {
                        continue;
                    }
                    this._valuesEnd[property] = [ this._object[property] ].concat(this._valuesEnd[property]);
                }
                this._valuesStart[property] = this._object[property];
                if (!Array.isArray(this._valuesStart[property])) {
                    this._valuesStart[property] *= 1;
                }
                this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
            }
            var time = 0;
            var total = Math.floor(frameRate * (this._duration / 1e3));
            var tick = this._duration / total;
            var output = [];
            while (total--) {
                var property;
                var elapsed = (time - this._startTime) / this._duration;
                elapsed = elapsed > 1 ? 1 : elapsed;
                var value = this._easingFunction(elapsed);
                var blob = {};
                for (property in this._valuesEnd) {
                    var start = this._valuesStart[property] || 0;
                    var end = this._valuesEnd[property];
                    if (end instanceof Array) {
                        blob[property] = this._interpolationFunction(end, value);
                    } else {
                        if (typeof end === "string") {
                            end = start + parseFloat(end, 10);
                        } else if (typeof end === "number") {
                            blob[property] = start + (end - start) * value;
                        }
                    }
                }
                output.push(blob);
                time += tick;
            }
            var blob = {};
            for (property in this._valuesEnd) {
                blob[property] = this._valuesEnd[property];
            }
            output.push(blob);
            if (this._yoyo) {
                var reversed = output.slice();
                reversed.reverse();
                output = output.concat(reversed);
            }
            if (typeof data !== "undefined") {
                data = data.concat(output);
                return data;
            } else {
                return output;
            }
        },
        stop: function() {
            this.isRunning = false;
            this._onUpdateCallback = null;
            this._manager.remove(this);
            return this;
        },
        delay: function(amount) {
            this._delayTime = amount;
            return this;
        },
        repeat: function(times) {
            this._repeat = times;
            return this;
        },
        yoyo: function(yoyo) {
            this._yoyo = yoyo;
            if (yoyo && this._repeat === 0) {
                this._repeat = 1;
            }
            return this;
        },
        easing: function(easing) {
            this._easingFunction = easing;
            return this;
        },
        interpolation: function(interpolation) {
            this._interpolationFunction = interpolation;
            return this;
        },
        chain: function() {
            this._chainedTweens = arguments;
            return this;
        },
        loop: function() {
            this._lastChild.chain(this);
            return this;
        },
        onUpdateCallback: function(callback, callbackContext) {
            this._onUpdateCallback = callback;
            this._onUpdateCallbackContext = callbackContext;
            return this;
        },
        pause: function() {
            this._codePaused = true;
            this._paused = true;
            this._pausedTime = this.game.time.now;
        },
        _pause: function() {
            if (!this._codePaused) {
                this._paused = true;
                this._pausedTime = this.game.time.now;
            }
        },
        resume: function() {
            if (this._paused) {
                this._paused = false;
                this._codePaused = false;
                this._startTime += this.game.time.now - this._pausedTime;
            }
        },
        _resume: function() {
            if (this._codePaused) {
                return;
            } else {
                this._startTime += this.game.time.pauseDuration;
                this._paused = false;
            }
        },
        update: function(time) {
            if (this.pendingDelete) {
                return false;
            }
            if (this._paused || time < this._startTime) {
                return true;
            }
            var property;
            if (time < this._startTime) {
                return true;
            }
            if (this._onStartCallbackFired === false) {
                this.onStart.dispatch(this._object);
                this._onStartCallbackFired = true;
            }
            var elapsed = (time - this._startTime) / this._duration;
            elapsed = elapsed > 1 ? 1 : elapsed;
            var value = this._easingFunction(elapsed);
            for (property in this._valuesEnd) {
                var start = this._valuesStart[property] || 0;
                var end = this._valuesEnd[property];
                if (end instanceof Array) {
                    this._object[property] = this._interpolationFunction(end, value);
                } else {
                    if (typeof end === "string") {
                        end = start + parseFloat(end, 10);
                    }
                    if (typeof end === "number") {
                        this._object[property] = start + (end - start) * value;
                    }
                }
            }
            if (this._onUpdateCallback !== null) {
                this._onUpdateCallback.call(this._onUpdateCallbackContext, this, value);
                if (!this.isRunning) {
                    return false;
                }
            }
            if (elapsed == 1) {
                if (this._repeat > 0) {
                    if (isFinite(this._repeat)) {
                        this._repeat--;
                    }
                    for (property in this._valuesStartRepeat) {
                        if (typeof this._valuesEnd[property] === "string") {
                            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property], 10);
                        }
                        if (this._yoyo) {
                            var tmp = this._valuesStartRepeat[property];
                            this._valuesStartRepeat[property] = this._valuesEnd[property];
                            this._valuesEnd[property] = tmp;
                        }
                        this._valuesStart[property] = this._valuesStartRepeat[property];
                    }
                    if (this._yoyo) {
                        this._reversed = !this._reversed;
                    }
                    this._startTime = time + this._delayTime;
                    this.onLoop.dispatch(this._object);
                    return true;
                } else {
                    this.isRunning = false;
                    this.onComplete.dispatch(this._object);
                    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                        this._chainedTweens[i].start(time);
                    }
                    return false;
                }
            }
            return true;
        }
    };
    Phaser.Tween.prototype.constructor = Phaser.Tween;
    Phaser.Easing = {
        Linear: {
            None: function(k) {
                return k;
            }
        },
        Quadratic: {
            In: function(k) {
                return k * k;
            },
            Out: function(k) {
                return k * (2 - k);
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k;
                return -.5 * (--k * (k - 2) - 1);
            }
        },
        Cubic: {
            In: function(k) {
                return k * k * k;
            },
            Out: function(k) {
                return --k * k * k + 1;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k;
                return .5 * ((k -= 2) * k * k + 2);
            }
        },
        Quartic: {
            In: function(k) {
                return k * k * k * k;
            },
            Out: function(k) {
                return 1 - --k * k * k * k;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k * k;
                return -.5 * ((k -= 2) * k * k * k - 2);
            }
        },
        Quintic: {
            In: function(k) {
                return k * k * k * k * k;
            },
            Out: function(k) {
                return --k * k * k * k * k + 1;
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return .5 * k * k * k * k * k;
                return .5 * ((k -= 2) * k * k * k * k + 2);
            }
        },
        Sinusoidal: {
            In: function(k) {
                return 1 - Math.cos(k * Math.PI / 2);
            },
            Out: function(k) {
                return Math.sin(k * Math.PI / 2);
            },
            InOut: function(k) {
                return .5 * (1 - Math.cos(Math.PI * k));
            }
        },
        Exponential: {
            In: function(k) {
                return k === 0 ? 0 : Math.pow(1024, k - 1);
            },
            Out: function(k) {
                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            },
            InOut: function(k) {
                if (k === 0) return 0;
                if (k === 1) return 1;
                if ((k *= 2) < 1) return .5 * Math.pow(1024, k - 1);
                return .5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            }
        },
        Circular: {
            In: function(k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            Out: function(k) {
                return Math.sqrt(1 - --k * k);
            },
            InOut: function(k) {
                if ((k *= 2) < 1) return -.5 * (Math.sqrt(1 - k * k) - 1);
                return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            }
        },
        Elastic: {
            In: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            },
            Out: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            },
            InOut: function(k) {
                var s, a = .1, p = .4;
                if (k === 0) return 0;
                if (k === 1) return 1;
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else s = p * Math.asin(1 / a) / (2 * Math.PI);
                if ((k *= 2) < 1) return -.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1;
            }
        },
        Back: {
            In: function(k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            Out: function(k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            InOut: function(k) {
                var s = 1.70158 * 1.525;
                if ((k *= 2) < 1) return .5 * (k * k * ((s + 1) * k - s));
                return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            }
        },
        Bounce: {
            In: function(k) {
                return 1 - Phaser.Easing.Bounce.Out(1 - k);
            },
            Out: function(k) {
                if (k < 1 / 2.75) {
                    return 7.5625 * k * k;
                } else if (k < 2 / 2.75) {
                    return 7.5625 * (k -= 1.5 / 2.75) * k + .75;
                } else if (k < 2.5 / 2.75) {
                    return 7.5625 * (k -= 2.25 / 2.75) * k + .9375;
                } else {
                    return 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
                }
            },
            InOut: function(k) {
                if (k < .5) return Phaser.Easing.Bounce.In(k * 2) * .5;
                return Phaser.Easing.Bounce.Out(k * 2 - 1) * .5 + .5;
            }
        }
    };
    Phaser.Easing.Default = Phaser.Easing.Linear.None;
    Phaser.Time = function(game) {
        this.game = game;
        this.time = 0;
        this.now = 0;
        this.elapsed = 0;
        this.pausedTime = 0;
        this.advancedTiming = false;
        this.fps = 0;
        this.fpsMin = 1e3;
        this.fpsMax = 0;
        this.msMin = 1e3;
        this.msMax = 0;
        this.physicsElapsed = 0;
        this.deltaCap = 0;
        this.timeCap = 1 / 60 * 1e3;
        this.frames = 0;
        this.pauseDuration = 0;
        this.timeToCall = 0;
        this.lastTime = 0;
        this.events = new Phaser.Timer(this.game, false);
        this._started = 0;
        this._timeLastSecond = 0;
        this._pauseStarted = 0;
        this._justResumed = false;
        this._timers = [];
        this._len = 0;
        this._i = 0;
    };
    Phaser.Time.prototype = {
        boot: function() {
            this._started = Date.now();
            this.events.start();
        },
        add: function(timer) {
            this._timers.push(timer);
            return timer;
        },
        create: function(autoDestroy) {
            if (typeof autoDestroy === "undefined") {
                autoDestroy = true;
            }
            var timer = new Phaser.Timer(this.game, autoDestroy);
            this._timers.push(timer);
            return timer;
        },
        removeAll: function() {
            for (var i = 0; i < this._timers.length; i++) {
                this._timers[i].destroy();
            }
            this._timers = [];
            this.events.removeAll();
        },
        update: function(time) {
            this.now = time;
            this.timeToCall = this.game.math.max(0, 16 - (time - this.lastTime));
            this.elapsed = this.now - this.time;
            if (this.elapsed > this.timeCap) {
                this.elapsed = this.timeCap;
            }
            this.physicsElapsed = this.elapsed / 1e3 || 1 / 60;
            if (this.deltaCap > 0 && this.physicsElapsed > this.deltaCap) {
                this.physicsElapsed = this.deltaCap;
            }
            if (this.advancedTiming) {
                this.msMin = this.game.math.min(this.msMin, this.elapsed);
                this.msMax = this.game.math.max(this.msMax, this.elapsed);
                this.frames++;
                if (this.now > this._timeLastSecond + 1e3) {
                    this.fps = Math.round(this.frames * 1e3 / (this.now - this._timeLastSecond));
                    this.fpsMin = this.game.math.min(this.fpsMin, this.fps);
                    this.fpsMax = this.game.math.max(this.fpsMax, this.fps);
                    this._timeLastSecond = this.now;
                    this.frames = 0;
                }
            }
            this.time = this.now;
            this.lastTime = time + this.timeToCall;
            if (!this.game.paused) {
                this.events.update(this.now);
                this._i = 0;
                this._len = this._timers.length;
                while (this._i < this._len) {
                    if (this._timers[this._i].update(this.now)) {
                        this._i++;
                    } else {
                        this._timers.splice(this._i, 1);
                        this._len--;
                    }
                }
            }
        },
        gamePaused: function() {
            this._pauseStarted = this.now;
            this.events.pause();
            var i = this._timers.length;
            while (i--) {
                this._timers[i]._pause();
            }
        },
        gameResumed: function() {
            this.time = this.now = Date.now();
            this.pauseDuration = this.time - this._pauseStarted;
            this.events.resume();
            var i = this._timers.length;
            while (i--) {
                this._timers[i]._resume();
            }
        },
        totalElapsedSeconds: function() {
            return (this.now - this._started) * .001;
        },
        elapsedSince: function(since) {
            return this.now - since;
        },
        elapsedSecondsSince: function(since) {
            return (this.now - since) * .001;
        },
        reset: function() {
            this._started = this.now;
            this.removeAll();
        }
    };
    Phaser.Time.prototype.constructor = Phaser.Time;
    Phaser.Timer = function(game, autoDestroy) {
        if (typeof autoDestroy === "undefined") {
            autoDestroy = true;
        }
        this.game = game;
        this.running = false;
        this.autoDestroy = autoDestroy;
        this.expired = false;
        this.elapsed = 0;
        this.events = [];
        this.onComplete = new Phaser.Signal();
        this.nextTick = 0;
        this.timeCap = 1e3;
        this.paused = false;
        this._codePaused = false;
        this._started = 0;
        this._pauseStarted = 0;
        this._pauseTotal = 0;
        this._now = Date.now();
        this._len = 0;
        this._marked = 0;
        this._i = 0;
        this._diff = 0;
        this._newTick = 0;
    };
    Phaser.Timer.MINUTE = 6e4;
    Phaser.Timer.SECOND = 1e3;
    Phaser.Timer.HALF = 500;
    Phaser.Timer.QUARTER = 250;
    Phaser.Timer.prototype = {
        create: function(delay, loop, repeatCount, callback, callbackContext, args) {
            var tick = delay;
            if (this._now === 0) {
                tick += this.game.time.now;
            } else {
                tick += this._now;
            }
            var event = new Phaser.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);
            this.events.push(event);
            this.order();
            this.expired = false;
            return event;
        },
        add: function(delay, callback, callbackContext) {
            return this.create(delay, false, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
        },
        repeat: function(delay, repeatCount, callback, callbackContext) {
            return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.splice.call(arguments, 4));
        },
        loop: function(delay, callback, callbackContext) {
            return this.create(delay, true, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
        },
        start: function(delay) {
            if (this.running) {
                return;
            }
            this._started = this.game.time.now + (delay || 0);
            this.running = true;
            for (var i = 0; i < this.events.length; i++) {
                this.events[i].tick = this.events[i].delay + this._started;
            }
        },
        stop: function(clearEvents) {
            this.running = false;
            if (typeof clearEvents === "undefined") {
                clearEvents = true;
            }
            if (clearEvents) {
                this.events.length = 0;
            }
        },
        remove: function(event) {
            for (var i = 0; i < this.events.length; i++) {
                if (this.events[i] === event) {
                    this.events[i].pendingDelete = true;
                    return true;
                }
            }
            return false;
        },
        order: function() {
            if (this.events.length > 0) {
                this.events.sort(this.sortHandler);
                this.nextTick = this.events[0].tick;
            }
        },
        sortHandler: function(a, b) {
            if (a.tick < b.tick) {
                return -1;
            } else if (a.tick > b.tick) {
                return 1;
            }
            return 0;
        },
        clearPendingEvents: function() {
            this._i = this.events.length;
            while (this._i--) {
                if (this.events[this._i].pendingDelete) {
                    this.events.splice(this._i, 1);
                }
            }
            this._len = this.events.length;
            this._i = 0;
        },
        update: function(time) {
            if (this.paused) {
                return true;
            }
            this.elapsed = time - this._now;
            this._now = time;
            if (this.elapsed > this.timeCap) {
                this.adjustEvents(time - this.elapsed);
            }
            this._marked = 0;
            this.clearPendingEvents();
            if (this.running && this._now >= this.nextTick && this._len > 0) {
                while (this._i < this._len && this.running) {
                    if (this._now >= this.events[this._i].tick) {
                        this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick);
                        if (this._newTick < 0) {
                            this._newTick = this._now + this.events[this._i].delay;
                        }
                        if (this.events[this._i].loop === true) {
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        } else if (this.events[this._i].repeatCount > 0) {
                            this.events[this._i].repeatCount--;
                            this.events[this._i].tick = this._newTick;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        } else {
                            this._marked++;
                            this.events[this._i].pendingDelete = true;
                            this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
                        }
                        this._i++;
                    } else {
                        break;
                    }
                }
                if (this.events.length > this._marked) {
                    this.order();
                } else {
                    this.expired = true;
                    this.onComplete.dispatch(this);
                }
            }
            if (this.expired && this.autoDestroy) {
                return false;
            } else {
                return true;
            }
        },
        pause: function() {
            if (!this.running) {
                return;
            }
            this._codePaused = true;
            if (this.paused) {
                return;
            }
            this._pauseStarted = this.game.time.now;
            this.paused = true;
        },
        _pause: function() {
            if (this.paused || !this.running) {
                return;
            }
            this._pauseStarted = this.game.time.now;
            this.paused = true;
        },
        adjustEvents: function(baseTime) {
            for (var i = 0; i < this.events.length; i++) {
                if (!this.events[i].pendingDelete) {
                    var t = this.events[i].tick - baseTime;
                    if (t < 0) {
                        t = 0;
                    }
                    this.events[i].tick = this._now + t;
                }
            }
            var d = this.nextTick - baseTime;
            if (d < 0) {
                this.nextTick = this._now;
            } else {
                this.nextTick = this._now + d;
            }
        },
        resume: function() {
            if (!this.paused) {
                return;
            }
            var now = this.game.time.now;
            this._pauseTotal += now - this._now;
            this._now = now;
            this.adjustEvents(this._pauseStarted);
            this.paused = false;
            this._codePaused = false;
        },
        _resume: function() {
            if (this._codePaused) {
                return;
            } else {
                this.resume();
            }
        },
        removeAll: function() {
            this.onComplete.removeAll();
            this.events.length = 0;
            this._len = 0;
            this._i = 0;
        },
        destroy: function() {
            this.onComplete.removeAll();
            this.running = false;
            this.events = [];
            this._len = 0;
            this._i = 0;
        }
    };
    Object.defineProperty(Phaser.Timer.prototype, "next", {
        get: function() {
            return this.nextTick;
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "duration", {
        get: function() {
            if (this.running && this.nextTick > this._now) {
                return this.nextTick - this._now;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "length", {
        get: function() {
            return this.events.length;
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "ms", {
        get: function() {
            if (this.running) {
                return this._now - this._started - this._pauseTotal;
            } else {
                return 0;
            }
        }
    });
    Object.defineProperty(Phaser.Timer.prototype, "seconds", {
        get: function() {
            if (this.running) {
                return this.ms * .001;
            } else {
                return 0;
            }
        }
    });
    Phaser.Timer.prototype.constructor = Phaser.Timer;
    Phaser.TimerEvent = function(timer, delay, tick, repeatCount, loop, callback, callbackContext, args) {
        this.timer = timer;
        this.delay = delay;
        this.tick = tick;
        this.repeatCount = repeatCount - 1;
        this.loop = loop;
        this.callback = callback;
        this.callbackContext = callbackContext;
        this.args = args;
        this.pendingDelete = false;
    };
    Phaser.TimerEvent.prototype.constructor = Phaser.TimerEvent;
    Phaser.AnimationManager = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.currentFrame = null;
        this.currentAnim = null;
        this.updateIfVisible = true;
        this.isLoaded = false;
        this._frameData = null;
        this._anims = {};
        this._outputFrames = [];
    };
    Phaser.AnimationManager.prototype = {
        loadFrameData: function(frameData, frame) {
            if (this.isLoaded) {
                for (var anim in this._anims) {
                    this._anims[anim].updateFrameData(frameData);
                }
            }
            this._frameData = frameData;
            if (typeof frame === "undefined" || frame === null) {
                this.frame = 0;
            } else {
                if (typeof frame === "string") {
                    this.frameName = frame;
                } else {
                    this.frame = frame;
                }
            }
            this.isLoaded = true;
            return true;
        },
        copyFrameData: function(frameData, frame) {
            this._frameData = frameData.clone();
            if (this.isLoaded) {
                for (var anim in this._anims) {
                    this._anims[anim].updateFrameData(this._frameData);
                }
            }
            if (typeof frame === "undefined" || frame === null) {
                this.frame = 0;
            } else {
                if (typeof frame === "string") {
                    this.frameName = frame;
                } else {
                    this.frame = frame;
                }
            }
            this.isLoaded = true;
            return true;
        },
        add: function(name, frames, frameRate, loop, useNumericIndex) {
            frames = frames || [];
            frameRate = frameRate || 60;
            if (typeof loop === "undefined") {
                loop = false;
            }
            if (typeof useNumericIndex === "undefined") {
                if (frames && typeof frames[0] === "number") {
                    useNumericIndex = true;
                } else {
                    useNumericIndex = false;
                }
            }
            if (this.sprite.events.onAnimationStart === null) {
                this.sprite.events.onAnimationStart = new Phaser.Signal();
                this.sprite.events.onAnimationComplete = new Phaser.Signal();
                this.sprite.events.onAnimationLoop = new Phaser.Signal();
            }
            this._outputFrames.length = 0;
            this._frameData.getFrameIndexes(frames, useNumericIndex, this._outputFrames);
            this._anims[name] = new Phaser.Animation(this.game, this.sprite, name, this._frameData, this._outputFrames, frameRate, loop);
            this.currentAnim = this._anims[name];
            this.currentFrame = this.currentAnim.currentFrame;
            if (this.sprite.__tilePattern) {
                this.sprite.__tilePattern = false;
                this.tilingTexture = false;
            }
            return this._anims[name];
        },
        validateFrames: function(frames, useNumericIndex) {
            if (typeof useNumericIndex == "undefined") {
                useNumericIndex = true;
            }
            for (var i = 0; i < frames.length; i++) {
                if (useNumericIndex === true) {
                    if (frames[i] > this._frameData.total) {
                        return false;
                    }
                } else {
                    if (this._frameData.checkFrameName(frames[i]) === false) {
                        return false;
                    }
                }
            }
            return true;
        },
        play: function(name, frameRate, loop, killOnComplete) {
            if (this._anims[name]) {
                if (this.currentAnim === this._anims[name]) {
                    if (this.currentAnim.isPlaying === false) {
                        this.currentAnim.paused = false;
                        return this.currentAnim.play(frameRate, loop, killOnComplete);
                    }
                    return this.currentAnim;
                } else {
                    if (this.currentAnim && this.currentAnim.isPlaying) {
                        this.currentAnim.stop();
                    }
                    this.currentAnim = this._anims[name];
                    this.currentAnim.paused = false;
                    this.currentFrame = this.currentAnim.currentFrame;
                    return this.currentAnim.play(frameRate, loop, killOnComplete);
                }
            }
        },
        stop: function(name, resetFrame) {
            if (typeof resetFrame == "undefined") {
                resetFrame = false;
            }
            if (typeof name == "string") {
                if (this._anims[name]) {
                    this.currentAnim = this._anims[name];
                    this.currentAnim.stop(resetFrame);
                }
            } else {
                if (this.currentAnim) {
                    this.currentAnim.stop(resetFrame);
                }
            }
        },
        update: function() {
            if (this.updateIfVisible && !this.sprite.visible) {
                return false;
            }
            if (this.currentAnim && this.currentAnim.update() === true) {
                this.currentFrame = this.currentAnim.currentFrame;
                return true;
            }
            return false;
        },
        next: function(quantity) {
            if (this.currentAnim) {
                this.currentAnim.next(quantity);
                this.currentFrame = this.currentAnim.currentFrame;
            }
        },
        previous: function(quantity) {
            if (this.currentAnim) {
                this.currentAnim.previous(quantity);
                this.currentFrame = this.currentAnim.currentFrame;
            }
        },
        getAnimation: function(name) {
            if (typeof name === "string") {
                if (this._anims[name]) {
                    return this._anims[name];
                }
            }
            return null;
        },
        refreshFrame: function() {
            this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);
            if (this.sprite.__tilePattern) {
                this.__tilePattern = false;
                this.tilingTexture = false;
            }
        },
        destroy: function() {
            var anim = null;
            for (var anim in this._anims) {
                if (this._anims.hasOwnProperty(anim)) {
                    this._anims[anim].destroy();
                }
            }
            this._anims = {};
            this._frameData = null;
            this._frameIndex = 0;
            this.currentAnim = null;
            this.currentFrame = null;
        }
    };
    Phaser.AnimationManager.prototype.constructor = Phaser.AnimationManager;
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData.total;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused;
        },
        set: function(value) {
            this.currentAnim.paused = value;
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame) {
                return this._frameIndex;
            }
        },
        set: function(value) {
            if (typeof value === "number" && this._frameData.getFrame(value) !== null) {
                this.currentFrame = this._frameData.getFrame(value);
                if (this.currentFrame) {
                    this._frameIndex = value;
                    this.sprite.setFrame(this.currentFrame);
                    if (this.sprite.__tilePattern) {
                        this.__tilePattern = false;
                        this.tilingTexture = false;
                    }
                }
            }
        }
    });
    Object.defineProperty(Phaser.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame) {
                return this.currentFrame.name;
            }
        },
        set: function(value) {
            if (typeof value === "string" && this._frameData.getFrameByName(value) !== null) {
                this.currentFrame = this._frameData.getFrameByName(value);
                if (this.currentFrame) {
                    this._frameIndex = this.currentFrame.index;
                    this.sprite.setFrame(this.currentFrame);
                    if (this.sprite.__tilePattern) {
                        this.__tilePattern = false;
                        this.tilingTexture = false;
                    }
                }
            } else {
                console.warn("Cannot set frameName: " + value);
            }
        }
    });
    Phaser.Animation = function(game, parent, name, frameData, frames, delay, loop) {
        this.game = game;
        this._parent = parent;
        this._frameData = frameData;
        this.name = name;
        this._frames = [];
        this._frames = this._frames.concat(frames);
        this.delay = 1e3 / delay;
        this.loop = loop;
        this.loopCount = 0;
        this.killOnComplete = false;
        this.isFinished = false;
        this.isPlaying = false;
        this.isPaused = false;
        this._pauseStartTime = 0;
        this._frameIndex = 0;
        this._frameDiff = 0;
        this._frameSkip = 1;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        this.onStart = new Phaser.Signal();
        this.onUpdate = null;
        this.onComplete = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.game.onPause.add(this.onPause, this);
        this.game.onResume.add(this.onResume, this);
    };
    Phaser.Animation.prototype = {
        play: function(frameRate, loop, killOnComplete) {
            if (typeof frameRate === "number") {
                this.delay = 1e3 / frameRate;
            }
            if (typeof loop === "boolean") {
                this.loop = loop;
            }
            if (typeof killOnComplete !== "undefined") {
                this.killOnComplete = killOnComplete;
            }
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setFrame(this.currentFrame);
            if (this._parent.__tilePattern) {
                this._parent.__tilePattern = false;
                this._parent.tilingTexture = false;
            }
            this._parent.events.onAnimationStart.dispatch(this._parent, this);
            this.onStart.dispatch(this._parent, this);
            return this;
        },
        restart: function() {
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this.loopCount = 0;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setFrame(this.currentFrame);
            this.onStart.dispatch(this._parent, this);
        },
        setFrame: function(frameId, useLocalFrameIndex) {
            var frameIndex;
            if (typeof useLocalFrameIndex === "undefined") {
                useLocalFrameIndex = false;
            }
            if (typeof frameId === "string") {
                for (var i = 0; i < this._frames.length; i++) {
                    if (this._frameData.getFrame(this._frames[i]).name === frameId) {
                        frameIndex = i;
                    }
                }
            } else if (typeof frameId === "number") {
                if (useLocalFrameIndex) {
                    frameIndex = frameId;
                } else {
                    for (var i = 0; i < this._frames.length; i++) {
                        if (this.frames[i] === frameIndex) {
                            frameIndex = i;
                        }
                    }
                }
            }
            if (frameIndex) {
                this._frameIndex = frameIndex - 1;
                this._timeNextFrame = this.game.time.now;
                this.update();
            }
        },
        stop: function(resetFrame, dispatchComplete) {
            if (typeof resetFrame === "undefined") {
                resetFrame = false;
            }
            if (typeof dispatchComplete === "undefined") {
                dispatchComplete = false;
            }
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            if (resetFrame) {
                this.currentFrame = this._frameData.getFrame(this._frames[0]);
                this._parent.setFrame(this.currentFrame);
            }
            if (dispatchComplete) {
                this._parent.events.onAnimationComplete.dispatch(this._parent, this);
                this.onComplete.dispatch(this._parent, this);
            }
        },
        onPause: function() {
            if (this.isPlaying) {
                this._frameDiff = this._timeNextFrame - this.game.time.now;
            }
        },
        onResume: function() {
            if (this.isPlaying) {
                this._timeNextFrame = this.game.time.now + this._frameDiff;
            }
        },
        update: function() {
            if (this.isPaused) {
                return false;
            }
            if (this.isPlaying && this.game.time.now >= this._timeNextFrame) {
                this._frameSkip = 1;
                this._frameDiff = this.game.time.now - this._timeNextFrame;
                this._timeLastFrame = this.game.time.now;
                if (this._frameDiff > this.delay) {
                    this._frameSkip = Math.floor(this._frameDiff / this.delay);
                    this._frameDiff -= this._frameSkip * this.delay;
                }
                this._timeNextFrame = this.game.time.now + (this.delay - this._frameDiff);
                this._frameIndex += this._frameSkip;
                if (this._frameIndex >= this._frames.length) {
                    if (this.loop) {
                        this._frameIndex %= this._frames.length;
                        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                        this.loopCount++;
                        this._parent.events.onAnimationLoop.dispatch(this._parent, this);
                        this.onLoop.dispatch(this._parent, this);
                    } else {
                        this.complete();
                    }
                }
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                if (this.currentFrame) {
                    this._parent.setFrame(this.currentFrame);
                    if (this._parent.__tilePattern) {
                        this._parent.__tilePattern = false;
                        this._parent.tilingTexture = false;
                    }
                    if (this.onUpdate) {
                        this.onUpdate.dispatch(this, this.currentFrame);
                    }
                }
                return true;
            }
            return false;
        },
        next: function(quantity) {
            if (typeof quantity === "undefined") {
                quantity = 1;
            }
            var frame = this._frameIndex + quantity;
            if (frame >= this._frames.length) {
                if (this.loop) {
                    frame %= this._frames.length;
                } else {
                    frame = this._frames.length - 1;
                }
            }
            if (frame !== this._frameIndex) {
                this._frameIndex = frame;
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                if (this.currentFrame) {
                    this._parent.setFrame(this.currentFrame);
                    if (this._parent.__tilePattern) {
                        this._parent.__tilePattern = false;
                        this._parent.tilingTexture = false;
                    }
                }
                if (this.onUpdate) {
                    this.onUpdate.dispatch(this, this.currentFrame);
                }
            }
        },
        previous: function(quantity) {
            if (typeof quantity === "undefined") {
                quantity = 1;
            }
            var frame = this._frameIndex - quantity;
            if (frame < 0) {
                if (this.loop) {
                    frame = this._frames.length + frame;
                } else {
                    frame++;
                }
            }
            if (frame !== this._frameIndex) {
                this._frameIndex = frame;
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                if (this.currentFrame) {
                    this._parent.setFrame(this.currentFrame);
                    if (this._parent.__tilePattern) {
                        this._parent.__tilePattern = false;
                        this._parent.tilingTexture = false;
                    }
                }
                if (this.onUpdate) {
                    this.onUpdate.dispatch(this, this.currentFrame);
                }
            }
        },
        updateFrameData: function(frameData) {
            this._frameData = frameData;
            this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
        },
        destroy: function() {
            this.game.onPause.remove(this.onPause, this);
            this.game.onResume.remove(this.onResume, this);
            this.game = null;
            this._parent = null;
            this._frames = null;
            this._frameData = null;
            this.currentFrame = null;
            this.isPlaying = false;
            this.onStart.dispose();
            this.onLoop.dispose();
            this.onComplete.dispose();
            if (this.onUpdate) {
                this.onUpdate.dispose();
            }
        },
        complete: function() {
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            this._parent.events.onAnimationComplete.dispatch(this._parent, this);
            this.onComplete.dispatch(this._parent, this);
            if (this.killOnComplete) {
                this._parent.kill();
            }
        }
    };
    Phaser.Animation.prototype.constructor = Phaser.Animation;
    Object.defineProperty(Phaser.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused;
        },
        set: function(value) {
            this.isPaused = value;
            if (value) {
                this._pauseStartTime = this.game.time.now;
            } else {
                if (this.isPlaying) {
                    this._timeNextFrame = this.game.time.now + this.delay;
                }
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length;
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "frame", {
        get: function() {
            if (this.currentFrame !== null) {
                return this.currentFrame.index;
            } else {
                return this._frameIndex;
            }
        },
        set: function(value) {
            this.currentFrame = this._frameData.getFrame(this._frames[value]);
            if (this.currentFrame !== null) {
                this._frameIndex = value;
                this._parent.setFrame(this.currentFrame);
                if (this.onUpdate) {
                    this.onUpdate.dispatch(this, this.currentFrame);
                }
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "speed", {
        get: function() {
            return Math.round(1e3 / this.delay);
        },
        set: function(value) {
            if (value >= 1) {
                this.delay = 1e3 / value;
            }
        }
    });
    Object.defineProperty(Phaser.Animation.prototype, "enableUpdate", {
        get: function() {
            return this.onUpdate !== null;
        },
        set: function(value) {
            if (value && this.onUpdate === null) {
                this.onUpdate = new Phaser.Signal();
            } else if (!value && this.onUpdate !== null) {
                this.onUpdate.dispose();
                this.onUpdate = null;
            }
        }
    });
    Phaser.Animation.generateFrameNames = function(prefix, start, stop, suffix, zeroPad) {
        if (typeof suffix == "undefined") {
            suffix = "";
        }
        var output = [];
        var frame = "";
        if (start < stop) {
            for (var i = start; i <= stop; i++) {
                if (typeof zeroPad == "number") {
                    frame = Phaser.Utils.pad(i.toString(), zeroPad, "0", 1);
                } else {
                    frame = i.toString();
                }
                frame = prefix + frame + suffix;
                output.push(frame);
            }
        } else {
            for (var i = start; i >= stop; i--) {
                if (typeof zeroPad == "number") {
                    frame = Phaser.Utils.pad(i.toString(), zeroPad, "0", 1);
                } else {
                    frame = i.toString();
                }
                frame = prefix + frame + suffix;
                output.push(frame);
            }
        }
        return output;
    };
    Phaser.Frame = function(index, x, y, width, height, name, uuid) {
        this.index = index;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.name = name;
        this.uuid = uuid;
        this.centerX = Math.floor(width / 2);
        this.centerY = Math.floor(height / 2);
        this.distance = Phaser.Math.distance(0, 0, width, height);
        this.rotated = false;
        this.rotationDirection = "cw";
        this.trimmed = false;
        this.sourceSizeW = width;
        this.sourceSizeH = height;
        this.spriteSourceSizeX = 0;
        this.spriteSourceSizeY = 0;
        this.spriteSourceSizeW = 0;
        this.spriteSourceSizeH = 0;
        this.right = this.x + this.width;
        this.bottom = this.y + this.height;
    };
    Phaser.Frame.prototype = {
        setTrim: function(trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {
            this.trimmed = trimmed;
            if (trimmed) {
                this.sourceSizeW = actualWidth;
                this.sourceSizeH = actualHeight;
                this.centerX = Math.floor(actualWidth / 2);
                this.centerY = Math.floor(actualHeight / 2);
                this.spriteSourceSizeX = destX;
                this.spriteSourceSizeY = destY;
                this.spriteSourceSizeW = destWidth;
                this.spriteSourceSizeH = destHeight;
            }
        },
        clone: function() {
            var output = new Phaser.Frame(this.index, this.x, this.y, this.width, this.height, this.name, this.uuid);
            for (var prop in this) {
                if (this.hasOwnProperty(prop)) {
                    output[prop] = this[prop];
                }
            }
            return output;
        },
        getRect: function(out) {
            if (typeof out === "undefined") {
                out = new Phaser.Rectangle(this.x, this.y, this.width, this.height);
            } else {
                out.setTo(this.x, this.y, this.width, this.height);
            }
            return out;
        }
    };
    Phaser.Frame.prototype.constructor = Phaser.Frame;
    Phaser.FrameData = function() {
        this._frames = [];
        this._frameNames = [];
    };
    Phaser.FrameData.prototype = {
        addFrame: function(frame) {
            frame.index = this._frames.length;
            this._frames.push(frame);
            if (frame.name !== "") {
                this._frameNames[frame.name] = frame.index;
            }
            return frame;
        },
        getFrame: function(index) {
            if (index > this._frames.length) {
                index = 0;
            }
            return this._frames[index];
        },
        getFrameByName: function(name) {
            if (typeof this._frameNames[name] === "number") {
                return this._frames[this._frameNames[name]];
            }
            return null;
        },
        checkFrameName: function(name) {
            if (this._frameNames[name] == null) {
                return false;
            }
            return true;
        },
        clone: function() {
            var output = new Phaser.FrameData();
            for (var i = 0; i < this._frames.length; i++) {
                output._frames.push(this._frames[i].clone());
            }
            for (var i = 0; i < this._frameNames.length; i++) {
                output._frameNames.push(this._frameNames[i]);
            }
            return output;
        },
        getFrameRange: function(start, end, output) {
            if (typeof output === "undefined") {
                output = [];
            }
            for (var i = start; i <= end; i++) {
                output.push(this._frames[i]);
            }
            return output;
        },
        getFrames: function(frames, useNumericIndex, output) {
            if (typeof useNumericIndex === "undefined") {
                useNumericIndex = true;
            }
            if (typeof output === "undefined") {
                output = [];
            }
            if (typeof frames === "undefined" || frames.length === 0) {
                for (var i = 0; i < this._frames.length; i++) {
                    output.push(this._frames[i]);
                }
            } else {
                for (var i = 0, len = frames.length; i < len; i++) {
                    if (useNumericIndex) {
                        output.push(this.getFrame(frames[i]));
                    } else {
                        output.push(this.getFrameByName(frames[i]));
                    }
                }
            }
            return output;
        },
        getFrameIndexes: function(frames, useNumericIndex, output) {
            if (typeof useNumericIndex === "undefined") {
                useNumericIndex = true;
            }
            if (typeof output === "undefined") {
                output = [];
            }
            if (typeof frames === "undefined" || frames.length === 0) {
                for (var i = 0, len = this._frames.length; i < len; i++) {
                    output.push(this._frames[i].index);
                }
            } else {
                for (var i = 0, len = frames.length; i < len; i++) {
                    if (useNumericIndex) {
                        output.push(frames[i]);
                    } else {
                        if (this.getFrameByName(frames[i])) {
                            output.push(this.getFrameByName(frames[i]).index);
                        }
                    }
                }
            }
            return output;
        }
    };
    Phaser.FrameData.prototype.constructor = Phaser.FrameData;
    Object.defineProperty(Phaser.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length;
        }
    });
    Phaser.AnimationParser = {
        spriteSheet: function(game, key, frameWidth, frameHeight, frameMax, margin, spacing) {
            var img = game.cache.getImage(key);
            if (img == null) {
                return null;
            }
            var width = img.width;
            var height = img.height;
            if (frameWidth <= 0) {
                frameWidth = Math.floor(-width / Math.min(-1, frameWidth));
            }
            if (frameHeight <= 0) {
                frameHeight = Math.floor(-height / Math.min(-1, frameHeight));
            }
            var row = Math.floor((width - margin) / (frameWidth + spacing));
            var column = Math.floor((height - margin) / (frameHeight + spacing));
            var total = row * column;
            if (frameMax !== -1) {
                total = frameMax;
            }
            if (width === 0 || height === 0 || width < frameWidth || height < frameHeight || total === 0) {
                console.warn("Phaser.AnimationParser.spriteSheet: '" + key + "'s width/height zero or width/height < given frameWidth/frameHeight");
                return null;
            }
            var data = new Phaser.FrameData();
            var x = margin;
            var y = margin;
            for (var i = 0; i < total; i++) {
                var uuid = game.rnd.uuid();
                data.addFrame(new Phaser.Frame(i, x, y, frameWidth, frameHeight, "", uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {
                    x: x,
                    y: y,
                    width: frameWidth,
                    height: frameHeight
                });
                x += frameWidth + spacing;
                if (x + frameWidth > width) {
                    x = margin;
                    y += frameHeight + spacing;
                }
            }
            return data;
        },
        JSONData: function(game, json, cacheKey) {
            if (!json["frames"]) {
                console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
                console.log(json);
                return;
            }
            var data = new Phaser.FrameData();
            var frames = json["frames"];
            var newFrame;
            for (var i = 0; i < frames.length; i++) {
                var uuid = game.rnd.uuid();
                newFrame = data.addFrame(new Phaser.Frame(i, frames[i].frame.x, frames[i].frame.y, frames[i].frame.w, frames[i].frame.h, frames[i].filename, uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                    x: frames[i].frame.x,
                    y: frames[i].frame.y,
                    width: frames[i].frame.w,
                    height: frames[i].frame.h
                });
                if (frames[i].trimmed) {
                    newFrame.setTrim(frames[i].trimmed, frames[i].sourceSize.w, frames[i].sourceSize.h, frames[i].spriteSourceSize.x, frames[i].spriteSourceSize.y, frames[i].spriteSourceSize.w, frames[i].spriteSourceSize.h);
                }
            }
            return data;
        },
        JSONDataHash: function(game, json, cacheKey) {
            if (!json["frames"]) {
                console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
                console.log(json);
                return;
            }
            var data = new Phaser.FrameData();
            var frames = json["frames"];
            var newFrame;
            var i = 0;
            for (var key in frames) {
                var uuid = game.rnd.uuid();
                newFrame = data.addFrame(new Phaser.Frame(i, frames[key].frame.x, frames[key].frame.y, frames[key].frame.w, frames[key].frame.h, key, uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                    x: frames[key].frame.x,
                    y: frames[key].frame.y,
                    width: frames[key].frame.w,
                    height: frames[key].frame.h
                });
                if (frames[key].trimmed) {
                    newFrame.setTrim(frames[key].trimmed, frames[key].sourceSize.w, frames[key].sourceSize.h, frames[key].spriteSourceSize.x, frames[key].spriteSourceSize.y, frames[key].spriteSourceSize.w, frames[key].spriteSourceSize.h);
                }
                i++;
            }
            return data;
        },
        XMLData: function(game, xml, cacheKey) {
            if (!xml.getElementsByTagName("TextureAtlas")) {
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                return;
            }
            var data = new Phaser.FrameData();
            var frames = xml.getElementsByTagName("SubTexture");
            var newFrame;
            var uuid;
            var name;
            var frame;
            var x;
            var y;
            var width;
            var height;
            var frameX;
            var frameY;
            var frameWidth;
            var frameHeight;
            for (var i = 0; i < frames.length; i++) {
                uuid = game.rnd.uuid();
                frame = frames[i].attributes;
                name = frame.name.nodeValue;
                x = parseInt(frame.x.nodeValue, 10);
                y = parseInt(frame.y.nodeValue, 10);
                width = parseInt(frame.width.nodeValue, 10);
                height = parseInt(frame.height.nodeValue, 10);
                frameX = null;
                frameY = null;
                if (frame.frameX) {
                    frameX = Math.abs(parseInt(frame.frameX.nodeValue, 10));
                    frameY = Math.abs(parseInt(frame.frameY.nodeValue, 10));
                    frameWidth = parseInt(frame.frameWidth.nodeValue, 10);
                    frameHeight = parseInt(frame.frameHeight.nodeValue, 10);
                }
                newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name, uuid));
                PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
                if (frameX !== null || frameY !== null) {
                    newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);
                }
            }
            return data;
        }
    };
    Phaser.Cache = function(game) {
        this.game = game;
        this._canvases = {};
        this._images = {};
        this._textures = {};
        this._sounds = {};
        this._text = {};
        this._json = {};
        this._physics = {};
        this._tilemaps = {};
        this._binary = {};
        this._bitmapDatas = {};
        this._bitmapFont = {};
        this.addDefaultImage();
        this.addMissingImage();
        this.onSoundUnlock = new Phaser.Signal();
        this._cacheMap = [];
        this._cacheMap[Phaser.Cache.CANVAS] = this._canvases;
        this._cacheMap[Phaser.Cache.IMAGE] = this._images;
        this._cacheMap[Phaser.Cache.TEXTURE] = this._textures;
        this._cacheMap[Phaser.Cache.SOUND] = this._sounds;
        this._cacheMap[Phaser.Cache.TEXT] = this._text;
        this._cacheMap[Phaser.Cache.PHYSICS] = this._physics;
        this._cacheMap[Phaser.Cache.TILEMAP] = this._tilemaps;
        this._cacheMap[Phaser.Cache.BINARY] = this._binary;
        this._cacheMap[Phaser.Cache.BITMAPDATA] = this._bitmapDatas;
        this._cacheMap[Phaser.Cache.BITMAPFONT] = this._bitmapFont;
        this._cacheMap[Phaser.Cache.JSON] = this._json;
    };
    Phaser.Cache.CANVAS = 1;
    Phaser.Cache.IMAGE = 2;
    Phaser.Cache.TEXTURE = 3;
    Phaser.Cache.SOUND = 4;
    Phaser.Cache.TEXT = 5;
    Phaser.Cache.PHYSICS = 6;
    Phaser.Cache.TILEMAP = 7;
    Phaser.Cache.BINARY = 8;
    Phaser.Cache.BITMAPDATA = 9;
    Phaser.Cache.BITMAPFONT = 10;
    Phaser.Cache.JSON = 11;
    Phaser.Cache.prototype = {
        addCanvas: function(key, canvas, context) {
            this._canvases[key] = {
                canvas: canvas,
                context: context
            };
        },
        addBinary: function(key, binaryData) {
            this._binary[key] = binaryData;
        },
        addBitmapData: function(key, bitmapData) {
            this._bitmapDatas[key] = bitmapData;
            return bitmapData;
        },
        addRenderTexture: function(key, texture) {
            var frame = new Phaser.Frame(0, 0, 0, texture.width, texture.height, "", "");
            this._textures[key] = {
                texture: texture,
                frame: frame
            };
        },
        addSpriteSheet: function(key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {
            this._images[key] = {
                url: url,
                data: data,
                frameWidth: frameWidth,
                frameHeight: frameHeight,
                margin: margin,
                spacing: spacing
            };
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
            this._images[key].frameData = Phaser.AnimationParser.spriteSheet(this.game, key, frameWidth, frameHeight, frameMax, margin, spacing);
        },
        addTilemap: function(key, url, mapData, format) {
            this._tilemaps[key] = {
                url: url,
                data: mapData,
                format: format
            };
        },
        addTextureAtlas: function(key, url, data, atlasData, format) {
            this._images[key] = {
                url: url,
                data: data
            };
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
            if (format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY) {
                this._images[key].frameData = Phaser.AnimationParser.JSONData(this.game, atlasData, key);
            } else if (format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH) {
                this._images[key].frameData = Phaser.AnimationParser.JSONDataHash(this.game, atlasData, key);
            } else if (format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) {
                this._images[key].frameData = Phaser.AnimationParser.XMLData(this.game, atlasData, key);
            }
        },
        addBitmapFont: function(key, url, data, xmlData, xSpacing, ySpacing) {
            this._images[key] = {
                url: url,
                data: data
            };
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
            Phaser.LoaderParser.bitmapFont(this.game, xmlData, key, xSpacing, ySpacing);
            this._bitmapFont[key] = PIXI.BitmapText.fonts[key];
        },
        addPhysicsData: function(key, url, JSONData, format) {
            this._physics[key] = {
                url: url,
                data: JSONData,
                format: format
            };
        },
        addDefaultImage: function() {
            var img = new Image();
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            this._images["__default"] = {
                url: null,
                data: img
            };
            this._images["__default"].frame = new Phaser.Frame(0, 0, 0, 32, 32, "", "");
            this._images["__default"].frameData = new Phaser.FrameData();
            this._images["__default"].frameData.addFrame(new Phaser.Frame(0, 0, 0, 32, 32, null, this.game.rnd.uuid()));
            PIXI.BaseTextureCache["__default"] = new PIXI.BaseTexture(img);
            PIXI.TextureCache["__default"] = new PIXI.Texture(PIXI.BaseTextureCache["__default"]);
        },
        addMissingImage: function() {
            var img = new Image();
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            this._images["__missing"] = {
                url: null,
                data: img
            };
            this._images["__missing"].frame = new Phaser.Frame(0, 0, 0, 32, 32, "", "");
            this._images["__missing"].frameData = new Phaser.FrameData();
            this._images["__missing"].frameData.addFrame(new Phaser.Frame(0, 0, 0, 32, 32, null, this.game.rnd.uuid()));
            PIXI.BaseTextureCache["__missing"] = new PIXI.BaseTexture(img);
            PIXI.TextureCache["__missing"] = new PIXI.Texture(PIXI.BaseTextureCache["__missing"]);
        },
        addText: function(key, url, data) {
            this._text[key] = {
                url: url,
                data: data
            };
        },
        addJSON: function(key, url, data) {
            this._json[key] = {
                url: url,
                data: data
            };
        },
        addImage: function(key, url, data) {
            this._images[key] = {
                url: url,
                data: data
            };
            this._images[key].frame = new Phaser.Frame(0, 0, 0, data.width, data.height, key, this.game.rnd.uuid());
            this._images[key].frameData = new Phaser.FrameData();
            this._images[key].frameData.addFrame(new Phaser.Frame(0, 0, 0, data.width, data.height, url, this.game.rnd.uuid()));
            PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);
            PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);
        },
        addSound: function(key, url, data, webAudio, audioTag) {
            webAudio = webAudio || true;
            audioTag = audioTag || false;
            var decoded = false;
            if (audioTag) {
                decoded = true;
            }
            this._sounds[key] = {
                url: url,
                data: data,
                isDecoding: false,
                decoded: decoded,
                webAudio: webAudio,
                audioTag: audioTag,
                locked: this.game.sound.touchLocked
            };
        },
        reloadSound: function(key) {
            var _this = this;
            if (this._sounds[key]) {
                this._sounds[key].data.src = this._sounds[key].url;
                this._sounds[key].data.addEventListener("canplaythrough", function() {
                    return _this.reloadSoundComplete(key);
                }, false);
                this._sounds[key].data.load();
            }
        },
        reloadSoundComplete: function(key) {
            if (this._sounds[key]) {
                this._sounds[key].locked = false;
                this.onSoundUnlock.dispatch(key);
            }
        },
        updateSound: function(key, property, value) {
            if (this._sounds[key]) {
                this._sounds[key][property] = value;
            }
        },
        decodedSound: function(key, data) {
            this._sounds[key].data = data;
            this._sounds[key].decoded = true;
            this._sounds[key].isDecoding = false;
        },
        getCanvas: function(key) {
            if (this._canvases[key]) {
                return this._canvases[key].canvas;
            } else {
                console.warn('Phaser.Cache.getCanvas: Invalid key: "' + key + '"');
            }
        },
        getBitmapData: function(key) {
            if (this._bitmapDatas[key]) {
                return this._bitmapDatas[key];
            } else {
                console.warn('Phaser.Cache.getBitmapData: Invalid key: "' + key + '"');
            }
        },
        getBitmapFont: function(key) {
            if (this._bitmapFont[key]) {
                return this._bitmapFont[key];
            } else {
                console.warn('Phaser.Cache.getBitmapFont: Invalid key: "' + key + '"');
            }
        },
        getPhysicsData: function(key, object, fixtureKey) {
            if (typeof object === "undefined" || object === null) {
                if (this._physics[key]) {
                    return this._physics[key].data;
                } else {
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key: "' + key + '"');
                }
            } else {
                if (this._physics[key] && this._physics[key].data[object]) {
                    var fixtures = this._physics[key].data[object];
                    if (fixtures && fixtureKey) {
                        for (var fixture in fixtures) {
                            fixture = fixtures[fixture];
                            if (fixture.fixtureKey === fixtureKey) {
                                return fixture;
                            }
                        }
                        console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + fixtureKey + " in " + key + '"');
                    } else {
                        return fixtures;
                    }
                } else {
                    console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + key + " / " + object + '"');
                }
            }
            return null;
        },
        checkKey: function(type, key) {
            if (this._cacheMap[type][key]) {
                return true;
            }
            return false;
        },
        checkCanvasKey: function(key) {
            return this.checkKey(Phaser.Cache.CANVAS, key);
        },
        checkImageKey: function(key) {
            return this.checkKey(Phaser.Cache.IMAGE, key);
        },
        checkTextureKey: function(key) {
            return this.checkKey(Phaser.Cache.TEXTURE, key);
        },
        checkSoundKey: function(key) {
            return this.checkKey(Phaser.Cache.SOUND, key);
        },
        checkTextKey: function(key) {
            return this.checkKey(Phaser.Cache.TEXT, key);
        },
        checkPhysicsKey: function(key) {
            return this.checkKey(Phaser.Cache.PHYSICS, key);
        },
        checkTilemapKey: function(key) {
            return this.checkKey(Phaser.Cache.TILEMAP, key);
        },
        checkBinaryKey: function(key) {
            return this.checkKey(Phaser.Cache.BINARY, key);
        },
        checkBitmapDataKey: function(key) {
            return this.checkKey(Phaser.Cache.BITMAPDATA, key);
        },
        checkBitmapFontKey: function(key) {
            return this.checkKey(Phaser.Cache.BITMAPFONT, key);
        },
        checkJSONKey: function(key) {
            return this.checkKey(Phaser.Cache.JSON, key);
        },
        getImage: function(key) {
            if (this._images[key]) {
                return this._images[key].data;
            } else {
                console.warn('Phaser.Cache.getImage: Invalid key: "' + key + '"');
                return null;
            }
        },
        getTilemapData: function(key) {
            if (this._tilemaps[key]) {
                return this._tilemaps[key];
            } else {
                console.warn('Phaser.Cache.getTilemapData: Invalid key: "' + key + '"');
            }
        },
        getFrameData: function(key) {
            if (this._images[key]) {
                return this._images[key].frameData;
            }
            return null;
        },
        updateFrameData: function(key, frameData) {
            if (this._images[key]) {
                this._images[key].frameData = frameData;
            }
        },
        getFrameByIndex: function(key, frame) {
            if (this._images[key]) {
                return this._images[key].frameData.getFrame(frame);
            }
            return null;
        },
        getFrameByName: function(key, frame) {
            if (this._images[key]) {
                return this._images[key].frameData.getFrameByName(frame);
            }
            return null;
        },
        getFrame: function(key) {
            if (this._images[key]) {
                return this._images[key].frame;
            }
            return null;
        },
        getTextureFrame: function(key) {
            if (this._textures[key]) {
                return this._textures[key].frame;
            }
            return null;
        },
        getTexture: function(key) {
            if (this._textures[key]) {
                return this._textures[key];
            } else {
                console.warn('Phaser.Cache.getTexture: Invalid key: "' + key + '"');
            }
        },
        getSound: function(key) {
            if (this._sounds[key]) {
                return this._sounds[key];
            } else {
                console.warn('Phaser.Cache.getSound: Invalid key: "' + key + '"');
            }
        },
        getSoundData: function(key) {
            if (this._sounds[key]) {
                return this._sounds[key].data;
            } else {
                console.warn('Phaser.Cache.getSoundData: Invalid key: "' + key + '"');
            }
        },
        isSoundDecoded: function(key) {
            if (this._sounds[key]) {
                return this._sounds[key].decoded;
            }
        },
        isSoundReady: function(key) {
            return this._sounds[key] && this._sounds[key].decoded && this.game.sound.touchLocked === false;
        },
        getFrameCount: function(key) {
            if (this._images[key]) {
                return this._images[key].frameData.total;
            }
            return 0;
        },
        getText: function(key) {
            if (this._text[key]) {
                return this._text[key].data;
            } else {
                console.warn('Phaser.Cache.getText: Invalid key: "' + key + '"');
            }
        },
        getJSON: function(key) {
            if (this._json[key]) {
                return this._json[key].data;
            } else {
                console.warn('Phaser.Cache.getJSON: Invalid key: "' + key + '"');
            }
        },
        getBinary: function(key) {
            if (this._binary[key]) {
                return this._binary[key];
            } else {
                console.warn('Phaser.Cache.getBinary: Invalid key: "' + key + '"');
            }
        },
        getKeys: function(type) {
            var array = null;
            switch (type) {
              case Phaser.Cache.CANVAS:
                array = this._canvases;
                break;

              case Phaser.Cache.IMAGE:
                array = this._images;
                break;

              case Phaser.Cache.TEXTURE:
                array = this._textures;
                break;

              case Phaser.Cache.SOUND:
                array = this._sounds;
                break;

              case Phaser.Cache.TEXT:
                array = this._text;
                break;

              case Phaser.Cache.PHYSICS:
                array = this._physics;
                break;

              case Phaser.Cache.TILEMAP:
                array = this._tilemaps;
                break;

              case Phaser.Cache.BINARY:
                array = this._binary;
                break;

              case Phaser.Cache.BITMAPDATA:
                array = this._bitmapDatas;
                break;

              case Phaser.Cache.BITMAPFONT:
                array = this._bitmapFont;
                break;

              case Phaser.Cache.JSON:
                array = this._json;
                break;
            }
            if (!array) {
                return;
            }
            var output = [];
            for (var item in array) {
                if (item !== "__default" && item !== "__missing") {
                    output.push(item);
                }
            }
            return output;
        },
        removeCanvas: function(key) {
            delete this._canvases[key];
        },
        removeImage: function(key) {
            delete this._images[key];
        },
        removeSound: function(key) {
            delete this._sounds[key];
        },
        removeText: function(key) {
            delete this._text[key];
        },
        removeJSON: function(key) {
            delete this._json[key];
        },
        removePhysics: function(key) {
            delete this._physics[key];
        },
        removeTilemap: function(key) {
            delete this._tilemaps[key];
        },
        removeBinary: function(key) {
            delete this._binary[key];
        },
        removeBitmapData: function(key) {
            delete this._bitmapDatas[key];
        },
        removeBitmapFont: function(key) {
            delete this._bitmapFont[key];
        },
        destroy: function() {
            for (var item in this._canvases) {
                delete this._canvases[item];
            }
            for (var item in this._images) {
                if (item !== "__default" && item !== "__missing") {
                    delete this._images[item];
                }
            }
            for (var item in this._sounds) {
                delete this._sounds[item];
            }
            for (var item in this._text) {
                delete this._text[item];
            }
            for (var item in this._json) {
                delete this._json[item];
            }
            for (var item in this._textures) {
                delete this._textures[item];
            }
            for (var item in this._physics) {
                delete this._physics[item];
            }
            for (var item in this._tilemaps) {
                delete this._tilemaps[item];
            }
            for (var item in this._binary) {
                delete this._binary[item];
            }
            for (var item in this._bitmapDatas) {
                delete this._bitmapDatas[item];
            }
            for (var item in this._bitmapFont) {
                delete this._bitmapFont[item];
            }
        }
    };
    Phaser.Cache.prototype.constructor = Phaser.Cache;
    Phaser.Loader = function(game) {
        this.game = game;
        this.isLoading = false;
        this.hasLoaded = false;
        this.progress = 0;
        this.progressFloat = 0;
        this.preloadSprite = null;
        this.crossOrigin = false;
        this.baseURL = "";
        this.onLoadStart = new Phaser.Signal();
        this.onFileStart = new Phaser.Signal();
        this.onFileComplete = new Phaser.Signal();
        this.onFileError = new Phaser.Signal();
        this.onLoadComplete = new Phaser.Signal();
        this.onPackComplete = new Phaser.Signal();
        this.useXDomainRequest = this.game.device.ieVersion === 9;
        this._packList = [];
        this._packIndex = 0;
        this._fileList = [];
        this._fileIndex = 0;
        this._progressChunk = 0;
        this._xhr = new XMLHttpRequest();
        this._ajax = null;
    };
    Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
    Phaser.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
    Phaser.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
    Phaser.Loader.PHYSICS_LIME_CORONA_JSON = 3;
    Phaser.Loader.PHYSICS_PHASER_JSON = 4;
    Phaser.Loader.prototype = {
        setPreloadSprite: function(sprite, direction) {
            direction = direction || 0;
            this.preloadSprite = {
                sprite: sprite,
                direction: direction,
                width: sprite.width,
                height: sprite.height,
                rect: null
            };
            if (direction === 0) {
                this.preloadSprite.rect = new Phaser.Rectangle(0, 0, 1, sprite.height);
            } else {
                this.preloadSprite.rect = new Phaser.Rectangle(0, 0, sprite.width, 1);
            }
            sprite.crop(this.preloadSprite.rect);
            sprite.visible = true;
        },
        checkKeyExists: function(type, key) {
            if (this._fileList.length > 0) {
                for (var i = 0; i < this._fileList.length; i++) {
                    if (this._fileList[i].type === type && this._fileList[i].key === key) {
                        return true;
                    }
                }
            }
            return false;
        },
        getAssetIndex: function(type, key) {
            if (this._fileList.length > 0) {
                for (var i = 0; i < this._fileList.length; i++) {
                    if (this._fileList[i].type === type && this._fileList[i].key === key) {
                        return i;
                    }
                }
            }
            return -1;
        },
        getAsset: function(type, key) {
            if (this._fileList.length > 0) {
                for (var i = 0; i < this._fileList.length; i++) {
                    if (this._fileList[i].type === type && this._fileList[i].key === key) {
                        return {
                            index: i,
                            file: this._fileList[i]
                        };
                    }
                }
            }
            return false;
        },
        reset: function() {
            this.preloadSprite = null;
            this.isLoading = false;
            this._packList.length = 0;
            this._packIndex = 0;
            this._fileList.length = 0;
            this._fileIndex = 0;
        },
        addToFileList: function(type, key, url, properties) {
            var entry = {
                type: type,
                key: key,
                url: url,
                data: null,
                error: false,
                loaded: false
            };
            if (typeof properties !== "undefined") {
                for (var prop in properties) {
                    entry[prop] = properties[prop];
                }
            }
            if (this.checkKeyExists(type, key) === false) {
                this._fileList.push(entry);
            }
        },
        replaceInFileList: function(type, key, url, properties) {
            var entry = {
                type: type,
                key: key,
                url: url,
                data: null,
                error: false,
                loaded: false
            };
            if (typeof properties !== "undefined") {
                for (var prop in properties) {
                    entry[prop] = properties[prop];
                }
            }
            var index = this.getAssetIndex(type, key);
            if (index === -1) {
                this._fileList.push(entry);
            } else {
                this._fileList[index] = entry;
            }
        },
        pack: function(key, url, data, callbackContext) {
            if (typeof url === "undefined") {
                url = null;
            }
            if (typeof data === "undefined") {
                data = null;
            }
            if (typeof callbackContext === "undefined") {
                callbackContext = this;
            }
            if (url === null && data === null) {
                console.warn("Phaser.Loader.pack - Both url and data are null. One must be set.");
                return this;
            }
            if (data) {
                if (typeof data === "string") {
                    data = JSON.parse(data);
                }
            }
            this._packList.push({
                key: key,
                url: url,
                data: data,
                loaded: false,
                error: false,
                callbackContext: callbackContext
            });
            return this;
        },
        image: function(key, url, overwrite) {
            if (typeof overwrite === "undefined") {
                overwrite = false;
            }
            if (overwrite) {
                this.replaceInFileList("image", key, url);
            } else {
                this.addToFileList("image", key, url);
            }
            return this;
        },
        text: function(key, url, overwrite) {
            if (typeof overwrite === "undefined") {
                overwrite = false;
            }
            if (overwrite) {
                this.replaceInFileList("text", key, url);
            } else {
                this.addToFileList("text", key, url);
            }
            return this;
        },
        json: function(key, url, overwrite) {
            if (typeof overwrite === "undefined") {
                overwrite = false;
            }
            if (overwrite) {
                this.replaceInFileList("json", key, url);
            } else {
                this.addToFileList("json", key, url);
            }
            return this;
        },
        script: function(key, url, callback, callbackContext) {
            if (typeof callback === "undefined") {
                callback = false;
            }
            if (callback !== false && typeof callbackContext === "undefined") {
                callbackContext = callback;
            }
            this.addToFileList("script", key, url, {
                callback: callback,
                callbackContext: callbackContext
            });
            return this;
        },
        binary: function(key, url, callback, callbackContext) {
            if (typeof callback === "undefined") {
                callback = false;
            }
            if (callback !== false && typeof callbackContext === "undefined") {
                callbackContext = callback;
            }
            this.addToFileList("binary", key, url, {
                callback: callback,
                callbackContext: callbackContext
            });
            return this;
        },
        spritesheet: function(key, url, frameWidth, frameHeight, frameMax, margin, spacing) {
            if (typeof frameMax === "undefined") {
                frameMax = -1;
            }
            if (typeof margin === "undefined") {
                margin = 0;
            }
            if (typeof spacing === "undefined") {
                spacing = 0;
            }
            this.addToFileList("spritesheet", key, url, {
                frameWidth: frameWidth,
                frameHeight: frameHeight,
                frameMax: frameMax,
                margin: margin,
                spacing: spacing
            });
            return this;
        },
        audio: function(key, urls, autoDecode) {
            if (typeof autoDecode === "undefined") {
                autoDecode = true;
            }
            this.addToFileList("audio", key, urls, {
                buffer: null,
                autoDecode: autoDecode
            });
            return this;
        },
        tilemap: function(key, url, data, format) {
            if (typeof url === "undefined") {
                url = null;
            }
            if (typeof data === "undefined") {
                data = null;
            }
            if (typeof format === "undefined") {
                format = Phaser.Tilemap.CSV;
            }
            if (url == null && data == null) {
                console.warn("Phaser.Loader.tilemap - Both url and data are null. One must be set.");
                return this;
            }
            if (data) {
                switch (format) {
                  case Phaser.Tilemap.CSV:
                    break;

                  case Phaser.Tilemap.TILED_JSON:
                    if (typeof data === "string") {
                        data = JSON.parse(data);
                    }
                    break;
                }
                this.game.cache.addTilemap(key, null, data, format);
            } else {
                this.addToFileList("tilemap", key, url, {
                    format: format
                });
            }
            return this;
        },
        physics: function(key, url, data, format) {
            if (typeof url === "undefined") {
                url = null;
            }
            if (typeof data === "undefined") {
                data = null;
            }
            if (typeof format === "undefined") {
                format = Phaser.Physics.LIME_CORONA_JSON;
            }
            if (url == null && data == null) {
                console.warn("Phaser.Loader.physics - Both url and data are null. One must be set.");
                return this;
            }
            if (data) {
                if (typeof data === "string") {
                    data = JSON.parse(data);
                }
                this.game.cache.addPhysicsData(key, null, data, format);
            } else {
                this.addToFileList("physics", key, url, {
                    format: format
                });
            }
            return this;
        },
        bitmapFont: function(key, textureURL, xmlURL, xmlData, xSpacing, ySpacing) {
            if (typeof xmlURL === "undefined") {
                xmlURL = null;
            }
            if (typeof xmlData === "undefined") {
                xmlData = null;
            }
            if (typeof xSpacing === "undefined") {
                xSpacing = 0;
            }
            if (typeof ySpacing === "undefined") {
                ySpacing = 0;
            }
            if (xmlURL) {
                this.addToFileList("bitmapfont", key, textureURL, {
                    xmlURL: xmlURL,
                    xSpacing: xSpacing,
                    ySpacing: ySpacing
                });
            } else {
                if (typeof xmlData === "string") {
                    var xml;
                    try {
                        if (window["DOMParser"]) {
                            var domparser = new DOMParser();
                            xml = domparser.parseFromString(xmlData, "text/xml");
                        } else {
                            xml = new ActiveXObject("Microsoft.XMLDOM");
                            xml.async = "false";
                            xml.loadXML(xmlData);
                        }
                    } catch (e) {
                        xml = undefined;
                    }
                    if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                        throw new Error("Phaser.Loader. Invalid Bitmap Font XML given");
                    } else {
                        this.addToFileList("bitmapfont", key, textureURL, {
                            xmlURL: null,
                            xmlData: xml,
                            xSpacing: xSpacing,
                            ySpacing: ySpacing
                        });
                    }
                }
            }
            return this;
        },
        atlasJSONArray: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);
        },
        atlasJSONHash: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);
        },
        atlasXML: function(key, textureURL, atlasURL, atlasData) {
            return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_XML_STARLING);
        },
        atlas: function(key, textureURL, atlasURL, atlasData, format) {
            if (typeof atlasURL === "undefined") {
                atlasURL = null;
            }
            if (typeof atlasData === "undefined") {
                atlasData = null;
            }
            if (typeof format === "undefined") {
                format = Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY;
            }
            if (atlasURL) {
                this.addToFileList("textureatlas", key, textureURL, {
                    atlasURL: atlasURL,
                    format: format
                });
            } else {
                switch (format) {
                  case Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                    if (typeof atlasData === "string") {
                        atlasData = JSON.parse(atlasData);
                    }
                    break;

                  case Phaser.Loader.TEXTURE_ATLAS_XML_STARLING:
                    if (typeof atlasData === "string") {
                        var xml;
                        try {
                            if (window["DOMParser"]) {
                                var domparser = new DOMParser();
                                xml = domparser.parseFromString(atlasData, "text/xml");
                            } else {
                                xml = new ActiveXObject("Microsoft.XMLDOM");
                                xml.async = "false";
                                xml.loadXML(atlasData);
                            }
                        } catch (e) {
                            xml = undefined;
                        }
                        if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                            throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                        } else {
                            atlasData = xml;
                        }
                    }
                    break;
                }
                this.addToFileList("textureatlas", key, textureURL, {
                    atlasURL: null,
                    atlasData: atlasData,
                    format: format
                });
            }
            return this;
        },
        removeFile: function(type, key) {
            var file = this.getAsset(type, key);
            if (file !== false) {
                this._fileList.splice(file.index, 1);
            }
        },
        removeAll: function() {
            this._fileList.length = 0;
        },
        start: function() {
            if (this.isLoading) {
                return;
            }
            if (this._packList.length > 0) {
                this._packIndex = 0;
                this.loadPack();
            } else {
                this.beginLoad();
            }
        },
        beginLoad: function() {
            this.progress = 0;
            this.progressFloat = 0;
            this.hasLoaded = false;
            this.isLoading = true;
            this.onLoadStart.dispatch(this._fileList.length);
            if (this._fileList.length > 0) {
                this._fileIndex = 0;
                this._progressChunk = 100 / this._fileList.length;
                this.loadFile();
            } else {
                this.progress = 100;
                this.progressFloat = 100;
                this.hasLoaded = true;
                this.isLoading = false;
                this.onLoadComplete.dispatch();
            }
        },
        loadPack: function() {
            if (!this._packList[this._packIndex]) {
                console.warn("Phaser.Loader loadPackList invalid index " + this._packIndex);
                return;
            }
            var pack = this._packList[this._packIndex];
            if (pack.data !== null) {
                this.packLoadComplete(this._packIndex, false);
            } else {
                this.xhrLoad(this._packIndex, this.baseURL + pack.url, "text", "packLoadComplete", "packLoadError");
            }
        },
        packLoadComplete: function(index, parse) {
            if (typeof parse === "undefined") {
                parse = true;
            }
            if (!this._packList[index]) {
                console.warn("Phaser.Loader packLoadComplete invalid index " + index);
                return;
            }
            var pack = this._packList[index];
            pack.loaded = true;
            if (parse) {
                var data = JSON.parse(this._xhr.responseText);
            } else {
                var data = this._packList[index].data;
            }
            if (data[pack.key]) {
                var file;
                for (var i = 0; i < data[pack.key].length; i++) {
                    file = data[pack.key][i];
                    switch (file.type) {
                      case "image":
                        this.image(file.key, file.url, file.overwrite);
                        break;

                      case "text":
                        this.text(file.key, file.url, file.overwrite);
                        break;

                      case "json":
                        this.json(file.key, file.url, file.overwrite);
                        break;

                      case "script":
                        this.script(file.key, file.url, file.callback, pack.callbackContext);
                        break;

                      case "binary":
                        this.binary(file.key, file.url, file.callback, pack.callbackContext);
                        break;

                      case "spritesheet":
                        this.spritesheet(file.key, file.url, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                        break;

                      case "audio":
                        this.audio(file.key, file.urls, file.autoDecode);
                        break;

                      case "tilemap":
                        this.tilemap(file.key, file.url, file.data, Phaser.Tilemap[file.format]);
                        break;

                      case "physics":
                        this.physics(file.key, file.url, file.data, Phaser.Loader[file.format]);
                        break;

                      case "bitmapFont":
                        this.bitmapFont(file.key, file.textureURL, file.xmlURL, file.xmlData, file.xSpacing, file.ySpacing);
                        break;

                      case "atlasJSONArray":
                        this.atlasJSONArray(file.key, file.textureURL, file.atlasURL, file.atlasData);
                        break;

                      case "atlasJSONHash":
                        this.atlasJSONHash(file.key, file.textureURL, file.atlasURL, file.atlasData);
                        break;

                      case "atlasXML":
                        this.atlasXML(file.key, file.textureURL, file.atlasURL, file.atlasData);
                        break;

                      case "atlas":
                        this.atlas(file.key, file.textureURL, file.atlasURL, file.atlasData, Phaser.Loader[file.format]);
                        break;
                    }
                }
            }
            this.nextPack(index, true);
        },
        packError: function(index) {
            this._packList[index].loaded = true;
            this._packList[index].error = true;
            this.onFileError.dispatch(this._packList[index].key, this._packList[index]);
            console.warn("Phaser.Loader error loading pack file: " + this._packList[index].key + " from URL " + this._packList[index].url);
            this.nextPack(index, false);
        },
        nextPack: function(index, success) {
            this.onPackComplete.dispatch(this._packList[index].key, success, this.totalLoadedPacks(), this._packList.length);
            this._packIndex++;
            if (this._packIndex < this._packList.length) {
                this.loadPack();
            } else {
                this.beginLoad();
            }
        },
        loadFile: function() {
            if (!this._fileList[this._fileIndex]) {
                console.warn("Phaser.Loader loadFile invalid index " + this._fileIndex);
                return;
            }
            var file = this._fileList[this._fileIndex];
            var _this = this;
            this.onFileStart.dispatch(this.progress, file.key);
            switch (file.type) {
              case "image":
              case "spritesheet":
              case "textureatlas":
              case "bitmapfont":
                file.data = new Image();
                file.data.name = file.key;
                file.data.onload = function() {
                    return _this.fileComplete(_this._fileIndex);
                };
                file.data.onerror = function() {
                    return _this.fileError(_this._fileIndex);
                };
                if (this.crossOrigin) {
                    file.data.crossOrigin = this.crossOrigin;
                }
                file.data.src = this.baseURL + file.url;
                break;

              case "audio":
                file.url = this.getAudioURL(file.url);
                if (file.url !== null) {
                    if (this.game.sound.usingWebAudio) {
                        this.xhrLoad(this._fileIndex, this.baseURL + file.url, "arraybuffer", "fileComplete", "fileError");
                    } else if (this.game.sound.usingAudioTag) {
                        if (this.game.sound.touchLocked) {
                            file.data = new Audio();
                            file.data.name = file.key;
                            file.data.preload = "auto";
                            file.data.src = this.baseURL + file.url;
                            this.fileComplete(this._fileIndex);
                        } else {
                            file.data = new Audio();
                            file.data.name = file.key;
                            file.data.onerror = function() {
                                return _this.fileError(_this._fileIndex);
                            };
                            file.data.preload = "auto";
                            file.data.src = this.baseURL + file.url;
                            file.data.addEventListener("canplaythrough", Phaser.GAMES[this.game.id].load.fileComplete(this._fileIndex), false);
                            file.data.load();
                        }
                    }
                } else {
                    this.fileError(this._fileIndex);
                }
                break;

              case "json":
                if (this.useXDomainRequest && window.XDomainRequest) {
                    this._ajax = new window.XDomainRequest();
                    this._ajax.timeout = 3e3;
                    this._ajax.onerror = function() {
                        return _this.dataLoadError(_this._fileIndex);
                    };
                    this._ajax.ontimeout = function() {
                        return _this.dataLoadError(_this._fileIndex);
                    };
                    this._ajax.onprogress = function() {};
                    this._ajax.onload = function() {
                        return _this.jsonLoadComplete(_this._fileIndex);
                    };
                    this._ajax.open("GET", this.baseURL + file.url, true);
                    setTimeout(function() {
                        this._ajax.send();
                    }, 0);
                } else {
                    this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "jsonLoadComplete", "dataLoadError");
                }
                break;

              case "tilemap":
                if (file.format === Phaser.Tilemap.TILED_JSON) {
                    this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "jsonLoadComplete", "dataLoadError");
                } else if (file.format === Phaser.Tilemap.CSV) {
                    this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "csvLoadComplete", "dataLoadError");
                } else {
                    throw new Error("Phaser.Loader. Invalid Tilemap format: " + file.format);
                }
                break;

              case "text":
              case "script":
              case "physics":
                this.xhrLoad(this._fileIndex, this.baseURL + file.url, "text", "fileComplete", "fileError");
                break;

              case "binary":
                this.xhrLoad(this._fileIndex, this.baseURL + file.url, "arraybuffer", "fileComplete", "fileError");
                break;
            }
        },
        xhrLoad: function(index, url, type, onload, onerror) {
            this._xhr.open("GET", url, true);
            this._xhr.responseType = type;
            var _this = this;
            this._xhr.onload = function() {
                return _this[onload](index);
            };
            this._xhr.onerror = function() {
                return _this[onerror](index);
            };
            this._xhr.send();
        },
        getAudioURL: function(urls) {
            var extension;
            if (typeof urls === "string") {
                urls = [ urls ];
            }
            for (var i = 0; i < urls.length; i++) {
                extension = urls[i].toLowerCase();
                extension = extension.substr((Math.max(0, extension.lastIndexOf(".")) || Infinity) + 1);
                if (this.game.device.canPlayAudio(extension)) {
                    return urls[i];
                }
            }
            return null;
        },
        fileError: function(index) {
            this._fileList[index].loaded = true;
            this._fileList[index].error = true;
            this.onFileError.dispatch(this._fileList[index].key, this._fileList[index]);
            console.warn("Phaser.Loader error loading file: " + this._fileList[index].key + " from URL " + this._fileList[index].url);
            this.nextFile(index, false);
        },
        fileComplete: function(index) {
            if (!this._fileList[index]) {
                console.warn("Phaser.Loader fileComplete invalid index " + index);
                return;
            }
            var file = this._fileList[index];
            file.loaded = true;
            var loadNext = true;
            switch (file.type) {
              case "image":
                this.game.cache.addImage(file.key, file.url, file.data);
                break;

              case "spritesheet":
                this.game.cache.addSpriteSheet(file.key, file.url, file.data, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);
                break;

              case "textureatlas":
                if (file.atlasURL == null) {
                    this.game.cache.addTextureAtlas(file.key, file.url, file.data, file.atlasData, file.format);
                } else {
                    loadNext = false;
                    if (file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY || file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH) {
                        this.xhrLoad(this._fileIndex, this.baseURL + file.atlasURL, "text", "jsonLoadComplete", "dataLoadError");
                    } else if (file.format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) {
                        this.xhrLoad(this._fileIndex, this.baseURL + file.atlasURL, "text", "xmlLoadComplete", "dataLoadError");
                    } else {
                        throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + file.format);
                    }
                }
                break;

              case "bitmapfont":
                if (file.xmlURL == null) {
                    this.game.cache.addBitmapFont(file.key, file.url, file.data, file.xmlData, file.xSpacing, file.ySpacing);
                } else {
                    loadNext = false;
                    this.xhrLoad(this._fileIndex, this.baseURL + file.xmlURL, "text", "xmlLoadComplete", "dataLoadError");
                }
                break;

              case "audio":
                if (this.game.sound.usingWebAudio) {
                    file.data = this._xhr.response;
                    this.game.cache.addSound(file.key, file.url, file.data, true, false);
                    if (file.autoDecode) {
                        var that = this;
                        var key = file.key;
                        this.game.cache.updateSound(key, "isDecoding", true);
                        this.game.sound.context.decodeAudioData(file.data, function(buffer) {
                            if (buffer) {
                                that.game.cache.decodedSound(key, buffer);
                                that.game.sound.onSoundDecode.dispatch(key, that.game.cache.getSound(key));
                            }
                        });
                    }
                } else {
                    file.data.removeEventListener("canplaythrough", Phaser.GAMES[this.game.id].load.fileComplete);
                    this.game.cache.addSound(file.key, file.url, file.data, false, true);
                }
                break;

              case "text":
                file.data = this._xhr.responseText;
                this.game.cache.addText(file.key, file.url, file.data);
                break;

              case "physics":
                var data = JSON.parse(this._xhr.responseText);
                this.game.cache.addPhysicsData(file.key, file.url, data, file.format);
                break;

              case "script":
                file.data = document.createElement("script");
                file.data.language = "javascript";
                file.data.type = "text/javascript";
                file.data.defer = false;
                file.data.text = this._xhr.responseText;
                document.head.appendChild(file.data);
                if (file.callback) {
                    file.data = file.callback.call(file.callbackContext, file.key, this._xhr.responseText);
                }
                break;

              case "binary":
                if (file.callback) {
                    file.data = file.callback.call(file.callbackContext, file.key, this._xhr.response);
                } else {
                    file.data = this._xhr.response;
                }
                this.game.cache.addBinary(file.key, file.data);
                break;
            }
            if (loadNext) {
                this.nextFile(index, true);
            }
        },
        jsonLoadComplete: function(index) {
            if (!this._fileList[index]) {
                console.warn("Phaser.Loader jsonLoadComplete invalid index " + index);
                return;
            }
            var file = this._fileList[index];
            if (this._ajax && this._ajax.responseText) {
                var data = JSON.parse(this._ajax.responseText);
            } else {
                var data = JSON.parse(this._xhr.responseText);
            }
            file.loaded = true;
            if (file.type === "tilemap") {
                this.game.cache.addTilemap(file.key, file.url, data, file.format);
            } else if (file.type === "json") {
                this.game.cache.addJSON(file.key, file.url, data);
            } else {
                this.game.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format);
            }
            this.nextFile(index, true);
        },
        csvLoadComplete: function(index) {
            if (!this._fileList[index]) {
                console.warn("Phaser.Loader csvLoadComplete invalid index " + index);
                return;
            }
            var file = this._fileList[index];
            var data = this._xhr.responseText;
            file.loaded = true;
            this.game.cache.addTilemap(file.key, file.url, data, file.format);
            this.nextFile(index, true);
        },
        dataLoadError: function(index) {
            var file = this._fileList[index];
            file.loaded = true;
            file.error = true;
            console.warn("Phaser.Loader dataLoadError: " + file.key);
            this.nextFile(index, true);
        },
        xmlLoadComplete: function(index) {
            var data = this._xhr.responseText;
            var xml;
            try {
                if (window["DOMParser"]) {
                    var domparser = new DOMParser();
                    xml = domparser.parseFromString(data, "text/xml");
                } else {
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }
            } catch (e) {
                xml = undefined;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                throw new Error("Phaser.Loader. Invalid XML given");
            }
            var file = this._fileList[index];
            file.loaded = true;
            if (file.type == "bitmapfont") {
                this.game.cache.addBitmapFont(file.key, file.url, file.data, xml, file.xSpacing, file.ySpacing);
            } else if (file.type == "textureatlas") {
                this.game.cache.addTextureAtlas(file.key, file.url, file.data, xml, file.format);
            }
            this.nextFile(index, true);
        },
        nextFile: function(previousIndex, success) {
            this.progressFloat += this._progressChunk;
            this.progress = Math.round(this.progressFloat);
            if (this.progress > 100) {
                this.progress = 100;
            }
            if (this.preloadSprite !== null) {
                if (this.preloadSprite.direction === 0) {
                    this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress);
                } else {
                    this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress);
                }
                this.preloadSprite.sprite.updateCrop();
            }
            this.onFileComplete.dispatch(this.progress, this._fileList[previousIndex].key, success, this.totalLoadedFiles(), this._fileList.length);
            if (this.totalQueuedFiles() > 0) {
                this._fileIndex++;
                this.loadFile();
            } else {
                this.hasLoaded = true;
                this.isLoading = false;
                this.removeAll();
                this.onLoadComplete.dispatch();
            }
        },
        totalLoadedFiles: function() {
            var total = 0;
            for (var i = 0; i < this._fileList.length; i++) {
                if (this._fileList[i].loaded) {
                    total++;
                }
            }
            return total;
        },
        totalQueuedFiles: function() {
            var total = 0;
            for (var i = 0; i < this._fileList.length; i++) {
                if (this._fileList[i].loaded === false) {
                    total++;
                }
            }
            return total;
        },
        totalLoadedPacks: function() {
            var total = 0;
            for (var i = 0; i < this._packList.length; i++) {
                if (this._packList[i].loaded) {
                    total++;
                }
            }
            return total;
        },
        totalQueuedPacks: function() {
            var total = 0;
            for (var i = 0; i < this._packList.length; i++) {
                if (this._packList[i].loaded === false) {
                    total++;
                }
            }
            return total;
        }
    };
    Phaser.Loader.prototype.constructor = Phaser.Loader;
    Phaser.LoaderParser = {
        bitmapFont: function(game, xml, cacheKey, xSpacing, ySpacing) {
            var data = {};
            var info = xml.getElementsByTagName("info")[0];
            var common = xml.getElementsByTagName("common")[0];
            data.font = info.getAttribute("face");
            data.size = parseInt(info.getAttribute("size"), 10);
            data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10) + ySpacing;
            data.chars = {};
            var letters = xml.getElementsByTagName("char");
            for (var i = 0; i < letters.length; i++) {
                var charCode = parseInt(letters[i].getAttribute("id"), 10);
                var textureRect = new PIXI.Rectangle(parseInt(letters[i].getAttribute("x"), 10), parseInt(letters[i].getAttribute("y"), 10), parseInt(letters[i].getAttribute("width"), 10), parseInt(letters[i].getAttribute("height"), 10));
                data.chars[charCode] = {
                    xOffset: parseInt(letters[i].getAttribute("xoffset"), 10),
                    yOffset: parseInt(letters[i].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(letters[i].getAttribute("xadvance"), 10) + xSpacing,
                    kerning: {},
                    texture: PIXI.TextureCache[cacheKey] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], textureRect)
                };
            }
            var kernings = xml.getElementsByTagName("kerning");
            for (i = 0; i < kernings.length; i++) {
                var first = parseInt(kernings[i].getAttribute("first"), 10);
                var second = parseInt(kernings[i].getAttribute("second"), 10);
                var amount = parseInt(kernings[i].getAttribute("amount"), 10);
                data.chars[second].kerning[first] = amount;
            }
            PIXI.BitmapText.fonts[cacheKey] = data;
        }
    };
    Phaser.Sound = function(game, key, volume, loop, connect) {
        if (typeof volume == "undefined") {
            volume = 1;
        }
        if (typeof loop == "undefined") {
            loop = false;
        }
        if (typeof connect === "undefined") {
            connect = game.sound.connectToMaster;
        }
        this.game = game;
        this.name = key;
        this.key = key;
        this.loop = loop;
        this.volume = volume;
        this.markers = {};
        this.context = null;
        this.autoplay = false;
        this.totalDuration = 0;
        this.startTime = 0;
        this.currentTime = 0;
        this.duration = 0;
        this.durationMS = 0;
        this.position = 0;
        this.stopTime = 0;
        this.paused = false;
        this.pausedPosition = 0;
        this.pausedTime = 0;
        this.isPlaying = false;
        this.currentMarker = "";
        this.pendingPlayback = false;
        this.override = false;
        this.usingWebAudio = this.game.sound.usingWebAudio;
        this.usingAudioTag = this.game.sound.usingAudioTag;
        this.externalNode = null;
        this.masterGainNode = null;
        this.gainNode = null;
        if (this.usingWebAudio) {
            this.context = this.game.sound.context;
            this.masterGainNode = this.game.sound.masterGain;
            if (typeof this.context.createGain === "undefined") {
                this.gainNode = this.context.createGainNode();
            } else {
                this.gainNode = this.context.createGain();
            }
            this.gainNode.gain.value = volume * this.game.sound.volume;
            if (connect) {
                this.gainNode.connect(this.masterGainNode);
            }
        } else {
            if (this.game.cache.getSound(key) && this.game.cache.isSoundReady(key)) {
                this._sound = this.game.cache.getSoundData(key);
                this.totalDuration = 0;
                if (this._sound.duration) {
                    this.totalDuration = this._sound.duration;
                }
            } else {
                this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);
            }
        }
        this.onDecoded = new Phaser.Signal();
        this.onPlay = new Phaser.Signal();
        this.onPause = new Phaser.Signal();
        this.onResume = new Phaser.Signal();
        this.onLoop = new Phaser.Signal();
        this.onStop = new Phaser.Signal();
        this.onMute = new Phaser.Signal();
        this.onMarkerComplete = new Phaser.Signal();
        this._volume = volume;
        this._buffer = null;
        this._muted = false;
        this._tempMarker = 0;
        this._tempPosition = 0;
        this._tempVolume = 0;
        this._muteVolume = 0;
        this._tempLoop = 0;
        this._paused = false;
        this._onDecodedEventDispatched = false;
    };
    Phaser.Sound.prototype = {
        soundHasUnlocked: function(key) {
            if (key === this.key) {
                this._sound = this.game.cache.getSoundData(this.key);
                this.totalDuration = this._sound.duration;
            }
        },
        addMarker: function(name, start, duration, volume, loop) {
            if (typeof volume == "undefined") {
                volume = 1;
            }
            if (typeof loop == "undefined") {
                loop = false;
            }
            this.markers[name] = {
                name: name,
                start: start,
                stop: start + duration,
                volume: volume,
                duration: duration,
                durationMS: duration * 1e3,
                loop: loop
            };
        },
        removeMarker: function(name) {
            delete this.markers[name];
        },
        update: function() {
            if (this.isDecoded && !this._onDecodedEventDispatched) {
                this.onDecoded.dispatch(this);
                this._onDecodedEventDispatched = true;
            }
            if (this.pendingPlayback && this.game.cache.isSoundReady(this.key)) {
                this.pendingPlayback = false;
                this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);
            }
            if (this.isPlaying) {
                this.currentTime = this.game.time.now - this.startTime;
                if (this.currentTime >= this.durationMS) {
                    if (this.usingWebAudio) {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            if (this.currentMarker === "") {
                                this.currentTime = 0;
                                this.startTime = this.game.time.now;
                            } else {
                                this.onMarkerComplete.dispatch(this.currentMarker, this);
                                this.play(this.currentMarker, 0, this.volume, true, true);
                            }
                        } else {
                            this.stop();
                        }
                    } else {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            this.play(this.currentMarker, 0, this.volume, true, true);
                        } else {
                            this.stop();
                        }
                    }
                }
            }
        },
        play: function(marker, position, volume, loop, forceRestart) {
            if (typeof marker === "undefined") {
                marker = "";
            }
            if (typeof forceRestart === "undefined") {
                forceRestart = true;
            }
            if (this.isPlaying && !forceRestart && !this.override) {
                return this;
            }
            if (this.isPlaying && (this.override || forceRestart)) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0);
                    } else {
                        this._sound.stop(0);
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0;
                }
            }
            this.currentMarker = marker;
            if (marker !== "") {
                if (this.markers[marker]) {
                    this.position = this.markers[marker].start;
                    this.volume = this.markers[marker].volume;
                    this.loop = this.markers[marker].loop;
                    this.duration = this.markers[marker].duration;
                    this.durationMS = this.markers[marker].durationMS;
                    if (typeof volume !== "undefined") {
                        this.volume = volume;
                    }
                    if (typeof loop !== "undefined") {
                        this.loop = loop;
                    }
                    this._tempMarker = marker;
                    this._tempPosition = this.position;
                    this._tempVolume = this.volume;
                    this._tempLoop = this.loop;
                } else {
                    console.warn("Phaser.Sound.play: audio marker " + marker + " doesn't exist");
                    return this;
                }
            } else {
                position = position || 0;
                if (typeof volume === "undefined") {
                    volume = this._volume;
                }
                if (typeof loop === "undefined") {
                    loop = this.loop;
                }
                this.position = position;
                this.volume = volume;
                this.loop = loop;
                this.duration = 0;
                this.durationMS = 0;
                this._tempMarker = marker;
                this._tempPosition = position;
                this._tempVolume = volume;
                this._tempLoop = loop;
            }
            if (this.usingWebAudio) {
                if (this.game.cache.isSoundDecoded(this.key)) {
                    if (this._buffer === null) {
                        this._buffer = this.game.cache.getSoundData(this.key);
                    }
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    if (this.externalNode) {
                        this._sound.connect(this.externalNode);
                    } else {
                        this._sound.connect(this.gainNode);
                    }
                    this.totalDuration = this._sound.buffer.duration;
                    if (this.duration === 0) {
                        this.duration = this.totalDuration;
                        this.durationMS = this.totalDuration * 1e3;
                    }
                    if (this.loop && marker === "") {
                        this._sound.loop = true;
                    }
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, this.position, this.duration);
                    } else {
                        this._sound.start(0, this.position, this.duration);
                    }
                    this.isPlaying = true;
                    this.startTime = this.game.time.now;
                    this.currentTime = 0;
                    this.stopTime = this.startTime + this.durationMS;
                    this.onPlay.dispatch(this);
                } else {
                    this.pendingPlayback = true;
                    if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === false) {
                        this.game.sound.decode(this.key, this);
                    }
                }
            } else {
                if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked) {
                    this.game.cache.reloadSound(this.key);
                    this.pendingPlayback = true;
                } else {
                    if (this._sound && (this.game.device.cocoonJS || this._sound.readyState === 4)) {
                        this._sound.play();
                        this.totalDuration = this._sound.duration;
                        if (this.duration === 0) {
                            this.duration = this.totalDuration;
                            this.durationMS = this.totalDuration * 1e3;
                        }
                        this._sound.currentTime = this.position;
                        this._sound.muted = this._muted;
                        if (this._muted) {
                            this._sound.volume = 0;
                        } else {
                            this._sound.volume = this._volume;
                        }
                        this.isPlaying = true;
                        this.startTime = this.game.time.now;
                        this.currentTime = 0;
                        this.stopTime = this.startTime + this.durationMS;
                        this.onPlay.dispatch(this);
                    } else {
                        this.pendingPlayback = true;
                    }
                }
            }
            return this;
        },
        restart: function(marker, position, volume, loop) {
            marker = marker || "";
            position = position || 0;
            volume = volume || 1;
            if (typeof loop == "undefined") {
                loop = false;
            }
            this.play(marker, position, volume, loop, true);
        },
        pause: function() {
            if (this.isPlaying && this._sound) {
                this.paused = true;
                this.pausedPosition = this.currentTime;
                this.pausedTime = this.game.time.now;
                this.onPause.dispatch(this);
                this.stop();
            }
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var p = this.position + this.pausedPosition / 1e3;
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    if (this.externalNode) {
                        this._sound.connect(this.externalNode);
                    } else {
                        this._sound.connect(this.gainNode);
                    }
                    if (this.loop) {
                        this._sound.loop = true;
                    }
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, p, this.duration);
                    } else {
                        this._sound.start(0, p, this.duration);
                    }
                } else {
                    this._sound.play();
                }
                this.isPlaying = true;
                this.paused = false;
                this.startTime += this.game.time.now - this.pausedTime;
                this.onResume.dispatch(this);
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0);
                    } else {
                        try {
                            this._sound.stop(0);
                        } catch (e) {}
                    }
                } else if (this.usingAudioTag) {
                    this._sound.pause();
                    this._sound.currentTime = 0;
                }
            }
            this.isPlaying = false;
            var prevMarker = this.currentMarker;
            if (this.currentMarker !== "") {
                this.onMarkerComplete.dispatch(this.currentMarker, this);
            }
            this.currentMarker = "";
            if (!this.paused) {
                this.onStop.dispatch(this, prevMarker);
            }
        },
        destroy: function(remove) {
            if (typeof remove === "undefined") {
                remove = true;
            }
            this.stop();
            if (remove) {
                this.game.sound.remove(this);
            } else {
                this.markers = {};
                this.context = null;
                this._buffer = null;
                this.externalNode = null;
                this.onDecoded.dispose();
                this.onPlay.dispose();
                this.onPause.dispose();
                this.onResume.dispose();
                this.onLoop.dispose();
                this.onStop.dispose();
                this.onMute.dispose();
                this.onMarkerComplete.dispose();
            }
        }
    };
    Phaser.Sound.prototype.constructor = Phaser.Sound;
    Object.defineProperty(Phaser.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding;
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key);
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute;
        },
        set: function(value) {
            value = value || null;
            if (value) {
                this._muted = true;
                if (this.usingWebAudio) {
                    this._muteVolume = this.gainNode.gain.value;
                    this.gainNode.gain.value = 0;
                } else if (this.usingAudioTag && this._sound) {
                    this._muteVolume = this._sound.volume;
                    this._sound.volume = 0;
                }
            } else {
                this._muted = false;
                if (this.usingWebAudio) {
                    this.gainNode.gain.value = this._muteVolume;
                } else if (this.usingAudioTag && this._sound) {
                    this._sound.volume = this._muteVolume;
                }
            }
            this.onMute.dispatch(this);
        }
    });
    Object.defineProperty(Phaser.Sound.prototype, "volume", {
        get: function() {
            return this._volume;
        },
        set: function(value) {
            if (this.usingWebAudio) {
                this._volume = value;
                this.gainNode.gain.value = value;
            } else if (this.usingAudioTag && this._sound) {
                if (value >= 0 && value <= 1) {
                    this._volume = value;
                    this._sound.volume = value;
                }
            }
        }
    });
    Phaser.SoundManager = function(game) {
        this.game = game;
        this.onSoundDecode = new Phaser.Signal();
        this._codeMuted = false;
        this._muted = false;
        this._unlockSource = null;
        this._volume = 1;
        this._sounds = [];
        this.context = null;
        this.usingWebAudio = true;
        this.usingAudioTag = false;
        this.noAudio = false;
        this.connectToMaster = true;
        this.touchLocked = false;
        this.channels = 32;
    };
    Phaser.SoundManager.prototype = {
        boot: function() {
            if (this.game.device.iOS && this.game.device.webAudio === false) {
                this.channels = 1;
            }
            if (!this.game.device.cocoonJS && this.game.device.iOS || window["PhaserGlobal"] && window["PhaserGlobal"].fakeiOSTouchLock) {
                this.game.input.touch.callbackContext = this;
                this.game.input.touch.touchStartCallback = this.unlock;
                this.game.input.mouse.callbackContext = this;
                this.game.input.mouse.mouseDownCallback = this.unlock;
                this.touchLocked = true;
            } else {
                this.touchLocked = false;
            }
            if (window["PhaserGlobal"]) {
                if (window["PhaserGlobal"].disableAudio === true) {
                    this.usingWebAudio = false;
                    this.noAudio = true;
                    return;
                }
                if (window["PhaserGlobal"].disableWebAudio === true) {
                    this.usingWebAudio = false;
                    this.usingAudioTag = true;
                    this.noAudio = false;
                    return;
                }
            }
            if (!!window["AudioContext"]) {
                try {
                    this.context = new window["AudioContext"]();
                } catch (error) {
                    this.context = null;
                    this.usingWebAudio = false;
                    this.noAudio = true;
                }
            } else if (!!window["webkitAudioContext"]) {
                try {
                    this.context = new window["webkitAudioContext"]();
                } catch (error) {
                    this.context = null;
                    this.usingWebAudio = false;
                    this.noAudio = true;
                }
            }
            if (!!window["Audio"] && this.context === null) {
                this.usingWebAudio = false;
                this.usingAudioTag = true;
                this.noAudio = false;
            }
            if (this.context !== null) {
                if (typeof this.context.createGain === "undefined") {
                    this.masterGain = this.context.createGainNode();
                } else {
                    this.masterGain = this.context.createGain();
                }
                this.masterGain.gain.value = 1;
                this.masterGain.connect(this.context.destination);
            }
        },
        unlock: function() {
            if (this.touchLocked === false) {
                return;
            }
            if (this.game.device.webAudio === false || window["PhaserGlobal"] && window["PhaserGlobal"].disableWebAudio === true) {
                this.touchLocked = false;
                this._unlockSource = null;
                this.game.input.touch.callbackContext = null;
                this.game.input.touch.touchStartCallback = null;
                this.game.input.mouse.callbackContext = null;
                this.game.input.mouse.mouseDownCallback = null;
            } else {
                var buffer = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource();
                this._unlockSource.buffer = buffer;
                this._unlockSource.connect(this.context.destination);
                this._unlockSource.noteOn(0);
            }
        },
        stopAll: function() {
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].stop();
                }
            }
        },
        pauseAll: function() {
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].pause();
                }
            }
        },
        resumeAll: function() {
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].resume();
                }
            }
        },
        decode: function(key, sound) {
            sound = sound || null;
            var soundData = this.game.cache.getSoundData(key);
            if (soundData) {
                if (this.game.cache.isSoundDecoded(key) === false) {
                    this.game.cache.updateSound(key, "isDecoding", true);
                    var that = this;
                    this.context.decodeAudioData(soundData, function(buffer) {
                        that.game.cache.decodedSound(key, buffer);
                        if (sound) {
                            that.onSoundDecode.dispatch(key, sound);
                        }
                    });
                }
            }
        },
        update: function() {
            if (this.touchLocked) {
                if (this.game.device.webAudio && this._unlockSource !== null) {
                    if (this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE) {
                        this.touchLocked = false;
                        this._unlockSource = null;
                        this.game.input.touch.callbackContext = null;
                        this.game.input.touch.touchStartCallback = null;
                    }
                }
            }
            for (var i = 0; i < this._sounds.length; i++) {
                this._sounds[i].update();
            }
        },
        add: function(key, volume, loop, connect) {
            if (typeof volume === "undefined") {
                volume = 1;
            }
            if (typeof loop === "undefined") {
                loop = false;
            }
            if (typeof connect === "undefined") {
                connect = this.connectToMaster;
            }
            var sound = new Phaser.Sound(this.game, key, volume, loop, connect);
            this._sounds.push(sound);
            return sound;
        },
        remove: function(sound) {
            var i = this._sounds.length;
            while (i--) {
                if (this._sounds[i] === sound) {
                    this._sounds[i].destroy(false);
                    this._sounds.splice(i, 1);
                    return true;
                }
            }
            return false;
        },
        removeByKey: function(key) {
            var i = this._sounds.length;
            var removed = 0;
            while (i--) {
                if (this._sounds[i].key === key) {
                    this._sounds[i].destroy(false);
                    this._sounds.splice(i, 1);
                    removed++;
                }
            }
            return removed;
        },
        play: function(key, volume, loop) {
            var sound = this.add(key, volume, loop);
            sound.play();
            return sound;
        },
        setMute: function() {
            if (this._muted) {
                return;
            }
            this._muted = true;
            if (this.usingWebAudio) {
                this._muteVolume = this.masterGain.gain.value;
                this.masterGain.gain.value = 0;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i].usingAudioTag) {
                    this._sounds[i].mute = true;
                }
            }
        },
        unsetMute: function() {
            if (!this._muted || this._codeMuted) {
                return;
            }
            this._muted = false;
            if (this.usingWebAudio) {
                this.masterGain.gain.value = this._muteVolume;
            }
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i].usingAudioTag) {
                    this._sounds[i].mute = false;
                }
            }
        },
        destroy: function() {
            this.stopAll();
            for (var i = 0; i < this._sounds.length; i++) {
                if (this._sounds[i]) {
                    this._sounds[i].destroy();
                }
            }
            this._sounds = [];
            this.onSoundDecode.dispose();
        }
    };
    Phaser.SoundManager.prototype.constructor = Phaser.SoundManager;
    Object.defineProperty(Phaser.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted;
        },
        set: function(value) {
            value = value || null;
            if (value) {
                if (this._muted) {
                    return;
                }
                this._codeMuted = true;
                this.setMute();
            } else {
                if (!this._muted) {
                    return;
                }
                this._codeMuted = false;
                this.unsetMute();
            }
        }
    });
    Object.defineProperty(Phaser.SoundManager.prototype, "volume", {
        get: function() {
            if (this.usingWebAudio) {
                return this.masterGain.gain.value;
            } else {
                return this._volume;
            }
        },
        set: function(value) {
            this._volume = value;
            if (this.usingWebAudio) {
                this.masterGain.gain.value = value;
            } else {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i].usingAudioTag) {
                        this._sounds[i].volume = this._sounds[i].volume * value;
                    }
                }
            }
        }
    });
    Phaser.Utils.Debug = function(game) {
        this.game = game;
        this.sprite = null;
        this.canvas = null;
        this.baseTexture = null;
        this.texture = null;
        this.textureFrame = null;
        this.context = null;
        this.font = "14px Courier";
        this.columnWidth = 100;
        this.lineHeight = 16;
        this.renderShadow = true;
        this.currentX = 0;
        this.currentY = 0;
        this.currentAlpha = 1;
        this.dirty = false;
    };
    Phaser.Utils.Debug.prototype = {
        boot: function() {
            if (this.game.renderType === Phaser.CANVAS) {
                this.context = this.game.context;
            } else {
                this.canvas = Phaser.Canvas.create(this.game.width, this.game.height, "", true);
                this.context = this.canvas.getContext("2d");
                this.baseTexture = new PIXI.BaseTexture(this.canvas);
                this.texture = new PIXI.Texture(this.baseTexture);
                this.textureFrame = new Phaser.Frame(0, 0, 0, this.game.width, this.game.height, "debug", this.game.rnd.uuid());
                this.sprite = this.game.make.image(0, 0, this.texture, this.textureFrame);
                this.game.stage.addChild(this.sprite);
            }
        },
        preUpdate: function() {
            if (this.dirty && this.sprite) {
                this.context.clearRect(0, 0, this.game.width, this.game.height);
                this.dirty = false;
            }
        },
        reset: function() {
            if (this.context) {
                this.context.clearRect(0, 0, this.game.width, this.game.height);
            }
            if (this.sprite) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
            }
        },
        start: function(x, y, color, columnWidth) {
            if (typeof x !== "number") {
                x = 0;
            }
            if (typeof y !== "number") {
                y = 0;
            }
            color = color || "rgb(255,255,255)";
            if (typeof columnWidth === "undefined") {
                columnWidth = 0;
            }
            this.currentX = x;
            this.currentY = y;
            this.currentColor = color;
            this.currentAlpha = this.context.globalAlpha;
            this.columnWidth = columnWidth;
            if (this.sprite) {
                this.dirty = true;
            }
            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.strokeStyle = color;
            this.context.fillStyle = color;
            this.context.font = this.font;
            this.context.globalAlpha = 1;
        },
        stop: function() {
            this.context.restore();
            this.context.globalAlpha = this.currentAlpha;
            if (this.sprite) {
                PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
            }
        },
        line: function() {
            var x = this.currentX;
            for (var i = 0; i < arguments.length; i++) {
                if (this.renderShadow) {
                    this.context.fillStyle = "rgb(0,0,0)";
                    this.context.fillText(arguments[i], x + 1, this.currentY + 1);
                    this.context.fillStyle = this.currentColor;
                }
                this.context.fillText(arguments[i], x, this.currentY);
                x += this.columnWidth;
            }
            this.currentY += this.lineHeight;
        },
        soundInfo: function(sound, x, y, color) {
            this.start(x, y, color);
            this.line("Sound: " + sound.key + " Locked: " + sound.game.sound.touchLocked);
            this.line("Is Ready?: " + this.game.cache.isSoundReady(sound.key) + " Pending Playback: " + sound.pendingPlayback);
            this.line("Decoded: " + sound.isDecoded + " Decoding: " + sound.isDecoding);
            this.line("Total Duration: " + sound.totalDuration + " Playing: " + sound.isPlaying);
            this.line("Time: " + sound.currentTime);
            this.line("Volume: " + sound.volume + " Muted: " + sound.mute);
            this.line("WebAudio: " + sound.usingWebAudio + " Audio: " + sound.usingAudioTag);
            if (sound.currentMarker !== "") {
                this.line("Marker: " + sound.currentMarker + " Duration: " + sound.duration + " (ms: " + sound.durationMS + ")");
                this.line("Start: " + sound.markers[sound.currentMarker].start + " Stop: " + sound.markers[sound.currentMarker].stop);
                this.line("Position: " + sound.position);
            }
            this.stop();
        },
        cameraInfo: function(camera, x, y, color) {
            this.start(x, y, color);
            this.line("Camera (" + camera.width + " x " + camera.height + ")");
            this.line("X: " + camera.x + " Y: " + camera.y);
            if (camera.bounds) {
                this.line("Bounds x: " + camera.bounds.x + " Y: " + camera.bounds.y + " w: " + camera.bounds.width + " h: " + camera.bounds.height);
            }
            this.line("View x: " + camera.view.x + " Y: " + camera.view.y + " w: " + camera.view.width + " h: " + camera.view.height);
            this.stop();
        },
        timer: function(timer, x, y, color) {
            this.start(x, y, color);
            this.line("Timer (running: " + timer.running + " expired: " + timer.expired + ")");
            this.line("Next Tick: " + timer.next + " Duration: " + timer.duration);
            this.line("Paused: " + timer.paused + " Length: " + timer.length);
            this.stop();
        },
        pointer: function(pointer, hideIfUp, downColor, upColor, color) {
            if (pointer == null) {
                return;
            }
            if (typeof hideIfUp === "undefined") {
                hideIfUp = false;
            }
            downColor = downColor || "rgba(0,255,0,0.5)";
            upColor = upColor || "rgba(255,0,0,0.5)";
            if (hideIfUp === true && pointer.isUp === true) {
                return;
            }
            this.start(pointer.x, pointer.y - 100, color);
            this.context.beginPath();
            this.context.arc(pointer.x, pointer.y, pointer.circle.radius, 0, Math.PI * 2);
            if (pointer.active) {
                this.context.fillStyle = downColor;
            } else {
                this.context.fillStyle = upColor;
            }
            this.context.fill();
            this.context.closePath();
            this.context.beginPath();
            this.context.moveTo(pointer.positionDown.x, pointer.positionDown.y);
            this.context.lineTo(pointer.position.x, pointer.position.y);
            this.context.lineWidth = 2;
            this.context.stroke();
            this.context.closePath();
            this.line("ID: " + pointer.id + " Active: " + pointer.active);
            this.line("World X: " + pointer.worldX + " World Y: " + pointer.worldY);
            this.line("Screen X: " + pointer.x + " Screen Y: " + pointer.y);
            this.line("Duration: " + pointer.duration + " ms");
            this.line("is Down: " + pointer.isDown + " is Up: " + pointer.isUp);
            this.stop();
        },
        spriteInputInfo: function(sprite, x, y, color) {
            this.start(x, y, color);
            this.line("Sprite Input: (" + sprite.width + " x " + sprite.height + ")");
            this.line("x: " + sprite.input.pointerX().toFixed(1) + " y: " + sprite.input.pointerY().toFixed(1));
            this.line("over: " + sprite.input.pointerOver() + " duration: " + sprite.input.overDuration().toFixed(0));
            this.line("down: " + sprite.input.pointerDown() + " duration: " + sprite.input.downDuration().toFixed(0));
            this.line("just over: " + sprite.input.justOver() + " just out: " + sprite.input.justOut());
            this.stop();
        },
        key: function(key, x, y, color) {
            this.start(x, y, color, 150);
            this.line("Key:", key.keyCode, "isDown:", key.isDown);
            this.line("justPressed:", key.justPressed(), "justReleased:", key.justReleased());
            this.line("Time Down:", key.timeDown.toFixed(0), "duration:", key.duration.toFixed(0));
            this.stop();
        },
        inputInfo: function(x, y, color) {
            this.start(x, y, color);
            this.line("Input");
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y);
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY);
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1));
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY);
            this.stop();
        },
        spriteBounds: function(sprite, color, filled) {
            var bounds = sprite.getBounds();
            bounds.x += this.game.camera.x;
            bounds.y += this.game.camera.y;
            this.rectangle(bounds, color, filled);
        },
        ropeSegments: function(rope, color, filled) {
            var segments = rope.segments;
            segments.forEach(function(segment) {
                this.rectangle(segment, color, filled);
            }, this);
        },
        spriteInfo: function(sprite, x, y, color) {
            this.start(x, y, color);
            this.line("Sprite: " + " (" + sprite.width + " x " + sprite.height + ") anchor: " + sprite.anchor.x + " x " + sprite.anchor.y);
            this.line("x: " + sprite.x.toFixed(1) + " y: " + sprite.y.toFixed(1));
            this.line("angle: " + sprite.angle.toFixed(1) + " rotation: " + sprite.rotation.toFixed(1));
            this.line("visible: " + sprite.visible + " in camera: " + sprite.inCamera);
            this.stop();
        },
        spriteCoords: function(sprite, x, y, color) {
            this.start(x, y, color, 100);
            if (sprite.name) {
                this.line(sprite.name);
            }
            this.line("x:", sprite.x.toFixed(2), "y:", sprite.y.toFixed(2));
            this.line("pos x:", sprite.position.x.toFixed(2), "pos y:", sprite.position.y.toFixed(2));
            this.line("world x:", sprite.world.x.toFixed(2), "world y:", sprite.world.y.toFixed(2));
            this.stop();
        },
        lineInfo: function(line, x, y, color) {
            this.start(x, y, color, 80);
            this.line("start.x:", line.start.x.toFixed(2), "start.y:", line.start.y.toFixed(2));
            this.line("end.x:", line.end.x.toFixed(2), "end.y:", line.end.y.toFixed(2));
            this.line("length:", line.length.toFixed(2), "angle:", line.angle);
            this.stop();
        },
        pixel: function(x, y, color, size) {
            size = size || 2;
            this.start();
            this.context.fillStyle = color;
            this.context.fillRect(x, y, size, size);
            this.stop();
        },
        geom: function(object, color, filled, forceType) {
            if (typeof filled === "undefined") {
                filled = true;
            }
            if (typeof forceType === "undefined") {
                forceType = 0;
            }
            color = color || "rgba(0,255,0,0.4)";
            this.start();
            this.context.fillStyle = color;
            this.context.strokeStyle = color;
            if (object instanceof Phaser.Rectangle || forceType === 1) {
                if (filled) {
                    this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
                } else {
                    this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
                }
            } else if (object instanceof Phaser.Circle || forceType === 2) {
                this.context.beginPath();
                this.context.arc(object.x - this.game.camera.x, object.y - this.game.camera.y, object.radius, 0, Math.PI * 2, false);
                this.context.closePath();
                if (filled) {
                    this.context.fill();
                } else {
                    this.context.stroke();
                }
            } else if (object instanceof Phaser.Point || forceType === 3) {
                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, 4, 4);
            } else if (object instanceof Phaser.Line || forceType === 4) {
                this.context.lineWidth = 1;
                this.context.beginPath();
                this.context.moveTo(object.start.x + .5 - this.game.camera.x, object.start.y + .5 - this.game.camera.y);
                this.context.lineTo(object.end.x + .5 - this.game.camera.x, object.end.y + .5 - this.game.camera.y);
                this.context.closePath();
                this.context.stroke();
            }
            this.stop();
        },
        rectangle: function(object, color, filled) {
            if (typeof filled === "undefined") {
                filled = true;
            }
            color = color || "rgba(0, 255, 0, 0.4)";
            this.start();
            if (filled) {
                this.context.fillStyle = color;
                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
            } else {
                this.context.strokeStyle = color;
                this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);
            }
            this.stop();
        },
        text: function(text, x, y, color, font) {
            color = color || "rgb(255,255,255)";
            font = font || "16px Courier";
            this.start();
            this.context.font = font;
            if (this.renderShadow) {
                this.context.fillStyle = "rgb(0,0,0)";
                this.context.fillText(text, x + 1, y + 1);
            }
            this.context.fillStyle = color;
            this.context.fillText(text, x, y);
            this.stop();
        },
        quadTree: function(quadtree, color) {
            color = color || "rgba(255,0,0,0.3)";
            this.start();
            var bounds = quadtree.bounds;
            if (quadtree.nodes.length === 0) {
                this.context.strokeStyle = color;
                this.context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                this.text("size: " + quadtree.objects.length, bounds.x + 4, bounds.y + 16, "rgb(0,200,0)", "12px Courier");
                this.context.strokeStyle = "rgb(0,255,0)";
                for (var i = 0; i < quadtree.objects.length; i++) {
                    this.context.strokeRect(quadtree.objects[i].x, quadtree.objects[i].y, quadtree.objects[i].width, quadtree.objects[i].height);
                }
            } else {
                for (var i = 0; i < quadtree.nodes.length; i++) {
                    this.quadTree(quadtree.nodes[i]);
                }
            }
            this.stop();
        },
        body: function(sprite, color, filled) {
            if (sprite.body) {
                if (sprite.body.type === Phaser.Physics.ARCADE) {
                    this.start();
                    Phaser.Physics.Arcade.Body.render(this.context, sprite.body, color, filled);
                    this.stop();
                } else if (sprite.body.type === Phaser.Physics.NINJA) {
                    this.start();
                    Phaser.Physics.Ninja.Body.render(this.context, sprite.body, color, filled);
                    this.stop();
                }
            }
        },
        bodyInfo: function(sprite, x, y, color) {
            if (sprite.body) {
                if (sprite.body.type === Phaser.Physics.ARCADE) {
                    this.start(x, y, color, 210);
                    Phaser.Physics.Arcade.Body.renderBodyInfo(this, sprite.body);
                    this.stop();
                }
            }
        }
    };
    Phaser.Utils.Debug.prototype.constructor = Phaser.Utils.Debug;
    Phaser.Color = {
        packPixel: function(r, g, b, a) {
            if (Phaser.Device.LITTLE_ENDIAN) {
                return (a << 24 | b << 16 | g << 8 | r) >>> 0;
            } else {
                return (r << 24 | g << 16 | b << 8 | a) >>> 0;
            }
        },
        unpackPixel: function(rgba, out, hsl, hsv) {
            if (typeof out === "undefined" || out === null) {
                out = Phaser.Color.createColor();
            }
            if (typeof hsl === "undefined" || hsl === null) {
                hsl = false;
            }
            if (typeof hsv === "undefined" || hsv === null) {
                hsv = false;
            }
            if (Phaser.Device.LITTLE_ENDIAN) {
                out.a = (rgba & 4278190080) >>> 24;
                out.b = (rgba & 16711680) >>> 16;
                out.g = (rgba & 65280) >>> 8;
                out.r = rgba & 255;
            } else {
                out.r = (rgba & 4278190080) >>> 24;
                out.g = (rgba & 16711680) >>> 16;
                out.b = (rgba & 65280) >>> 8;
                out.a = rgba & 255;
            }
            out.color = rgba;
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a / 255 + ")";
            if (hsl) {
                Phaser.Color.RGBtoHSL(out.r, out.g, out.b, out);
            }
            if (hsv) {
                Phaser.Color.RGBtoHSV(out.r, out.g, out.b, out);
            }
            return out;
        },
        fromRGBA: function(rgba, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            out.r = (rgba & 4278190080) >>> 24;
            out.g = (rgba & 16711680) >>> 16;
            out.b = (rgba & 65280) >>> 8;
            out.a = rgba & 255;
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")";
            return out;
        },
        toRGBA: function(r, g, b, a) {
            return r << 24 | g << 16 | b << 8 | a;
        },
        RGBtoHSL: function(r, g, b, out) {
            if (!out) {
                out = Phaser.Color.createColor(r, g, b, 1);
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            out.h = 0;
            out.s = 0;
            out.l = (max + min) / 2;
            if (max !== min) {
                var d = max - min;
                out.s = out.l > .5 ? d / (2 - max - min) : d / (max + min);
                if (max === r) {
                    out.h = (g - b) / d + (g < b ? 6 : 0);
                } else if (max === g) {
                    out.h = (b - r) / d + 2;
                } else if (max === b) {
                    out.h = (r - g) / d + 4;
                }
                out.h /= 6;
            }
            return out;
        },
        HSLtoRGB: function(h, s, l, out) {
            if (!out) {
                out = Phaser.Color.createColor(l, l, l);
            } else {
                out.r = l;
                out.g = l;
                out.b = l;
            }
            if (s !== 0) {
                var q = l < .5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                out.r = Phaser.Color.hueToColor(p, q, h + 1 / 3);
                out.g = Phaser.Color.hueToColor(p, q, h);
                out.b = Phaser.Color.hueToColor(p, q, h - 1 / 3);
            }
            out.r = Math.floor(out.r * 255 | 0);
            out.g = Math.floor(out.g * 255 | 0);
            out.b = Math.floor(out.b * 255 | 0);
            Phaser.Color.updateColor(out);
            return out;
        },
        RGBtoHSV: function(r, g, b, out) {
            if (!out) {
                out = Phaser.Color.createColor(r, g, b, 255);
            }
            r /= 255;
            g /= 255;
            b /= 255;
            var min = Math.min(r, g, b);
            var max = Math.max(r, g, b);
            var d = max - min;
            out.h = 0;
            out.s = max === 0 ? 0 : d / max;
            out.v = max;
            if (max !== min) {
                if (max === r) {
                    out.h = (g - b) / d + (g < b ? 6 : 0);
                } else if (max === g) {
                    out.h = (b - r) / d + 2;
                } else if (max === b) {
                    out.h = (r - g) / d + 4;
                }
                out.h /= 6;
            }
            return out;
        },
        HSVtoRGB: function(h, s, v, out) {
            if (typeof out === "undefined") {
                out = Phaser.Color.createColor(0, 0, 0, 1, h, s, 0, v);
            }
            var r, g, b;
            var i = Math.floor(h * 6);
            var f = h * 6 - i;
            var p = v * (1 - s);
            var q = v * (1 - f * s);
            var t = v * (1 - (1 - f) * s);
            switch (i % 6) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;

              case 1:
                r = q;
                g = v;
                b = p;
                break;

              case 2:
                r = p;
                g = v;
                b = t;
                break;

              case 3:
                r = p;
                g = q;
                b = v;
                break;

              case 4:
                r = t;
                g = p;
                b = v;
                break;

              case 5:
                r = v;
                g = p;
                b = q;
                break;
            }
            out.r = Math.floor(r * 255);
            out.g = Math.floor(g * 255);
            out.b = Math.floor(b * 255);
            Phaser.Color.updateColor(out);
            return out;
        },
        hueToColor: function(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        },
        createColor: function(r, g, b, a, h, s, l, v) {
            var out = {
                r: r || 0,
                g: g || 0,
                b: b || 0,
                a: a || 1,
                h: h || 0,
                s: s || 0,
                l: l || 0,
                v: v || 0,
                color: 0
            };
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")";
            return out;
        },
        updateColor: function(out) {
            out.rgba = "rgba(" + out.r + "," + out.g + "," + out.b + "," + out.a + ")";
            return out;
        },
        getColor32: function(a, r, g, b) {
            return a << 24 | r << 16 | g << 8 | b;
        },
        getColor: function(r, g, b) {
            return r << 16 | g << 8 | b;
        },
        RGBtoString: function(r, g, b, a, prefix) {
            if (typeof a === "undefined") {
                a = 255;
            }
            if (typeof prefix === "undefined") {
                prefix = "#";
            }
            if (prefix === "#") {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            } else {
                return "0x" + Phaser.Color.componentToHex(a) + Phaser.Color.componentToHex(r) + Phaser.Color.componentToHex(g) + Phaser.Color.componentToHex(b);
            }
        },
        hexToRGB: function(hex) {
            var rgb = Phaser.Color.hexToColor(hex);
            if (rgb) {
                return Phaser.Color.getColor32(rgb.a, rgb.r, rgb.g, rgb.b);
            }
        },
        hexToColor: function(hex, out) {
            if (!out) {
                out = Phaser.Color.createColor();
            }
            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
            });
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
                out.r = parseInt(result[1], 16);
                out.g = parseInt(result[2], 16);
                out.b = parseInt(result[3], 16);
            }
            return out;
        },
        componentToHex: function(color) {
            var hex = color.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        },
        HSVColorWheel: function(s, v) {
            if (typeof s === "undefined") {
                s = 1;
            }
            if (typeof v === "undefined") {
                v = 1;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
                colors.push(Phaser.Color.HSVtoRGB(c / 359, s, v));
            }
            return colors;
        },
        HSLColorWheel: function(s, l) {
            if (typeof s === "undefined") {
                s = .5;
            }
            if (typeof l === "undefined") {
                l = .5;
            }
            var colors = [];
            for (var c = 0; c <= 359; c++) {
                colors.push(Phaser.Color.HSLtoRGB(c / 359, s, l));
            }
            return colors;
        },
        interpolateColor: function(color1, color2, steps, currentStep, alpha) {
            if (typeof alpha === "undefined") {
                alpha = 255;
            }
            var src1 = Phaser.Color.getRGB(color1);
            var src2 = Phaser.Color.getRGB(color2);
            var r = (src2.red - src1.red) * currentStep / steps + src1.red;
            var g = (src2.green - src1.green) * currentStep / steps + src1.green;
            var b = (src2.blue - src1.blue) * currentStep / steps + src1.blue;
            return Phaser.Color.getColor32(alpha, r, g, b);
        },
        interpolateColorWithRGB: function(color, r, g, b, steps, currentStep) {
            var src = Phaser.Color.getRGB(color);
            var or = (r - src.red) * currentStep / steps + src.red;
            var og = (g - src.green) * currentStep / steps + src.green;
            var ob = (b - src.blue) * currentStep / steps + src.blue;
            return Phaser.Color.getColor(or, og, ob);
        },
        interpolateRGB: function(r1, g1, b1, r2, g2, b2, steps, currentStep) {
            var r = (r2 - r1) * currentStep / steps + r1;
            var g = (g2 - g1) * currentStep / steps + g1;
            var b = (b2 - b1) * currentStep / steps + b1;
            return Phaser.Color.getColor(r, g, b);
        },
        getRandomColor: function(min, max, alpha) {
            if (typeof min === "undefined") {
                min = 0;
            }
            if (typeof max === "undefined") {
                max = 255;
            }
            if (typeof alpha === "undefined") {
                alpha = 255;
            }
            if (max > 255 || min > max) {
                return Phaser.Color.getColor(255, 255, 255);
            }
            var red = min + Math.round(Math.random() * (max - min));
            var green = min + Math.round(Math.random() * (max - min));
            var blue = min + Math.round(Math.random() * (max - min));
            return Phaser.Color.getColor32(alpha, red, green, blue);
        },
        getRGB: function(color) {
            if (color > 16777215) {
                return {
                    alpha: color >>> 24,
                    red: color >> 16 & 255,
                    green: color >> 8 & 255,
                    blue: color & 255,
                    a: color >>> 24,
                    r: color >> 16 & 255,
                    g: color >> 8 & 255,
                    b: color & 255
                };
            } else {
                return {
                    alpha: 255,
                    red: color >> 16 & 255,
                    green: color >> 8 & 255,
                    blue: color & 255,
                    a: 255,
                    r: color >> 16 & 255,
                    g: color >> 8 & 255,
                    b: color & 255
                };
            }
        },
        getWebRGB: function(color) {
            if (typeof color === "object") {
                return "rgba(" + color.r.toString() + "," + color.g.toString() + "," + color.b.toString() + "," + (color.a / 255).toString() + ")";
            } else {
                var rgb = Phaser.Color.getRGB(color);
                return "rgba(" + rgb.r.toString() + "," + rgb.g.toString() + "," + rgb.b.toString() + "," + (rgb.a / 255).toString() + ")";
            }
        },
        getAlpha: function(color) {
            return color >>> 24;
        },
        getAlphaFloat: function(color) {
            return (color >>> 24) / 255;
        },
        getRed: function(color) {
            return color >> 16 & 255;
        },
        getGreen: function(color) {
            return color >> 8 & 255;
        },
        getBlue: function(color) {
            return color & 255;
        }
    };
    Phaser.Physics = function(game, config) {
        config = config || {};
        this.game = game;
        this.config = config;
        this.arcade = null;
        this.p2 = null;
        this.ninja = null;
        this.box2d = null;
        this.chipmunk = null;
        this.parseConfig();
    };
    Phaser.Physics.ARCADE = 0;
    Phaser.Physics.P2JS = 1;
    Phaser.Physics.NINJA = 2;
    Phaser.Physics.BOX2D = 3;
    Phaser.Physics.CHIPMUNK = 5;
    Phaser.Physics.prototype = {
        parseConfig: function() {
            if ((!this.config.hasOwnProperty("arcade") || this.config["arcade"] === true) && Phaser.Physics.hasOwnProperty("Arcade")) {
                this.arcade = new Phaser.Physics.Arcade(this.game);
                this.game.time.deltaCap = .2;
            }
            if (this.config.hasOwnProperty("ninja") && this.config["ninja"] === true && Phaser.Physics.hasOwnProperty("Ninja")) {
                this.ninja = new Phaser.Physics.Ninja(this.game);
            }
            if (this.config.hasOwnProperty("p2") && this.config["p2"] === true && Phaser.Physics.hasOwnProperty("P2")) {
                this.p2 = new Phaser.Physics.P2(this.game, this.config);
            }
        },
        startSystem: function(system) {
            if (system === Phaser.Physics.ARCADE) {
                this.arcade = new Phaser.Physics.Arcade(this.game);
            } else if (system === Phaser.Physics.P2JS) {
                this.p2 = new Phaser.Physics.P2(this.game, this.config);
            }
            if (system === Phaser.Physics.NINJA) {
                this.ninja = new Phaser.Physics.Ninja(this.game);
            } else if (system === Phaser.Physics.BOX2D && this.box2d === null) {
                throw new Error("The Box2D physics system has not been implemented yet.");
            } else if (system === Phaser.Physics.CHIPMUNK && this.chipmunk === null) {
                throw new Error("The Chipmunk physics system has not been implemented yet.");
            }
        },
        enable: function(object, system, debug) {
            if (typeof system === "undefined") {
                system = Phaser.Physics.ARCADE;
            }
            if (typeof debug === "undefined") {
                debug = false;
            }
            if (system === Phaser.Physics.ARCADE) {
                this.arcade.enable(object);
            } else if (system === Phaser.Physics.P2JS && this.p2) {
                this.p2.enable(object, debug);
            } else if (system === Phaser.Physics.NINJA && this.ninja) {
                this.ninja.enableAABB(object);
            }
        },
        preUpdate: function() {
            if (this.p2) {
                this.p2.preUpdate();
            }
        },
        update: function() {
            if (this.p2) {
                this.p2.update();
            }
        },
        setBoundsToWorld: function() {
            if (this.arcade) {
                this.arcade.setBoundsToWorld();
            }
            if (this.ninja) {
                this.ninja.setBoundsToWorld();
            }
            if (this.p2) {
                this.p2.setBoundsToWorld();
            }
        },
        clear: function() {
            if (this.p2) {
                this.p2.clear();
            }
        },
        destroy: function() {
            if (this.p2) {
                this.p2.destroy();
            }
            this.arcade = null;
            this.ninja = null;
            this.p2 = null;
        }
    };
    Phaser.Physics.prototype.constructor = Phaser.Physics;
    Phaser.Physics.Arcade = function(game) {
        this.game = game;
        this.gravity = new Phaser.Point();
        this.bounds = new Phaser.Rectangle(0, 0, game.world.width, game.world.height);
        this.checkCollision = {
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.OVERLAP_BIAS = 4;
        this.TILE_BIAS = 16;
        this.forceX = false;
        this.skipQuadTree = false;
        this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
        this._overlap = 0;
        this._maxOverlap = 0;
        this._velocity1 = 0;
        this._velocity2 = 0;
        this._newVelocity1 = 0;
        this._newVelocity2 = 0;
        this._average = 0;
        this._mapData = [];
        this._result = false;
        this._total = 0;
        this._angle = 0;
        this._dx = 0;
        this._dy = 0;
        this.setBoundsToWorld();
    };
    Phaser.Physics.Arcade.prototype.constructor = Phaser.Physics.Arcade;
    Phaser.Physics.Arcade.prototype = {
        setBounds: function(x, y, width, height) {
            this.bounds.setTo(x, y, width, height);
        },
        setBoundsToWorld: function() {
            this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);
        },
        enable: function(object, children) {
            if (typeof children === "undefined") {
                children = true;
            }
            var i = 1;
            if (Array.isArray(object)) {
                i = object.length;
                while (i--) {
                    if (object[i] instanceof Phaser.Group) {
                        this.enable(object[i].children, children);
                    } else {
                        this.enableBody(object[i]);
                        if (children && object[i].hasOwnProperty("children") && object[i].children.length > 0) {
                            this.enable(object[i], true);
                        }
                    }
                }
            } else {
                if (object instanceof Phaser.Group) {
                    this.enable(object.children, children);
                } else {
                    this.enableBody(object);
                    if (children && object.hasOwnProperty("children") && object.children.length > 0) {
                        this.enable(object.children, true);
                    }
                }
            }
        },
        enableBody: function(object) {
            if (object.hasOwnProperty("body") && object.body === null) {
                object.body = new Phaser.Physics.Arcade.Body(object);
            }
        },
        updateMotion: function(body) {
            this._velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular) - body.angularVelocity;
            body.angularVelocity += this._velocityDelta;
            body.rotation += body.angularVelocity * this.game.time.physicsElapsed;
            body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x);
            body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y);
        },
        computeVelocity: function(axis, body, velocity, acceleration, drag, max) {
            max = max || 1e4;
            if (axis == 1 && body.allowGravity) {
                velocity += (this.gravity.x + body.gravity.x) * this.game.time.physicsElapsed;
            } else if (axis == 2 && body.allowGravity) {
                velocity += (this.gravity.y + body.gravity.y) * this.game.time.physicsElapsed;
            }
            if (acceleration) {
                velocity += acceleration * this.game.time.physicsElapsed;
            } else if (drag) {
                this._drag = drag * this.game.time.physicsElapsed;
                if (velocity - this._drag > 0) {
                    velocity -= this._drag;
                } else if (velocity + this._drag < 0) {
                    velocity += this._drag;
                } else {
                    velocity = 0;
                }
            }
            if (velocity > max) {
                velocity = max;
            } else if (velocity < -max) {
                velocity = -max;
            }
            return velocity;
        },
        overlap: function(object1, object2, overlapCallback, processCallback, callbackContext) {
            overlapCallback = overlapCallback || null;
            processCallback = processCallback || null;
            callbackContext = callbackContext || overlapCallback;
            this._result = false;
            this._total = 0;
            if (!Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len = object2.length; i < len; i++) {
                    this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, true);
                }
            } else if (Array.isArray(object1) && !Array.isArray(object2)) {
                for (var i = 0, len = object1.length; i < len; i++) {
                    this.collideHandler(object1[i], object2, overlapCallback, processCallback, callbackContext, true);
                }
            } else if (Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len = object1.length; i < len; i++) {
                    for (var j = 0, len2 = object2.length; j < len2; j++) {
                        this.collideHandler(object1[i], object2[j], overlapCallback, processCallback, callbackContext, true);
                    }
                }
            } else {
                this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, true);
            }
            return this._total > 0;
        },
        collide: function(object1, object2, collideCallback, processCallback, callbackContext) {
            collideCallback = collideCallback || null;
            processCallback = processCallback || null;
            callbackContext = callbackContext || collideCallback;
            this._result = false;
            this._total = 0;
            if (!Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len = object2.length; i < len; i++) {
                    this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, false);
                }
            } else if (Array.isArray(object1) && !Array.isArray(object2)) {
                for (var i = 0, len = object1.length; i < len; i++) {
                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, false);
                }
            } else if (Array.isArray(object1) && Array.isArray(object2)) {
                for (var i = 0, len1 = object1.length; i < len1; i++) {
                    for (var j = 0, len2 = object2.length; j < len2; j++) {
                        this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, false);
                    }
                }
            } else {
                this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false);
            }
            return this._total > 0;
        },
        collideHandler: function(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (typeof object2 === "undefined" && (object1.type === Phaser.GROUP || object1.type === Phaser.EMITTER)) {
                this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);
                return;
            }
            if (object1 && object2 && object1.exists && object2.exists) {
                if (object1.type == Phaser.SPRITE || object1.type == Phaser.TILESPRITE) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.TILEMAPLAYER) {
                        this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);
                    }
                } else if (object1.type == Phaser.GROUP) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.TILEMAPLAYER) {
                        this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);
                    }
                } else if (object1.type == Phaser.TILEMAPLAYER) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);
                    }
                } else if (object1.type == Phaser.EMITTER) {
                    if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE) {
                        this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER) {
                        this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else if (object2.type == Phaser.TILEMAPLAYER) {
                        this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);
                    }
                }
            }
        },
        collideSpriteVsSprite: function(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (!sprite1.body || !sprite2.body) {
                return false;
            }
            if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {
                if (collideCallback) {
                    collideCallback.call(callbackContext, sprite1, sprite2);
                }
                this._total++;
            }
            return true;
        },
        collideSpriteVsGroup: function(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group.length === 0 || !sprite.body) {
                return;
            }
            if (sprite.body.skipQuadTree || this.skipQuadTree) {
                for (var i = 0, len = group.children.length; i < len; i++) {
                    if (group.children[i] && group.children[i].exists) {
                        this.collideSpriteVsSprite(sprite, group.children[i], collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                }
            } else {
                this.quadTree.clear();
                this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
                this.quadTree.populate(group);
                this._potentials = this.quadTree.retrieve(sprite);
                for (var i = 0, len = this._potentials.length; i < len; i++) {
                    if (this.separate(sprite.body, this._potentials[i], processCallback, callbackContext, overlapOnly)) {
                        if (collideCallback) {
                            collideCallback.call(callbackContext, sprite, this._potentials[i].sprite);
                        }
                        this._total++;
                    }
                }
            }
        },
        collideGroupVsSelf: function(group, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group.length === 0) {
                return;
            }
            var len = group.children.length;
            for (var i = 0; i < len; i++) {
                for (var j = i + 1; j <= len; j++) {
                    if (group.children[i] && group.children[j] && group.children[i].exists && group.children[j].exists) {
                        this.collideSpriteVsSprite(group.children[i], group.children[j], collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                }
            }
        },
        collideGroupVsGroup: function(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {
            if (group1.length === 0 || group2.length === 0) {
                return;
            }
            for (var i = 0, len = group1.children.length; i < len; i++) {
                if (group1.children[i].exists) {
                    if (group1.children[i].type === Phaser.GROUP) {
                        this.collideGroupVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
                    } else {
                        this.collideSpriteVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);
                    }
                }
            }
        },
        collideSpriteVsTilemapLayer: function(sprite, tilemapLayer, collideCallback, processCallback, callbackContext) {
            if (!sprite.body) {
                return;
            }
            this._mapData = tilemapLayer.getTiles(sprite.body.position.x - sprite.body.tilePadding.x, sprite.body.position.y - sprite.body.tilePadding.y, sprite.body.width + sprite.body.tilePadding.x, sprite.body.height + sprite.body.tilePadding.y, false, false);
            if (this._mapData.length === 0) {
                return;
            }
            for (var i = 0; i < this._mapData.length; i++) {
                if (processCallback) {
                    if (processCallback.call(callbackContext, sprite, this._mapData[i])) {
                        if (this.separateTile(i, sprite.body, this._mapData[i])) {
                            this._total++;
                            if (collideCallback) {
                                collideCallback.call(callbackContext, sprite, this._mapData[i]);
                            }
                        }
                    }
                } else {
                    if (this.separateTile(i, sprite.body, this._mapData[i])) {
                        this._total++;
                        if (collideCallback) {
                            collideCallback.call(callbackContext, sprite, this._mapData[i]);
                        }
                    }
                }
            }
        },
        collideGroupVsTilemapLayer: function(group, tilemapLayer, collideCallback, processCallback, callbackContext) {
            if (group.length === 0) {
                return;
            }
            for (var i = 0, len = group.children.length; i < len; i++) {
                if (group.children[i].exists) {
                    this.collideSpriteVsTilemapLayer(group.children[i], tilemapLayer, collideCallback, processCallback, callbackContext);
                }
            }
        },
        separate: function(body1, body2, processCallback, callbackContext, overlapOnly) {
            if (!body1.enable || !body2.enable || !this.intersects(body1, body2)) {
                return false;
            }
            if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false) {
                return false;
            }
            if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {
                this._result = this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly);
            } else {
                this._result = this.separateY(body1, body2, overlapOnly) || this.separateX(body1, body2, overlapOnly);
            }
            if (overlapOnly) {
                return true;
            } else {
                return this._result;
            }
        },
        intersects: function(body1, body2) {
            if (body1.right <= body2.position.x) {
                return false;
            }
            if (body1.bottom <= body2.position.y) {
                return false;
            }
            if (body1.position.x >= body2.right) {
                return false;
            }
            if (body1.position.y >= body2.bottom) {
                return false;
            }
            return true;
        },
        separateX: function(body1, body2, overlapOnly) {
            if (body1.immovable && body2.immovable) {
                return false;
            }
            this._overlap = 0;
            if (this.intersects(body1, body2)) {
                this._maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS;
                if (body1.deltaX() === 0 && body2.deltaX() === 0) {
                    body1.embedded = true;
                    body2.embedded = true;
                } else if (body1.deltaX() > body2.deltaX()) {
                    this._overlap = body1.right - body2.x;
                    if (this._overlap > this._maxOverlap || body1.checkCollision.right === false || body2.checkCollision.left === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.right = true;
                        body2.touching.none = false;
                        body2.touching.left = true;
                    }
                } else if (body1.deltaX() < body2.deltaX()) {
                    this._overlap = body1.x - body2.width - body2.x;
                    if (-this._overlap > this._maxOverlap || body1.checkCollision.left === false || body2.checkCollision.right === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.left = true;
                        body2.touching.none = false;
                        body2.touching.right = true;
                    }
                }
                body1.overlapX = this._overlap;
                body2.overlapX = this._overlap;
                if (this._overlap !== 0) {
                    if (overlapOnly || body1.customSeparateX || body2.customSeparateX) {
                        return true;
                    }
                    this._velocity1 = body1.velocity.x;
                    this._velocity2 = body2.velocity.x;
                    if (!body1.immovable && !body2.immovable) {
                        this._overlap *= .5;
                        body1.x = body1.x - this._overlap;
                        body2.x += this._overlap;
                        this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1);
                        this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        body1.velocity.x = this._average + this._newVelocity1 * body1.bounce.x;
                        body2.velocity.x = this._average + this._newVelocity2 * body2.bounce.x;
                    } else if (!body1.immovable) {
                        body1.x = body1.x - this._overlap;
                        body1.velocity.x = this._velocity2 - this._velocity1 * body1.bounce.x;
                    } else if (!body2.immovable) {
                        body2.x += this._overlap;
                        body2.velocity.x = this._velocity1 - this._velocity2 * body2.bounce.x;
                    }
                    return true;
                }
            }
            return false;
        },
        separateY: function(body1, body2, overlapOnly) {
            if (body1.immovable && body2.immovable) {
                return false;
            }
            this._overlap = 0;
            if (this.intersects(body1, body2)) {
                this._maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS;
                if (body1.deltaY() === 0 && body2.deltaY() === 0) {
                    body1.embedded = true;
                    body2.embedded = true;
                } else if (body1.deltaY() > body2.deltaY()) {
                    this._overlap = body1.bottom - body2.y;
                    if (this._overlap > this._maxOverlap || body1.checkCollision.down === false || body2.checkCollision.up === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.down = true;
                        body2.touching.none = false;
                        body2.touching.up = true;
                    }
                } else if (body1.deltaY() < body2.deltaY()) {
                    this._overlap = body1.y - body2.bottom;
                    if (-this._overlap > this._maxOverlap || body1.checkCollision.up === false || body2.checkCollision.down === false) {
                        this._overlap = 0;
                    } else {
                        body1.touching.none = false;
                        body1.touching.up = true;
                        body2.touching.none = false;
                        body2.touching.down = true;
                    }
                }
                body1.overlapY = this._overlap;
                body2.overlapY = this._overlap;
                if (this._overlap !== 0) {
                    if (overlapOnly || body1.customSeparateY || body2.customSeparateY) {
                        return true;
                    }
                    this._velocity1 = body1.velocity.y;
                    this._velocity2 = body2.velocity.y;
                    if (!body1.immovable && !body2.immovable) {
                        this._overlap *= .5;
                        body1.y = body1.y - this._overlap;
                        body2.y += this._overlap;
                        this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1);
                        this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * .5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        body1.velocity.y = this._average + this._newVelocity1 * body1.bounce.y;
                        body2.velocity.y = this._average + this._newVelocity2 * body2.bounce.y;
                    } else if (!body1.immovable) {
                        body1.y = body1.y - this._overlap;
                        body1.velocity.y = this._velocity2 - this._velocity1 * body1.bounce.y;
                        if (body2.moves) {
                            body1.x += body2.x - body2.prev.x;
                        }
                    } else if (!body2.immovable) {
                        body2.y += this._overlap;
                        body2.velocity.y = this._velocity1 - this._velocity2 * body2.bounce.y;
                        if (body1.moves) {
                            body2.x += body1.x - body1.prev.x;
                        }
                    }
                    return true;
                }
            }
            return false;
        },
        separateTile: function(i, body, tile) {
            if (!body.enable || !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                return false;
            }
            if (tile.collisionCallback && !tile.collisionCallback.call(tile.collisionCallbackContext, body.sprite, tile)) {
                return false;
            } else if (tile.layer.callbacks[tile.index] && !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, body.sprite, tile)) {
                return false;
            }
            if (!tile.faceLeft && !tile.faceRight && !tile.faceTop && !tile.faceBottom) {
                return false;
            }
            var ox = 0;
            var oy = 0;
            var minX = 0;
            var minY = 1;
            if (body.deltaAbsX() > body.deltaAbsY()) {
                minX = -1;
            } else if (body.deltaAbsX() < body.deltaAbsY()) {
                minY = -1;
            }
            if (body.deltaX() !== 0 && body.deltaY() !== 0 && (tile.faceLeft || tile.faceRight) && (tile.faceTop || tile.faceBottom)) {
                minX = Math.min(Math.abs(body.position.x - tile.right), Math.abs(body.right - tile.left));
                minY = Math.min(Math.abs(body.position.y - tile.bottom), Math.abs(body.bottom - tile.top));
            }
            if (minX < minY) {
                if (tile.faceLeft || tile.faceRight) {
                    ox = this.tileCheckX(body, tile);
                    if (ox !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                        return true;
                    }
                }
                if (tile.faceTop || tile.faceBottom) {
                    oy = this.tileCheckY(body, tile);
                }
            } else {
                if (tile.faceTop || tile.faceBottom) {
                    oy = this.tileCheckY(body, tile);
                    if (oy !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom)) {
                        return true;
                    }
                }
                if (tile.faceLeft || tile.faceRight) {
                    ox = this.tileCheckX(body, tile);
                }
            }
            return ox !== 0 || oy !== 0;
        },
        tileCheckX: function(body, tile) {
            var ox = 0;
            if (body.deltaX() < 0 && !body.blocked.left && tile.collideRight && body.checkCollision.left) {
                if (tile.faceRight && body.x < tile.right) {
                    ox = body.x - tile.right;
                    if (ox < -this.TILE_BIAS) {
                        ox = 0;
                    }
                }
            } else if (body.deltaX() > 0 && !body.blocked.right && tile.collideLeft && body.checkCollision.right) {
                if (tile.faceLeft && body.right > tile.left) {
                    ox = body.right - tile.left;
                    if (ox > this.TILE_BIAS) {
                        ox = 0;
                    }
                }
            }
            if (ox !== 0) {
                this.processTileSeparationX(body, ox);
            }
            return ox;
        },
        tileCheckY: function(body, tile) {
            var oy = 0;
            if (body.deltaY() < 0 && !body.blocked.up && tile.collideDown && body.checkCollision.up) {
                if (tile.faceBottom && body.y < tile.bottom) {
                    oy = body.y - tile.bottom;
                    if (oy < -this.TILE_BIAS) {
                        oy = 0;
                    }
                }
            } else if (body.deltaY() > 0 && !body.blocked.down && tile.collideUp && body.checkCollision.down) {
                if (tile.faceTop && body.bottom > tile.top) {
                    oy = body.bottom - tile.top;
                    if (oy > this.TILE_BIAS) {
                        oy = 0;
                    }
                }
            }
            if (oy !== 0) {
                this.processTileSeparationY(body, oy);
            }
            return oy;
        },
        processTileSeparationX: function(body, x) {
            if (x < 0) {
                body.blocked.left = true;
            } else if (x > 0) {
                body.blocked.right = true;
            }
            body.position.x -= x;
            if (body.bounce.x === 0) {
                body.velocity.x = 0;
            } else {
                body.velocity.x = -body.velocity.x * body.bounce.x;
            }
        },
        processTileSeparationY: function(body, y) {
            if (y < 0) {
                body.blocked.up = true;
            } else if (y > 0) {
                body.blocked.down = true;
            }
            body.position.y -= y;
            if (body.bounce.y === 0) {
                body.velocity.y = 0;
            } else {
                body.velocity.y = -body.velocity.y * body.bounce.y;
            }
        },
        getObjectsUnderPointer: function(pointer, group, callback, callbackContext) {
            if (group.length === 0 || !pointer.exists) {
                return;
            }
            this.quadTree.clear();
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
            this.quadTree.populate(group);
            var rect = new Phaser.Rectangle(pointer.x, pointer.y, 1, 1);
            var output = [];
            this._potentials = this.quadTree.retrieve(rect);
            for (var i = 0, len = this._potentials.length; i < len; i++) {
                if (this._potentials[i].hitTest(pointer.x, pointer.y)) {
                    if (callback) {
                        callback.call(callbackContext, pointer, this._potentials[i].sprite);
                    }
                    output.push(this._potentials[i].sprite);
                }
            }
            return output;
        },
        moveToObject: function(displayObject, destination, speed, maxTime) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof maxTime === "undefined") {
                maxTime = 0;
            }
            this._angle = Math.atan2(destination.y - displayObject.y, destination.x - displayObject.x);
            if (maxTime > 0) {
                speed = this.distanceBetween(displayObject, destination) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(this._angle) * speed;
            displayObject.body.velocity.y = Math.sin(this._angle) * speed;
            return this._angle;
        },
        moveToPointer: function(displayObject, speed, pointer, maxTime) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            pointer = pointer || this.game.input.activePointer;
            if (typeof maxTime === "undefined") {
                maxTime = 0;
            }
            this._angle = this.angleToPointer(displayObject, pointer);
            if (maxTime > 0) {
                speed = this.distanceToPointer(displayObject, pointer) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(this._angle) * speed;
            displayObject.body.velocity.y = Math.sin(this._angle) * speed;
            return this._angle;
        },
        moveToXY: function(displayObject, x, y, speed, maxTime) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof maxTime === "undefined") {
                maxTime = 0;
            }
            this._angle = Math.atan2(y - displayObject.y, x - displayObject.x);
            if (maxTime > 0) {
                speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1e3);
            }
            displayObject.body.velocity.x = Math.cos(this._angle) * speed;
            displayObject.body.velocity.y = Math.sin(this._angle) * speed;
            return this._angle;
        },
        velocityFromAngle: function(angle, speed, point) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(this.game.math.degToRad(angle)) * speed, Math.sin(this.game.math.degToRad(angle)) * speed);
        },
        velocityFromRotation: function(rotation, speed, point) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
        },
        accelerationFromRotation: function(rotation, speed, point) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            point = point || new Phaser.Point();
            return point.setTo(Math.cos(rotation) * speed, Math.sin(rotation) * speed);
        },
        accelerateToObject: function(displayObject, destination, speed, xSpeedMax, ySpeedMax) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof xSpeedMax === "undefined") {
                xSpeedMax = 1e3;
            }
            if (typeof ySpeedMax === "undefined") {
                ySpeedMax = 1e3;
            }
            this._angle = this.angleBetween(displayObject, destination);
            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return this._angle;
        },
        accelerateToPointer: function(displayObject, pointer, speed, xSpeedMax, ySpeedMax) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof pointer === "undefined") {
                pointer = this.game.input.activePointer;
            }
            if (typeof xSpeedMax === "undefined") {
                xSpeedMax = 1e3;
            }
            if (typeof ySpeedMax === "undefined") {
                ySpeedMax = 1e3;
            }
            this._angle = this.angleToPointer(displayObject, pointer);
            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return this._angle;
        },
        accelerateToXY: function(displayObject, x, y, speed, xSpeedMax, ySpeedMax) {
            if (typeof speed === "undefined") {
                speed = 60;
            }
            if (typeof xSpeedMax === "undefined") {
                xSpeedMax = 1e3;
            }
            if (typeof ySpeedMax === "undefined") {
                ySpeedMax = 1e3;
            }
            this._angle = this.angleToXY(displayObject, x, y);
            displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);
            displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);
            return this._angle;
        },
        distanceBetween: function(source, target) {
            this._dx = source.x - target.x;
            this._dy = source.y - target.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy);
        },
        distanceToXY: function(displayObject, x, y) {
            this._dx = displayObject.x - x;
            this._dy = displayObject.y - y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy);
        },
        distanceToPointer: function(displayObject, pointer) {
            pointer = pointer || this.game.input.activePointer;
            this._dx = displayObject.x - pointer.x;
            this._dy = displayObject.y - pointer.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy);
        },
        angleBetween: function(source, target) {
            this._dx = target.x - source.x;
            this._dy = target.y - source.y;
            return Math.atan2(this._dy, this._dx);
        },
        angleToXY: function(displayObject, x, y) {
            this._dx = x - displayObject.x;
            this._dy = y - displayObject.y;
            return Math.atan2(this._dy, this._dx);
        },
        angleToPointer: function(displayObject, pointer) {
            pointer = pointer || this.game.input.activePointer;
            this._dx = pointer.worldX - displayObject.x;
            this._dy = pointer.worldY - displayObject.y;
            return Math.atan2(this._dy, this._dx);
        }
    };
    Phaser.Physics.Arcade.Body = function(sprite) {
        this.sprite = sprite;
        this.game = sprite.game;
        this.type = Phaser.Physics.ARCADE;
        this.enable = true;
        this.offset = new Phaser.Point();
        this.position = new Phaser.Point(sprite.x, sprite.y);
        this.prev = new Phaser.Point(this.position.x, this.position.y);
        this.allowRotation = true;
        this.rotation = sprite.rotation;
        this.preRotation = sprite.rotation;
        this.sourceWidth = sprite.texture.frame.width;
        this.sourceHeight = sprite.texture.frame.height;
        this.width = sprite.width;
        this.height = sprite.height;
        this.halfWidth = Math.abs(sprite.width / 2);
        this.halfHeight = Math.abs(sprite.height / 2);
        this.center = new Phaser.Point(sprite.x + this.halfWidth, sprite.y + this.halfHeight);
        this.velocity = new Phaser.Point();
        this.newVelocity = new Phaser.Point(0, 0);
        this.deltaMax = new Phaser.Point(0, 0);
        this.acceleration = new Phaser.Point();
        this.drag = new Phaser.Point();
        this.allowGravity = true;
        this.gravity = new Phaser.Point(0, 0);
        this.bounce = new Phaser.Point();
        this.maxVelocity = new Phaser.Point(1e4, 1e4);
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.angularDrag = 0;
        this.maxAngular = 1e3;
        this.mass = 1;
        this.angle = 0;
        this.speed = 0;
        this.facing = Phaser.NONE;
        this.immovable = false;
        this.moves = true;
        this.customSeparateX = false;
        this.customSeparateY = false;
        this.overlapX = 0;
        this.overlapY = 0;
        this.embedded = false;
        this.collideWorldBounds = false;
        this.checkCollision = {
            none: false,
            any: true,
            up: true,
            down: true,
            left: true,
            right: true
        };
        this.touching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.wasTouching = {
            none: true,
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.blocked = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        this.tilePadding = new Phaser.Point();
        this.phase = 0;
        this.skipQuadTree = false;
        this._reset = true;
        this._sx = sprite.scale.x;
        this._sy = sprite.scale.y;
        this._dx = 0;
        this._dy = 0;
    };
    Phaser.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            var asx = Math.abs(this.sprite.scale.x);
            var asy = Math.abs(this.sprite.scale.y);
            if (asx !== this._sx || asy !== this._sy) {
                this.width = this.sourceWidth * asx;
                this.height = this.sourceHeight * asy;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this._sx = asx;
                this._sy = asy;
                this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
                this._reset = true;
            }
        },
        preUpdate: function() {
            if (!this.enable) {
                return;
            }
            this.phase = 1;
            this.wasTouching.none = this.touching.none;
            this.wasTouching.up = this.touching.up;
            this.wasTouching.down = this.touching.down;
            this.wasTouching.left = this.touching.left;
            this.wasTouching.right = this.touching.right;
            this.touching.none = true;
            this.touching.up = false;
            this.touching.down = false;
            this.touching.left = false;
            this.touching.right = false;
            this.blocked.up = false;
            this.blocked.down = false;
            this.blocked.left = false;
            this.blocked.right = false;
            this.embedded = false;
            this.updateBounds();
            this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.height + this.offset.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            if (this._reset || this.sprite._cache[4] === 1) {
                this.prev.x = this.position.x;
                this.prev.y = this.position.y;
            }
            if (this.moves) {
                this.game.physics.arcade.updateMotion(this);
                this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed);
                this.position.x += this.newVelocity.x;
                this.position.y += this.newVelocity.y;
                if (this.position.x !== this.prev.x || this.position.y !== this.prev.y) {
                    this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                }
                if (this.collideWorldBounds) {
                    this.checkWorldBounds();
                }
            }
            this._dx = this.deltaX();
            this._dy = this.deltaY();
            this._reset = false;
        },
        postUpdate: function() {
            if (!this.enable) {
                return;
            }
            if (this.phase === 2) {
                return;
            }
            this.phase = 2;
            if (this.deltaX() < 0) {
                this.facing = Phaser.LEFT;
            } else if (this.deltaX() > 0) {
                this.facing = Phaser.RIGHT;
            }
            if (this.deltaY() < 0) {
                this.facing = Phaser.UP;
            } else if (this.deltaY() > 0) {
                this.facing = Phaser.DOWN;
            }
            if (this.moves) {
                this._dx = this.deltaX();
                this._dy = this.deltaY();
                if (this.deltaMax.x !== 0 && this._dx !== 0) {
                    if (this._dx < 0 && this._dx < -this.deltaMax.x) {
                        this._dx = -this.deltaMax.x;
                    } else if (this._dx > 0 && this._dx > this.deltaMax.x) {
                        this._dx = this.deltaMax.x;
                    }
                }
                if (this.deltaMax.y !== 0 && this._dy !== 0) {
                    if (this._dy < 0 && this._dy < -this.deltaMax.y) {
                        this._dy = -this.deltaMax.y;
                    } else if (this._dy > 0 && this._dy > this.deltaMax.y) {
                        this._dy = this.deltaMax.y;
                    }
                }
                this.sprite.x += this._dx;
                this.sprite.y += this._dy;
            }
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
            if (this.allowRotation) {
                this.sprite.angle += this.deltaZ();
            }
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
        },
        destroy: function() {
            this.sprite.body = null;
            this.sprite = null;
        },
        checkWorldBounds: function() {
            if (this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left) {
                this.position.x = this.game.physics.arcade.bounds.x;
                this.velocity.x *= -this.bounce.x;
                this.blocked.left = true;
            } else if (this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right) {
                this.position.x = this.game.physics.arcade.bounds.right - this.width;
                this.velocity.x *= -this.bounce.x;
                this.blocked.right = true;
            }
            if (this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up) {
                this.position.y = this.game.physics.arcade.bounds.y;
                this.velocity.y *= -this.bounce.y;
                this.blocked.up = true;
            } else if (this.bottom > this.game.physics.arcade.bounds.bottom && this.game.physics.arcade.checkCollision.down) {
                this.position.y = this.game.physics.arcade.bounds.bottom - this.height;
                this.velocity.y *= -this.bounce.y;
                this.blocked.down = true;
            }
        },
        setSize: function(width, height, offsetX, offsetY) {
            if (typeof offsetX === "undefined") {
                offsetX = this.offset.x;
            }
            if (typeof offsetY === "undefined") {
                offsetY = this.offset.y;
            }
            this.sourceWidth = width;
            this.sourceHeight = height;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.offset.setTo(offsetX, offsetY);
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        reset: function(x, y) {
            this.velocity.set(0);
            this.acceleration.set(0);
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.position.x = x - this.sprite.anchor.x * this.width + this.offset.x;
            this.position.y = y - this.sprite.anchor.y * this.height + this.offset.y;
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
            this.rotation = this.sprite.angle;
            this.preRotation = this.rotation;
            this._sx = this.sprite.scale.x;
            this._sy = this.sprite.scale.y;
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        hitTest: function(x, y) {
            return Phaser.Rectangle.contains(this, x, y);
        },
        onFloor: function() {
            return this.blocked.down;
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right;
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
        },
        deltaX: function() {
            return this.position.x - this.prev.x;
        },
        deltaY: function() {
            return this.position.y - this.prev.y;
        },
        deltaZ: function() {
            return this.rotation - this.preRotation;
        }
    };
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x;
        },
        set: function(value) {
            this.position.x = value;
        }
    });
    Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y;
        },
        set: function(value) {
            this.position.y = value;
        }
    });
    Phaser.Physics.Arcade.Body.render = function(context, body, color, filled) {
        if (typeof filled === "undefined") {
            filled = true;
        }
        color = color || "rgba(0,255,0,0.4)";
        if (filled) {
            context.fillStyle = color;
            context.fillRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);
        } else {
            context.strokeStyle = color;
            context.strokeRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);
        }
    };
    Phaser.Physics.Arcade.Body.renderBodyInfo = function(debug, body) {
        debug.line("x: " + body.x.toFixed(2), "y: " + body.y.toFixed(2), "width: " + body.width, "height: " + body.height);
        debug.line("velocity x: " + body.velocity.x.toFixed(2), "y: " + body.velocity.y.toFixed(2), "deltaX: " + body._dx.toFixed(2), "deltaY: " + body._dy.toFixed(2));
        debug.line("acceleration x: " + body.acceleration.x.toFixed(2), "y: " + body.acceleration.y.toFixed(2), "speed: " + body.speed.toFixed(2), "angle: " + body.angle.toFixed(2));
        debug.line("gravity x: " + body.gravity.x, "y: " + body.gravity.y, "bounce x: " + body.bounce.x.toFixed(2), "y: " + body.bounce.y.toFixed(2));
        debug.line("touching left: " + body.touching.left, "right: " + body.touching.right, "up: " + body.touching.up, "down: " + body.touching.down);
        debug.line("blocked left: " + body.blocked.left, "right: " + body.blocked.right, "up: " + body.blocked.up, "down: " + body.blocked.down);
    };
    Phaser.Physics.Arcade.Body.prototype.constructor = Phaser.Physics.Arcade.Body;
    Phaser.Particles = function(game) {
        this.game = game;
        this.emitters = {};
        this.ID = 0;
    };
    Phaser.Particles.prototype = {
        add: function(emitter) {
            this.emitters[emitter.name] = emitter;
            return emitter;
        },
        remove: function(emitter) {
            delete this.emitters[emitter.name];
        },
        update: function() {
            for (var key in this.emitters) {
                if (this.emitters[key].exists) {
                    this.emitters[key].update();
                }
            }
        }
    };
    Phaser.Particles.prototype.constructor = Phaser.Particles;
    Phaser.Particles.Arcade = {};
    Phaser.Particles.Arcade.Emitter = function(game, x, y, maxParticles) {
        this.maxParticles = maxParticles || 50;
        Phaser.Group.call(this, game);
        this.name = "emitter" + this.game.particles.ID++;
        this.type = Phaser.EMITTER;
        this.area = new Phaser.Rectangle(x, y, 1, 1);
        this.minParticleSpeed = new Phaser.Point(-100, -100);
        this.maxParticleSpeed = new Phaser.Point(100, 100);
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this.scaleData = null;
        this.minRotation = -360;
        this.maxRotation = 360;
        this.minParticleAlpha = 1;
        this.maxParticleAlpha = 1;
        this.alphaData = null;
        this.gravity = 100;
        this.particleClass = Phaser.Particle;
        this.particleDrag = new Phaser.Point();
        this.angularDrag = 0;
        this.frequency = 100;
        this.lifespan = 2e3;
        this.bounce = new Phaser.Point();
        this.on = false;
        this.particleAnchor = new Phaser.Point(.5, .5);
        this.blendMode = Phaser.blendModes.NORMAL;
        this.emitX = x;
        this.emitY = y;
        this.autoScale = false;
        this.autoAlpha = false;
        this.particleBringToTop = false;
        this.particleSendToBack = false;
        this._minParticleScale = new Phaser.Point(1, 1);
        this._maxParticleScale = new Phaser.Point(1, 1);
        this._quantity = 0;
        this._timer = 0;
        this._counter = 0;
        this._explode = true;
        this._frames = null;
    };
    Phaser.Particles.Arcade.Emitter.prototype = Object.create(Phaser.Group.prototype);
    Phaser.Particles.Arcade.Emitter.prototype.constructor = Phaser.Particles.Arcade.Emitter;
    Phaser.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.on) {
            if (this._explode) {
                this._counter = 0;
                do {
                    this.emitParticle();
                    this._counter++;
                } while (this._counter < this._quantity);
                this.on = false;
            } else {
                if (this.game.time.now >= this._timer) {
                    this.emitParticle();
                    this._counter++;
                    if (this._quantity > 0) {
                        if (this._counter >= this._quantity) {
                            this.on = false;
                        }
                    }
                    this._timer = this.game.time.now + this.frequency;
                }
            }
        }
        var i = this.children.length;
        while (i--) {
            if (this.children[i].exists) {
                this.children[i].update();
            }
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.makeParticles = function(keys, frames, quantity, collide, collideWorldBounds) {
        if (typeof frames === "undefined") {
            frames = 0;
        }
        if (typeof quantity === "undefined") {
            quantity = this.maxParticles;
        }
        if (typeof collide === "undefined") {
            collide = false;
        }
        if (typeof collideWorldBounds === "undefined") {
            collideWorldBounds = false;
        }
        var particle;
        var i = 0;
        var rndKey = keys;
        var rndFrame = frames;
        this._frames = frames;
        while (i < quantity) {
            if (Array.isArray(keys)) {
                rndKey = this.game.rnd.pick(keys);
            }
            if (Array.isArray(frames)) {
                rndFrame = this.game.rnd.pick(frames);
            }
            particle = new this.particleClass(this.game, 0, 0, rndKey, rndFrame);
            this.game.physics.arcade.enable(particle, false);
            if (collide) {
                particle.body.checkCollision.any = true;
                particle.body.checkCollision.none = false;
            } else {
                particle.body.checkCollision.none = true;
            }
            particle.body.collideWorldBounds = collideWorldBounds;
            particle.exists = false;
            particle.visible = false;
            particle.anchor.copyFrom(this.particleAnchor);
            this.add(particle);
            i++;
        }
        return this;
    };
    Phaser.Particles.Arcade.Emitter.prototype.kill = function() {
        this.on = false;
        this.alive = false;
        this.exists = false;
    };
    Phaser.Particles.Arcade.Emitter.prototype.revive = function() {
        this.alive = true;
        this.exists = true;
    };
    Phaser.Particles.Arcade.Emitter.prototype.explode = function(lifespan, quantity) {
        this.start(true, lifespan, 0, quantity, false);
    };
    Phaser.Particles.Arcade.Emitter.prototype.flow = function(lifespan, frequency, quantity) {
        this.start(false, lifespan, frequency, quantity, true);
    };
    Phaser.Particles.Arcade.Emitter.prototype.start = function(explode, lifespan, frequency, quantity, forceQuantity) {
        if (typeof explode === "undefined") {
            explode = true;
        }
        if (typeof lifespan === "undefined") {
            lifespan = 0;
        }
        if (typeof frequency === "undefined" || frequency === null) {
            frequency = 250;
        }
        if (typeof quantity === "undefined") {
            quantity = 0;
        }
        if (typeof forceQuantity === "undefined") {
            forceQuantity = false;
        }
        this.revive();
        this.visible = true;
        this.on = true;
        this._explode = explode;
        this.lifespan = lifespan;
        this.frequency = frequency;
        if (explode || forceQuantity) {
            this._quantity = quantity;
        } else {
            this._quantity += quantity;
        }
        this._counter = 0;
        this._timer = this.game.time.now + frequency;
    };
    Phaser.Particles.Arcade.Emitter.prototype.emitParticle = function() {
        var particle = this.getFirstExists(false);
        if (particle === null) {
            return;
        }
        if (this.width > 1 || this.height > 1) {
            particle.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom));
        } else {
            particle.reset(this.emitX, this.emitY);
        }
        particle.angle = 0;
        particle.lifespan = this.lifespan;
        if (this.particleBringToTop) {
            this.bringToTop(particle);
        } else if (this.particleSendToBack) {
            this.sendToBack(particle);
        }
        if (this.autoScale) {
            particle.setScaleData(this.scaleData);
        } else if (this.minParticleScale !== 1 || this.maxParticleScale !== 1) {
            particle.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale));
        } else if (this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y) {
            particle.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y));
        }
        if (Array.isArray(this._frames === "object")) {
            particle.frame = this.game.rnd.pick(this._frames);
        } else {
            particle.frame = this._frames;
        }
        if (this.autoAlpha) {
            particle.setAlphaData(this.alphaData);
        } else {
            particle.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha);
        }
        particle.blendMode = this.blendMode;
        particle.body.updateBounds();
        particle.body.bounce.setTo(this.bounce.x, this.bounce.y);
        particle.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x);
        particle.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y);
        particle.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation);
        particle.body.gravity.y = this.gravity;
        particle.body.drag.x = this.particleDrag.x;
        particle.body.drag.y = this.particleDrag.y;
        particle.body.angularDrag = this.angularDrag;
        particle.onEmit();
    };
    Phaser.Particles.Arcade.Emitter.prototype.setSize = function(width, height) {
        this.area.width = width;
        this.area.height = height;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setXSpeed = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minParticleSpeed.x = min;
        this.maxParticleSpeed.x = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setYSpeed = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minParticleSpeed.y = min;
        this.maxParticleSpeed.y = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setRotation = function(min, max) {
        min = min || 0;
        max = max || 0;
        this.minRotation = min;
        this.maxRotation = max;
    };
    Phaser.Particles.Arcade.Emitter.prototype.setAlpha = function(min, max, rate, ease, yoyo) {
        if (typeof min === "undefined") {
            min = 1;
        }
        if (typeof max === "undefined") {
            max = 1;
        }
        if (typeof rate === "undefined") {
            rate = 0;
        }
        if (typeof ease === "undefined") {
            ease = Phaser.Easing.Linear.None;
        }
        if (typeof yoyo === "undefined") {
            yoyo = false;
        }
        this.minParticleAlpha = min;
        this.maxParticleAlpha = max;
        this.autoAlpha = false;
        if (rate > 0 && min !== max) {
            var tweenData = {
                v: min
            };
            var tween = this.game.make.tween(tweenData).to({
                v: max
            }, rate, ease);
            tween.yoyo(yoyo);
            this.alphaData = tween.generateData(60);
            this.alphaData.reverse();
            this.autoAlpha = true;
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.setScale = function(minX, maxX, minY, maxY, rate, ease, yoyo) {
        if (typeof minX === "undefined") {
            minX = 1;
        }
        if (typeof maxX === "undefined") {
            maxX = 1;
        }
        if (typeof minY === "undefined") {
            minY = 1;
        }
        if (typeof maxY === "undefined") {
            maxY = 1;
        }
        if (typeof rate === "undefined") {
            rate = 0;
        }
        if (typeof ease === "undefined") {
            ease = Phaser.Easing.Linear.None;
        }
        if (typeof yoyo === "undefined") {
            yoyo = false;
        }
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this._minParticleScale.set(minX, minY);
        this._maxParticleScale.set(maxX, maxY);
        this.autoScale = false;
        if (rate > 0 && minX !== maxX || minY !== maxY) {
            var tweenData = {
                x: minX,
                y: minY
            };
            var tween = this.game.make.tween(tweenData).to({
                x: maxX,
                y: maxY
            }, rate, ease);
            tween.yoyo(yoyo);
            this.scaleData = tween.generateData(60);
            this.scaleData.reverse();
            this.autoScale = true;
        }
    };
    Phaser.Particles.Arcade.Emitter.prototype.at = function(object) {
        if (object.center) {
            this.emitX = object.center.x;
            this.emitY = object.center.y;
        } else {
            this.emitX = object.world.x + object.anchor.x * object.width;
            this.emitY = object.world.y + object.anchor.y * object.height;
        }
    };
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "width", {
        get: function() {
            return this.area.width;
        },
        set: function(value) {
            this.area.width = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "height", {
        get: function() {
            return this.area.height;
        },
        set: function(value) {
            this.area.height = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX;
        },
        set: function(value) {
            this.emitX = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY;
        },
        set: function(value) {
            this.emitY = value;
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.area.width / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.area.width / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.area.height / 2);
        }
    });
    Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.area.height / 2);
        }
    });
    Phaser.Tile = function(layer, index, x, y, width, height) {
        this.layer = layer;
        this.index = index;
        this.x = x;
        this.y = y;
        this.worldX = x * width;
        this.worldY = y * height;
        this.width = width;
        this.height = height;
        this.centerX = Math.abs(width / 2);
        this.centerY = Math.abs(height / 2);
        this.alpha = 1;
        this.properties = {};
        this.scanned = false;
        this.faceTop = false;
        this.faceBottom = false;
        this.faceLeft = false;
        this.faceRight = false;
        this.collideLeft = false;
        this.collideRight = false;
        this.collideUp = false;
        this.collideDown = false;
        this.collisionCallback = null;
        this.collisionCallbackContext = this;
    };
    Phaser.Tile.prototype = {
        containsPoint: function(x, y) {
            return !(x < this.worldX || y < this.worldY || x > this.right || y > this.bottom);
        },
        intersects: function(x, y, right, bottom) {
            if (right <= this.worldX) {
                return false;
            }
            if (bottom <= this.worldY) {
                return false;
            }
            if (x >= this.worldX + this.width) {
                return false;
            }
            if (y >= this.worldY + this.height) {
                return false;
            }
            return true;
        },
        setCollisionCallback: function(callback, context) {
            this.collisionCallback = callback;
            this.collisionCallbackContext = context;
        },
        destroy: function() {
            this.collisionCallback = null;
            this.collisionCallbackContext = null;
            this.properties = null;
        },
        setCollision: function(left, right, up, down) {
            this.collideLeft = left;
            this.collideRight = right;
            this.collideUp = up;
            this.collideDown = down;
            this.faceLeft = left;
            this.faceRight = right;
            this.faceTop = up;
            this.faceBottom = down;
        },
        resetCollision: function() {
            this.collideLeft = false;
            this.collideRight = false;
            this.collideUp = false;
            this.collideDown = false;
            this.faceTop = false;
            this.faceBottom = false;
            this.faceLeft = false;
            this.faceRight = false;
        },
        isInteresting: function(collides, faces) {
            if (collides && faces) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback;
            } else if (collides) {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
            } else if (faces) {
                return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;
            }
            return false;
        },
        copy: function(tile) {
            this.index = tile.index;
            this.alpha = tile.alpha;
            this.properties = tile.properties;
            this.collideUp = tile.collideUp;
            this.collideDown = tile.collideDown;
            this.collideLeft = tile.collideLeft;
            this.collideRight = tile.collideRight;
            this.collisionCallback = tile.collisionCallback;
            this.collisionCallbackContext = tile.collisionCallbackContext;
        }
    };
    Phaser.Tile.prototype.constructor = Phaser.Tile;
    Object.defineProperty(Phaser.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "left", {
        get: function() {
            return this.worldX;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "top", {
        get: function() {
            return this.worldY;
        }
    });
    Object.defineProperty(Phaser.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height;
        }
    });
    Phaser.Tilemap = function(game, key, tileWidth, tileHeight, width, height) {
        this.game = game;
        this.key = key;
        var data = Phaser.TilemapParser.parse(this.game, key, tileWidth, tileHeight, width, height);
        if (data === null) {
            return;
        }
        this.width = data.width;
        this.height = data.height;
        this.tileWidth = data.tileWidth;
        this.tileHeight = data.tileHeight;
        this.orientation = data.orientation;
        this.format = data.format;
        this.version = data.version;
        this.properties = data.properties;
        this.widthInPixels = data.widthInPixels;
        this.heightInPixels = data.heightInPixels;
        this.layers = data.layers;
        this.tilesets = data.tilesets;
        this.tiles = data.tiles;
        this.objects = data.objects;
        this.collideIndexes = [];
        this.collision = data.collision;
        this.images = data.images;
        this.currentLayer = 0;
        this.debugMap = [];
        this._results = [];
        this._tempA = 0;
        this._tempB = 0;
    };
    Phaser.Tilemap.CSV = 0;
    Phaser.Tilemap.TILED_JSON = 1;
    Phaser.Tilemap.NORTH = 0;
    Phaser.Tilemap.EAST = 1;
    Phaser.Tilemap.SOUTH = 2;
    Phaser.Tilemap.WEST = 3;
    Phaser.Tilemap.prototype = {
        create: function(name, width, height, tileWidth, tileHeight, group) {
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            this.width = width;
            this.height = height;
            this.setTileSize(tileWidth, tileHeight);
            this.layers.length = 0;
            return this.createBlankLayer(name, width, height, tileWidth, tileHeight, group);
        },
        setTileSize: function(tileWidth, tileHeight) {
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;
            this.widthInPixels = this.width * tileWidth;
            this.heightInPixels = this.height * tileHeight;
        },
        addTilesetImage: function(tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {
            if (typeof tileWidth === "undefined") {
                tileWidth = this.tileWidth;
            }
            if (typeof tileHeight === "undefined") {
                tileHeight = this.tileHeight;
            }
            if (typeof tileMargin === "undefined") {
                tileMargin = 0;
            }
            if (typeof tileSpacing === "undefined") {
                tileSpacing = 0;
            }
            if (typeof gid === "undefined") {
                gid = 0;
            }
            if (tileWidth === 0) {
                tileWidth = 32;
            }
            if (tileHeight === 0) {
                tileHeight = 32;
            }
            if (typeof key === "undefined") {
                if (typeof tileset === "string") {
                    key = tileset;
                    if (!this.game.cache.checkImageKey(key)) {
                        console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + key + '"');
                        return null;
                    }
                } else {
                    return null;
                }
            }
            if (typeof tileset === "string") {
                tileset = this.getTilesetIndex(tileset);
                if (tileset === null && this.format === Phaser.Tilemap.TILED_JSON) {
                    console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + key + '"');
                    return null;
                }
            }
            if (this.tilesets[tileset]) {
                this.tilesets[tileset].setImage(this.game.cache.getImage(key));
                return this.tilesets[tileset];
            } else {
                var newSet = new Phaser.Tileset(key, gid, tileWidth, tileHeight, tileMargin, tileSpacing, {});
                newSet.setImage(this.game.cache.getImage(key));
                this.tilesets.push(newSet);
                var i = this.tilesets.length - 1;
                var x = tileMargin;
                var y = tileMargin;
                var count = 0;
                var countX = 0;
                var countY = 0;
                for (var t = gid; t < gid + newSet.total; t++) {
                    this.tiles[t] = [ x, y, i ];
                    x += tileWidth + tileSpacing;
                    count++;
                    if (count === newSet.total) {
                        break;
                    }
                    countX++;
                    if (countX === newSet.columns) {
                        x = tileMargin;
                        y += tileHeight + tileSpacing;
                        countX = 0;
                        countY++;
                        if (countY === newSet.rows) {
                            break;
                        }
                    }
                }
                return newSet;
            }
            return null;
        },
        createFromObjects: function(name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) {
            if (typeof exists === "undefined") {
                exists = true;
            }
            if (typeof autoCull === "undefined") {
                autoCull = false;
            }
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            if (typeof CustomClass === "undefined") {
                CustomClass = Phaser.Sprite;
            }
            if (typeof adjustY === "undefined") {
                adjustY = true;
            }
            if (!this.objects[name]) {
                console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + name);
                return;
            }
            var sprite;
            for (var i = 0, len = this.objects[name].length; i < len; i++) {
                if (this.objects[name][i].gid === gid) {
                    sprite = new CustomClass(this.game, this.objects[name][i].x, this.objects[name][i].y, key, frame);
                    sprite.name = this.objects[name][i].name;
                    sprite.visible = this.objects[name][i].visible;
                    sprite.autoCull = autoCull;
                    sprite.exists = exists;
                    if (adjustY) {
                        sprite.y -= sprite.height;
                    }
                    group.add(sprite);
                    for (var property in this.objects[name][i].properties) {
                        group.set(sprite, property, this.objects[name][i].properties[property], false, false, 0, true);
                    }
                }
            }
        },
        createLayer: function(layer, width, height, group) {
            if (typeof width === "undefined") {
                width = this.game.width;
            }
            if (typeof height === "undefined") {
                height = this.game.height;
            }
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            var index = layer;
            if (typeof layer === "string") {
                index = this.getLayerIndex(layer);
            }
            if (index === null || index > this.layers.length) {
                console.warn("Tilemap.createLayer: Invalid layer ID given: " + index);
                return;
            }
            return group.add(new Phaser.TilemapLayer(this.game, this, index, width, height));
        },
        createBlankLayer: function(name, width, height, tileWidth, tileHeight, group) {
            if (typeof group === "undefined") {
                group = this.game.world;
            }
            if (this.getLayerIndex(name) !== null) {
                console.warn("Tilemap.createBlankLayer: Layer with matching name already exists");
                return;
            }
            var layer = {
                name: name,
                x: 0,
                y: 0,
                width: width,
                height: height,
                widthInPixels: width * tileWidth,
                heightInPixels: height * tileHeight,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: null
            };
            var row;
            var output = [];
            for (var y = 0; y < height; y++) {
                row = [];
                for (var x = 0; x < width; x++) {
                    row.push(new Phaser.Tile(layer, -1, x, y, tileWidth, tileHeight));
                }
                output.push(row);
            }
            layer.data = output;
            this.layers.push(layer);
            this.currentLayer = this.layers.length - 1;
            var w = layer.widthInPixels;
            var h = layer.heightInPixels;
            if (w > this.game.width) {
                w = this.game.width;
            }
            if (h > this.game.height) {
                h = this.game.height;
            }
            var output = new Phaser.TilemapLayer(this.game, this, this.layers.length - 1, w, h);
            output.name = name;
            return group.add(output);
        },
        getIndex: function(location, name) {
            for (var i = 0; i < location.length; i++) {
                if (location[i].name === name) {
                    return i;
                }
            }
            return null;
        },
        getLayerIndex: function(name) {
            return this.getIndex(this.layers, name);
        },
        getTilesetIndex: function(name) {
            return this.getIndex(this.tilesets, name);
        },
        getImageIndex: function(name) {
            return this.getIndex(this.images, name);
        },
        getObjectIndex: function(name) {
            return this.getIndex(this.objects, name);
        },
        setTileIndexCallback: function(indexes, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            if (typeof indexes === "number") {
                this.layers[layer].callbacks[indexes] = {
                    callback: callback,
                    callbackContext: callbackContext
                };
            } else {
                for (var i = 0, len = indexes.length; i < len; i++) {
                    this.layers[layer].callbacks[indexes[i]] = {
                        callback: callback,
                        callbackContext: callbackContext
                    };
                }
            }
        },
        setTileLocationCallback: function(x, y, width, height, callback, callbackContext, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].setCollisionCallback(callback, callbackContext);
            }
        },
        setCollision: function(indexes, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            if (typeof indexes === "number") {
                return this.setCollisionByIndex(indexes, collides, layer, true);
            } else {
                for (var i = 0, len = indexes.length; i < len; i++) {
                    this.setCollisionByIndex(indexes[i], collides, layer, false);
                }
                if (recalculate) {
                    this.calculateFaces(layer);
                }
            }
        },
        setCollisionBetween: function(start, stop, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            if (start > stop) {
                return;
            }
            for (var index = start; index <= stop; index++) {
                this.setCollisionByIndex(index, collides, layer, false);
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
        },
        setCollisionByExclusion: function(indexes, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            layer = this.getLayer(layer);
            for (var i = 0, len = this.tiles.length; i < len; i++) {
                if (indexes.indexOf(i) === -1) {
                    this.setCollisionByIndex(i, collides, layer, false);
                }
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
        },
        setCollisionByIndex: function(index, collides, layer, recalculate) {
            if (typeof collides === "undefined") {
                collides = true;
            }
            if (typeof layer === "undefined") {
                layer = this.currentLayer;
            }
            if (typeof recalculate === "undefined") {
                recalculate = true;
            }
            if (collides) {
                this.collideIndexes.push(index);
            } else {
                var i = this.collideIndexes.indexOf(index);
                if (i > -1) {
                    this.collideIndexes.splice(i, 1);
                }
            }
            for (var y = 0; y < this.layers[layer].height; y++) {
                for (var x = 0; x < this.layers[layer].width; x++) {
                    var tile = this.layers[layer].data[y][x];
                    if (tile && tile.index === index) {
                        if (collides) {
                            tile.setCollision(true, true, true, true);
                        } else {
                            tile.resetCollision();
                        }
                        tile.faceTop = collides;
                        tile.faceBottom = collides;
                        tile.faceLeft = collides;
                        tile.faceRight = collides;
                    }
                }
            }
            if (recalculate) {
                this.calculateFaces(layer);
            }
            return layer;
        },
        getLayer: function(layer) {
            if (typeof layer === "undefined") {
                layer = this.currentLayer;
            } else if (typeof layer === "string") {
                layer = this.getLayerIndex(layer);
            } else if (layer instanceof Phaser.TilemapLayer) {
                layer = layer.index;
            }
            return layer;
        },
        setPreventRecalculate: function(value) {
            if (value === true && this.preventingRecalculate !== true) {
                this.preventingRecalculate = true;
                this.needToRecalculate = {};
            }
            if (value === false && this.preventingRecalculate === true) {
                this.preventingRecalculate = false;
                for (var i in this.needToRecalculate) {
                    this.calculateFaces(i);
                }
                this.needToRecalculate = false;
            }
        },
        calculateFaces: function(layer) {
            if (this.preventingRecalculate) {
                this.needToRecalculate[layer] = true;
                return;
            }
            var above = null;
            var below = null;
            var left = null;
            var right = null;
            for (var y = 0, h = this.layers[layer].height; y < h; y++) {
                for (var x = 0, w = this.layers[layer].width; x < w; x++) {
                    var tile = this.layers[layer].data[y][x];
                    if (tile) {
                        above = this.getTileAbove(layer, x, y);
                        below = this.getTileBelow(layer, x, y);
                        left = this.getTileLeft(layer, x, y);
                        right = this.getTileRight(layer, x, y);
                        if (tile.collides) {
                            tile.faceTop = true;
                            tile.faceBottom = true;
                            tile.faceLeft = true;
                            tile.faceRight = true;
                        }
                        if (above && above.collides) {
                            tile.faceTop = false;
                        }
                        if (below && below.collides) {
                            tile.faceBottom = false;
                        }
                        if (left && left.collides) {
                            tile.faceLeft = false;
                        }
                        if (right && right.collides) {
                            tile.faceRight = false;
                        }
                    }
                }
            }
        },
        getTileAbove: function(layer, x, y) {
            if (y > 0) {
                return this.layers[layer].data[y - 1][x];
            }
            return null;
        },
        getTileBelow: function(layer, x, y) {
            if (y < this.layers[layer].height - 1) {
                return this.layers[layer].data[y + 1][x];
            }
            return null;
        },
        getTileLeft: function(layer, x, y) {
            if (x > 0) {
                return this.layers[layer].data[y][x - 1];
            }
            return null;
        },
        getTileRight: function(layer, x, y) {
            if (x < this.layers[layer].width - 1) {
                return this.layers[layer].data[y][x + 1];
            }
            return null;
        },
        setLayer: function(layer) {
            layer = this.getLayer(layer);
            if (this.layers[layer]) {
                this.currentLayer = layer;
            }
        },
        hasTile: function(x, y, layer) {
            layer = this.getLayer(layer);
            return this.layers[layer].data[y][x].index > -1;
        },
        removeTile: function(x, y, layer) {
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                if (this.hasTile(x, y, layer)) {
                    var tile = this.layers[layer].data[y][x];
                    this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], -1, x, y, this.tileWidth, this.tileHeight);
                    this.layers[layer].dirty = true;
                    this.calculateFaces(layer);
                    return tile;
                }
            }
        },
        removeTileWorldXY: function(x, y, tileWidth, tileHeight, layer) {
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.removeTile(x, y, layer);
        },
        putTile: function(tile, x, y, layer) {
            if (tile === null) {
                return this.removeTile(x, y, layer);
            }
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                var index;
                if (tile instanceof Phaser.Tile) {
                    index = tile.index;
                    if (this.hasTile(x, y, layer)) {
                        this.layers[layer].data[y][x].copy(tile);
                    } else {
                        this.layers[layer].data[y][x] = new Phaser.Tile(layer, index, x, y, tile.width, tile.height);
                    }
                } else {
                    index = tile;
                    if (this.hasTile(x, y, layer)) {
                        this.layers[layer].data[y][x].index = index;
                    } else {
                        this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], index, x, y, this.tileWidth, this.tileHeight);
                    }
                }
                if (this.collideIndexes.indexOf(index) > -1) {
                    this.layers[layer].data[y][x].setCollision(true, true, true, true);
                } else {
                    this.layers[layer].data[y][x].resetCollision();
                }
                this.layers[layer].dirty = true;
                this.calculateFaces(layer);
                return this.layers[layer].data[y][x];
            }
            return null;
        },
        putTileWorldXY: function(tile, x, y, tileWidth, tileHeight, layer) {
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.putTile(tile, x, y, layer);
        },
        searchTileIndex: function(index, skip, reverse, layer) {
            if (typeof skip === "undefined") {
                skip = 0;
            }
            if (typeof reverse === "undefined") {
                reverse = false;
            }
            layer = this.getLayer(layer);
            var c = 0;
            if (reverse) {
                for (var y = this.layers[layer].height - 1; y >= 0; y--) {
                    for (var x = this.layers[layer].width - 1; x >= 0; x--) {
                        if (this.layers[layer].data[y][x].index === index) {
                            if (c === skip) {
                                return this.layers[layer].data[y][x];
                            } else {
                                c++;
                            }
                        }
                    }
                }
            } else {
                for (var y = 0; y < this.layers[layer].height; y++) {
                    for (var x = 0; x < this.layers[layer].width; x++) {
                        if (this.layers[layer].data[y][x].index === index) {
                            if (c === skip) {
                                return this.layers[layer].data[y][x];
                            } else {
                                c++;
                            }
                        }
                    }
                }
            }
            return null;
        },
        getTile: function(x, y, layer, nonNull) {
            if (typeof nonNull === "undefined") {
                nonNull = false;
            }
            layer = this.getLayer(layer);
            if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) {
                if (this.layers[layer].data[y][x].index === -1) {
                    if (nonNull) {
                        return this.layers[layer].data[y][x];
                    } else {
                        return null;
                    }
                } else {
                    return this.layers[layer].data[y][x];
                }
            } else {
                return null;
            }
        },
        getTileWorldXY: function(x, y, tileWidth, tileHeight, layer) {
            if (typeof tileWidth === "undefined") {
                tileWidth = this.tileWidth;
            }
            if (typeof tileHeight === "undefined") {
                tileHeight = this.tileHeight;
            }
            layer = this.getLayer(layer);
            x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;
            y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;
            return this.getTile(x, y, layer);
        },
        copy: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            if (!this.layers[layer]) {
                this._results.length = 0;
                return;
            }
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            if (typeof width === "undefined") {
                width = this.layers[layer].width;
            }
            if (typeof height === "undefined") {
                height = this.layers[layer].height;
            }
            if (x < 0) {
                x = 0;
            }
            if (y < 0) {
                y = 0;
            }
            if (width > this.layers[layer].width) {
                width = this.layers[layer].width;
            }
            if (height > this.layers[layer].height) {
                height = this.layers[layer].height;
            }
            this._results.length = 0;
            this._results.push({
                x: x,
                y: y,
                width: width,
                height: height,
                layer: layer
            });
            for (var ty = y; ty < y + height; ty++) {
                for (var tx = x; tx < x + width; tx++) {
                    this._results.push(this.layers[layer].data[ty][tx]);
                }
            }
            return this._results;
        },
        paste: function(x, y, tileblock, layer) {
            if (typeof x === "undefined") {
                x = 0;
            }
            if (typeof y === "undefined") {
                y = 0;
            }
            layer = this.getLayer(layer);
            if (!tileblock || tileblock.length < 2) {
                return;
            }
            var diffX = tileblock[1].x - x;
            var diffY = tileblock[1].y - y;
            for (var i = 1; i < tileblock.length; i++) {
                this.layers[layer].data[diffY + tileblock[i].y][diffX + tileblock[i].x].copy(tileblock[i]);
            }
            this.layers[layer].dirty = true;
            this.calculateFaces(layer);
        },
        swap: function(tileA, tileB, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            this._tempA = tileA;
            this._tempB = tileB;
            this._results.forEach(this.swapHandler, this);
            this.paste(x, y, this._results, layer);
        },
        swapHandler: function(value) {
            if (value.index === this._tempA) {
                value.index = this._tempB;
            } else if (value.index === this._tempB) {
                value.index = this._tempA;
            }
        },
        forEach: function(callback, context, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            this._results.forEach(callback, context);
            this.paste(x, y, this._results, layer);
        },
        replace: function(source, dest, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                if (this._results[i].index === source) {
                    this._results[i].index = dest;
                }
            }
            this.paste(x, y, this._results, layer);
        },
        random: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            var indexes = [];
            for (var t = 1; t < this._results.length; t++) {
                if (this._results[t].index) {
                    var idx = this._results[t].index;
                    if (indexes.indexOf(idx) === -1) {
                        indexes.push(idx);
                    }
                }
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = this.game.rnd.pick(indexes);
            }
            this.paste(x, y, this._results, layer);
        },
        shuffle: function(x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            var indexes = [];
            for (var t = 1; t < this._results.length; t++) {
                if (this._results[t].index) {
                    indexes.push(this._results[t].index);
                }
            }
            Phaser.Utils.shuffle(indexes);
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = indexes[i - 1];
            }
            this.paste(x, y, this._results, layer);
        },
        fill: function(index, x, y, width, height, layer) {
            layer = this.getLayer(layer);
            this.copy(x, y, width, height, layer);
            if (this._results.length < 2) {
                return;
            }
            for (var i = 1; i < this._results.length; i++) {
                this._results[i].index = index;
            }
            this.paste(x, y, this._results, layer);
        },
        removeAllLayers: function() {
            this.layers.length = 0;
            this.currentLayer = 0;
        },
        dump: function() {
            var txt = "";
            var args = [ "" ];
            for (var y = 0; y < this.layers[this.currentLayer].height; y++) {
                for (var x = 0; x < this.layers[this.currentLayer].width; x++) {
                    txt += "%c  ";
                    if (this.layers[this.currentLayer].data[y][x] > 1) {
                        if (this.debugMap[this.layers[this.currentLayer].data[y][x]]) {
                            args.push("background: " + this.debugMap[this.layers[this.currentLayer].data[y][x]]);
                        } else {
                            args.push("background: #ffffff");
                        }
                    } else {
                        args.push("background: rgb(0, 0, 0)");
                    }
                }
                txt += "\n";
            }
            args[0] = txt;
            console.log.apply(console, args);
        },
        destroy: function() {
            this.removeAllLayers();
            this.data = [];
            this.game = null;
        }
    };
    Phaser.Tilemap.prototype.constructor = Phaser.Tilemap;
    Object.defineProperty(Phaser.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer];
        },
        set: function(value) {
            if (value !== this.currentLayer) {
                this.setLayer(value);
            }
        }
    });
    Phaser.TilemapLayer = function(game, tilemap, index, width, height) {
        this.game = game;
        this.map = tilemap;
        this.index = index;
        this.layer = tilemap.layers[index];
        this.canvas = Phaser.Canvas.create(width, height, "", true);
        this.context = this.canvas.getContext("2d");
        this.baseTexture = new PIXI.BaseTexture(this.canvas);
        this.texture = new PIXI.Texture(this.baseTexture);
        this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, "tilemapLayer", game.rnd.uuid());
        Phaser.Image.call(this, this.game, 0, 0, this.texture, this.textureFrame);
        this.name = "";
        this.type = Phaser.TILEMAPLAYER;
        this.fixedToCamera = true;
        this.cameraOffset = new Phaser.Point(0, 0);
        this.tileColor = "rgb(255, 255, 255)";
        this.debug = false;
        this.debugAlpha = .5;
        this.debugColor = "rgba(0, 255, 0, 1)";
        this.debugFill = false;
        this.debugFillColor = "rgba(0, 255, 0, 0.2)";
        this.debugCallbackColor = "rgba(255, 0, 0, 1)";
        this.scrollFactorX = 1;
        this.scrollFactorY = 1;
        this.dirty = true;
        this.rayStepRate = 4;
        this.wrap = false;
        this._mc = {
            cw: tilemap.tileWidth,
            ch: tilemap.tileHeight,
            ga: 1,
            dx: 0,
            dy: 0,
            dw: 0,
            dh: 0,
            tx: 0,
            ty: 0,
            tw: 0,
            th: 0,
            tl: 0,
            maxX: 0,
            maxY: 0,
            startX: 0,
            startY: 0,
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0
        };
        this._results = [];
        this.updateMax();
    };
    Phaser.TilemapLayer.prototype = Object.create(Phaser.Image.prototype);
    Phaser.TilemapLayer.prototype.constructor = Phaser.TilemapLayer;
    Phaser.TilemapLayer.prototype.postUpdate = function() {
        Phaser.Image.prototype.postUpdate.call(this);
        this.scrollX = this.game.camera.x * this.scrollFactorX;
        this.scrollY = this.game.camera.y * this.scrollFactorY;
        this.render();
        if (this._cache[7] === 1) {
            this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
            this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
        }
    };
    Phaser.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels, this.layer.heightInPixels);
    };
    Phaser.TilemapLayer.prototype._fixX = function(x) {
        if (x < 0) {
            x = 0;
        }
        if (this.scrollFactorX === 1) {
            return x;
        }
        return this._mc.x + (x - this._mc.x / this.scrollFactorX);
    };
    Phaser.TilemapLayer.prototype._unfixX = function(x) {
        if (this.scrollFactorX === 1) {
            return x;
        }
        return this._mc.x / this.scrollFactorX + (x - this._mc.x);
    };
    Phaser.TilemapLayer.prototype._fixY = function(y) {
        if (y < 0) {
            y = 0;
        }
        if (this.scrollFactorY === 1) {
            return y;
        }
        return this._mc.y + (y - this._mc.y / this.scrollFactorY);
    };
    Phaser.TilemapLayer.prototype._unfixY = function(y) {
        if (this.scrollFactorY === 1) {
            return y;
        }
        return this._mc.y / this.scrollFactorY + (y - this._mc.y);
    };
    Phaser.TilemapLayer.prototype.getTileX = function(x) {
        return this.game.math.snapToFloor(this._fixX(x), this.map.tileWidth) / this.map.tileWidth;
    };
    Phaser.TilemapLayer.prototype.getTileY = function(y) {
        return this.game.math.snapToFloor(this._fixY(y), this.map.tileHeight) / this.map.tileHeight;
    };
    Phaser.TilemapLayer.prototype.getTileXY = function(x, y, point) {
        point.x = this.getTileX(x);
        point.y = this.getTileY(y);
        return point;
    };
    Phaser.TilemapLayer.prototype.getRayCastTiles = function(line, stepRate, collides, interestingFace) {
        if (typeof stepRate === "undefined" || stepRate === null) {
            stepRate = this.rayStepRate;
        }
        if (typeof collides === "undefined") {
            collides = false;
        }
        if (typeof interestingFace === "undefined") {
            interestingFace = false;
        }
        var tiles = this.getTiles(line.x, line.y, line.width, line.height, collides, interestingFace);
        if (tiles.length === 0) {
            return [];
        }
        var coords = line.coordinatesOnLine(stepRate);
        var total = coords.length;
        var results = [];
        for (var i = 0; i < tiles.length; i++) {
            for (var t = 0; t < total; t++) {
                if (tiles[i].containsPoint(coords[t][0], coords[t][1])) {
                    results.push(tiles[i]);
                    break;
                }
            }
        }
        return results;
    };
    Phaser.TilemapLayer.prototype.getTiles = function(x, y, width, height, collides, interestingFace) {
        if (typeof collides === "undefined") {
            collides = false;
        }
        if (typeof interestingFace === "undefined") {
            interestingFace = false;
        }
        x = this._fixX(x);
        y = this._fixY(y);
        if (width > this.layer.widthInPixels) {
            width = this.layer.widthInPixels;
        }
        if (height > this.layer.heightInPixels) {
            height = this.layer.heightInPixels;
        }
        this._mc.tx = this.game.math.snapToFloor(x, this._mc.cw) / this._mc.cw;
        this._mc.ty = this.game.math.snapToFloor(y, this._mc.ch) / this._mc.ch;
        this._mc.tw = (this.game.math.snapToCeil(width, this._mc.cw) + this._mc.cw) / this._mc.cw;
        this._mc.th = (this.game.math.snapToCeil(height, this._mc.ch) + this._mc.ch) / this._mc.ch;
        this._results.length = 0;
        for (var wy = this._mc.ty; wy < this._mc.ty + this._mc.th; wy++) {
            for (var wx = this._mc.tx; wx < this._mc.tx + this._mc.tw; wx++) {
                if (this.layer.data[wy] && this.layer.data[wy][wx]) {
                    if (!collides && !interestingFace || this.layer.data[wy][wx].isInteresting(collides, interestingFace)) {
                        this._results.push(this.layer.data[wy][wx]);
                    }
                }
            }
        }
        return this._results;
    };
    Phaser.TilemapLayer.prototype.updateMax = function() {
        this._mc.maxX = this.game.math.ceil(this.canvas.width / this.map.tileWidth) + 1;
        this._mc.maxY = this.game.math.ceil(this.canvas.height / this.map.tileHeight) + 1;
        this.dirty = true;
    };
    Phaser.TilemapLayer.prototype.render = function() {
        if (this.layer.dirty) {
            this.dirty = true;
        }
        if (!this.dirty || !this.visible) {
            return;
        }
        this._mc.prevX = this._mc.dx;
        this._mc.prevY = this._mc.dy;
        this._mc.dx = -(this._mc.x - this._mc.startX * this.map.tileWidth);
        this._mc.dy = -(this._mc.y - this._mc.startY * this.map.tileHeight);
        this._mc.tx = this._mc.dx;
        this._mc.ty = this._mc.dy;
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.fillStyle = this.tileColor;
        var tile;
        var set;
        if (this.debug) {
            this.context.globalAlpha = this.debugAlpha;
        }
        for (var y = this._mc.startY, lenY = this._mc.startY + this._mc.maxY; y < lenY; y++) {
            this._column = null;
            if (y < 0 && this.wrap) {
                this._column = this.layer.data[y + this.map.height];
            } else if (y >= this.map.height && this.wrap) {
                this._column = this.layer.data[y - this.map.height];
            } else if (this.layer.data[y]) {
                this._column = this.layer.data[y];
            }
            if (this._column) {
                for (var x = this._mc.startX, lenX = this._mc.startX + this._mc.maxX; x < lenX; x++) {
                    var tile = null;
                    if (x < 0 && this.wrap) {
                        tile = this._column[x + this.map.width];
                    } else if (x >= this.map.width && this.wrap) {
                        tile = this._column[x - this.map.width];
                    } else if (this._column[x]) {
                        tile = this._column[x];
                    }
                    if (tile && tile.index > -1) {
                        set = this.map.tilesets[this.map.tiles[tile.index][2]];
                        if (this.debug === false && tile.alpha !== this.context.globalAlpha) {
                            this.context.globalAlpha = tile.alpha;
                        }
                        set.draw(this.context, Math.floor(this._mc.tx), Math.floor(this._mc.ty), tile.index);
                        if (tile.debug) {
                            this.context.fillStyle = "rgba(0, 255, 0, 0.4)";
                            this.context.fillRect(Math.floor(this._mc.tx), Math.floor(this._mc.ty), this.map.tileWidth, this.map.tileHeight);
                        }
                    }
                    this._mc.tx += this.map.tileWidth;
                }
            }
            this._mc.tx = this._mc.dx;
            this._mc.ty += this.map.tileHeight;
        }
        if (this.debug) {
            this.context.globalAlpha = 1;
            this.renderDebug();
        }
        if (this.game.renderType === Phaser.WEBGL) {
            PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);
        }
        this.dirty = false;
        this.layer.dirty = false;
        return true;
    };
    Phaser.TilemapLayer.prototype.renderDebug = function() {
        this._mc.tx = this._mc.dx;
        this._mc.ty = this._mc.dy;
        this.context.strokeStyle = this.debugColor;
        this.context.fillStyle = this.debugFillColor;
        for (var y = this._mc.startY, lenY = this._mc.startY + this._mc.maxY; y < lenY; y++) {
            this._column = null;
            if (y < 0 && this.wrap) {
                this._column = this.layer.data[y + this.map.height];
            } else if (y >= this.map.height && this.wrap) {
                this._column = this.layer.data[y - this.map.height];
            } else if (this.layer.data[y]) {
                this._column = this.layer.data[y];
            }
            if (this._column) {
                for (var x = this._mc.startX, lenX = this._mc.startX + this._mc.maxX; x < lenX; x++) {
                    var tile = null;
                    if (x < 0 && this.wrap) {
                        tile = this._column[x + this.map.width];
                    } else if (x >= this.map.width && this.wrap) {
                        tile = this._column[x - this.map.width];
                    } else if (this._column[x]) {
                        tile = this._column[x];
                    }
                    if (tile && (tile.faceTop || tile.faceBottom || tile.faceLeft || tile.faceRight)) {
                        this._mc.tx = Math.floor(this._mc.tx);
                        if (this.debugFill) {
                            this.context.fillRect(this._mc.tx, this._mc.ty, this._mc.cw, this._mc.ch);
                        }
                        this.context.beginPath();
                        if (tile.faceTop) {
                            this.context.moveTo(this._mc.tx, this._mc.ty);
                            this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty);
                        }
                        if (tile.faceBottom) {
                            this.context.moveTo(this._mc.tx, this._mc.ty + this._mc.ch);
                            this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch);
                        }
                        if (tile.faceLeft) {
                            this.context.moveTo(this._mc.tx, this._mc.ty);
                            this.context.lineTo(this._mc.tx, this._mc.ty + this._mc.ch);
                        }
                        if (tile.faceRight) {
                            this.context.moveTo(this._mc.tx + this._mc.cw, this._mc.ty);
                            this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch);
                        }
                        this.context.stroke();
                    }
                    this._mc.tx += this.map.tileWidth;
                }
            }
            this._mc.tx = this._mc.dx;
            this._mc.ty += this.map.tileHeight;
        }
    };
    Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._mc.x;
        },
        set: function(value) {
            if (value !== this._mc.x) {
                this._mc.x = value;
                this._mc.startX = this.game.math.floor(this._mc.x / this.map.tileWidth);
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._mc.y;
        },
        set: function(value) {
            if (value !== this._mc.y) {
                this._mc.y = value;
                this._mc.startY = this.game.math.floor(this._mc.y / this.map.tileHeight);
                this.dirty = true;
            }
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw;
        },
        set: function(value) {
            this._mc.cw = value;
            this.dirty = true;
        }
    });
    Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch;
        },
        set: function(value) {
            this._mc.ch = value;
            this.dirty = true;
        }
    });
    Phaser.TilemapParser = {
        parse: function(game, key, tileWidth, tileHeight, width, height) {
            if (typeof tileWidth === "undefined") {
                tileWidth = 32;
            }
            if (typeof tileHeight === "undefined") {
                tileHeight = 32;
            }
            if (typeof width === "undefined") {
                width = 10;
            }
            if (typeof height === "undefined") {
                height = 10;
            }
            if (typeof key === "undefined") {
                return this.getEmptyData();
            }
            if (key === null) {
                return this.getEmptyData(tileWidth, tileHeight, width, height);
            }
            var map = game.cache.getTilemapData(key);
            if (map) {
                if (map.format === Phaser.Tilemap.CSV) {
                    return this.parseCSV(key, map.data, tileWidth, tileHeight);
                } else if (!map.format || map.format === Phaser.Tilemap.TILED_JSON) {
                    return this.parseTiledJSON(map.data);
                }
            } else {
                console.warn("Phaser.TilemapParser.parse - No map data found for key " + key);
            }
        },
        parseCSV: function(key, data, tileWidth, tileHeight) {
            var map = this.getEmptyData();
            data = data.trim();
            var output = [];
            var rows = data.split("\n");
            var height = rows.length;
            var width = 0;
            for (var y = 0; y < rows.length; y++) {
                output[y] = [];
                var column = rows[y].split(",");
                for (var x = 0; x < column.length; x++) {
                    output[y][x] = new Phaser.Tile(map.layers[0], parseInt(column[x], 10), x, y, tileWidth, tileHeight);
                }
                if (width === 0) {
                    width = column.length;
                }
            }
            map.format = Phaser.Tilemap.CSV;
            map.name = key;
            map.width = width;
            map.height = height;
            map.tileWidth = tileWidth;
            map.tileHeight = tileHeight;
            map.widthInPixels = width * tileWidth;
            map.heightInPixels = height * tileHeight;
            map.layers[0].width = width;
            map.layers[0].height = height;
            map.layers[0].widthInPixels = map.widthInPixels;
            map.layers[0].heightInPixels = map.heightInPixels;
            map.layers[0].data = output;
            return map;
        },
        getEmptyData: function(tileWidth, tileHeight, width, height) {
            var map = {};
            map.width = 0;
            map.height = 0;
            map.tileWidth = 0;
            map.tileHeight = 0;
            if (typeof tileWidth !== "undefined" && tileWidth !== null) {
                map.tileWidth = tileWidth;
            }
            if (typeof tileHeight !== "undefined" && tileHeight !== null) {
                map.tileHeight = tileHeight;
            }
            if (typeof width !== "undefined" && width !== null) {
                map.width = width;
            }
            if (typeof height !== "undefined" && height !== null) {
                map.height = height;
            }
            map.orientation = "orthogonal";
            map.version = "1";
            map.properties = {};
            map.widthInPixels = 0;
            map.heightInPixels = 0;
            var layers = [];
            var layer = {
                name: "layer",
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                widthInPixels: 0,
                heightInPixels: 0,
                alpha: 1,
                visible: true,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: []
            };
            layers.push(layer);
            map.layers = layers;
            map.images = [];
            map.objects = {};
            map.collision = {};
            map.tilesets = [];
            map.tiles = [];
            return map;
        },
        parseTiledJSON: function(json) {
            if (json.orientation !== "orthogonal") {
                console.warn("TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser");
                return null;
            }
            var map = {};
            map.width = json.width;
            map.height = json.height;
            map.tileWidth = json.tilewidth;
            map.tileHeight = json.tileheight;
            map.orientation = json.orientation;
            map.format = Phaser.Tilemap.TILED_JSON;
            map.version = json.version;
            map.properties = json.properties;
            map.widthInPixels = map.width * map.tileWidth;
            map.heightInPixels = map.height * map.tileHeight;
            var layers = [];
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "tilelayer") {
                    continue;
                }
                var layer = {
                    name: json.layers[i].name,
                    x: json.layers[i].x,
                    y: json.layers[i].y,
                    width: json.layers[i].width,
                    height: json.layers[i].height,
                    widthInPixels: json.layers[i].width * json.tilewidth,
                    heightInPixels: json.layers[i].height * json.tileheight,
                    alpha: json.layers[i].opacity,
                    visible: json.layers[i].visible,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: []
                };
                if (json.layers[i].properties) {
                    layer.properties = json.layers[i].properties;
                }
                var x = 0;
                var row = [];
                var output = [];
                for (var t = 0, len = json.layers[i].data.length; t < len; t++) {
                    if (json.layers[i].data[t] > 0) {
                        row.push(new Phaser.Tile(layer, json.layers[i].data[t], x, output.length, json.tilewidth, json.tileheight));
                    } else {
                        row.push(new Phaser.Tile(layer, -1, x, output.length, json.tilewidth, json.tileheight));
                    }
                    x++;
                    if (x === json.layers[i].width) {
                        output.push(row);
                        x = 0;
                        row = [];
                    }
                }
                layer.data = output;
                layers.push(layer);
            }
            map.layers = layers;
            var images = [];
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "imagelayer") {
                    continue;
                }
                var image = {
                    name: json.layers[i].name,
                    image: json.layers[i].image,
                    x: json.layers[i].x,
                    y: json.layers[i].y,
                    alpha: json.layers[i].opacity,
                    visible: json.layers[i].visible,
                    properties: {}
                };
                if (json.layers[i].properties) {
                    image.properties = json.layers[i].properties;
                }
                images.push(image);
            }
            map.images = images;
            var tilesets = [];
            for (var i = 0; i < json.tilesets.length; i++) {
                var set = json.tilesets[i];
                var newSet = new Phaser.Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);
                if (set.tileproperties) {
                    newSet.tileProperties = set.tileproperties;
                }
                newSet.rows = Math.round((set.imageheight - set.margin) / (set.tileheight + set.spacing));
                newSet.columns = Math.round((set.imagewidth - set.margin) / (set.tilewidth + set.spacing));
                newSet.total = newSet.rows * newSet.columns;
                if (newSet.rows % 1 !== 0 || newSet.columns % 1 !== 0) {
                    console.warn("TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.");
                } else {
                    tilesets.push(newSet);
                }
            }
            map.tilesets = tilesets;
            var objects = {};
            var collision = {};
            function slice(obj, fields) {
                var sliced = {};
                for (var k in fields) {
                    var key = fields[k];
                    sliced[key] = obj[key];
                }
                return sliced;
            }
            for (var i = 0; i < json.layers.length; i++) {
                if (json.layers[i].type !== "objectgroup") {
                    continue;
                }
                objects[json.layers[i].name] = [];
                collision[json.layers[i].name] = [];
                for (var v = 0, len = json.layers[i].objects.length; v < len; v++) {
                    if (json.layers[i].objects[v].gid) {
                        var object = {
                            gid: json.layers[i].objects[v].gid,
                            name: json.layers[i].objects[v].name,
                            x: json.layers[i].objects[v].x,
                            y: json.layers[i].objects[v].y,
                            visible: json.layers[i].objects[v].visible,
                            properties: json.layers[i].objects[v].properties
                        };
                        objects[json.layers[i].name].push(object);
                    } else if (json.layers[i].objects[v].polyline) {
                        var object = {
                            name: json.layers[i].objects[v].name,
                            type: json.layers[i].objects[v].type,
                            x: json.layers[i].objects[v].x,
                            y: json.layers[i].objects[v].y,
                            width: json.layers[i].objects[v].width,
                            height: json.layers[i].objects[v].height,
                            visible: json.layers[i].objects[v].visible,
                            properties: json.layers[i].objects[v].properties
                        };
                        object.polyline = [];
                        for (var p = 0; p < json.layers[i].objects[v].polyline.length; p++) {
                            object.polyline.push([ json.layers[i].objects[v].polyline[p].x, json.layers[i].objects[v].polyline[p].y ]);
                        }
                        collision[json.layers[i].name].push(object);
                        objects[json.layers[i].name].push(object);
                    } else if (json.layers[i].objects[v].polygon) {
                        var object = slice(json.layers[i].objects[v], [ "name", "type", "x", "y", "visible", "properties" ]);
                        object.polygon = [];
                        for (var p = 0; p < json.layers[i].objects[v].polygon.length; p++) {
                            object.polygon.push([ json.layers[i].objects[v].polygon[p].x, json.layers[i].objects[v].polygon[p].y ]);
                        }
                        objects[json.layers[i].name].push(object);
                    } else if (json.layers[i].objects[v].ellipse) {
                        var object = slice(json.layers[i].objects[v], [ "name", "type", "ellipse", "x", "y", "width", "height", "visible", "properties" ]);
                        objects[json.layers[i].name].push(object);
                    } else {
                        var object = slice(json.layers[i].objects[v], [ "name", "type", "x", "y", "width", "height", "visible", "properties" ]);
                        object.rectangle = true;
                        objects[json.layers[i].name].push(object);
                    }
                }
            }
            map.objects = objects;
            map.collision = collision;
            map.tiles = [];
            for (var i = 0; i < map.tilesets.length; i++) {
                var set = map.tilesets[i];
                var x = set.tileMargin;
                var y = set.tileMargin;
                var count = 0;
                var countX = 0;
                var countY = 0;
                for (var t = set.firstgid; t < set.firstgid + set.total; t++) {
                    map.tiles[t] = [ x, y, i ];
                    x += set.tileWidth + set.tileSpacing;
                    count++;
                    if (count === set.total) {
                        break;
                    }
                    countX++;
                    if (countX === set.columns) {
                        x = set.tileMargin;
                        y += set.tileHeight + set.tileSpacing;
                        countX = 0;
                        countY++;
                        if (countY === set.rows) {
                            break;
                        }
                    }
                }
            }
            var i, j, k;
            var layer, tile, sid, set;
            for (i = 0; i < map.layers.length; i++) {
                layer = map.layers[i];
                for (j = 0; j < layer.data.length; j++) {
                    row = layer.data[j];
                    for (k = 0; k < row.length; k++) {
                        tile = row[k];
                        if (tile.index < 0) {
                            continue;
                        }
                        sid = map.tiles[tile.index][2];
                        set = map.tilesets[sid];
                        if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) {
                            tile.properties = set.tileProperties[tile.index - set.firstgid];
                        }
                    }
                }
            }
            return map;
        }
    };
    Phaser.Tileset = function(name, firstgid, width, height, margin, spacing, properties) {
        if (typeof width === "undefined" || width <= 0) {
            width = 32;
        }
        if (typeof height === "undefined" || height <= 0) {
            height = 32;
        }
        if (typeof margin === "undefined") {
            margin = 0;
        }
        if (typeof spacing === "undefined") {
            spacing = 0;
        }
        this.name = name;
        this.firstgid = firstgid;
        this.tileWidth = width;
        this.tileHeight = height;
        this.tileMargin = margin;
        this.tileSpacing = spacing;
        this.properties = properties;
        this.image = null;
        this.rows = 0;
        this.columns = 0;
        this.total = 0;
        this.drawCoords = [];
    };
    Phaser.Tileset.prototype = {
        draw: function(context, x, y, index) {
            if (!this.image || !this.drawCoords[index]) {
                return;
            }
            context.drawImage(this.image, this.drawCoords[index][0], this.drawCoords[index][1], this.tileWidth, this.tileHeight, x, y, this.tileWidth, this.tileHeight);
        },
        setImage: function(image) {
            this.image = image;
            this.rows = Math.round((image.height - this.tileMargin) / (this.tileHeight + this.tileSpacing));
            this.columns = Math.round((image.width - this.tileMargin) / (this.tileWidth + this.tileSpacing));
            this.total = this.rows * this.columns;
            this.drawCoords.length = 0;
            var tx = this.tileMargin;
            var ty = this.tileMargin;
            var i = this.firstgid;
            for (var y = 0; y < this.rows; y++) {
                for (var x = 0; x < this.columns; x++) {
                    this.drawCoords[i] = [ tx, ty ];
                    tx += this.tileWidth + this.tileSpacing;
                    i++;
                }
                tx = this.tileMargin;
                ty += this.tileHeight + this.tileSpacing;
            }
        },
        setSpacing: function(margin, spacing) {
            this.tileMargin = margin;
            this.tileSpacing = spacing;
            this.setImage(this.image);
        }
    };
    Phaser.Tileset.prototype.constructor = Phaser.Tileset;
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = Phaser;
        }
        exports.Phaser = Phaser;
    } else if (typeof define !== "undefined" && define.amd) {
        define("Phaser", function() {
            return root.Phaser = Phaser;
        }());
    } else {
        root.Phaser = Phaser;
    }
}).call(this);

!function(e) {
    "object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define("p2", function() {
        return this.p2 = e();
    }()) : "undefined" != typeof window ? window.p2 = e() : "undefined" != typeof global ? self.p2 = e() : "undefined" != typeof self && (self.p2 = e());
}(function() {
    var define, module, exports;
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    throw new Error("Cannot find module '" + o + "'");
                }
                var f = n[o] = {
                    exports: {}
                };
                t[o][0].call(f.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, f, f.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(require, module, exports) {
            require = function e(t, n, r) {
                function s(o, u) {
                    if (!n[o]) {
                        if (!t[o]) {
                            var a = typeof require == "function" && require;
                            if (!u && a) return a(o, !0);
                            if (i) return i(o, !0);
                            throw new Error("Cannot find module '" + o + "'");
                        }
                        var f = n[o] = {
                            exports: {}
                        };
                        t[o][0].call(f.exports, function(e) {
                            var n = t[o][1][e];
                            return s(n ? n : e);
                        }, f, f.exports, e, t, n, r);
                    }
                    return n[o].exports;
                }
                var i = typeof require == "function" && require;
                for (var o = 0; o < r.length; o++) s(r[o]);
                return s;
            }({
                PcZj9L: [ function(require, module, exports) {
                    var TA = require("typedarray");
                    var xDataView = typeof DataView === "undefined" ? TA.DataView : DataView;
                    var xArrayBuffer = typeof ArrayBuffer === "undefined" ? TA.ArrayBuffer : ArrayBuffer;
                    var xUint8Array = typeof Uint8Array === "undefined" ? TA.Uint8Array : Uint8Array;
                    exports.Buffer = Buffer;
                    exports.SlowBuffer = Buffer;
                    exports.INSPECT_MAX_BYTES = 50;
                    Buffer.poolSize = 8192;
                    var browserSupport;
                    function Buffer(subject, encoding) {
                        var type = typeof subject;
                        if (encoding === "base64" && type === "string") {
                            subject = stringtrim(subject);
                            while (subject.length % 4 !== 0) {
                                subject = subject + "=";
                            }
                        }
                        var length;
                        if (type === "number") length = coerce(subject); else if (type === "string") length = Buffer.byteLength(subject, encoding); else if (type === "object") length = coerce(subject.length); else throw new Error("First argument needs to be a number, array or string.");
                        var buf = augment(new xUint8Array(length));
                        if (Buffer.isBuffer(subject)) {
                            buf.set(subject);
                        } else if (isArrayIsh(subject)) {
                            for (var i = 0; i < length; i++) {
                                if (Buffer.isBuffer(subject)) buf[i] = subject.readUInt8(i); else buf[i] = subject[i];
                            }
                        } else if (type === "string") {
                            buf.write(subject, 0, encoding);
                        }
                        return buf;
                    }
                    Buffer.isEncoding = function(encoding) {
                        switch ((encoding + "").toLowerCase()) {
                          case "hex":
                          case "utf8":
                          case "utf-8":
                          case "ascii":
                          case "binary":
                          case "base64":
                          case "ucs2":
                          case "ucs-2":
                          case "utf16le":
                          case "utf-16le":
                          case "raw":
                            return true;

                          default:
                            return false;
                        }
                    };
                    Buffer.isBuffer = function isBuffer(b) {
                        return b && b._isBuffer;
                    };
                    Buffer.byteLength = function(str, encoding) {
                        switch (encoding || "utf8") {
                          case "hex":
                            return str.length / 2;

                          case "utf8":
                          case "utf-8":
                            return utf8ToBytes(str).length;

                          case "ascii":
                          case "binary":
                            return str.length;

                          case "base64":
                            return base64ToBytes(str).length;

                          default:
                            throw new Error("Unknown encoding");
                        }
                    };
                    Buffer.concat = function(list, totalLength) {
                        if (!Array.isArray(list)) {
                            throw new Error("Usage: Buffer.concat(list, [totalLength])\n" + "list should be an Array.");
                        }
                        var i;
                        var buf;
                        if (list.length === 0) {
                            return new Buffer(0);
                        } else if (list.length === 1) {
                            return list[0];
                        }
                        if (typeof totalLength !== "number") {
                            totalLength = 0;
                            for (i = 0; i < list.length; i++) {
                                buf = list[i];
                                totalLength += buf.length;
                            }
                        }
                        var buffer = new Buffer(totalLength);
                        var pos = 0;
                        for (i = 0; i < list.length; i++) {
                            buf = list[i];
                            buf.copy(buffer, pos);
                            pos += buf.length;
                        }
                        return buffer;
                    };
                    function _hexWrite(buf, string, offset, length) {
                        offset = Number(offset) || 0;
                        var remaining = buf.length - offset;
                        if (!length) {
                            length = remaining;
                        } else {
                            length = Number(length);
                            if (length > remaining) {
                                length = remaining;
                            }
                        }
                        var strLen = string.length;
                        if (strLen % 2 !== 0) {
                            throw new Error("Invalid hex string");
                        }
                        if (length > strLen / 2) {
                            length = strLen / 2;
                        }
                        for (var i = 0; i < length; i++) {
                            var byte = parseInt(string.substr(i * 2, 2), 16);
                            if (isNaN(byte)) throw new Error("Invalid hex string");
                            buf[offset + i] = byte;
                        }
                        Buffer._charsWritten = i * 2;
                        return i;
                    }
                    function _utf8Write(buf, string, offset, length) {
                        var bytes, pos;
                        return Buffer._charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length);
                    }
                    function _asciiWrite(buf, string, offset, length) {
                        var bytes, pos;
                        return Buffer._charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
                    }
                    function _binaryWrite(buf, string, offset, length) {
                        return _asciiWrite(buf, string, offset, length);
                    }
                    function _base64Write(buf, string, offset, length) {
                        var bytes, pos;
                        return Buffer._charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
                    }
                    function BufferWrite(string, offset, length, encoding) {
                        if (isFinite(offset)) {
                            if (!isFinite(length)) {
                                encoding = length;
                                length = undefined;
                            }
                        } else {
                            var swap = encoding;
                            encoding = offset;
                            offset = length;
                            length = swap;
                        }
                        offset = Number(offset) || 0;
                        var remaining = this.length - offset;
                        if (!length) {
                            length = remaining;
                        } else {
                            length = Number(length);
                            if (length > remaining) {
                                length = remaining;
                            }
                        }
                        encoding = String(encoding || "utf8").toLowerCase();
                        switch (encoding) {
                          case "hex":
                            return _hexWrite(this, string, offset, length);

                          case "utf8":
                          case "utf-8":
                            return _utf8Write(this, string, offset, length);

                          case "ascii":
                            return _asciiWrite(this, string, offset, length);

                          case "binary":
                            return _binaryWrite(this, string, offset, length);

                          case "base64":
                            return _base64Write(this, string, offset, length);

                          default:
                            throw new Error("Unknown encoding");
                        }
                    }
                    function BufferToString(encoding, start, end) {
                        var self = this instanceof ProxyBuffer ? this._proxy : this;
                        encoding = String(encoding || "utf8").toLowerCase();
                        start = Number(start) || 0;
                        end = end !== undefined ? Number(end) : end = self.length;
                        if (end === start) return "";
                        switch (encoding) {
                          case "hex":
                            return _hexSlice(self, start, end);

                          case "utf8":
                          case "utf-8":
                            return _utf8Slice(self, start, end);

                          case "ascii":
                            return _asciiSlice(self, start, end);

                          case "binary":
                            return _binarySlice(self, start, end);

                          case "base64":
                            return _base64Slice(self, start, end);

                          default:
                            throw new Error("Unknown encoding");
                        }
                    }
                    function BufferToJSON() {
                        return {
                            type: "Buffer",
                            data: Array.prototype.slice.call(this, 0)
                        };
                    }
                    function BufferCopy(target, target_start, start, end) {
                        var source = this;
                        if (!start) start = 0;
                        if (!end && end !== 0) end = this.length;
                        if (!target_start) target_start = 0;
                        if (end === start) return;
                        if (target.length === 0 || source.length === 0) return;
                        if (end < start) throw new Error("sourceEnd < sourceStart");
                        if (target_start < 0 || target_start >= target.length) throw new Error("targetStart out of bounds");
                        if (start < 0 || start >= source.length) throw new Error("sourceStart out of bounds");
                        if (end < 0 || end > source.length) throw new Error("sourceEnd out of bounds");
                        if (end > this.length) end = this.length;
                        if (target.length - target_start < end - start) end = target.length - target_start + start;
                        for (var i = 0; i < end - start; i++) target[i + target_start] = this[i + start];
                    }
                    function _base64Slice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        return require("base64-js").fromByteArray(bytes);
                    }
                    function _utf8Slice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        var res = "";
                        var tmp = "";
                        var i = 0;
                        while (i < bytes.length) {
                            if (bytes[i] <= 127) {
                                res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
                                tmp = "";
                            } else {
                                tmp += "%" + bytes[i].toString(16);
                            }
                            i++;
                        }
                        return res + decodeUtf8Char(tmp);
                    }
                    function _asciiSlice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        var ret = "";
                        for (var i = 0; i < bytes.length; i++) ret += String.fromCharCode(bytes[i]);
                        return ret;
                    }
                    function _binarySlice(buf, start, end) {
                        return _asciiSlice(buf, start, end);
                    }
                    function _hexSlice(buf, start, end) {
                        var len = buf.length;
                        if (!start || start < 0) start = 0;
                        if (!end || end < 0 || end > len) end = len;
                        var out = "";
                        for (var i = start; i < end; i++) {
                            out += toHex(buf[i]);
                        }
                        return out;
                    }
                    function BufferSlice(start, end) {
                        var len = this.length;
                        start = clamp(start, len, 0);
                        end = clamp(end, len, len);
                        return augment(this.subarray(start, end));
                    }
                    function BufferReadUInt8(offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "Trying to read beyond buffer length");
                        }
                        if (offset >= buf.length) return;
                        return buf[offset];
                    }
                    function _readUInt16(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setUint8(0, buf[len - 1]);
                            return dv.getUint16(0, littleEndian);
                        } else {
                            return buf._dataview.getUint16(offset, littleEndian);
                        }
                    }
                    function BufferReadUInt16LE(offset, noAssert) {
                        return _readUInt16(this, offset, true, noAssert);
                    }
                    function BufferReadUInt16BE(offset, noAssert) {
                        return _readUInt16(this, offset, false, noAssert);
                    }
                    function _readUInt32(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            for (var i = 0; i + offset < len; i++) {
                                dv.setUint8(i, buf[i + offset]);
                            }
                            return dv.getUint32(0, littleEndian);
                        } else {
                            return buf._dataview.getUint32(offset, littleEndian);
                        }
                    }
                    function BufferReadUInt32LE(offset, noAssert) {
                        return _readUInt32(this, offset, true, noAssert);
                    }
                    function BufferReadUInt32BE(offset, noAssert) {
                        return _readUInt32(this, offset, false, noAssert);
                    }
                    function BufferReadInt8(offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "Trying to read beyond buffer length");
                        }
                        if (offset >= buf.length) return;
                        return buf._dataview.getInt8(offset);
                    }
                    function _readInt16(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setUint8(0, buf[len - 1]);
                            return dv.getInt16(0, littleEndian);
                        } else {
                            return buf._dataview.getInt16(offset, littleEndian);
                        }
                    }
                    function BufferReadInt16LE(offset, noAssert) {
                        return _readInt16(this, offset, true, noAssert);
                    }
                    function BufferReadInt16BE(offset, noAssert) {
                        return _readInt16(this, offset, false, noAssert);
                    }
                    function _readInt32(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to read beyond buffer length");
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            for (var i = 0; i + offset < len; i++) {
                                dv.setUint8(i, buf[i + offset]);
                            }
                            return dv.getInt32(0, littleEndian);
                        } else {
                            return buf._dataview.getInt32(offset, littleEndian);
                        }
                    }
                    function BufferReadInt32LE(offset, noAssert) {
                        return _readInt32(this, offset, true, noAssert);
                    }
                    function BufferReadInt32BE(offset, noAssert) {
                        return _readInt32(this, offset, false, noAssert);
                    }
                    function _readFloat(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset + 3 < buf.length, "Trying to read beyond buffer length");
                        }
                        return buf._dataview.getFloat32(offset, littleEndian);
                    }
                    function BufferReadFloatLE(offset, noAssert) {
                        return _readFloat(this, offset, true, noAssert);
                    }
                    function BufferReadFloatBE(offset, noAssert) {
                        return _readFloat(this, offset, false, noAssert);
                    }
                    function _readDouble(buf, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset + 7 < buf.length, "Trying to read beyond buffer length");
                        }
                        return buf._dataview.getFloat64(offset, littleEndian);
                    }
                    function BufferReadDoubleLE(offset, noAssert) {
                        return _readDouble(this, offset, true, noAssert);
                    }
                    function BufferReadDoubleBE(offset, noAssert) {
                        return _readDouble(this, offset, false, noAssert);
                    }
                    function BufferWriteUInt8(value, offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "trying to write beyond buffer length");
                            verifuint(value, 255);
                        }
                        if (offset >= buf.length) return;
                        buf[offset] = value;
                    }
                    function _writeUInt16(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "trying to write beyond buffer length");
                            verifuint(value, 65535);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setUint16(0, value, littleEndian);
                            buf[offset] = dv.getUint8(0);
                        } else {
                            buf._dataview.setUint16(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteUInt16LE(value, offset, noAssert) {
                        _writeUInt16(this, value, offset, true, noAssert);
                    }
                    function BufferWriteUInt16BE(value, offset, noAssert) {
                        _writeUInt16(this, value, offset, false, noAssert);
                    }
                    function _writeUInt32(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "trying to write beyond buffer length");
                            verifuint(value, 4294967295);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            dv.setUint32(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setUint32(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteUInt32LE(value, offset, noAssert) {
                        _writeUInt32(this, value, offset, true, noAssert);
                    }
                    function BufferWriteUInt32BE(value, offset, noAssert) {
                        _writeUInt32(this, value, offset, false, noAssert);
                    }
                    function BufferWriteInt8(value, offset, noAssert) {
                        var buf = this;
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset < buf.length, "Trying to write beyond buffer length");
                            verifsint(value, 127, -128);
                        }
                        if (offset >= buf.length) return;
                        buf._dataview.setInt8(offset, value);
                    }
                    function _writeInt16(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 1 < buf.length, "Trying to write beyond buffer length");
                            verifsint(value, 32767, -32768);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 1 === len) {
                            var dv = new xDataView(new xArrayBuffer(2));
                            dv.setInt16(0, value, littleEndian);
                            buf[offset] = dv.getUint8(0);
                        } else {
                            buf._dataview.setInt16(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteInt16LE(value, offset, noAssert) {
                        _writeInt16(this, value, offset, true, noAssert);
                    }
                    function BufferWriteInt16BE(value, offset, noAssert) {
                        _writeInt16(this, value, offset, false, noAssert);
                    }
                    function _writeInt32(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to write beyond buffer length");
                            verifsint(value, 2147483647, -2147483648);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            dv.setInt32(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setInt32(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteInt32LE(value, offset, noAssert) {
                        _writeInt32(this, value, offset, true, noAssert);
                    }
                    function BufferWriteInt32BE(value, offset, noAssert) {
                        _writeInt32(this, value, offset, false, noAssert);
                    }
                    function _writeFloat(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 3 < buf.length, "Trying to write beyond buffer length");
                            verifIEEE754(value, 3.4028234663852886e38, -3.4028234663852886e38);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 3 >= len) {
                            var dv = new xDataView(new xArrayBuffer(4));
                            dv.setFloat32(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setFloat32(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteFloatLE(value, offset, noAssert) {
                        _writeFloat(this, value, offset, true, noAssert);
                    }
                    function BufferWriteFloatBE(value, offset, noAssert) {
                        _writeFloat(this, value, offset, false, noAssert);
                    }
                    function _writeDouble(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            assert(value !== undefined && value !== null, "missing value");
                            assert(typeof littleEndian === "boolean", "missing or invalid endian");
                            assert(offset !== undefined && offset !== null, "missing offset");
                            assert(offset + 7 < buf.length, "Trying to write beyond buffer length");
                            verifIEEE754(value, 1.7976931348623157e308, -1.7976931348623157e308);
                        }
                        var len = buf.length;
                        if (offset >= len) {
                            return;
                        } else if (offset + 7 >= len) {
                            var dv = new xDataView(new xArrayBuffer(8));
                            dv.setFloat64(0, value, littleEndian);
                            for (var i = 0; i + offset < len; i++) {
                                buf[i + offset] = dv.getUint8(i);
                            }
                        } else {
                            buf._dataview.setFloat64(offset, value, littleEndian);
                        }
                    }
                    function BufferWriteDoubleLE(value, offset, noAssert) {
                        _writeDouble(this, value, offset, true, noAssert);
                    }
                    function BufferWriteDoubleBE(value, offset, noAssert) {
                        _writeDouble(this, value, offset, false, noAssert);
                    }
                    function BufferFill(value, start, end) {
                        if (!value) value = 0;
                        if (!start) start = 0;
                        if (!end) end = this.length;
                        if (typeof value === "string") {
                            value = value.charCodeAt(0);
                        }
                        if (typeof value !== "number" || isNaN(value)) {
                            throw new Error("value is not a number");
                        }
                        if (end < start) throw new Error("end < start");
                        if (end === start) return;
                        if (this.length === 0) return;
                        if (start < 0 || start >= this.length) {
                            throw new Error("start out of bounds");
                        }
                        if (end < 0 || end > this.length) {
                            throw new Error("end out of bounds");
                        }
                        for (var i = start; i < end; i++) {
                            this[i] = value;
                        }
                    }
                    function BufferInspect() {
                        var out = [];
                        var len = this.length;
                        for (var i = 0; i < len; i++) {
                            out[i] = toHex(this[i]);
                            if (i === exports.INSPECT_MAX_BYTES) {
                                out[i + 1] = "...";
                                break;
                            }
                        }
                        return "<Buffer " + out.join(" ") + ">";
                    }
                    function BufferToArrayBuffer() {
                        return new Buffer(this).buffer;
                    }
                    function stringtrim(str) {
                        if (str.trim) return str.trim();
                        return str.replace(/^\s+|\s+$/g, "");
                    }
                    function _browserSupport() {
                        var arr = new xUint8Array(0);
                        arr.foo = function() {
                            return 42;
                        };
                        try {
                            return 42 === arr.foo();
                        } catch (e) {
                            return false;
                        }
                    }
                    function ProxyBuffer(arr) {
                        this._arr = arr;
                        if (arr.byteLength !== 0) this._dataview = new xDataView(arr.buffer, arr.byteOffset, arr.byteLength);
                    }
                    ProxyBuffer.prototype.write = BufferWrite;
                    ProxyBuffer.prototype.toString = BufferToString;
                    ProxyBuffer.prototype.toLocaleString = BufferToString;
                    ProxyBuffer.prototype.toJSON = BufferToJSON;
                    ProxyBuffer.prototype.copy = BufferCopy;
                    ProxyBuffer.prototype.slice = BufferSlice;
                    ProxyBuffer.prototype.readUInt8 = BufferReadUInt8;
                    ProxyBuffer.prototype.readUInt16LE = BufferReadUInt16LE;
                    ProxyBuffer.prototype.readUInt16BE = BufferReadUInt16BE;
                    ProxyBuffer.prototype.readUInt32LE = BufferReadUInt32LE;
                    ProxyBuffer.prototype.readUInt32BE = BufferReadUInt32BE;
                    ProxyBuffer.prototype.readInt8 = BufferReadInt8;
                    ProxyBuffer.prototype.readInt16LE = BufferReadInt16LE;
                    ProxyBuffer.prototype.readInt16BE = BufferReadInt16BE;
                    ProxyBuffer.prototype.readInt32LE = BufferReadInt32LE;
                    ProxyBuffer.prototype.readInt32BE = BufferReadInt32BE;
                    ProxyBuffer.prototype.readFloatLE = BufferReadFloatLE;
                    ProxyBuffer.prototype.readFloatBE = BufferReadFloatBE;
                    ProxyBuffer.prototype.readDoubleLE = BufferReadDoubleLE;
                    ProxyBuffer.prototype.readDoubleBE = BufferReadDoubleBE;
                    ProxyBuffer.prototype.writeUInt8 = BufferWriteUInt8;
                    ProxyBuffer.prototype.writeUInt16LE = BufferWriteUInt16LE;
                    ProxyBuffer.prototype.writeUInt16BE = BufferWriteUInt16BE;
                    ProxyBuffer.prototype.writeUInt32LE = BufferWriteUInt32LE;
                    ProxyBuffer.prototype.writeUInt32BE = BufferWriteUInt32BE;
                    ProxyBuffer.prototype.writeInt8 = BufferWriteInt8;
                    ProxyBuffer.prototype.writeInt16LE = BufferWriteInt16LE;
                    ProxyBuffer.prototype.writeInt16BE = BufferWriteInt16BE;
                    ProxyBuffer.prototype.writeInt32LE = BufferWriteInt32LE;
                    ProxyBuffer.prototype.writeInt32BE = BufferWriteInt32BE;
                    ProxyBuffer.prototype.writeFloatLE = BufferWriteFloatLE;
                    ProxyBuffer.prototype.writeFloatBE = BufferWriteFloatBE;
                    ProxyBuffer.prototype.writeDoubleLE = BufferWriteDoubleLE;
                    ProxyBuffer.prototype.writeDoubleBE = BufferWriteDoubleBE;
                    ProxyBuffer.prototype.fill = BufferFill;
                    ProxyBuffer.prototype.inspect = BufferInspect;
                    ProxyBuffer.prototype.toArrayBuffer = BufferToArrayBuffer;
                    ProxyBuffer.prototype._isBuffer = true;
                    ProxyBuffer.prototype.subarray = function() {
                        return this._arr.subarray.apply(this._arr, arguments);
                    };
                    ProxyBuffer.prototype.set = function() {
                        return this._arr.set.apply(this._arr, arguments);
                    };
                    var ProxyHandler = {
                        get: function(target, name) {
                            if (name in target) return target[name]; else return target._arr[name];
                        },
                        set: function(target, name, value) {
                            target._arr[name] = value;
                        }
                    };
                    function augment(arr) {
                        if (browserSupport === undefined) {
                            browserSupport = _browserSupport();
                        }
                        if (browserSupport) {
                            arr.write = BufferWrite;
                            arr.toString = BufferToString;
                            arr.toLocaleString = BufferToString;
                            arr.toJSON = BufferToJSON;
                            arr.copy = BufferCopy;
                            arr.slice = BufferSlice;
                            arr.readUInt8 = BufferReadUInt8;
                            arr.readUInt16LE = BufferReadUInt16LE;
                            arr.readUInt16BE = BufferReadUInt16BE;
                            arr.readUInt32LE = BufferReadUInt32LE;
                            arr.readUInt32BE = BufferReadUInt32BE;
                            arr.readInt8 = BufferReadInt8;
                            arr.readInt16LE = BufferReadInt16LE;
                            arr.readInt16BE = BufferReadInt16BE;
                            arr.readInt32LE = BufferReadInt32LE;
                            arr.readInt32BE = BufferReadInt32BE;
                            arr.readFloatLE = BufferReadFloatLE;
                            arr.readFloatBE = BufferReadFloatBE;
                            arr.readDoubleLE = BufferReadDoubleLE;
                            arr.readDoubleBE = BufferReadDoubleBE;
                            arr.writeUInt8 = BufferWriteUInt8;
                            arr.writeUInt16LE = BufferWriteUInt16LE;
                            arr.writeUInt16BE = BufferWriteUInt16BE;
                            arr.writeUInt32LE = BufferWriteUInt32LE;
                            arr.writeUInt32BE = BufferWriteUInt32BE;
                            arr.writeInt8 = BufferWriteInt8;
                            arr.writeInt16LE = BufferWriteInt16LE;
                            arr.writeInt16BE = BufferWriteInt16BE;
                            arr.writeInt32LE = BufferWriteInt32LE;
                            arr.writeInt32BE = BufferWriteInt32BE;
                            arr.writeFloatLE = BufferWriteFloatLE;
                            arr.writeFloatBE = BufferWriteFloatBE;
                            arr.writeDoubleLE = BufferWriteDoubleLE;
                            arr.writeDoubleBE = BufferWriteDoubleBE;
                            arr.fill = BufferFill;
                            arr.inspect = BufferInspect;
                            arr.toArrayBuffer = BufferToArrayBuffer;
                            arr._isBuffer = true;
                            if (arr.byteLength !== 0) arr._dataview = new xDataView(arr.buffer, arr.byteOffset, arr.byteLength);
                            return arr;
                        } else {
                            var proxyBuffer = new ProxyBuffer(arr);
                            var proxy = new Proxy(proxyBuffer, ProxyHandler);
                            proxyBuffer._proxy = proxy;
                            return proxy;
                        }
                    }
                    function clamp(index, len, defaultValue) {
                        if (typeof index !== "number") return defaultValue;
                        index = ~~index;
                        if (index >= len) return len;
                        if (index >= 0) return index;
                        index += len;
                        if (index >= 0) return index;
                        return 0;
                    }
                    function coerce(length) {
                        length = ~~Math.ceil(+length);
                        return length < 0 ? 0 : length;
                    }
                    function isArrayIsh(subject) {
                        return Array.isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === "object" && typeof subject.length === "number";
                    }
                    function toHex(n) {
                        if (n < 16) return "0" + n.toString(16);
                        return n.toString(16);
                    }
                    function utf8ToBytes(str) {
                        var byteArray = [];
                        for (var i = 0; i < str.length; i++) if (str.charCodeAt(i) <= 127) byteArray.push(str.charCodeAt(i)); else {
                            var h = encodeURIComponent(str.charAt(i)).substr(1).split("%");
                            for (var j = 0; j < h.length; j++) byteArray.push(parseInt(h[j], 16));
                        }
                        return byteArray;
                    }
                    function asciiToBytes(str) {
                        var byteArray = [];
                        for (var i = 0; i < str.length; i++) {
                            byteArray.push(str.charCodeAt(i) & 255);
                        }
                        return byteArray;
                    }
                    function base64ToBytes(str) {
                        return require("base64-js").toByteArray(str);
                    }
                    function blitBuffer(src, dst, offset, length) {
                        var pos, i = 0;
                        while (i < length) {
                            if (i + offset >= dst.length || i >= src.length) break;
                            dst[i + offset] = src[i];
                            i++;
                        }
                        return i;
                    }
                    function decodeUtf8Char(str) {
                        try {
                            return decodeURIComponent(str);
                        } catch (err) {
                            return String.fromCharCode(65533);
                        }
                    }
                    function verifuint(value, max) {
                        assert(typeof value == "number", "cannot write a non-number as a number");
                        assert(value >= 0, "specified a negative value for writing an unsigned value");
                        assert(value <= max, "value is larger than maximum value for type");
                        assert(Math.floor(value) === value, "value has a fractional component");
                    }
                    function verifsint(value, max, min) {
                        assert(typeof value == "number", "cannot write a non-number as a number");
                        assert(value <= max, "value larger than maximum allowed value");
                        assert(value >= min, "value smaller than minimum allowed value");
                        assert(Math.floor(value) === value, "value has a fractional component");
                    }
                    function verifIEEE754(value, max, min) {
                        assert(typeof value == "number", "cannot write a non-number as a number");
                        assert(value <= max, "value larger than maximum allowed value");
                        assert(value >= min, "value smaller than minimum allowed value");
                    }
                    function assert(test, message) {
                        if (!test) throw new Error(message || "Failed assertion");
                    }
                }, {
                    "base64-js": 3,
                    typedarray: 4
                } ],
                "native-buffer-browserify": [ function(require, module, exports) {
                    module.exports = require("PcZj9L");
                }, {} ],
                3: [ function(require, module, exports) {
                    (function(exports) {
                        "use strict";
                        var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                        function b64ToByteArray(b64) {
                            var i, j, l, tmp, placeHolders, arr;
                            if (b64.length % 4 > 0) {
                                throw "Invalid string. Length must be a multiple of 4";
                            }
                            placeHolders = b64.indexOf("=");
                            placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;
                            arr = [];
                            l = placeHolders > 0 ? b64.length - 4 : b64.length;
                            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                                tmp = lookup.indexOf(b64[i]) << 18 | lookup.indexOf(b64[i + 1]) << 12 | lookup.indexOf(b64[i + 2]) << 6 | lookup.indexOf(b64[i + 3]);
                                arr.push((tmp & 16711680) >> 16);
                                arr.push((tmp & 65280) >> 8);
                                arr.push(tmp & 255);
                            }
                            if (placeHolders === 2) {
                                tmp = lookup.indexOf(b64[i]) << 2 | lookup.indexOf(b64[i + 1]) >> 4;
                                arr.push(tmp & 255);
                            } else if (placeHolders === 1) {
                                tmp = lookup.indexOf(b64[i]) << 10 | lookup.indexOf(b64[i + 1]) << 4 | lookup.indexOf(b64[i + 2]) >> 2;
                                arr.push(tmp >> 8 & 255);
                                arr.push(tmp & 255);
                            }
                            return arr;
                        }
                        function uint8ToBase64(uint8) {
                            var i, extraBytes = uint8.length % 3, output = "", temp, length;
                            function tripletToBase64(num) {
                                return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
                            }
                            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                                output += tripletToBase64(temp);
                            }
                            switch (extraBytes) {
                              case 1:
                                temp = uint8[uint8.length - 1];
                                output += lookup[temp >> 2];
                                output += lookup[temp << 4 & 63];
                                output += "==";
                                break;

                              case 2:
                                temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                                output += lookup[temp >> 10];
                                output += lookup[temp >> 4 & 63];
                                output += lookup[temp << 2 & 63];
                                output += "=";
                                break;
                            }
                            return output;
                        }
                        module.exports.toByteArray = b64ToByteArray;
                        module.exports.fromByteArray = uint8ToBase64;
                    })();
                }, {} ],
                4: [ function(require, module, exports) {
                    var undefined = void 0;
                    var MAX_ARRAY_LENGTH = 1e5;
                    var ECMAScript = function() {
                        var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
                        return {
                            Class: function(v) {
                                return opts.call(v).replace(/^\[object *|\]$/g, "");
                            },
                            HasProperty: function(o, p) {
                                return p in o;
                            },
                            HasOwnProperty: function(o, p) {
                                return ophop.call(o, p);
                            },
                            IsCallable: function(o) {
                                return typeof o === "function";
                            },
                            ToInt32: function(v) {
                                return v >> 0;
                            },
                            ToUint32: function(v) {
                                return v >>> 0;
                            }
                        };
                    }();
                    var LN2 = Math.LN2, abs = Math.abs, floor = Math.floor, log = Math.log, min = Math.min, pow = Math.pow, round = Math.round;
                    function configureProperties(obj) {
                        if (getOwnPropertyNames && defineProperty) {
                            var props = getOwnPropertyNames(obj), i;
                            for (i = 0; i < props.length; i += 1) {
                                defineProperty(obj, props[i], {
                                    value: obj[props[i]],
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                            }
                        }
                    }
                    var defineProperty = Object.defineProperty || function(o, p, desc) {
                        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
                        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
                            Object.prototype.__defineGetter__.call(o, p, desc.get);
                        }
                        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
                            Object.prototype.__defineSetter__.call(o, p, desc.set);
                        }
                        if (ECMAScript.HasProperty(desc, "value")) {
                            o[p] = desc.value;
                        }
                        return o;
                    };
                    var getOwnPropertyNames = Object.getOwnPropertyNames || function getOwnPropertyNames(o) {
                        if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
                        var props = [], p;
                        for (p in o) {
                            if (ECMAScript.HasOwnProperty(o, p)) {
                                props.push(p);
                            }
                        }
                        return props;
                    };
                    function makeArrayAccessors(obj) {
                        if (!defineProperty) {
                            return;
                        }
                        if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
                        function makeArrayAccessor(index) {
                            defineProperty(obj, index, {
                                get: function() {
                                    return obj._getter(index);
                                },
                                set: function(v) {
                                    obj._setter(index, v);
                                },
                                enumerable: true,
                                configurable: false
                            });
                        }
                        var i;
                        for (i = 0; i < obj.length; i += 1) {
                            makeArrayAccessor(i);
                        }
                    }
                    function as_signed(value, bits) {
                        var s = 32 - bits;
                        return value << s >> s;
                    }
                    function as_unsigned(value, bits) {
                        var s = 32 - bits;
                        return value << s >>> s;
                    }
                    function packI8(n) {
                        return [ n & 255 ];
                    }
                    function unpackI8(bytes) {
                        return as_signed(bytes[0], 8);
                    }
                    function packU8(n) {
                        return [ n & 255 ];
                    }
                    function unpackU8(bytes) {
                        return as_unsigned(bytes[0], 8);
                    }
                    function packU8Clamped(n) {
                        n = round(Number(n));
                        return [ n < 0 ? 0 : n > 255 ? 255 : n & 255 ];
                    }
                    function packI16(n) {
                        return [ n >> 8 & 255, n & 255 ];
                    }
                    function unpackI16(bytes) {
                        return as_signed(bytes[0] << 8 | bytes[1], 16);
                    }
                    function packU16(n) {
                        return [ n >> 8 & 255, n & 255 ];
                    }
                    function unpackU16(bytes) {
                        return as_unsigned(bytes[0] << 8 | bytes[1], 16);
                    }
                    function packI32(n) {
                        return [ n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255 ];
                    }
                    function unpackI32(bytes) {
                        return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
                    }
                    function packU32(n) {
                        return [ n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255 ];
                    }
                    function unpackU32(bytes) {
                        return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
                    }
                    function packIEEE754(v, ebits, fbits) {
                        var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
                        function roundToEven(n) {
                            var w = floor(n), f = n - w;
                            if (f < .5) return w;
                            if (f > .5) return w + 1;
                            return w % 2 ? w + 1 : w;
                        }
                        if (v !== v) {
                            e = (1 << ebits) - 1;
                            f = pow(2, fbits - 1);
                            s = 0;
                        } else if (v === Infinity || v === -Infinity) {
                            e = (1 << ebits) - 1;
                            f = 0;
                            s = v < 0 ? 1 : 0;
                        } else if (v === 0) {
                            e = 0;
                            f = 0;
                            s = 1 / v === -Infinity ? 1 : 0;
                        } else {
                            s = v < 0;
                            v = abs(v);
                            if (v >= pow(2, 1 - bias)) {
                                e = min(floor(log(v) / LN2), 1023);
                                f = roundToEven(v / pow(2, e) * pow(2, fbits));
                                if (f / pow(2, fbits) >= 2) {
                                    e = e + 1;
                                    f = 1;
                                }
                                if (e > bias) {
                                    e = (1 << ebits) - 1;
                                    f = 0;
                                } else {
                                    e = e + bias;
                                    f = f - pow(2, fbits);
                                }
                            } else {
                                e = 0;
                                f = roundToEven(v / pow(2, 1 - bias - fbits));
                            }
                        }
                        bits = [];
                        for (i = fbits; i; i -= 1) {
                            bits.push(f % 2 ? 1 : 0);
                            f = floor(f / 2);
                        }
                        for (i = ebits; i; i -= 1) {
                            bits.push(e % 2 ? 1 : 0);
                            e = floor(e / 2);
                        }
                        bits.push(s ? 1 : 0);
                        bits.reverse();
                        str = bits.join("");
                        bytes = [];
                        while (str.length) {
                            bytes.push(parseInt(str.substring(0, 8), 2));
                            str = str.substring(8);
                        }
                        return bytes;
                    }
                    function unpackIEEE754(bytes, ebits, fbits) {
                        var bits = [], i, j, b, str, bias, s, e, f;
                        for (i = bytes.length; i; i -= 1) {
                            b = bytes[i - 1];
                            for (j = 8; j; j -= 1) {
                                bits.push(b % 2 ? 1 : 0);
                                b = b >> 1;
                            }
                        }
                        bits.reverse();
                        str = bits.join("");
                        bias = (1 << ebits - 1) - 1;
                        s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
                        e = parseInt(str.substring(1, 1 + ebits), 2);
                        f = parseInt(str.substring(1 + ebits), 2);
                        if (e === (1 << ebits) - 1) {
                            return f !== 0 ? NaN : s * Infinity;
                        } else if (e > 0) {
                            return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
                        } else if (f !== 0) {
                            return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
                        } else {
                            return s < 0 ? -0 : 0;
                        }
                    }
                    function unpackF64(b) {
                        return unpackIEEE754(b, 11, 52);
                    }
                    function packF64(v) {
                        return packIEEE754(v, 11, 52);
                    }
                    function unpackF32(b) {
                        return unpackIEEE754(b, 8, 23);
                    }
                    function packF32(v) {
                        return packIEEE754(v, 8, 23);
                    }
                    (function() {
                        var ArrayBuffer = function ArrayBuffer(length) {
                            length = ECMAScript.ToInt32(length);
                            if (length < 0) throw new RangeError("ArrayBuffer size is not a small enough positive integer");
                            this.byteLength = length;
                            this._bytes = [];
                            this._bytes.length = length;
                            var i;
                            for (i = 0; i < this.byteLength; i += 1) {
                                this._bytes[i] = 0;
                            }
                            configureProperties(this);
                        };
                        exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
                        var ArrayBufferView = function ArrayBufferView() {};
                        function makeConstructor(bytesPerElement, pack, unpack) {
                            var ctor;
                            ctor = function(buffer, byteOffset, length) {
                                var array, sequence, i, s;
                                if (!arguments.length || typeof arguments[0] === "number") {
                                    this.length = ECMAScript.ToInt32(arguments[0]);
                                    if (length < 0) throw new RangeError("ArrayBufferView size is not a small enough positive integer");
                                    this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    this.buffer = new ArrayBuffer(this.byteLength);
                                    this.byteOffset = 0;
                                } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
                                    array = arguments[0];
                                    this.length = array.length;
                                    this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    this.buffer = new ArrayBuffer(this.byteLength);
                                    this.byteOffset = 0;
                                    for (i = 0; i < this.length; i += 1) {
                                        this._setter(i, array._getter(i));
                                    }
                                } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
                                    sequence = arguments[0];
                                    this.length = ECMAScript.ToUint32(sequence.length);
                                    this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    this.buffer = new ArrayBuffer(this.byteLength);
                                    this.byteOffset = 0;
                                    for (i = 0; i < this.length; i += 1) {
                                        s = sequence[i];
                                        this._setter(i, Number(s));
                                    }
                                } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
                                    this.buffer = buffer;
                                    this.byteOffset = ECMAScript.ToUint32(byteOffset);
                                    if (this.byteOffset > this.buffer.byteLength) {
                                        throw new RangeError("byteOffset out of range");
                                    }
                                    if (this.byteOffset % this.BYTES_PER_ELEMENT) {
                                        throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
                                    }
                                    if (arguments.length < 3) {
                                        this.byteLength = this.buffer.byteLength - this.byteOffset;
                                        if (this.byteLength % this.BYTES_PER_ELEMENT) {
                                            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
                                        }
                                        this.length = this.byteLength / this.BYTES_PER_ELEMENT;
                                    } else {
                                        this.length = ECMAScript.ToUint32(length);
                                        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                                    }
                                    if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
                                        throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
                                    }
                                } else {
                                    throw new TypeError("Unexpected argument type(s)");
                                }
                                this.constructor = ctor;
                                configureProperties(this);
                                makeArrayAccessors(this);
                            };
                            ctor.prototype = new ArrayBufferView();
                            ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
                            ctor.prototype._pack = pack;
                            ctor.prototype._unpack = unpack;
                            ctor.BYTES_PER_ELEMENT = bytesPerElement;
                            ctor.prototype._getter = function(index) {
                                if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
                                index = ECMAScript.ToUint32(index);
                                if (index >= this.length) {
                                    return undefined;
                                }
                                var bytes = [], i, o;
                                for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, 
                                o += 1) {
                                    bytes.push(this.buffer._bytes[o]);
                                }
                                return this._unpack(bytes);
                            };
                            ctor.prototype.get = ctor.prototype._getter;
                            ctor.prototype._setter = function(index, value) {
                                if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
                                index = ECMAScript.ToUint32(index);
                                if (index >= this.length) {
                                    return undefined;
                                }
                                var bytes = this._pack(value), i, o;
                                for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, 
                                o += 1) {
                                    this.buffer._bytes[o] = bytes[i];
                                }
                            };
                            ctor.prototype.set = function(index, value) {
                                if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
                                var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
                                if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
                                    array = arguments[0];
                                    offset = ECMAScript.ToUint32(arguments[1]);
                                    if (offset + array.length > this.length) {
                                        throw new RangeError("Offset plus length of array is out of range");
                                    }
                                    byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
                                    byteLength = array.length * this.BYTES_PER_ELEMENT;
                                    if (array.buffer === this.buffer) {
                                        tmp = [];
                                        for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                                            tmp[i] = array.buffer._bytes[s];
                                        }
                                        for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                                            this.buffer._bytes[d] = tmp[i];
                                        }
                                    } else {
                                        for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, 
                                        d += 1) {
                                            this.buffer._bytes[d] = array.buffer._bytes[s];
                                        }
                                    }
                                } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
                                    sequence = arguments[0];
                                    len = ECMAScript.ToUint32(sequence.length);
                                    offset = ECMAScript.ToUint32(arguments[1]);
                                    if (offset + len > this.length) {
                                        throw new RangeError("Offset plus length of array is out of range");
                                    }
                                    for (i = 0; i < len; i += 1) {
                                        s = sequence[i];
                                        this._setter(offset + i, Number(s));
                                    }
                                } else {
                                    throw new TypeError("Unexpected argument type(s)");
                                }
                            };
                            ctor.prototype.subarray = function(start, end) {
                                function clamp(v, min, max) {
                                    return v < min ? min : v > max ? max : v;
                                }
                                start = ECMAScript.ToInt32(start);
                                end = ECMAScript.ToInt32(end);
                                if (arguments.length < 1) {
                                    start = 0;
                                }
                                if (arguments.length < 2) {
                                    end = this.length;
                                }
                                if (start < 0) {
                                    start = this.length + start;
                                }
                                if (end < 0) {
                                    end = this.length + end;
                                }
                                start = clamp(start, 0, this.length);
                                end = clamp(end, 0, this.length);
                                var len = end - start;
                                if (len < 0) {
                                    len = 0;
                                }
                                return new this.constructor(this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
                            };
                            return ctor;
                        }
                        var Int8Array = makeConstructor(1, packI8, unpackI8);
                        var Uint8Array = makeConstructor(1, packU8, unpackU8);
                        var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
                        var Int16Array = makeConstructor(2, packI16, unpackI16);
                        var Uint16Array = makeConstructor(2, packU16, unpackU16);
                        var Int32Array = makeConstructor(4, packI32, unpackI32);
                        var Uint32Array = makeConstructor(4, packU32, unpackU32);
                        var Float32Array = makeConstructor(4, packF32, unpackF32);
                        var Float64Array = makeConstructor(8, packF64, unpackF64);
                        exports.Int8Array = exports.Int8Array || Int8Array;
                        exports.Uint8Array = exports.Uint8Array || Uint8Array;
                        exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
                        exports.Int16Array = exports.Int16Array || Int16Array;
                        exports.Uint16Array = exports.Uint16Array || Uint16Array;
                        exports.Int32Array = exports.Int32Array || Int32Array;
                        exports.Uint32Array = exports.Uint32Array || Uint32Array;
                        exports.Float32Array = exports.Float32Array || Float32Array;
                        exports.Float64Array = exports.Float64Array || Float64Array;
                    })();
                    (function() {
                        function r(array, index) {
                            return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
                        }
                        var IS_BIG_ENDIAN = function() {
                            var u16array = new exports.Uint16Array([ 4660 ]), u8array = new exports.Uint8Array(u16array.buffer);
                            return r(u8array, 0) === 18;
                        }();
                        var DataView = function DataView(buffer, byteOffset, byteLength) {
                            if (arguments.length === 0) {
                                buffer = new ArrayBuffer(0);
                            } else if (!(buffer instanceof ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
                                throw new TypeError("TypeError");
                            }
                            this.buffer = buffer || new ArrayBuffer(0);
                            this.byteOffset = ECMAScript.ToUint32(byteOffset);
                            if (this.byteOffset > this.buffer.byteLength) {
                                throw new RangeError("byteOffset out of range");
                            }
                            if (arguments.length < 3) {
                                this.byteLength = this.buffer.byteLength - this.byteOffset;
                            } else {
                                this.byteLength = ECMAScript.ToUint32(byteLength);
                            }
                            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
                                throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
                            }
                            configureProperties(this);
                        };
                        function makeGetter(arrayType) {
                            return function(byteOffset, littleEndian) {
                                byteOffset = ECMAScript.ToUint32(byteOffset);
                                if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
                                    throw new RangeError("Array index out of range");
                                }
                                byteOffset += this.byteOffset;
                                var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
                                for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
                                    bytes.push(r(uint8Array, i));
                                }
                                if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
                                    bytes.reverse();
                                }
                                return r(new arrayType(new Uint8Array(bytes).buffer), 0);
                            };
                        }
                        DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
                        DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
                        DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
                        DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
                        DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
                        DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
                        DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
                        DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
                        function makeSetter(arrayType) {
                            return function(byteOffset, value, littleEndian) {
                                byteOffset = ECMAScript.ToUint32(byteOffset);
                                if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
                                    throw new RangeError("Array index out of range");
                                }
                                var typeArray = new arrayType([ value ]), byteArray = new Uint8Array(typeArray.buffer), bytes = [], i, byteView;
                                for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
                                    bytes.push(r(byteArray, i));
                                }
                                if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
                                    bytes.reverse();
                                }
                                byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
                                byteView.set(bytes);
                            };
                        }
                        DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
                        DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
                        DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
                        DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
                        DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
                        DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
                        DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
                        DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
                        exports.DataView = exports.DataView || DataView;
                    })();
                }, {} ]
            }, {}, []);
            module.exports = require("native-buffer-browserify").Buffer;
        }, {} ],
        2: [ function(require, module, exports) {
            var process = module.exports = {};
            process.nextTick = function() {
                var canSetImmediate = typeof window !== "undefined" && window.setImmediate;
                var canPost = typeof window !== "undefined" && window.postMessage && window.addEventListener;
                if (canSetImmediate) {
                    return function(f) {
                        return window.setImmediate(f);
                    };
                }
                if (canPost) {
                    var queue = [];
                    window.addEventListener("message", function(ev) {
                        if (ev.source === window && ev.data === "process-tick") {
                            ev.stopPropagation();
                            if (queue.length > 0) {
                                var fn = queue.shift();
                                fn();
                            }
                        }
                    }, true);
                    return function nextTick(fn) {
                        queue.push(fn);
                        window.postMessage("process-tick", "*");
                    };
                }
                return function nextTick(fn) {
                    setTimeout(fn, 0);
                };
            }();
            process.title = "browser";
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.binding = function(name) {
                throw new Error("process.binding is not supported");
            };
            process.cwd = function() {
                return "/";
            };
            process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            };
        }, {} ],
        3: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Line.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            var Scalar = require("./Scalar");
            module.exports = Line;
            function Line() {}
            Line.lineInt = function(l1, l2, precision) {
                precision = precision || 0;
                var i = [ 0, 0 ];
                var a1, b1, c1, a2, b2, c2, det;
                a1 = l1[1][1] - l1[0][1];
                b1 = l1[0][0] - l1[1][0];
                c1 = a1 * l1[0][0] + b1 * l1[0][1];
                a2 = l2[1][1] - l2[0][1];
                b2 = l2[0][0] - l2[1][0];
                c2 = a2 * l2[0][0] + b2 * l2[0][1];
                det = a1 * b2 - a2 * b1;
                if (!Scalar.eq(det, 0, precision)) {
                    i[0] = (b2 * c1 - b1 * c2) / det;
                    i[1] = (a1 * c2 - a2 * c1) / det;
                }
                return i;
            };
            Line.segmentsIntersect = function(p1, p2, q1, q2) {
                var dx = p2[0] - p1[0];
                var dy = p2[1] - p1[1];
                var da = q2[0] - q1[0];
                var db = q2[1] - q1[1];
                if (da * dy - db * dx == 0) return false;
                var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
                var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
                return s >= 0 && s <= 1 && t >= 0 && t <= 1;
            };
        }, {
            "./Scalar": 6,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        4: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Point.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            module.exports = Point;
            function Point() {}
            Point.area = function(a, b, c) {
                return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
            };
            Point.left = function(a, b, c) {
                return Point.area(a, b, c) > 0;
            };
            Point.leftOn = function(a, b, c) {
                return Point.area(a, b, c) >= 0;
            };
            Point.right = function(a, b, c) {
                return Point.area(a, b, c) < 0;
            };
            Point.rightOn = function(a, b, c) {
                return Point.area(a, b, c) <= 0;
            };
            var tmpPoint1 = [], tmpPoint2 = [];
            Point.collinear = function(a, b, c, thresholdAngle) {
                if (!thresholdAngle) return Point.area(a, b, c) == 0; else {
                    var ab = tmpPoint1, bc = tmpPoint2;
                    ab[0] = b[0] - a[0];
                    ab[1] = b[1] - a[1];
                    bc[0] = c[0] - b[0];
                    bc[1] = c[1] - b[1];
                    var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
                    return angle < thresholdAngle;
                }
            };
            Point.sqdist = function(a, b) {
                var dx = b[0] - a[0];
                var dy = b[1] - a[1];
                return dx * dx + dy * dy;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        5: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Polygon.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            var Line = require("./Line"), Point = require("./Point"), Scalar = require("./Scalar");
            module.exports = Polygon;
            function Polygon() {
                this.vertices = [];
            }
            Polygon.prototype.at = function(i) {
                var v = this.vertices, s = v.length;
                return v[i < 0 ? i % s + s : i % s];
            };
            Polygon.prototype.first = function() {
                return this.vertices[0];
            };
            Polygon.prototype.last = function() {
                return this.vertices[this.vertices.length - 1];
            };
            Polygon.prototype.clear = function() {
                this.vertices.length = 0;
            };
            Polygon.prototype.append = function(poly, from, to) {
                if (typeof from == "undefined") throw new Error("From is not given!");
                if (typeof to == "undefined") throw new Error("To is not given!");
                if (to - 1 < from) throw new Error("lol1");
                if (to > poly.vertices.length) throw new Error("lol2");
                if (from < 0) throw new Error("lol3");
                for (var i = from; i < to; i++) {
                    this.vertices.push(poly.vertices[i]);
                }
            };
            Polygon.prototype.makeCCW = function() {
                var br = 0, v = this.vertices;
                for (var i = 1; i < this.vertices.length; ++i) {
                    if (v[i][1] < v[br][1] || v[i][1] == v[br][1] && v[i][0] > v[br][0]) {
                        br = i;
                    }
                }
                if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
                    this.reverse();
                }
            };
            Polygon.prototype.reverse = function() {
                var tmp = [];
                for (var i = 0, N = this.vertices.length; i !== N; i++) {
                    tmp.push(this.vertices.pop());
                }
                this.vertices = tmp;
            };
            Polygon.prototype.isReflex = function(i) {
                return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
            };
            var tmpLine1 = [], tmpLine2 = [];
            Polygon.prototype.canSee = function(a, b) {
                var p, dist, l1 = tmpLine1, l2 = tmpLine2;
                if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
                    return false;
                }
                dist = Point.sqdist(this.at(a), this.at(b));
                for (var i = 0; i !== this.vertices.length; ++i) {
                    if ((i + 1) % this.vertices.length === a || i === a) continue;
                    if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) {
                        l1[0] = this.at(a);
                        l1[1] = this.at(b);
                        l2[0] = this.at(i);
                        l2[1] = this.at(i + 1);
                        p = Line.lineInt(l1, l2);
                        if (Point.sqdist(this.at(a), p) < dist) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Polygon.prototype.copy = function(i, j, targetPoly) {
                var p = targetPoly || new Polygon();
                p.clear();
                if (i < j) {
                    for (var k = i; k <= j; k++) p.vertices.push(this.vertices[k]);
                } else {
                    for (var k = 0; k <= j; k++) p.vertices.push(this.vertices[k]);
                    for (var k = i; k < this.vertices.length; k++) p.vertices.push(this.vertices[k]);
                }
                return p;
            };
            Polygon.prototype.getCutEdges = function() {
                var min = [], tmp1 = [], tmp2 = [], tmpPoly = new Polygon();
                var nDiags = Number.MAX_VALUE;
                for (var i = 0; i < this.vertices.length; ++i) {
                    if (this.isReflex(i)) {
                        for (var j = 0; j < this.vertices.length; ++j) {
                            if (this.canSee(i, j)) {
                                tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                                tmp2 = this.copy(j, i, tmpPoly).getCutEdges();
                                for (var k = 0; k < tmp2.length; k++) tmp1.push(tmp2[k]);
                                if (tmp1.length < nDiags) {
                                    min = tmp1;
                                    nDiags = tmp1.length;
                                    min.push([ this.at(i), this.at(j) ]);
                                }
                            }
                        }
                    }
                }
                return min;
            };
            Polygon.prototype.decomp = function() {
                var edges = this.getCutEdges();
                if (edges.length > 0) return this.slice(edges); else return [ this ];
            };
            Polygon.prototype.slice = function(cutEdges) {
                if (cutEdges.length == 0) return [ this ];
                if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length == 2 && cutEdges[0][0] instanceof Array) {
                    var polys = [ this ];
                    for (var i = 0; i < cutEdges.length; i++) {
                        var cutEdge = cutEdges[i];
                        for (var j = 0; j < polys.length; j++) {
                            var poly = polys[j];
                            var result = poly.slice(cutEdge);
                            if (result) {
                                polys.splice(j, 1);
                                polys.push(result[0], result[1]);
                                break;
                            }
                        }
                    }
                    return polys;
                } else {
                    var cutEdge = cutEdges;
                    var i = this.vertices.indexOf(cutEdge[0]);
                    var j = this.vertices.indexOf(cutEdge[1]);
                    if (i != -1 && j != -1) {
                        return [ this.copy(i, j), this.copy(j, i) ];
                    } else {
                        return false;
                    }
                }
            };
            Polygon.prototype.isSimple = function() {
                var path = this.vertices;
                for (var i = 0; i < path.length - 1; i++) {
                    for (var j = 0; j < i - 1; j++) {
                        if (Line.segmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                            return false;
                        }
                    }
                }
                for (var i = 1; i < path.length - 2; i++) {
                    if (Line.segmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
                        return false;
                    }
                }
                return true;
            };
            function getIntersectionPoint(p1, p2, q1, q2, delta) {
                delta = delta || 0;
                var a1 = p2[1] - p1[1];
                var b1 = p1[0] - p2[0];
                var c1 = a1 * p1[0] + b1 * p1[1];
                var a2 = q2[1] - q1[1];
                var b2 = q1[0] - q2[0];
                var c2 = a2 * q1[0] + b2 * q1[1];
                var det = a1 * b2 - a2 * b1;
                if (!Scalar.eq(det, 0, delta)) return [ (b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det ]; else return [ 0, 0 ];
            }
            Polygon.prototype.quickDecomp = function(result, reflexVertices, steinerPoints, delta, maxlevel, level) {
                maxlevel = maxlevel || 100;
                level = level || 0;
                delta = delta || 25;
                result = typeof result != "undefined" ? result : [];
                reflexVertices = reflexVertices || [];
                steinerPoints = steinerPoints || [];
                var upperInt = [ 0, 0 ], lowerInt = [ 0, 0 ], p = [ 0, 0 ];
                var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
                var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
                var lowerPoly = new Polygon(), upperPoly = new Polygon();
                var poly = this, v = this.vertices;
                if (v.length < 3) return result;
                level++;
                if (level > maxlevel) {
                    console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
                    return result;
                }
                for (var i = 0; i < this.vertices.length; ++i) {
                    if (poly.isReflex(i)) {
                        reflexVertices.push(poly.vertices[i]);
                        upperDist = lowerDist = Number.MAX_VALUE;
                        for (var j = 0; j < this.vertices.length; ++j) {
                            if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) {
                                p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1));
                                if (Point.right(poly.at(i + 1), poly.at(i), p)) {
                                    d = Point.sqdist(poly.vertices[i], p);
                                    if (d < lowerDist) {
                                        lowerDist = d;
                                        lowerInt = p;
                                        lowerIndex = j;
                                    }
                                }
                            }
                            if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                                if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                                    d = Point.sqdist(poly.vertices[i], p);
                                    if (d < upperDist) {
                                        upperDist = d;
                                        upperInt = p;
                                        upperIndex = j;
                                    }
                                }
                            }
                        }
                        if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                            p[0] = (lowerInt[0] + upperInt[0]) / 2;
                            p[1] = (lowerInt[1] + upperInt[1]) / 2;
                            steinerPoints.push(p);
                            if (i < upperIndex) {
                                lowerPoly.append(poly, i, upperIndex + 1);
                                lowerPoly.vertices.push(p);
                                upperPoly.vertices.push(p);
                                if (lowerIndex != 0) {
                                    upperPoly.append(poly, lowerIndex, poly.vertices.length);
                                }
                                upperPoly.append(poly, 0, i + 1);
                            } else {
                                if (i != 0) {
                                    lowerPoly.append(poly, i, poly.vertices.length);
                                }
                                lowerPoly.append(poly, 0, upperIndex + 1);
                                lowerPoly.vertices.push(p);
                                upperPoly.vertices.push(p);
                                upperPoly.append(poly, lowerIndex, i + 1);
                            }
                        } else {
                            if (lowerIndex > upperIndex) {
                                upperIndex += this.vertices.length;
                            }
                            closestDist = Number.MAX_VALUE;
                            if (upperIndex < lowerIndex) {
                                return result;
                            }
                            for (var j = lowerIndex; j <= upperIndex; ++j) {
                                if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j)) && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                                    d = Point.sqdist(poly.at(i), poly.at(j));
                                    if (d < closestDist) {
                                        closestDist = d;
                                        closestIndex = j % this.vertices.length;
                                    }
                                }
                            }
                            if (i < closestIndex) {
                                lowerPoly.append(poly, i, closestIndex + 1);
                                if (closestIndex != 0) {
                                    upperPoly.append(poly, closestIndex, v.length);
                                }
                                upperPoly.append(poly, 0, i + 1);
                            } else {
                                if (i != 0) {
                                    lowerPoly.append(poly, i, v.length);
                                }
                                lowerPoly.append(poly, 0, closestIndex + 1);
                                upperPoly.append(poly, closestIndex, i + 1);
                            }
                        }
                        if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                            lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                        } else {
                            upperPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                            lowerPoly.quickDecomp(result, reflexVertices, steinerPoints, delta, maxlevel, level);
                        }
                        return result;
                    }
                }
                result.push(this);
                return result;
            };
            Polygon.prototype.removeCollinearPoints = function(precision) {
                var num = 0;
                for (var i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) {
                    if (Point.collinear(this.at(i - 1), this.at(i), this.at(i + 1), precision)) {
                        this.vertices.splice(i % this.vertices.length, 1);
                        i--;
                        num++;
                    }
                }
                return num;
            };
        }, {
            "./Line": 3,
            "./Point": 4,
            "./Scalar": 6,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        6: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\Scalar.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            module.exports = Scalar;
            function Scalar() {}
            Scalar.eq = function(a, b, precision) {
                precision = precision || 0;
                return Math.abs(a - b) < precision;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        7: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\node_modules\\poly-decomp\\src\\index.js", __dirname = "/..\\node_modules\\poly-decomp\\src";
            module.exports = {
                Polygon: require("./Polygon"),
                Point: require("./Point")
            };
        }, {
            "./Point": 4,
            "./Polygon": 5,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        8: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/..\\package.json", __dirname = "/..";
            module.exports = {
                name: "p2",
                version: "0.6.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: [ "p2.js", "p2", "physics", "engine", "2d" ],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [ {
                    type: "MIT"
                } ],
                devDependencies: {
                    grunt: "~0.4.0",
                    "grunt-contrib-jshint": "~0.9.2",
                    "grunt-contrib-nodeunit": "~0.1.2",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        9: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\AABB.js", __dirname = "/collision";
            var vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = AABB;
            function AABB(options) {
                this.lowerBound = vec2.create();
                if (options && options.lowerBound) {
                    vec2.copy(this.lowerBound, options.lowerBound);
                }
                this.upperBound = vec2.create();
                if (options && options.upperBound) {
                    vec2.copy(this.upperBound, options.upperBound);
                }
            }
            var tmp = vec2.create();
            AABB.prototype.setFromPoints = function(points, position, angle, skinSize) {
                var l = this.lowerBound, u = this.upperBound;
                if (typeof angle !== "number") {
                    angle = 0;
                }
                if (angle !== 0) {
                    vec2.rotate(l, points[0], angle);
                } else {
                    vec2.copy(l, points[0]);
                }
                vec2.copy(u, l);
                var cosAngle = Math.cos(angle), sinAngle = Math.sin(angle);
                for (var i = 1; i < points.length; i++) {
                    var p = points[i];
                    if (angle !== 0) {
                        var x = p[0], y = p[1];
                        tmp[0] = cosAngle * x - sinAngle * y;
                        tmp[1] = sinAngle * x + cosAngle * y;
                        p = tmp;
                    }
                    for (var j = 0; j < 2; j++) {
                        if (p[j] > u[j]) {
                            u[j] = p[j];
                        }
                        if (p[j] < l[j]) {
                            l[j] = p[j];
                        }
                    }
                }
                if (position) {
                    vec2.add(this.lowerBound, this.lowerBound, position);
                    vec2.add(this.upperBound, this.upperBound, position);
                }
                if (skinSize) {
                    this.lowerBound[0] -= skinSize;
                    this.lowerBound[1] -= skinSize;
                    this.upperBound[0] += skinSize;
                    this.upperBound[1] += skinSize;
                }
            };
            AABB.prototype.copy = function(aabb) {
                vec2.copy(this.lowerBound, aabb.lowerBound);
                vec2.copy(this.upperBound, aabb.upperBound);
            };
            AABB.prototype.extend = function(aabb) {
                var i = 2;
                while (i--) {
                    var l = aabb.lowerBound[i];
                    if (this.lowerBound[i] > l) {
                        this.lowerBound[i] = l;
                    }
                    var u = aabb.upperBound[i];
                    if (this.upperBound[i] < u) {
                        this.upperBound[i] = u;
                    }
                }
            };
            AABB.prototype.overlaps = function(aabb) {
                var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
                return (l2[0] <= u1[0] && u1[0] <= u2[0] || l1[0] <= u2[0] && u2[0] <= u1[0]) && (l2[1] <= u1[1] && u1[1] <= u2[1] || l1[1] <= u2[1] && u2[1] <= u1[1]);
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        10: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\Broadphase.js", __dirname = "/collision";
            var vec2 = require("../math/vec2");
            var Body = require("../objects/Body");
            module.exports = Broadphase;
            function Broadphase(type) {
                this.type = type;
                this.result = [];
                this.world = null;
                this.boundingVolumeType = Broadphase.AABB;
            }
            Broadphase.AABB = 1;
            Broadphase.BOUNDING_CIRCLE = 2;
            Broadphase.prototype.setWorld = function(world) {
                this.world = world;
            };
            Broadphase.prototype.getCollisionPairs = function(world) {
                throw new Error("getCollisionPairs must be implemented in a subclass!");
            };
            var dist = vec2.create();
            Broadphase.boundingRadiusCheck = function(bodyA, bodyB) {
                vec2.sub(dist, bodyA.position, bodyB.position);
                var d2 = vec2.squaredLength(dist), r = bodyA.boundingRadius + bodyB.boundingRadius;
                return d2 <= r * r;
            };
            Broadphase.aabbCheck = function(bodyA, bodyB) {
                return bodyA.getAABB().overlaps(bodyB.getAABB());
            };
            Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB) {
                var result;
                switch (this.boundingVolumeType) {
                  case Broadphase.BOUNDING_CIRCLE:
                    result = Broadphase.boundingRadiusCheck(bodyA, bodyB);
                    break;

                  case Broadphase.AABB:
                    result = Broadphase.aabbCheck(bodyA, bodyB);
                    break;

                  default:
                    throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
                }
                return result;
            };
            Broadphase.canCollide = function(bodyA, bodyB) {
                if (bodyA.type === Body.STATIC && bodyB.type === Body.STATIC) {
                    return false;
                }
                if (bodyA.type === Body.KINEMATIC && bodyB.type === Body.STATIC || bodyA.type === Body.STATIC && bodyB.type === Body.KINEMATIC) {
                    return false;
                }
                if (bodyA.type === Body.KINEMATIC && bodyB.type === Body.KINEMATIC) {
                    return false;
                }
                if (bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING) {
                    return false;
                }
                if (bodyA.sleepState === Body.SLEEPING && bodyB.type === Body.STATIC || bodyB.sleepState === Body.SLEEPING && bodyA.type === Body.STATIC) {
                    return false;
                }
                return true;
            };
            Broadphase.NAIVE = 1;
            Broadphase.SAP = 2;
        }, {
            "../math/vec2": 31,
            "../objects/Body": 32,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        11: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\GridBroadphase.js", __dirname = "/collision";
            var Circle = require("../shapes/Circle"), Plane = require("../shapes/Plane"), Particle = require("../shapes/Particle"), Broadphase = require("../collision/Broadphase"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = GridBroadphase;
            function GridBroadphase(options) {
                Broadphase.apply(this);
                options = Utils.defaults(options, {
                    xmin: -100,
                    xmax: 100,
                    ymin: -100,
                    ymax: 100,
                    nx: 10,
                    ny: 10
                });
                this.xmin = options.xmin;
                this.ymin = options.ymin;
                this.xmax = options.xmax;
                this.ymax = options.ymax;
                this.nx = options.nx;
                this.ny = options.ny;
                this.binsizeX = (this.xmax - this.xmin) / this.nx;
                this.binsizeY = (this.ymax - this.ymin) / this.ny;
            }
            GridBroadphase.prototype = new Broadphase();
            GridBroadphase.prototype.getCollisionPairs = function(world) {
                var result = [], bodies = world.bodies, Ncolliding = bodies.length, binsizeX = this.binsizeX, binsizeY = this.binsizeY, nx = this.nx, ny = this.ny, xmin = this.xmin, ymin = this.ymin, xmax = this.xmax, ymax = this.ymax;
                var bins = [], Nbins = nx * ny;
                for (var i = 0; i < Nbins; i++) {
                    bins.push([]);
                }
                var xmult = nx / (xmax - xmin);
                var ymult = ny / (ymax - ymin);
                for (var i = 0; i !== Ncolliding; i++) {
                    var bi = bodies[i];
                    var aabb = bi.aabb;
                    var lowerX = Math.max(aabb.lowerBound[0], xmin);
                    var lowerY = Math.max(aabb.lowerBound[1], ymin);
                    var upperX = Math.min(aabb.upperBound[0], xmax);
                    var upperY = Math.min(aabb.upperBound[1], ymax);
                    var xi1 = Math.floor(xmult * (lowerX - xmin));
                    var yi1 = Math.floor(ymult * (lowerY - ymin));
                    var xi2 = Math.floor(xmult * (upperX - xmin));
                    var yi2 = Math.floor(ymult * (upperY - ymin));
                    for (var j = xi1; j <= xi2; j++) {
                        for (var k = yi1; k <= yi2; k++) {
                            var xi = j;
                            var yi = k;
                            var idx = xi * (ny - 1) + yi;
                            if (idx >= 0 && idx < Nbins) {
                                bins[idx].push(bi);
                            }
                        }
                    }
                }
                for (var i = 0; i !== Nbins; i++) {
                    var bin = bins[i];
                    for (var j = 0, NbodiesInBin = bin.length; j !== NbodiesInBin; j++) {
                        var bi = bin[j];
                        for (var k = 0; k !== j; k++) {
                            var bj = bin[k];
                            if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                                result.push(bi, bj);
                            }
                        }
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 10,
            "../math/vec2": 31,
            "../shapes/Circle": 38,
            "../shapes/Particle": 42,
            "../shapes/Plane": 43,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        12: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\NaiveBroadphase.js", __dirname = "/collision";
            var Circle = require("../shapes/Circle"), Plane = require("../shapes/Plane"), Shape = require("../shapes/Shape"), Particle = require("../shapes/Particle"), Broadphase = require("../collision/Broadphase"), vec2 = require("../math/vec2");
            module.exports = NaiveBroadphase;
            function NaiveBroadphase() {
                Broadphase.call(this, Broadphase.NAIVE);
            }
            NaiveBroadphase.prototype = new Broadphase();
            NaiveBroadphase.prototype.getCollisionPairs = function(world) {
                var bodies = world.bodies, result = this.result;
                result.length = 0;
                for (var i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++) {
                    var bi = bodies[i];
                    for (var j = 0; j < i; j++) {
                        var bj = bodies[j];
                        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                            result.push(bi, bj);
                        }
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 10,
            "../math/vec2": 31,
            "../shapes/Circle": 38,
            "../shapes/Particle": 42,
            "../shapes/Plane": 43,
            "../shapes/Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        13: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\Narrowphase.js", __dirname = "/collision";
            var vec2 = require("../math/vec2"), sub = vec2.sub, add = vec2.add, dot = vec2.dot, Utils = require("../utils/Utils"), TupleDictionary = require("../utils/TupleDictionary"), Equation = require("../equations/Equation"), ContactEquation = require("../equations/ContactEquation"), FrictionEquation = require("../equations/FrictionEquation"), Circle = require("../shapes/Circle"), Convex = require("../shapes/Convex"), Shape = require("../shapes/Shape"), Body = require("../objects/Body"), Rectangle = require("../shapes/Rectangle");
            module.exports = Narrowphase;
            var yAxis = vec2.fromValues(0, 1);
            var tmp1 = vec2.fromValues(0, 0), tmp2 = vec2.fromValues(0, 0), tmp3 = vec2.fromValues(0, 0), tmp4 = vec2.fromValues(0, 0), tmp5 = vec2.fromValues(0, 0), tmp6 = vec2.fromValues(0, 0), tmp7 = vec2.fromValues(0, 0), tmp8 = vec2.fromValues(0, 0), tmp9 = vec2.fromValues(0, 0), tmp10 = vec2.fromValues(0, 0), tmp11 = vec2.fromValues(0, 0), tmp12 = vec2.fromValues(0, 0), tmp13 = vec2.fromValues(0, 0), tmp14 = vec2.fromValues(0, 0), tmp15 = vec2.fromValues(0, 0), tmp16 = vec2.fromValues(0, 0), tmp17 = vec2.fromValues(0, 0), tmp18 = vec2.fromValues(0, 0), tmpArray = [];
            function Narrowphase() {
                this.contactEquations = [];
                this.frictionEquations = [];
                this.enableFriction = true;
                this.slipForce = 10;
                this.frictionCoefficient = .3;
                this.surfaceVelocity = 0;
                this.reuseObjects = true;
                this.reusableContactEquations = [];
                this.reusableFrictionEquations = [];
                this.restitution = 0;
                this.stiffness = Equation.DEFAULT_STIFFNESS;
                this.relaxation = Equation.DEFAULT_RELAXATION;
                this.frictionStiffness = Equation.DEFAULT_STIFFNESS;
                this.frictionRelaxation = Equation.DEFAULT_RELAXATION;
                this.enableFrictionReduction = true;
                this.collidingBodiesLastStep = new TupleDictionary();
                this.contactSkinSize = .01;
            }
            Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB) {
                var id1 = bodyA.id | 0, id2 = bodyB.id | 0;
                return !!this.collidingBodiesLastStep.get(id1, id2);
            };
            Narrowphase.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                var eqs = this.contactEquations;
                var l = eqs.length;
                while (l--) {
                    var eq = eqs[l], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
                    this.collidingBodiesLastStep.set(id1, id2, true);
                }
                if (this.reuseObjects) {
                    var ce = this.contactEquations, fe = this.frictionEquations, rfe = this.reusableFrictionEquations, rce = this.reusableContactEquations;
                    Utils.appendArray(rce, ce);
                    Utils.appendArray(rfe, fe);
                }
                this.contactEquations.length = this.frictionEquations.length = 0;
            };
            Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB) {
                var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA, bodyB);
                c.bodyA = bodyA;
                c.bodyB = bodyB;
                c.shapeA = shapeA;
                c.shapeB = shapeB;
                c.restitution = this.restitution;
                c.firstImpact = !this.collidedLastStep(bodyA, bodyB);
                c.stiffness = this.stiffness;
                c.relaxation = this.relaxation;
                c.needsUpdate = true;
                c.enabled = true;
                c.offset = this.contactSkinSize;
                return c;
            };
            Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB) {
                var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA, bodyB);
                c.bodyA = bodyA;
                c.bodyB = bodyB;
                c.shapeA = shapeA;
                c.shapeB = shapeB;
                c.setSlipForce(this.slipForce);
                c.frictionCoefficient = this.frictionCoefficient;
                c.relativeVelocity = this.surfaceVelocity;
                c.enabled = true;
                c.needsUpdate = true;
                c.stiffness = this.frictionStiffness;
                c.relaxation = this.frictionRelaxation;
                c.contactEquations.length = 0;
                return c;
            };
            Narrowphase.prototype.createFrictionFromContact = function(c) {
                var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                vec2.copy(eq.contactPointA, c.contactPointA);
                vec2.copy(eq.contactPointB, c.contactPointB);
                vec2.rotate90cw(eq.t, c.normalA);
                eq.contactEquations.push(c);
                return eq;
            };
            Narrowphase.prototype.createFrictionFromAverage = function(numContacts) {
                if (!numContacts) {
                    throw new Error("numContacts == 0!");
                }
                var c = this.contactEquations[this.contactEquations.length - 1];
                var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
                var bodyA = c.bodyA;
                var bodyB = c.bodyB;
                vec2.set(eq.contactPointA, 0, 0);
                vec2.set(eq.contactPointB, 0, 0);
                vec2.set(eq.t, 0, 0);
                for (var i = 0; i !== numContacts; i++) {
                    c = this.contactEquations[this.contactEquations.length - 1 - i];
                    if (c.bodyA === bodyA) {
                        vec2.add(eq.t, eq.t, c.normalA);
                        vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                        vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
                    } else {
                        vec2.sub(eq.t, eq.t, c.normalA);
                        vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
                        vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
                    }
                    eq.contactEquations.push(c);
                }
                var invNumContacts = 1 / numContacts;
                vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
                vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
                vec2.normalize(eq.t, eq.t);
                vec2.rotate90cw(eq.t, eq.t);
                return eq;
            };
            Narrowphase.prototype[Shape.LINE | Shape.CONVEX] = Narrowphase.prototype.convexLine = function(convexBody, convexShape, convexOffset, convexAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            Narrowphase.prototype[Shape.LINE | Shape.RECTANGLE] = Narrowphase.prototype.lineRectangle = function(lineBody, lineShape, lineOffset, lineAngle, rectangleBody, rectangleShape, rectangleOffset, rectangleAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {
                vec2.set(convexShape.vertices[0], -capsuleShape.length * .5, -capsuleShape.radius);
                vec2.set(convexShape.vertices[1], capsuleShape.length * .5, -capsuleShape.radius);
                vec2.set(convexShape.vertices[2], capsuleShape.length * .5, capsuleShape.radius);
                vec2.set(convexShape.vertices[3], -capsuleShape.length * .5, capsuleShape.radius);
            }
            var convexCapsule_tempRect = new Rectangle(1, 1), convexCapsule_tempVec = vec2.create();
            Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] = Narrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] = Narrowphase.prototype.convexCapsule = function(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                var circlePos = convexCapsule_tempVec;
                vec2.set(circlePos, capsuleShape.length / 2, 0);
                vec2.rotate(circlePos, circlePos, capsuleAngle);
                vec2.add(circlePos, circlePos, capsulePosition);
                var result1 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                vec2.set(circlePos, -capsuleShape.length / 2, 0);
                vec2.rotate(circlePos, circlePos, capsuleAngle);
                vec2.add(circlePos, circlePos, capsulePosition);
                var result2 = this.circleConvex(capsuleBody, capsuleShape, circlePos, capsuleAngle, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
                if (justTest && (result1 || result2)) {
                    return true;
                }
                var r = convexCapsule_tempRect;
                setConvexToCapsuleShapeMiddle(r, capsuleShape);
                var result = this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);
                return result + result1 + result2;
            };
            Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] = Narrowphase.prototype.lineCapsule = function(lineBody, lineShape, linePosition, lineAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            var capsuleCapsule_tempVec1 = vec2.create();
            var capsuleCapsule_tempVec2 = vec2.create();
            var capsuleCapsule_tempRect1 = new Rectangle(1, 1);
            Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] = Narrowphase.prototype.capsuleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                var enableFrictionBefore;
                var circlePosi = capsuleCapsule_tempVec1, circlePosj = capsuleCapsule_tempVec2;
                var numContacts = 0;
                for (var i = 0; i < 2; i++) {
                    vec2.set(circlePosi, (i === 0 ? -1 : 1) * si.length / 2, 0);
                    vec2.rotate(circlePosi, circlePosi, ai);
                    vec2.add(circlePosi, circlePosi, xi);
                    for (var j = 0; j < 2; j++) {
                        vec2.set(circlePosj, (j === 0 ? -1 : 1) * sj.length / 2, 0);
                        vec2.rotate(circlePosj, circlePosj, aj);
                        vec2.add(circlePosj, circlePosj, xj);
                        if (this.enableFrictionReduction) {
                            enableFrictionBefore = this.enableFriction;
                            this.enableFriction = false;
                        }
                        var result = this.circleCircle(bi, si, circlePosi, ai, bj, sj, circlePosj, aj, justTest, si.radius, sj.radius);
                        if (this.enableFrictionReduction) {
                            this.enableFriction = enableFrictionBefore;
                        }
                        if (justTest && result) {
                            return true;
                        }
                        numContacts += result;
                    }
                }
                if (this.enableFrictionReduction) {
                    enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                var rect = capsuleCapsule_tempRect1;
                setConvexToCapsuleShapeMiddle(rect, si);
                var result1 = this.convexCapsule(bi, rect, xi, ai, bj, sj, xj, aj, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest && result1) {
                    return true;
                }
                numContacts += result1;
                if (this.enableFrictionReduction) {
                    var enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                setConvexToCapsuleShapeMiddle(rect, sj);
                var result2 = this.convexCapsule(bj, rect, xj, aj, bi, si, xi, ai, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest && result2) {
                    return true;
                }
                numContacts += result2;
                if (this.enableFrictionReduction) {
                    if (numContacts && this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            Narrowphase.prototype[Shape.LINE | Shape.LINE] = Narrowphase.prototype.lineLine = function(bodyA, shapeA, positionA, angleA, bodyB, shapeB, positionB, angleB, justTest) {
                if (justTest) {
                    return false;
                } else {
                    return 0;
                }
            };
            Narrowphase.prototype[Shape.PLANE | Shape.LINE] = Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldVertex01 = tmp3, worldVertex11 = tmp4, worldEdge = tmp5, worldEdgeUnit = tmp6, dist = tmp7, worldNormal = tmp8, worldTangent = tmp9, verts = tmpArray, numContacts = 0;
                vec2.set(worldVertex0, -lineShape.length / 2, 0);
                vec2.set(worldVertex1, lineShape.length / 2, 0);
                vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                add(worldVertex01, worldVertex01, lineOffset);
                add(worldVertex11, worldVertex11, lineOffset);
                vec2.copy(worldVertex0, worldVertex01);
                vec2.copy(worldVertex1, worldVertex11);
                sub(worldEdge, worldVertex1, worldVertex0);
                vec2.normalize(worldEdgeUnit, worldEdge);
                vec2.rotate90cw(worldTangent, worldEdgeUnit);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                verts[0] = worldVertex0;
                verts[1] = worldVertex1;
                for (var i = 0; i < verts.length; i++) {
                    var v = verts[i];
                    sub(dist, v, planeOffset);
                    var d = dot(dist, worldNormal);
                    if (d < 0) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(planeBody, lineBody, planeShape, lineShape);
                        numContacts++;
                        vec2.copy(c.normalA, worldNormal);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(dist, worldNormal, d);
                        sub(c.contactPointA, v, dist);
                        sub(c.contactPointA, c.contactPointA, planeBody.position);
                        sub(c.contactPointB, v, lineOffset);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (!this.enableFrictionReduction) {
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (justTest) {
                    return false;
                }
                if (!this.enableFrictionReduction) {
                    if (numContacts && this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] = Narrowphase.prototype.particleCapsule = function(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
                return this.circleLine(particleBody, particleShape, particlePosition, particleAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] = Narrowphase.prototype.circleLine = function(circleBody, circleShape, circleOffset, circleAngle, lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
                var lineRadius = lineRadius || 0, circleRadius = typeof circleRadius !== "undefined" ? circleRadius : circleShape.radius, orthoDist = tmp1, lineToCircleOrthoUnit = tmp2, projectedPoint = tmp3, centerDist = tmp4, worldTangent = tmp5, worldEdge = tmp6, worldEdgeUnit = tmp7, worldVertex0 = tmp8, worldVertex1 = tmp9, worldVertex01 = tmp10, worldVertex11 = tmp11, dist = tmp12, lineToCircle = tmp13, lineEndToLineRadius = tmp14, verts = tmpArray;
                vec2.set(worldVertex0, -lineShape.length / 2, 0);
                vec2.set(worldVertex1, lineShape.length / 2, 0);
                vec2.rotate(worldVertex01, worldVertex0, lineAngle);
                vec2.rotate(worldVertex11, worldVertex1, lineAngle);
                add(worldVertex01, worldVertex01, lineOffset);
                add(worldVertex11, worldVertex11, lineOffset);
                vec2.copy(worldVertex0, worldVertex01);
                vec2.copy(worldVertex1, worldVertex11);
                sub(worldEdge, worldVertex1, worldVertex0);
                vec2.normalize(worldEdgeUnit, worldEdge);
                vec2.rotate90cw(worldTangent, worldEdgeUnit);
                sub(dist, circleOffset, worldVertex0);
                var d = dot(dist, worldTangent);
                sub(centerDist, worldVertex0, lineOffset);
                sub(lineToCircle, circleOffset, lineOffset);
                var radiusSum = circleRadius + lineRadius;
                if (Math.abs(d) < radiusSum) {
                    vec2.scale(orthoDist, worldTangent, d);
                    sub(projectedPoint, circleOffset, orthoDist);
                    vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
                    vec2.normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
                    vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
                    add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
                    var pos = dot(worldEdgeUnit, projectedPoint);
                    var pos0 = dot(worldEdgeUnit, worldVertex0);
                    var pos1 = dot(worldEdgeUnit, worldVertex1);
                    if (pos > pos0 && pos < pos1) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                        vec2.scale(c.normalA, orthoDist, -1);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(c.contactPointA, c.normalA, circleRadius);
                        add(c.contactPointA, c.contactPointA, circleOffset);
                        sub(c.contactPointA, c.contactPointA, circleBody.position);
                        sub(c.contactPointB, projectedPoint, lineOffset);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                }
                verts[0] = worldVertex0;
                verts[1] = worldVertex1;
                for (var i = 0; i < verts.length; i++) {
                    var v = verts[i];
                    sub(dist, v, circleOffset);
                    if (vec2.squaredLength(dist) < Math.pow(radiusSum, 2)) {
                        if (justTest) {
                            return true;
                        }
                        var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                        vec2.copy(c.normalA, dist);
                        vec2.normalize(c.normalA, c.normalA);
                        vec2.scale(c.contactPointA, c.normalA, circleRadius);
                        add(c.contactPointA, c.contactPointA, circleOffset);
                        sub(c.contactPointA, c.contactPointA, circleBody.position);
                        sub(c.contactPointB, v, lineOffset);
                        vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
                        add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
                        add(c.contactPointB, c.contactPointB, lineOffset);
                        sub(c.contactPointB, c.contactPointB, lineBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                        return 1;
                    }
                }
                return 0;
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] = Narrowphase.prototype.circleCapsule = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                return this.circleLine(bi, si, xi, ai, bj, sj, xj, aj, justTest, sj.radius);
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] = Narrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] = Narrowphase.prototype.circleConvex = function(circleBody, circleShape, circleOffset, circleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
                var circleRadius = typeof circleRadius === "number" ? circleRadius : circleShape.radius;
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldNormal = tmp5, centerDist = tmp6, convexToCircle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, candidate = tmp14, candidateDist = tmp15, minCandidate = tmp16, found = false, minCandidateDistance = Number.MAX_VALUE;
                var numReported = 0;
                var verts = convexShape.vertices;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    vec2.rotate90cw(worldNormal, worldEdgeUnit);
                    vec2.scale(candidate, worldNormal, -circleShape.radius);
                    add(candidate, candidate, circleOffset);
                    if (pointInConvex(candidate, convexShape, convexOffset, convexAngle)) {
                        vec2.sub(candidateDist, worldVertex0, candidate);
                        var candidateDistance = Math.abs(vec2.dot(candidateDist, worldNormal));
                        if (candidateDistance < minCandidateDistance) {
                            vec2.copy(minCandidate, candidate);
                            minCandidateDistance = candidateDistance;
                            vec2.scale(closestEdgeProjectedPoint, worldNormal, candidateDistance);
                            vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
                            found = true;
                        }
                    }
                }
                if (found) {
                    if (justTest) {
                        return true;
                    }
                    var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                    vec2.sub(c.normalA, minCandidate, circleOffset);
                    vec2.normalize(c.normalA, c.normalA);
                    vec2.scale(c.contactPointA, c.normalA, circleRadius);
                    add(c.contactPointA, c.contactPointA, circleOffset);
                    sub(c.contactPointA, c.contactPointA, circleBody.position);
                    sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
                if (circleRadius > 0) {
                    for (var i = 0; i < verts.length; i++) {
                        var localVertex = verts[i];
                        vec2.rotate(worldVertex, localVertex, convexAngle);
                        add(worldVertex, worldVertex, convexOffset);
                        sub(dist, worldVertex, circleOffset);
                        if (vec2.squaredLength(dist) < Math.pow(circleRadius, 2)) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                            vec2.copy(c.normalA, dist);
                            vec2.normalize(c.normalA, c.normalA);
                            vec2.scale(c.contactPointA, c.normalA, circleRadius);
                            add(c.contactPointA, c.contactPointA, circleOffset);
                            sub(c.contactPointA, c.contactPointA, circleBody.position);
                            sub(c.contactPointB, worldVertex, convexOffset);
                            add(c.contactPointB, c.contactPointB, convexOffset);
                            sub(c.contactPointB, c.contactPointB, convexBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                            return 1;
                        }
                    }
                }
                return 0;
            };
            var pic_worldVertex0 = vec2.create(), pic_worldVertex1 = vec2.create(), pic_r0 = vec2.create(), pic_r1 = vec2.create();
            function pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {
                var worldVertex0 = pic_worldVertex0, worldVertex1 = pic_worldVertex1, r0 = pic_r0, r1 = pic_r1, point = worldPoint, verts = convexShape.vertices, lastCross = null;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(r0, worldVertex0, point);
                    sub(r1, worldVertex1, point);
                    var cross = vec2.crossLength(r0, r1);
                    if (lastCross === null) {
                        lastCross = cross;
                    }
                    if (cross * lastCross <= 0) {
                        return false;
                    }
                    lastCross = cross;
                }
                return true;
            }
            Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] = Narrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] = Narrowphase.prototype.particleConvex = function(particleBody, particleShape, particleOffset, particleAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldTangent = tmp5, centerDist = tmp6, convexToparticle = tmp7, orthoDist = tmp8, projectedPoint = tmp9, dist = tmp10, worldVertex = tmp11, closestEdge = -1, closestEdgeDistance = null, closestEdgeOrthoDist = tmp12, closestEdgeProjectedPoint = tmp13, r0 = tmp14, r1 = tmp15, localPoint = tmp16, candidateDist = tmp17, minEdgeNormal = tmp18, minCandidateDistance = Number.MAX_VALUE;
                var numReported = 0, found = false, verts = convexShape.vertices;
                if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var lastCross = null;
                for (var i = 0; i !== verts.length + 1; i++) {
                    var v0 = verts[i % verts.length], v1 = verts[(i + 1) % verts.length];
                    vec2.rotate(worldVertex0, v0, convexAngle);
                    vec2.rotate(worldVertex1, v1, convexAngle);
                    add(worldVertex0, worldVertex0, convexOffset);
                    add(worldVertex1, worldVertex1, convexOffset);
                    sub(worldEdge, worldVertex1, worldVertex0);
                    vec2.normalize(worldEdgeUnit, worldEdge);
                    vec2.rotate90cw(worldTangent, worldEdgeUnit);
                    sub(dist, particleOffset, worldVertex0);
                    var d = dot(dist, worldTangent);
                    sub(centerDist, worldVertex0, convexOffset);
                    sub(convexToparticle, particleOffset, convexOffset);
                    vec2.sub(candidateDist, worldVertex0, particleOffset);
                    var candidateDistance = Math.abs(vec2.dot(candidateDist, worldTangent));
                    if (candidateDistance < minCandidateDistance) {
                        minCandidateDistance = candidateDistance;
                        vec2.scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);
                        vec2.add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
                        vec2.copy(minEdgeNormal, worldTangent);
                        found = true;
                    }
                }
                if (found) {
                    var c = this.createContactEquation(particleBody, convexBody, particleShape, convexShape);
                    vec2.scale(c.normalA, minEdgeNormal, -1);
                    vec2.normalize(c.normalA, c.normalA);
                    vec2.set(c.contactPointA, 0, 0);
                    add(c.contactPointA, c.contactPointA, particleOffset);
                    sub(c.contactPointA, c.contactPointA, particleBody.position);
                    sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
                return 0;
            };
            Narrowphase.prototype[Shape.CIRCLE] = Narrowphase.prototype.circleCircle = function(bodyA, shapeA, offsetA, angleA, bodyB, shapeB, offsetB, angleB, justTest, radiusA, radiusB) {
                var dist = tmp1, radiusA = radiusA || shapeA.radius, radiusB = radiusB || shapeB.radius;
                sub(dist, offsetA, offsetB);
                var r = radiusA + radiusB;
                if (vec2.squaredLength(dist) > Math.pow(r, 2)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                sub(c.normalA, offsetB, offsetA);
                vec2.normalize(c.normalA, c.normalA);
                vec2.scale(c.contactPointA, c.normalA, radiusA);
                vec2.scale(c.contactPointB, c.normalA, -radiusB);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] = Narrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] = Narrowphase.prototype.planeConvex = function(planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
                var worldVertex = tmp1, worldNormal = tmp2, dist = tmp3;
                var numReported = 0;
                vec2.rotate(worldNormal, yAxis, planeAngle);
                for (var i = 0; i !== convexShape.vertices.length; i++) {
                    var v = convexShape.vertices[i];
                    vec2.rotate(worldVertex, v, convexAngle);
                    add(worldVertex, worldVertex, convexOffset);
                    sub(dist, worldVertex, planeOffset);
                    if (dot(dist, worldNormal) <= 0) {
                        if (justTest) {
                            return true;
                        }
                        numReported++;
                        var c = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);
                        sub(dist, worldVertex, planeOffset);
                        vec2.copy(c.normalA, worldNormal);
                        var d = dot(dist, c.normalA);
                        vec2.scale(dist, c.normalA, d);
                        sub(c.contactPointB, worldVertex, convexBody.position);
                        sub(c.contactPointA, worldVertex, dist);
                        sub(c.contactPointA, c.contactPointA, planeBody.position);
                        this.contactEquations.push(c);
                        if (!this.enableFrictionReduction) {
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (this.enableFrictionReduction) {
                    if (this.enableFriction && numReported) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numReported));
                    }
                }
                return numReported;
            };
            Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] = Narrowphase.prototype.particlePlane = function(particleBody, particleShape, particleOffset, particleAngle, planeBody, planeShape, planeOffset, planeAngle, justTest) {
                var dist = tmp1, worldNormal = tmp2;
                planeAngle = planeAngle || 0;
                sub(dist, particleOffset, planeOffset);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                var d = dot(dist, worldNormal);
                if (d > 0) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(planeBody, particleBody, planeShape, particleShape);
                vec2.copy(c.normalA, worldNormal);
                vec2.scale(dist, c.normalA, d);
                sub(c.contactPointA, particleOffset, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                sub(c.contactPointB, particleOffset, particleBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] = Narrowphase.prototype.circleParticle = function(circleBody, circleShape, circleOffset, circleAngle, particleBody, particleShape, particleOffset, particleAngle, justTest) {
                var dist = tmp1;
                sub(dist, particleOffset, circleOffset);
                if (vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var c = this.createContactEquation(circleBody, particleBody, circleShape, particleShape);
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA, c.normalA);
                vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, particleOffset, particleBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            };
            var planeCapsule_tmpCircle = new Circle(1), planeCapsule_tmp1 = vec2.create(), planeCapsule_tmp2 = vec2.create(), planeCapsule_tmp3 = vec2.create();
            Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] = Narrowphase.prototype.planeCapsule = function(planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
                var end1 = planeCapsule_tmp1, end2 = planeCapsule_tmp2, circle = planeCapsule_tmpCircle, dst = planeCapsule_tmp3;
                vec2.set(end1, -capsuleShape.length / 2, 0);
                vec2.rotate(end1, end1, capsuleAngle);
                add(end1, end1, capsuleOffset);
                vec2.set(end2, capsuleShape.length / 2, 0);
                vec2.rotate(end2, end2, capsuleAngle);
                add(end2, end2, capsuleOffset);
                circle.radius = capsuleShape.radius;
                var enableFrictionBefore;
                if (this.enableFrictionReduction) {
                    enableFrictionBefore = this.enableFriction;
                    this.enableFriction = false;
                }
                var numContacts1 = this.circlePlane(capsuleBody, circle, end1, 0, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = this.circlePlane(capsuleBody, circle, end2, 0, planeBody, planeShape, planeOffset, planeAngle, justTest);
                if (this.enableFrictionReduction) {
                    this.enableFriction = enableFrictionBefore;
                }
                if (justTest) {
                    return numContacts1 || numContacts2;
                } else {
                    var numTotal = numContacts1 + numContacts2;
                    if (this.enableFrictionReduction) {
                        if (numTotal) {
                            this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
                        }
                    }
                    return numTotal;
                }
            };
            Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] = Narrowphase.prototype.circlePlane = function(bi, si, xi, ai, bj, sj, xj, aj, justTest) {
                var circleBody = bi, circleShape = si, circleOffset = xi, planeBody = bj, shapeB = sj, planeOffset = xj, planeAngle = aj;
                planeAngle = planeAngle || 0;
                var planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
                sub(planeToCircle, circleOffset, planeOffset);
                vec2.rotate(worldNormal, yAxis, planeAngle);
                var d = dot(worldNormal, planeToCircle);
                if (d > circleShape.radius) {
                    return 0;
                }
                if (justTest) {
                    return true;
                }
                var contact = this.createContactEquation(planeBody, circleBody, sj, si);
                vec2.copy(contact.normalA, worldNormal);
                vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
                add(contact.contactPointB, contact.contactPointB, circleOffset);
                sub(contact.contactPointB, contact.contactPointB, circleBody.position);
                vec2.scale(temp, contact.normalA, d);
                sub(contact.contactPointA, planeToCircle, temp);
                add(contact.contactPointA, contact.contactPointA, planeOffset);
                sub(contact.contactPointA, contact.contactPointA, planeBody.position);
                this.contactEquations.push(contact);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(contact));
                }
                return 1;
            };
            Narrowphase.prototype[Shape.CONVEX] = Narrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] = Narrowphase.prototype[Shape.RECTANGLE] = Narrowphase.prototype.convexConvex = function(bi, si, xi, ai, bj, sj, xj, aj, justTest, precision) {
                var sepAxis = tmp1, worldPoint = tmp2, worldPoint0 = tmp3, worldPoint1 = tmp4, worldEdge = tmp5, projected = tmp6, penetrationVec = tmp7, dist = tmp8, worldNormal = tmp9, numContacts = 0, precision = typeof precision === "number" ? precision : 0;
                var found = Narrowphase.findSeparatingAxis(si, xi, ai, sj, xj, aj, sepAxis);
                if (!found) {
                    return 0;
                }
                sub(dist, xj, xi);
                if (dot(sepAxis, dist) > 0) {
                    vec2.scale(sepAxis, sepAxis, -1);
                }
                var closestEdge1 = Narrowphase.getClosestEdge(si, ai, sepAxis, true), closestEdge2 = Narrowphase.getClosestEdge(sj, aj, sepAxis);
                if (closestEdge1 === -1 || closestEdge2 === -1) {
                    return 0;
                }
                for (var k = 0; k < 2; k++) {
                    var closestEdgeA = closestEdge1, closestEdgeB = closestEdge2, shapeA = si, shapeB = sj, offsetA = xi, offsetB = xj, angleA = ai, angleB = aj, bodyA = bi, bodyB = bj;
                    if (k === 0) {
                        var tmp;
                        tmp = closestEdgeA;
                        closestEdgeA = closestEdgeB;
                        closestEdgeB = tmp;
                        tmp = shapeA;
                        shapeA = shapeB;
                        shapeB = tmp;
                        tmp = offsetA;
                        offsetA = offsetB;
                        offsetB = tmp;
                        tmp = angleA;
                        angleA = angleB;
                        angleB = tmp;
                        tmp = bodyA;
                        bodyA = bodyB;
                        bodyB = tmp;
                    }
                    for (var j = closestEdgeB; j < closestEdgeB + 2; j++) {
                        var v = shapeB.vertices[(j + shapeB.vertices.length) % shapeB.vertices.length];
                        vec2.rotate(worldPoint, v, angleB);
                        add(worldPoint, worldPoint, offsetB);
                        var insideNumEdges = 0;
                        for (var i = closestEdgeA - 1; i < closestEdgeA + 2; i++) {
                            var v0 = shapeA.vertices[(i + shapeA.vertices.length) % shapeA.vertices.length], v1 = shapeA.vertices[(i + 1 + shapeA.vertices.length) % shapeA.vertices.length];
                            vec2.rotate(worldPoint0, v0, angleA);
                            vec2.rotate(worldPoint1, v1, angleA);
                            add(worldPoint0, worldPoint0, offsetA);
                            add(worldPoint1, worldPoint1, offsetA);
                            sub(worldEdge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(worldNormal, worldEdge);
                            vec2.normalize(worldNormal, worldNormal);
                            sub(dist, worldPoint, worldPoint0);
                            var d = dot(worldNormal, dist);
                            if (i === closestEdgeA && d <= precision || i !== closestEdgeA && d <= 0) {
                                insideNumEdges++;
                            }
                        }
                        if (insideNumEdges >= 3) {
                            if (justTest) {
                                return true;
                            }
                            var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
                            numContacts++;
                            var v0 = shapeA.vertices[closestEdgeA % shapeA.vertices.length], v1 = shapeA.vertices[(closestEdgeA + 1) % shapeA.vertices.length];
                            vec2.rotate(worldPoint0, v0, angleA);
                            vec2.rotate(worldPoint1, v1, angleA);
                            add(worldPoint0, worldPoint0, offsetA);
                            add(worldPoint1, worldPoint1, offsetA);
                            sub(worldEdge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(c.normalA, worldEdge);
                            vec2.normalize(c.normalA, c.normalA);
                            sub(dist, worldPoint, worldPoint0);
                            var d = dot(c.normalA, dist);
                            vec2.scale(penetrationVec, c.normalA, d);
                            sub(c.contactPointA, worldPoint, offsetA);
                            sub(c.contactPointA, c.contactPointA, penetrationVec);
                            add(c.contactPointA, c.contactPointA, offsetA);
                            sub(c.contactPointA, c.contactPointA, bodyA.position);
                            sub(c.contactPointB, worldPoint, offsetB);
                            add(c.contactPointB, c.contactPointB, offsetB);
                            sub(c.contactPointB, c.contactPointB, bodyB.position);
                            this.contactEquations.push(c);
                            if (!this.enableFrictionReduction) {
                                if (this.enableFriction) {
                                    this.frictionEquations.push(this.createFrictionFromContact(c));
                                }
                            }
                        }
                    }
                }
                if (this.enableFrictionReduction) {
                    if (this.enableFriction && numContacts) {
                        this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
                    }
                }
                return numContacts;
            };
            var pcoa_tmp1 = vec2.fromValues(0, 0);
            Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result) {
                var max = null, min = null, v, value, localAxis = pcoa_tmp1;
                vec2.rotate(localAxis, worldAxis, -convexAngle);
                for (var i = 0; i < convexShape.vertices.length; i++) {
                    v = convexShape.vertices[i];
                    value = dot(v, localAxis);
                    if (max === null || value > max) {
                        max = value;
                    }
                    if (min === null || value < min) {
                        min = value;
                    }
                }
                if (min > max) {
                    var t = min;
                    min = max;
                    max = t;
                }
                var offset = dot(convexOffset, worldAxis);
                vec2.set(result, min + offset, max + offset);
            };
            var fsa_tmp1 = vec2.fromValues(0, 0), fsa_tmp2 = vec2.fromValues(0, 0), fsa_tmp3 = vec2.fromValues(0, 0), fsa_tmp4 = vec2.fromValues(0, 0), fsa_tmp5 = vec2.fromValues(0, 0), fsa_tmp6 = vec2.fromValues(0, 0);
            Narrowphase.findSeparatingAxis = function(c1, offset1, angle1, c2, offset2, angle2, sepAxis) {
                var maxDist = null, overlap = false, found = false, edge = fsa_tmp1, worldPoint0 = fsa_tmp2, worldPoint1 = fsa_tmp3, normal = fsa_tmp4, span1 = fsa_tmp5, span2 = fsa_tmp6;
                if (c1 instanceof Rectangle && c2 instanceof Rectangle) {
                    for (var j = 0; j !== 2; j++) {
                        var c = c1, angle = angle1;
                        if (j === 1) {
                            c = c2;
                            angle = angle2;
                        }
                        for (var i = 0; i !== 2; i++) {
                            if (i === 0) {
                                vec2.set(normal, 0, 1);
                            } else if (i === 1) {
                                vec2.set(normal, 1, 0);
                            }
                            if (angle !== 0) {
                                vec2.rotate(normal, normal, angle);
                            }
                            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                            var a = span1, b = span2, swapped = false;
                            if (span1[0] > span2[0]) {
                                b = span1;
                                a = span2;
                                swapped = true;
                            }
                            var dist = b[0] - a[1];
                            overlap = dist <= 0;
                            if (maxDist === null || dist > maxDist) {
                                vec2.copy(sepAxis, normal);
                                maxDist = dist;
                                found = overlap;
                            }
                        }
                    }
                } else {
                    for (var j = 0; j !== 2; j++) {
                        var c = c1, angle = angle1;
                        if (j === 1) {
                            c = c2;
                            angle = angle2;
                        }
                        for (var i = 0; i !== c.vertices.length; i++) {
                            vec2.rotate(worldPoint0, c.vertices[i], angle);
                            vec2.rotate(worldPoint1, c.vertices[(i + 1) % c.vertices.length], angle);
                            sub(edge, worldPoint1, worldPoint0);
                            vec2.rotate90cw(normal, edge);
                            vec2.normalize(normal, normal);
                            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
                            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);
                            var a = span1, b = span2, swapped = false;
                            if (span1[0] > span2[0]) {
                                b = span1;
                                a = span2;
                                swapped = true;
                            }
                            var dist = b[0] - a[1];
                            overlap = dist <= 0;
                            if (maxDist === null || dist > maxDist) {
                                vec2.copy(sepAxis, normal);
                                maxDist = dist;
                                found = overlap;
                            }
                        }
                    }
                }
                return found;
            };
            var gce_tmp1 = vec2.fromValues(0, 0), gce_tmp2 = vec2.fromValues(0, 0), gce_tmp3 = vec2.fromValues(0, 0);
            Narrowphase.getClosestEdge = function(c, angle, axis, flip) {
                var localAxis = gce_tmp1, edge = gce_tmp2, normal = gce_tmp3;
                vec2.rotate(localAxis, axis, -angle);
                if (flip) {
                    vec2.scale(localAxis, localAxis, -1);
                }
                var closestEdge = -1, N = c.vertices.length, maxDot = -1;
                for (var i = 0; i !== N; i++) {
                    sub(edge, c.vertices[(i + 1) % N], c.vertices[i % N]);
                    vec2.rotate90cw(normal, edge);
                    vec2.normalize(normal, normal);
                    var d = dot(normal, localAxis);
                    if (closestEdge === -1 || d > maxDot) {
                        closestEdge = i % N;
                        maxDot = d;
                    }
                }
                return closestEdge;
            };
            var circleHeightfield_candidate = vec2.create(), circleHeightfield_dist = vec2.create(), circleHeightfield_v0 = vec2.create(), circleHeightfield_v1 = vec2.create(), circleHeightfield_minCandidate = vec2.create(), circleHeightfield_worldNormal = vec2.create(), circleHeightfield_minCandidateNormal = vec2.create();
            Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] = Narrowphase.prototype.circleHeightfield = function(circleBody, circleShape, circlePos, circleAngle, hfBody, hfShape, hfPos, hfAngle, justTest, radius) {
                var data = hfShape.data, radius = radius || circleShape.radius, w = hfShape.elementWidth, dist = circleHeightfield_dist, candidate = circleHeightfield_candidate, minCandidate = circleHeightfield_minCandidate, minCandidateNormal = circleHeightfield_minCandidateNormal, worldNormal = circleHeightfield_worldNormal, v0 = circleHeightfield_v0, v1 = circleHeightfield_v1;
                var idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);
                if (idxA < 0) {
                    idxA = 0;
                }
                if (idxB >= data.length) {
                    idxB = data.length - 1;
                }
                var max = data[idxA], min = data[idxB];
                for (var i = idxA; i < idxB; i++) {
                    if (data[i] < min) {
                        min = data[i];
                    }
                    if (data[i] > max) {
                        max = data[i];
                    }
                }
                if (circlePos[1] - radius > max) {
                    return justTest ? false : 0;
                }
                var found = false;
                for (var i = idxA; i < idxB; i++) {
                    vec2.set(v0, i * w, data[i]);
                    vec2.set(v1, (i + 1) * w, data[i + 1]);
                    vec2.add(v0, v0, hfPos);
                    vec2.add(v1, v1, hfPos);
                    vec2.sub(worldNormal, v1, v0);
                    vec2.rotate(worldNormal, worldNormal, Math.PI / 2);
                    vec2.normalize(worldNormal, worldNormal);
                    vec2.scale(candidate, worldNormal, -radius);
                    vec2.add(candidate, candidate, circlePos);
                    vec2.sub(dist, candidate, v0);
                    var d = vec2.dot(dist, worldNormal);
                    if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {
                        if (justTest) {
                            return true;
                        }
                        found = true;
                        vec2.scale(dist, worldNormal, -d);
                        vec2.add(minCandidate, candidate, dist);
                        vec2.copy(minCandidateNormal, worldNormal);
                        var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                        vec2.copy(c.normalA, minCandidateNormal);
                        vec2.scale(c.contactPointB, c.normalA, -radius);
                        add(c.contactPointB, c.contactPointB, circlePos);
                        sub(c.contactPointB, c.contactPointB, circleBody.position);
                        vec2.copy(c.contactPointA, minCandidate);
                        vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);
                        this.contactEquations.push(c);
                        if (this.enableFriction) {
                            this.frictionEquations.push(this.createFrictionFromContact(c));
                        }
                    }
                }
                found = false;
                if (radius > 0) {
                    for (var i = idxA; i <= idxB; i++) {
                        vec2.set(v0, i * w, data[i]);
                        vec2.add(v0, v0, hfPos);
                        vec2.sub(dist, circlePos, v0);
                        if (vec2.squaredLength(dist) < Math.pow(radius, 2)) {
                            if (justTest) {
                                return true;
                            }
                            found = true;
                            var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                            vec2.copy(c.normalA, dist);
                            vec2.normalize(c.normalA, c.normalA);
                            vec2.scale(c.contactPointB, c.normalA, -radius);
                            add(c.contactPointB, c.contactPointB, circlePos);
                            sub(c.contactPointB, c.contactPointB, circleBody.position);
                            sub(c.contactPointA, v0, hfPos);
                            add(c.contactPointA, c.contactPointA, hfPos);
                            sub(c.contactPointA, c.contactPointA, hfBody.position);
                            this.contactEquations.push(c);
                            if (this.enableFriction) {
                                this.frictionEquations.push(this.createFrictionFromContact(c));
                            }
                        }
                    }
                }
                if (found) {
                    return 1;
                }
                return 0;
            };
            var convexHeightfield_v0 = vec2.create(), convexHeightfield_v1 = vec2.create(), convexHeightfield_tilePos = vec2.create(), convexHeightfield_tempConvexShape = new Convex([ vec2.create(), vec2.create(), vec2.create(), vec2.create() ]);
            Narrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] = Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function(convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, hfAngle, justTest) {
                var data = hfShape.data, w = hfShape.elementWidth, v0 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
                var idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);
                if (idxA < 0) {
                    idxA = 0;
                }
                if (idxB >= data.length) {
                    idxB = data.length - 1;
                }
                var max = data[idxA], min = data[idxB];
                for (var i = idxA; i < idxB; i++) {
                    if (data[i] < min) {
                        min = data[i];
                    }
                    if (data[i] > max) {
                        max = data[i];
                    }
                }
                if (convexBody.aabb.lowerBound[1] > max) {
                    return justTest ? false : 0;
                }
                var found = false;
                var numContacts = 0;
                for (var i = idxA; i < idxB; i++) {
                    vec2.set(v0, i * w, data[i]);
                    vec2.set(v1, (i + 1) * w, data[i + 1]);
                    vec2.add(v0, v0, hfPos);
                    vec2.add(v1, v1, hfPos);
                    var tileHeight = 100;
                    vec2.set(tilePos, (v1[0] + v0[0]) * .5, (v1[1] + v0[1] - tileHeight) * .5);
                    vec2.sub(tileConvex.vertices[0], v1, tilePos);
                    vec2.sub(tileConvex.vertices[1], v0, tilePos);
                    vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
                    vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
                    tileConvex.vertices[2][1] -= tileHeight;
                    tileConvex.vertices[3][1] -= tileHeight;
                    numContacts += this.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
                }
                return numContacts;
            };
        }, {
            "../equations/ContactEquation": 22,
            "../equations/Equation": 23,
            "../equations/FrictionEquation": 24,
            "../math/vec2": 31,
            "../objects/Body": 32,
            "../shapes/Circle": 38,
            "../shapes/Convex": 39,
            "../shapes/Rectangle": 44,
            "../shapes/Shape": 45,
            "../utils/TupleDictionary": 49,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        14: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/collision\\SAPBroadphase.js", __dirname = "/collision";
            var Utils = require("../utils/Utils"), Broadphase = require("../collision/Broadphase");
            module.exports = SAPBroadphase;
            function SAPBroadphase() {
                Broadphase.call(this, Broadphase.SAP);
                this.axisList = [];
                this.axisIndex = 0;
                var that = this;
                this._addBodyHandler = function(e) {
                    that.axisList.push(e.body);
                };
                this._removeBodyHandler = function(e) {
                    var idx = that.axisList.indexOf(e.body);
                    if (idx !== -1) {
                        that.axisList.splice(idx, 1);
                    }
                };
            }
            SAPBroadphase.prototype = new Broadphase();
            SAPBroadphase.prototype.setWorld = function(world) {
                this.axisList.length = 0;
                Utils.appendArray(this.axisList, world.bodies);
                world.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler);
                world.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler);
                this.world = world;
            };
            SAPBroadphase.sortAxisList = function(a, axisIndex) {
                axisIndex = axisIndex | 0;
                for (var i = 1, l = a.length; i < l; i++) {
                    var v = a[i];
                    for (var j = i - 1; j >= 0; j--) {
                        if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {
                            break;
                        }
                        a[j + 1] = a[j];
                    }
                    a[j + 1] = v;
                }
                return a;
            };
            SAPBroadphase.prototype.getCollisionPairs = function(world) {
                var bodies = this.axisList, result = this.result, axisIndex = this.axisIndex;
                result.length = 0;
                var l = bodies.length;
                while (l--) {
                    var b = bodies[l];
                    if (b.aabbNeedsUpdate) {
                        b.updateAABB();
                    }
                }
                SAPBroadphase.sortAxisList(bodies, axisIndex);
                for (var i = 0, N = bodies.length | 0; i !== N; i++) {
                    var bi = bodies[i];
                    for (var j = i + 1; j < N; j++) {
                        var bj = bodies[j];
                        var overlaps = bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex];
                        if (!overlaps) {
                            break;
                        }
                        if (Broadphase.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                            result.push(bi, bj);
                        }
                    }
                }
                return result;
            };
        }, {
            "../collision/Broadphase": 10,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        15: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\Constraint.js", __dirname = "/constraints";
            module.exports = Constraint;
            var Utils = require("../utils/Utils");
            function Constraint(bodyA, bodyB, type, options) {
                this.type = type;
                options = Utils.defaults(options, {
                    collideConnected: true,
                    wakeUpBodies: true
                });
                this.equations = [];
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.collideConnected = options.collideConnected;
                if (options.wakeUpBodies) {
                    if (bodyA) {
                        bodyA.wakeUp();
                    }
                    if (bodyB) {
                        bodyB.wakeUp();
                    }
                }
            }
            Constraint.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!");
            };
            Constraint.DISTANCE = 1;
            Constraint.GEAR = 2;
            Constraint.LOCK = 3;
            Constraint.PRISMATIC = 4;
            Constraint.REVOLUTE = 5;
            Constraint.prototype.setStiffness = function(stiffness) {
                var eqs = this.equations;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    eq.stiffness = stiffness;
                    eq.needsUpdate = true;
                }
            };
            Constraint.prototype.setRelaxation = function(relaxation) {
                var eqs = this.equations;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    eq.relaxation = relaxation;
                    eq.needsUpdate = true;
                }
            };
        }, {
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        16: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\DistanceConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), Equation = require("../equations/Equation"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = DistanceConstraint;
            function DistanceConstraint(bodyA, bodyB, options) {
                options = Utils.defaults(options, {
                    localAnchorA: [ 0, 0 ],
                    localAnchorB: [ 0, 0 ]
                });
                Constraint.call(this, bodyA, bodyB, Constraint.DISTANCE, options);
                this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);
                this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);
                var localAnchorA = this.localAnchorA;
                var localAnchorB = this.localAnchorB;
                this.distance = 0;
                if (typeof options.distance === "number") {
                    this.distance = options.distance;
                } else {
                    var worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), r = vec2.create();
                    vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
                    vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);
                    vec2.add(r, bodyB.position, worldAnchorB);
                    vec2.sub(r, r, worldAnchorA);
                    vec2.sub(r, r, bodyA.position);
                    this.distance = vec2.length(r);
                }
                var maxForce;
                if (typeof options.maxForce === "undefined") {
                    maxForce = Number.MAX_VALUE;
                } else {
                    maxForce = options.maxForce;
                }
                var normal = new Equation(bodyA, bodyB, -maxForce, maxForce);
                this.equations = [ normal ];
                this.maxForce = maxForce;
                var r = vec2.create();
                var ri = vec2.create();
                var rj = vec2.create();
                var that = this;
                normal.computeGq = function() {
                    var bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position;
                    vec2.rotate(ri, localAnchorA, bodyA.angle);
                    vec2.rotate(rj, localAnchorB, bodyB.angle);
                    vec2.add(r, xj, rj);
                    vec2.sub(r, r, ri);
                    vec2.sub(r, r, xi);
                    return vec2.length(r) - that.distance;
                };
                this.setMaxForce(maxForce);
                this.upperLimitEnabled = false;
                this.upperLimit = 1;
                this.lowerLimitEnabled = false;
                this.lowerLimit = 0;
                this.position = 0;
            }
            DistanceConstraint.prototype = new Constraint();
            var n = vec2.create();
            var ri = vec2.create();
            var rj = vec2.create();
            DistanceConstraint.prototype.update = function() {
                var normal = this.equations[0], bodyA = this.bodyA, bodyB = this.bodyB, distance = this.distance, xi = bodyA.position, xj = bodyB.position, normalEquation = this.equations[0], G = normal.G;
                vec2.rotate(ri, this.localAnchorA, bodyA.angle);
                vec2.rotate(rj, this.localAnchorB, bodyB.angle);
                vec2.add(n, xj, rj);
                vec2.sub(n, n, ri);
                vec2.sub(n, n, xi);
                this.position = vec2.length(n);
                var violating = false;
                if (this.upperLimitEnabled) {
                    if (this.position > this.upperLimit) {
                        normalEquation.maxForce = 0;
                        normalEquation.minForce = -this.maxForce;
                        this.distance = this.upperLimit;
                        violating = true;
                    }
                }
                if (this.lowerLimitEnabled) {
                    if (this.position < this.lowerLimit) {
                        normalEquation.maxForce = this.maxForce;
                        normalEquation.minForce = 0;
                        this.distance = this.lowerLimit;
                        violating = true;
                    }
                }
                if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {
                    normalEquation.enabled = false;
                    return;
                }
                normalEquation.enabled = true;
                vec2.normalize(n, n);
                var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                G[0] = -n[0];
                G[1] = -n[1];
                G[2] = -rixn;
                G[3] = n[0];
                G[4] = n[1];
                G[5] = rjxn;
            };
            DistanceConstraint.prototype.setMaxForce = function(f) {
                var normal = this.equations[0];
                normal.minForce = -f;
                normal.maxForce = f;
            };
            DistanceConstraint.prototype.getMaxForce = function(f) {
                var normal = this.equations[0];
                return normal.maxForce;
            };
        }, {
            "../equations/Equation": 23,
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        17: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\GearConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), Equation = require("../equations/Equation"), AngleLockEquation = require("../equations/AngleLockEquation"), vec2 = require("../math/vec2");
            module.exports = GearConstraint;
            function GearConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);
                this.ratio = typeof options.ratio === "number" ? options.ratio : 1;
                this.angle = typeof options.angle === "number" ? options.angle : bodyB.angle - this.ratio * bodyA.angle;
                options.angle = this.angle;
                options.ratio = this.ratio;
                this.equations = [ new AngleLockEquation(bodyA, bodyB, options) ];
                if (typeof options.maxTorque === "number") {
                    this.setMaxTorque(options.maxTorque);
                }
            }
            GearConstraint.prototype = new Constraint();
            GearConstraint.prototype.update = function() {
                var eq = this.equations[0];
                if (eq.ratio !== this.ratio) {
                    eq.setRatio(this.ratio);
                }
                eq.angle = this.angle;
            };
            GearConstraint.prototype.setMaxTorque = function(torque) {
                this.equations[0].setMaxTorque(torque);
            };
            GearConstraint.prototype.getMaxTorque = function(torque) {
                return this.equations[0].maxForce;
            };
        }, {
            "../equations/AngleLockEquation": 21,
            "../equations/Equation": 23,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        18: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\LockConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), vec2 = require("../math/vec2"), Equation = require("../equations/Equation");
            module.exports = LockConstraint;
            function LockConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.LOCK, options);
                var maxForce = typeof options.maxForce === "undefined" ? Number.MAX_VALUE : options.maxForce;
                var localAngleB = options.localAngleB || 0;
                var x = new Equation(bodyA, bodyB, -maxForce, maxForce), y = new Equation(bodyA, bodyB, -maxForce, maxForce), rot = new Equation(bodyA, bodyB, -maxForce, maxForce);
                var l = vec2.create(), g = vec2.create(), that = this;
                x.computeGq = function() {
                    vec2.rotate(l, that.localOffsetB, bodyA.angle);
                    vec2.sub(g, bodyB.position, bodyA.position);
                    vec2.sub(g, g, l);
                    return g[0];
                };
                y.computeGq = function() {
                    vec2.rotate(l, that.localOffsetB, bodyA.angle);
                    vec2.sub(g, bodyB.position, bodyA.position);
                    vec2.sub(g, g, l);
                    return g[1];
                };
                var r = vec2.create(), t = vec2.create();
                rot.computeGq = function() {
                    vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
                    vec2.scale(r, r, -1);
                    vec2.sub(g, bodyA.position, bodyB.position);
                    vec2.add(g, g, r);
                    vec2.rotate(t, r, -Math.PI / 2);
                    vec2.normalize(t, t);
                    return vec2.dot(g, t);
                };
                this.localOffsetB = vec2.create();
                if (options.localOffsetB) {
                    vec2.copy(this.localOffsetB, options.localOffsetB);
                } else {
                    vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
                    vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
                }
                this.localAngleB = 0;
                if (typeof options.localAngleB === "number") {
                    this.localAngleB = options.localAngleB;
                } else {
                    this.localAngleB = bodyB.angle - bodyA.angle;
                }
                this.equations.push(x, y, rot);
                this.setMaxForce(maxForce);
            }
            LockConstraint.prototype = new Constraint();
            LockConstraint.prototype.setMaxForce = function(force) {
                var eqs = this.equations;
                for (var i = 0; i < this.equations.length; i++) {
                    eqs[i].maxForce = force;
                    eqs[i].minForce = -force;
                }
            };
            LockConstraint.prototype.getMaxForce = function() {
                return this.equations[0].maxForce;
            };
            var l = vec2.create();
            var r = vec2.create();
            var t = vec2.create();
            var xAxis = vec2.fromValues(1, 0);
            var yAxis = vec2.fromValues(0, 1);
            LockConstraint.prototype.update = function() {
                var x = this.equations[0], y = this.equations[1], rot = this.equations[2], bodyA = this.bodyA, bodyB = this.bodyB;
                vec2.rotate(l, this.localOffsetB, bodyA.angle);
                vec2.rotate(r, this.localOffsetB, bodyB.angle - this.localAngleB);
                vec2.scale(r, r, -1);
                vec2.rotate(t, r, Math.PI / 2);
                vec2.normalize(t, t);
                x.G[0] = -1;
                x.G[1] = 0;
                x.G[2] = -vec2.crossLength(l, xAxis);
                x.G[3] = 1;
                y.G[0] = 0;
                y.G[1] = -1;
                y.G[2] = -vec2.crossLength(l, yAxis);
                y.G[4] = 1;
                rot.G[0] = -t[0];
                rot.G[1] = -t[1];
                rot.G[3] = t[0];
                rot.G[4] = t[1];
                rot.G[5] = vec2.crossLength(r, t);
            };
        }, {
            "../equations/Equation": 23,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        19: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\PrismaticConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), ContactEquation = require("../equations/ContactEquation"), Equation = require("../equations/Equation"), vec2 = require("../math/vec2"), RotationalLockEquation = require("../equations/RotationalLockEquation");
            module.exports = PrismaticConstraint;
            function PrismaticConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.PRISMATIC, options);
                var localAnchorA = vec2.fromValues(0, 0), localAxisA = vec2.fromValues(1, 0), localAnchorB = vec2.fromValues(0, 0);
                if (options.localAnchorA) {
                    vec2.copy(localAnchorA, options.localAnchorA);
                }
                if (options.localAxisA) {
                    vec2.copy(localAxisA, options.localAxisA);
                }
                if (options.localAnchorB) {
                    vec2.copy(localAnchorB, options.localAnchorB);
                }
                this.localAnchorA = localAnchorA;
                this.localAnchorB = localAnchorB;
                this.localAxisA = localAxisA;
                var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                var trans = new Equation(bodyA, bodyB, -maxForce, maxForce);
                var ri = new vec2.create(), rj = new vec2.create(), gg = new vec2.create(), t = new vec2.create();
                trans.computeGq = function() {
                    return vec2.dot(gg, t);
                };
                trans.updateJacobian = function() {
                    var G = this.G, xi = bodyA.position, xj = bodyB.position;
                    vec2.rotate(ri, localAnchorA, bodyA.angle);
                    vec2.rotate(rj, localAnchorB, bodyB.angle);
                    vec2.add(gg, xj, rj);
                    vec2.sub(gg, gg, xi);
                    vec2.sub(gg, gg, ri);
                    vec2.rotate(t, localAxisA, bodyA.angle + Math.PI / 2);
                    G[0] = -t[0];
                    G[1] = -t[1];
                    G[2] = -vec2.crossLength(ri, t) + vec2.crossLength(t, gg);
                    G[3] = t[0];
                    G[4] = t[1];
                    G[5] = vec2.crossLength(rj, t);
                };
                this.equations.push(trans);
                if (!options.disableRotationalLock) {
                    var rot = new RotationalLockEquation(bodyA, bodyB, -maxForce, maxForce);
                    this.equations.push(rot);
                }
                this.position = 0;
                this.velocity = 0;
                this.lowerLimitEnabled = typeof options.lowerLimit !== "undefined" ? true : false;
                this.upperLimitEnabled = typeof options.upperLimit !== "undefined" ? true : false;
                this.lowerLimit = typeof options.lowerLimit !== "undefined" ? options.lowerLimit : 0;
                this.upperLimit = typeof options.upperLimit !== "undefined" ? options.upperLimit : 1;
                this.upperLimitEquation = new ContactEquation(bodyA, bodyB);
                this.lowerLimitEquation = new ContactEquation(bodyA, bodyB);
                this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
                this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;
                this.motorEquation = new Equation(bodyA, bodyB);
                this.motorEnabled = false;
                this.motorSpeed = 0;
                var that = this;
                var motorEquation = this.motorEquation;
                var old = motorEquation.computeGW;
                motorEquation.computeGq = function() {
                    return 0;
                };
                motorEquation.computeGW = function() {
                    var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                    return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;
                };
            }
            PrismaticConstraint.prototype = new Constraint();
            var worldAxisA = vec2.create(), worldAnchorA = vec2.create(), worldAnchorB = vec2.create(), orientedAnchorA = vec2.create(), orientedAnchorB = vec2.create(), tmp = vec2.create();
            PrismaticConstraint.prototype.update = function() {
                var eqs = this.equations, trans = eqs[0], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation, bodyA = this.bodyA, bodyB = this.bodyB, localAxisA = this.localAxisA, localAnchorA = this.localAnchorA, localAnchorB = this.localAnchorB;
                trans.updateJacobian();
                vec2.rotate(worldAxisA, localAxisA, bodyA.angle);
                vec2.rotate(orientedAnchorA, localAnchorA, bodyA.angle);
                vec2.add(worldAnchorA, orientedAnchorA, bodyA.position);
                vec2.rotate(orientedAnchorB, localAnchorB, bodyB.angle);
                vec2.add(worldAnchorB, orientedAnchorB, bodyB.position);
                var relPosition = this.position = vec2.dot(worldAnchorB, worldAxisA) - vec2.dot(worldAnchorA, worldAxisA);
                if (this.motorEnabled) {
                    var G = this.motorEquation.G;
                    G[0] = worldAxisA[0];
                    G[1] = worldAxisA[1];
                    G[2] = vec2.crossLength(worldAxisA, orientedAnchorB);
                    G[3] = -worldAxisA[0];
                    G[4] = -worldAxisA[1];
                    G[5] = -vec2.crossLength(worldAxisA, orientedAnchorA);
                }
                if (this.upperLimitEnabled && relPosition > upperLimit) {
                    vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
                    vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                    vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                    vec2.scale(tmp, worldAxisA, upperLimit);
                    vec2.add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);
                    if (eqs.indexOf(upperLimitEquation) === -1) {
                        eqs.push(upperLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(upperLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                if (this.lowerLimitEnabled && relPosition < lowerLimit) {
                    vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
                    vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
                    vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
                    vec2.scale(tmp, worldAxisA, lowerLimit);
                    vec2.sub(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);
                    if (eqs.indexOf(lowerLimitEquation) === -1) {
                        eqs.push(lowerLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(lowerLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
            };
            PrismaticConstraint.prototype.enableMotor = function() {
                if (this.motorEnabled) {
                    return;
                }
                this.equations.push(this.motorEquation);
                this.motorEnabled = true;
            };
            PrismaticConstraint.prototype.disableMotor = function() {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations.splice(i, 1);
                this.motorEnabled = false;
            };
            PrismaticConstraint.prototype.setLimits = function(lower, upper) {
                if (typeof lower === "number") {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = true;
                } else {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = false;
                }
                if (typeof upper === "number") {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = true;
                } else {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = false;
                }
            };
        }, {
            "../equations/ContactEquation": 22,
            "../equations/Equation": 23,
            "../equations/RotationalLockEquation": 25,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        20: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/constraints\\RevoluteConstraint.js", __dirname = "/constraints";
            var Constraint = require("./Constraint"), Equation = require("../equations/Equation"), RotationalVelocityEquation = require("../equations/RotationalVelocityEquation"), RotationalLockEquation = require("../equations/RotationalLockEquation"), vec2 = require("../math/vec2");
            module.exports = RevoluteConstraint;
            var worldPivotA = vec2.create(), worldPivotB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1), g = vec2.create();
            function RevoluteConstraint(bodyA, bodyB, options) {
                options = options || {};
                Constraint.call(this, bodyA, bodyB, Constraint.REVOLUTE, options);
                var maxForce = this.maxForce = typeof options.maxForce !== "undefined" ? options.maxForce : Number.MAX_VALUE;
                this.pivotA = vec2.create();
                this.pivotB = vec2.create();
                if (options.worldPivot) {
                    vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
                    vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
                    vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
                    vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
                } else {
                    vec2.copy(this.pivotA, options.localPivotA);
                    vec2.copy(this.pivotB, options.localPivotB);
                }
                var eqs = this.equations = [ new Equation(bodyA, bodyB, -maxForce, maxForce), new Equation(bodyA, bodyB, -maxForce, maxForce) ];
                var x = eqs[0];
                var y = eqs[1];
                var that = this;
                x.computeGq = function() {
                    vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                    vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                    vec2.add(g, bodyB.position, worldPivotB);
                    vec2.sub(g, g, bodyA.position);
                    vec2.sub(g, g, worldPivotA);
                    return vec2.dot(g, xAxis);
                };
                y.computeGq = function() {
                    vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
                    vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
                    vec2.add(g, bodyB.position, worldPivotB);
                    vec2.sub(g, g, bodyA.position);
                    vec2.sub(g, g, worldPivotA);
                    return vec2.dot(g, yAxis);
                };
                y.minForce = x.minForce = -maxForce;
                y.maxForce = x.maxForce = maxForce;
                this.motorEquation = new RotationalVelocityEquation(bodyA, bodyB);
                this.motorEnabled = false;
                this.angle = 0;
                this.lowerLimitEnabled = false;
                this.upperLimitEnabled = false;
                this.lowerLimit = 0;
                this.upperLimit = 0;
                this.upperLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                this.lowerLimitEquation = new RotationalLockEquation(bodyA, bodyB);
                this.upperLimitEquation.minForce = 0;
                this.lowerLimitEquation.maxForce = 0;
            }
            RevoluteConstraint.prototype = new Constraint();
            RevoluteConstraint.prototype.setLimits = function(lower, upper) {
                if (typeof lower === "number") {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = true;
                } else {
                    this.lowerLimit = lower;
                    this.lowerLimitEnabled = false;
                }
                if (typeof upper === "number") {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = true;
                } else {
                    this.upperLimit = upper;
                    this.upperLimitEnabled = false;
                }
            };
            RevoluteConstraint.prototype.update = function() {
                var bodyA = this.bodyA, bodyB = this.bodyB, pivotA = this.pivotA, pivotB = this.pivotB, eqs = this.equations, normal = eqs[0], tangent = eqs[1], x = eqs[0], y = eqs[1], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation;
                var relAngle = this.angle = bodyB.angle - bodyA.angle;
                if (this.upperLimitEnabled && relAngle > upperLimit) {
                    upperLimitEquation.angle = upperLimit;
                    if (eqs.indexOf(upperLimitEquation) === -1) {
                        eqs.push(upperLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(upperLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                if (this.lowerLimitEnabled && relAngle < lowerLimit) {
                    lowerLimitEquation.angle = lowerLimit;
                    if (eqs.indexOf(lowerLimitEquation) === -1) {
                        eqs.push(lowerLimitEquation);
                    }
                } else {
                    var idx = eqs.indexOf(lowerLimitEquation);
                    if (idx !== -1) {
                        eqs.splice(idx, 1);
                    }
                }
                vec2.rotate(worldPivotA, pivotA, bodyA.angle);
                vec2.rotate(worldPivotB, pivotB, bodyB.angle);
                x.G[0] = -1;
                x.G[1] = 0;
                x.G[2] = -vec2.crossLength(worldPivotA, xAxis);
                x.G[3] = 1;
                x.G[4] = 0;
                x.G[5] = vec2.crossLength(worldPivotB, xAxis);
                y.G[0] = 0;
                y.G[1] = -1;
                y.G[2] = -vec2.crossLength(worldPivotA, yAxis);
                y.G[3] = 0;
                y.G[4] = 1;
                y.G[5] = vec2.crossLength(worldPivotB, yAxis);
            };
            RevoluteConstraint.prototype.enableMotor = function() {
                if (this.motorEnabled) {
                    return;
                }
                this.equations.push(this.motorEquation);
                this.motorEnabled = true;
            };
            RevoluteConstraint.prototype.disableMotor = function() {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations.splice(i, 1);
                this.motorEnabled = false;
            };
            RevoluteConstraint.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled;
            };
            RevoluteConstraint.prototype.setMotorSpeed = function(speed) {
                if (!this.motorEnabled) {
                    return;
                }
                var i = this.equations.indexOf(this.motorEquation);
                this.equations[i].relativeVelocity = speed;
            };
            RevoluteConstraint.prototype.getMotorSpeed = function() {
                if (!this.motorEnabled) {
                    return false;
                }
                return this.motorEquation.relativeVelocity;
            };
        }, {
            "../equations/Equation": 23,
            "../equations/RotationalLockEquation": 25,
            "../equations/RotationalVelocityEquation": 26,
            "../math/vec2": 31,
            "./Constraint": 15,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        21: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\AngleLockEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = AngleLockEquation;
            function AngleLockEquation(bodyA, bodyB, options) {
                options = options || {};
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = options.angle || 0;
                this.ratio = typeof options.ratio === "number" ? options.ratio : 1;
                this.setRatio(this.ratio);
            }
            AngleLockEquation.prototype = new Equation();
            AngleLockEquation.prototype.constructor = AngleLockEquation;
            AngleLockEquation.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
            };
            AngleLockEquation.prototype.setRatio = function(ratio) {
                var G = this.G;
                G[2] = ratio;
                G[5] = -1;
                this.ratio = ratio;
            };
            AngleLockEquation.prototype.setMaxTorque = function(torque) {
                this.maxForce = torque;
                this.minForce = -torque;
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        22: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\ContactEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = ContactEquation;
            function ContactEquation(bodyA, bodyB) {
                Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);
                this.contactPointA = vec2.create();
                this.penetrationVec = vec2.create();
                this.contactPointB = vec2.create();
                this.normalA = vec2.create();
                this.restitution = 0;
                this.firstImpact = false;
                this.shapeA = null;
                this.shapeB = null;
            }
            ContactEquation.prototype = new Equation();
            ContactEquation.prototype.constructor = ContactEquation;
            ContactEquation.prototype.computeB = function(a, b, h) {
                var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = bi.position, xj = bj.position;
                var penetrationVec = this.penetrationVec, n = this.normalA, G = this.G;
                var rixn = vec2.crossLength(ri, n), rjxn = vec2.crossLength(rj, n);
                G[0] = -n[0];
                G[1] = -n[1];
                G[2] = -rixn;
                G[3] = n[0];
                G[4] = n[1];
                G[5] = rjxn;
                vec2.add(penetrationVec, xj, rj);
                vec2.sub(penetrationVec, penetrationVec, xi);
                vec2.sub(penetrationVec, penetrationVec, ri);
                var GW, Gq;
                if (this.firstImpact && this.restitution !== 0) {
                    Gq = 0;
                    GW = 1 / b * (1 + this.restitution) * this.computeGW();
                } else {
                    Gq = vec2.dot(n, penetrationVec) + this.offset;
                    GW = this.computeGW();
                }
                var GiMf = this.computeGiMf();
                var B = -Gq * a - GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        23: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\Equation.js", __dirname = "/equations";
            module.exports = Equation;
            var vec2 = require("../math/vec2"), Utils = require("../utils/Utils"), Body = require("../objects/Body");
            function Equation(bodyA, bodyB, minForce, maxForce) {
                this.minForce = typeof minForce === "undefined" ? -Number.MAX_VALUE : minForce;
                this.maxForce = typeof maxForce === "undefined" ? Number.MAX_VALUE : maxForce;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
                this.stiffness = Equation.DEFAULT_STIFFNESS;
                this.relaxation = Equation.DEFAULT_RELAXATION;
                this.G = new Utils.ARRAY_TYPE(6);
                for (var i = 0; i < 6; i++) {
                    this.G[i] = 0;
                }
                this.offset = 0;
                this.a = 0;
                this.b = 0;
                this.epsilon = 0;
                this.timeStep = 1 / 60;
                this.needsUpdate = true;
                this.multiplier = 0;
                this.relativeVelocity = 0;
                this.enabled = true;
            }
            Equation.prototype.constructor = Equation;
            Equation.DEFAULT_STIFFNESS = 1e6;
            Equation.DEFAULT_RELAXATION = 4;
            Equation.prototype.update = function() {
                var k = this.stiffness, d = this.relaxation, h = this.timeStep;
                this.a = 4 / (h * (1 + 4 * d));
                this.b = 4 * d / (1 + 4 * d);
                this.epsilon = 4 / (h * h * k * (1 + 4 * d));
                this.needsUpdate = false;
            };
            Equation.prototype.gmult = function(G, vi, wi, vj, wj) {
                return G[0] * vi[0] + G[1] * vi[1] + G[2] * wi + G[3] * vj[0] + G[4] * vj[1] + G[5] * wj;
            };
            Equation.prototype.computeB = function(a, b, h) {
                var GW = this.computeGW();
                var Gq = this.computeGq();
                var GiMf = this.computeGiMf();
                return -Gq * a - GW * b - GiMf * h;
            };
            var qi = vec2.create(), qj = vec2.create();
            Equation.prototype.computeGq = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, xi = bi.position, xj = bj.position, ai = bi.angle, aj = bj.angle;
                return this.gmult(G, qi, ai, qj, aj) + this.offset;
            };
            Equation.prototype.computeGW = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
                return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;
            };
            Equation.prototype.computeGWlambda = function() {
                var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
                return this.gmult(G, vi, wi, vj, wj);
            };
            var iMfi = vec2.create(), iMfj = vec2.create();
            Equation.prototype.computeGiMf = function() {
                var bi = this.bodyA, bj = this.bodyB, fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                vec2.scale(iMfi, fi, invMassi);
                vec2.scale(iMfj, fj, invMassj);
                return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);
            };
            Equation.prototype.computeGiMGt = function() {
                var bi = this.bodyA, bj = this.bodyB, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
                return G[0] * G[0] * invMassi + G[1] * G[1] * invMassi + G[2] * G[2] * invIi + G[3] * G[3] * invMassj + G[4] * G[4] * invMassj + G[5] * G[5] * invIj;
            };
            var addToWlambda_temp = vec2.create(), addToWlambda_Gi = vec2.create(), addToWlambda_Gj = vec2.create(), addToWlambda_ri = vec2.create(), addToWlambda_rj = vec2.create(), addToWlambda_Mdiag = vec2.create();
            Equation.prototype.addToWlambda = function(deltalambda) {
                var bi = this.bodyA, bj = this.bodyB, temp = addToWlambda_temp, Gi = addToWlambda_Gi, Gj = addToWlambda_Gj, ri = addToWlambda_ri, rj = addToWlambda_rj, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, Mdiag = addToWlambda_Mdiag, G = this.G;
                Gi[0] = G[0];
                Gi[1] = G[1];
                Gj[0] = G[3];
                Gj[1] = G[4];
                vec2.scale(temp, Gi, invMassi * deltalambda);
                vec2.add(bi.vlambda, bi.vlambda, temp);
                bi.wlambda += invIi * G[2] * deltalambda;
                vec2.scale(temp, Gj, invMassj * deltalambda);
                vec2.add(bj.vlambda, bj.vlambda, temp);
                bj.wlambda += invIj * G[5] * deltalambda;
            };
            Equation.prototype.computeInvC = function(eps) {
                return 1 / (this.computeGiMGt() + eps);
            };
        }, {
            "../math/vec2": 31,
            "../objects/Body": 32,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        24: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\FrictionEquation.js", __dirname = "/equations";
            var vec2 = require("../math/vec2"), Equation = require("./Equation"), Utils = require("../utils/Utils");
            module.exports = FrictionEquation;
            function FrictionEquation(bodyA, bodyB, slipForce) {
                Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
                this.contactPointA = vec2.create();
                this.contactPointB = vec2.create();
                this.t = vec2.create();
                this.contactEquations = [];
                this.shapeA = null;
                this.shapeB = null;
                this.frictionCoefficient = .3;
            }
            FrictionEquation.prototype = new Equation();
            FrictionEquation.prototype.constructor = FrictionEquation;
            FrictionEquation.prototype.setSlipForce = function(slipForce) {
                this.maxForce = slipForce;
                this.minForce = -slipForce;
            };
            FrictionEquation.prototype.getSlipForce = function() {
                return this.maxForce;
            };
            FrictionEquation.prototype.computeB = function(a, b, h) {
                var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, t = this.t, G = this.G;
                G[0] = -t[0];
                G[1] = -t[1];
                G[2] = -vec2.crossLength(ri, t);
                G[3] = t[0];
                G[4] = t[1];
                G[5] = vec2.crossLength(rj, t);
                var GW = this.computeGW(), GiMf = this.computeGiMf();
                var B = -GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        25: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\RotationalLockEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = RotationalLockEquation;
            function RotationalLockEquation(bodyA, bodyB, options) {
                options = options || {};
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.angle = options.angle || 0;
                var G = this.G;
                G[2] = 1;
                G[5] = -1;
            }
            RotationalLockEquation.prototype = new Equation();
            RotationalLockEquation.prototype.constructor = RotationalLockEquation;
            var worldVectorA = vec2.create(), worldVectorB = vec2.create(), xAxis = vec2.fromValues(1, 0), yAxis = vec2.fromValues(0, 1);
            RotationalLockEquation.prototype.computeGq = function() {
                vec2.rotate(worldVectorA, xAxis, this.bodyA.angle + this.angle);
                vec2.rotate(worldVectorB, yAxis, this.bodyB.angle);
                return vec2.dot(worldVectorA, worldVectorB);
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        26: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/equations\\RotationalVelocityEquation.js", __dirname = "/equations";
            var Equation = require("./Equation"), vec2 = require("../math/vec2");
            module.exports = RotationalVelocityEquation;
            function RotationalVelocityEquation(bodyA, bodyB) {
                Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
                this.relativeVelocity = 1;
                this.ratio = 1;
            }
            RotationalVelocityEquation.prototype = new Equation();
            RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
            RotationalVelocityEquation.prototype.computeB = function(a, b, h) {
                var G = this.G;
                G[2] = -1;
                G[5] = this.ratio;
                var GiMf = this.computeGiMf();
                var GW = this.computeGW();
                var B = -GW * b - h * GiMf;
                return B;
            };
        }, {
            "../math/vec2": 31,
            "./Equation": 23,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        27: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/events\\EventEmitter.js", __dirname = "/events";
            var EventEmitter = function() {};
            module.exports = EventEmitter;
            EventEmitter.prototype = {
                constructor: EventEmitter,
                on: function(type, listener, context) {
                    listener.context = context || this;
                    if (this._listeners === undefined) {
                        this._listeners = {};
                    }
                    var listeners = this._listeners;
                    if (listeners[type] === undefined) {
                        listeners[type] = [];
                    }
                    if (listeners[type].indexOf(listener) === -1) {
                        listeners[type].push(listener);
                    }
                    return this;
                },
                has: function(type, listener) {
                    if (this._listeners === undefined) {
                        return false;
                    }
                    var listeners = this._listeners;
                    if (listener) {
                        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                            return true;
                        }
                    } else {
                        if (listeners[type] !== undefined) {
                            return true;
                        }
                    }
                    return false;
                },
                off: function(type, listener) {
                    if (this._listeners === undefined) {
                        return this;
                    }
                    var listeners = this._listeners;
                    var index = listeners[type].indexOf(listener);
                    if (index !== -1) {
                        listeners[type].splice(index, 1);
                    }
                    return this;
                },
                emit: function(event) {
                    if (this._listeners === undefined) {
                        return this;
                    }
                    var listeners = this._listeners;
                    var listenerArray = listeners[event.type];
                    if (listenerArray !== undefined) {
                        event.target = this;
                        for (var i = 0, l = listenerArray.length; i < l; i++) {
                            var listener = listenerArray[i];
                            listener.call(listener.context, event);
                        }
                    }
                    return this;
                }
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        28: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/material\\ContactMaterial.js", __dirname = "/material";
            var Material = require("./Material");
            var Equation = require("../equations/Equation");
            module.exports = ContactMaterial;
            function ContactMaterial(materialA, materialB, options) {
                options = options || {};
                if (!(materialA instanceof Material) || !(materialB instanceof Material)) {
                    throw new Error("First two arguments must be Material instances.");
                }
                this.id = ContactMaterial.idCounter++;
                this.materialA = materialA;
                this.materialB = materialB;
                this.friction = typeof options.friction !== "undefined" ? Number(options.friction) : .3;
                this.restitution = typeof options.restitution !== "undefined" ? Number(options.restitution) : 0;
                this.stiffness = typeof options.stiffness !== "undefined" ? Number(options.stiffness) : Equation.DEFAULT_STIFFNESS;
                this.relaxation = typeof options.relaxation !== "undefined" ? Number(options.relaxation) : Equation.DEFAULT_RELAXATION;
                this.frictionStiffness = typeof options.frictionStiffness !== "undefined" ? Number(options.frictionStiffness) : Equation.DEFAULT_STIFFNESS;
                this.frictionRelaxation = typeof options.frictionRelaxation !== "undefined" ? Number(options.frictionRelaxation) : Equation.DEFAULT_RELAXATION;
                this.surfaceVelocity = typeof options.surfaceVelocity !== "undefined" ? Number(options.surfaceVelocity) : 0;
                this.contactSkinSize = .005;
            }
            ContactMaterial.idCounter = 0;
        }, {
            "../equations/Equation": 23,
            "./Material": 29,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        29: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/material\\Material.js", __dirname = "/material";
            module.exports = Material;
            function Material(id) {
                this.id = id || Material.idCounter++;
            }
            Material.idCounter = 0;
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        30: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/math\\polyk.js", __dirname = "/math";
            var PolyK = {};
            PolyK.GetArea = function(p) {
                if (p.length < 6) return 0;
                var l = p.length - 2;
                var sum = 0;
                for (var i = 0; i < l; i += 2) sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
                sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
                return -sum * .5;
            };
            PolyK.Triangulate = function(p) {
                var n = p.length >> 1;
                if (n < 3) return [];
                var tgs = [];
                var avl = [];
                for (var i = 0; i < n; i++) avl.push(i);
                var i = 0;
                var al = n;
                while (al > 3) {
                    var i0 = avl[(i + 0) % al];
                    var i1 = avl[(i + 1) % al];
                    var i2 = avl[(i + 2) % al];
                    var ax = p[2 * i0], ay = p[2 * i0 + 1];
                    var bx = p[2 * i1], by = p[2 * i1 + 1];
                    var cx = p[2 * i2], cy = p[2 * i2 + 1];
                    var earFound = false;
                    if (PolyK._convex(ax, ay, bx, by, cx, cy)) {
                        earFound = true;
                        for (var j = 0; j < al; j++) {
                            var vi = avl[j];
                            if (vi == i0 || vi == i1 || vi == i2) continue;
                            if (PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                                earFound = false;
                                break;
                            }
                        }
                    }
                    if (earFound) {
                        tgs.push(i0, i1, i2);
                        avl.splice((i + 1) % al, 1);
                        al--;
                        i = 0;
                    } else if (i++ > 3 * al) break;
                }
                tgs.push(avl[0], avl[1], avl[2]);
                return tgs;
            };
            PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy) {
                var v0x = cx - ax;
                var v0y = cy - ay;
                var v1x = bx - ax;
                var v1y = by - ay;
                var v2x = px - ax;
                var v2y = py - ay;
                var dot00 = v0x * v0x + v0y * v0y;
                var dot01 = v0x * v1x + v0y * v1y;
                var dot02 = v0x * v2x + v0y * v2y;
                var dot11 = v1x * v1x + v1y * v1y;
                var dot12 = v1x * v2x + v1y * v2y;
                var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return u >= 0 && v >= 0 && u + v < 1;
            };
            PolyK._convex = function(ax, ay, bx, by, cx, cy) {
                return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
            };
            module.exports = PolyK;
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        31: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/math\\vec2.js", __dirname = "/math";
            var vec2 = module.exports = {};
            var Utils = require("../utils/Utils");
            vec2.crossLength = function(a, b) {
                return a[0] * b[1] - a[1] * b[0];
            };
            vec2.crossVZ = function(out, vec, zcomp) {
                vec2.rotate(out, vec, -Math.PI / 2);
                vec2.scale(out, out, zcomp);
                return out;
            };
            vec2.crossZV = function(out, zcomp, vec) {
                vec2.rotate(out, vec, Math.PI / 2);
                vec2.scale(out, out, zcomp);
                return out;
            };
            vec2.rotate = function(out, a, angle) {
                if (angle !== 0) {
                    var c = Math.cos(angle), s = Math.sin(angle), x = a[0], y = a[1];
                    out[0] = c * x - s * y;
                    out[1] = s * x + c * y;
                } else {
                    out[0] = a[0];
                    out[1] = a[1];
                }
            };
            vec2.rotate90cw = function(out, a) {
                var x = a[0];
                var y = a[1];
                out[0] = y;
                out[1] = -x;
            };
            vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle) {
                vec2.copy(out, worldPoint);
                vec2.sub(out, out, framePosition);
                vec2.rotate(out, out, -frameAngle);
            };
            vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle) {
                vec2.copy(out, localPoint);
                vec2.rotate(out, out, frameAngle);
                vec2.add(out, out, framePosition);
            };
            vec2.centroid = function(out, a, b, c) {
                vec2.add(out, a, b);
                vec2.add(out, out, c);
                vec2.scale(out, out, 1 / 3);
                return out;
            };
            vec2.create = function() {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = 0;
                out[1] = 0;
                return out;
            };
            vec2.clone = function(a) {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };
            vec2.fromValues = function(x, y) {
                var out = new Utils.ARRAY_TYPE(2);
                out[0] = x;
                out[1] = y;
                return out;
            };
            vec2.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };
            vec2.set = function(out, x, y) {
                out[0] = x;
                out[1] = y;
                return out;
            };
            vec2.add = function(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                return out;
            };
            vec2.subtract = function(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                return out;
            };
            vec2.sub = vec2.subtract;
            vec2.multiply = function(out, a, b) {
                out[0] = a[0] * b[0];
                out[1] = a[1] * b[1];
                return out;
            };
            vec2.mul = vec2.multiply;
            vec2.divide = function(out, a, b) {
                out[0] = a[0] / b[0];
                out[1] = a[1] / b[1];
                return out;
            };
            vec2.div = vec2.divide;
            vec2.scale = function(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                return out;
            };
            vec2.distance = function(a, b) {
                var x = b[0] - a[0], y = b[1] - a[1];
                return Math.sqrt(x * x + y * y);
            };
            vec2.dist = vec2.distance;
            vec2.squaredDistance = function(a, b) {
                var x = b[0] - a[0], y = b[1] - a[1];
                return x * x + y * y;
            };
            vec2.sqrDist = vec2.squaredDistance;
            vec2.length = function(a) {
                var x = a[0], y = a[1];
                return Math.sqrt(x * x + y * y);
            };
            vec2.len = vec2.length;
            vec2.squaredLength = function(a) {
                var x = a[0], y = a[1];
                return x * x + y * y;
            };
            vec2.sqrLen = vec2.squaredLength;
            vec2.negate = function(out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                return out;
            };
            vec2.normalize = function(out, a) {
                var x = a[0], y = a[1];
                var len = x * x + y * y;
                if (len > 0) {
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                }
                return out;
            };
            vec2.dot = function(a, b) {
                return a[0] * b[0] + a[1] * b[1];
            };
            vec2.str = function(a) {
                return "vec2(" + a[0] + ", " + a[1] + ")";
            };
        }, {
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        32: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\Body.js", __dirname = "/objects";
            var vec2 = require("../math/vec2"), decomp = require("poly-decomp"), Convex = require("../shapes/Convex"), AABB = require("../collision/AABB"), EventEmitter = require("../events/EventEmitter");
            module.exports = Body;
            function Body(options) {
                options = options || {};
                EventEmitter.call(this);
                this.id = ++Body._idCounter;
                this.world = null;
                this.shapes = [];
                this.shapeOffsets = [];
                this.shapeAngles = [];
                this.mass = options.mass || 0;
                this.invMass = 0;
                this.inertia = 0;
                this.invInertia = 0;
                this.invMassSolve = 0;
                this.invInertiaSolve = 0;
                this.fixedRotation = !!options.fixedRotation;
                this.position = vec2.fromValues(0, 0);
                if (options.position) {
                    vec2.copy(this.position, options.position);
                }
                this.interpolatedPosition = vec2.fromValues(0, 0);
                this.interpolatedAngle = 0;
                this.previousPosition = vec2.fromValues(0, 0);
                this.previousAngle = 0;
                this.velocity = vec2.fromValues(0, 0);
                if (options.velocity) {
                    vec2.copy(this.velocity, options.velocity);
                }
                this.vlambda = vec2.fromValues(0, 0);
                this.wlambda = 0;
                this.angle = options.angle || 0;
                this.angularVelocity = options.angularVelocity || 0;
                this.force = vec2.create();
                if (options.force) {
                    vec2.copy(this.force, options.force);
                }
                this.angularForce = options.angularForce || 0;
                this.damping = typeof options.damping === "number" ? options.damping : .1;
                this.angularDamping = typeof options.angularDamping === "number" ? options.angularDamping : .1;
                this.type = Body.STATIC;
                if (typeof options.type !== "undefined") {
                    this.type = options.type;
                } else if (!options.mass) {
                    this.type = Body.STATIC;
                } else {
                    this.type = Body.DYNAMIC;
                }
                this.boundingRadius = 0;
                this.aabb = new AABB();
                this.aabbNeedsUpdate = true;
                this.allowSleep = true;
                this.wantsToSleep = false;
                this.sleepState = Body.AWAKE;
                this.sleepSpeedLimit = .2;
                this.sleepTimeLimit = 1;
                this.gravityScale = 1;
                this.timeLastSleepy = 0;
                this.concavePath = null;
                this._wakeUpAfterNarrowphase = false;
                this.updateMassProperties();
            }
            Body.prototype = new EventEmitter();
            Body._idCounter = 0;
            Body.prototype.updateSolveMassProperties = function() {
                if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
                    this.invMassSolve = 0;
                    this.invInertiaSolve = 0;
                } else {
                    this.invMassSolve = this.invMass;
                    this.invInertiaSolve = this.invInertia;
                }
            };
            Body.prototype.setDensity = function(density) {
                var totalArea = this.getArea();
                this.mass = totalArea * density;
                this.updateMassProperties();
            };
            Body.prototype.getArea = function() {
                var totalArea = 0;
                for (var i = 0; i < this.shapes.length; i++) {
                    totalArea += this.shapes[i].area;
                }
                return totalArea;
            };
            Body.prototype.getAABB = function() {
                if (this.aabbNeedsUpdate) {
                    this.updateAABB();
                }
                return this.aabb;
            };
            var shapeAABB = new AABB(), tmp = vec2.create();
            Body.prototype.updateAABB = function() {
                var shapes = this.shapes, shapeOffsets = this.shapeOffsets, shapeAngles = this.shapeAngles, N = shapes.length, offset = tmp, bodyAngle = this.angle;
                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i], angle = shapeAngles[i] + bodyAngle;
                    vec2.rotate(offset, shapeOffsets[i], bodyAngle);
                    vec2.add(offset, offset, this.position);
                    shape.computeAABB(shapeAABB, offset, angle);
                    if (i === 0) {
                        this.aabb.copy(shapeAABB);
                    } else {
                        this.aabb.extend(shapeAABB);
                    }
                }
                this.aabbNeedsUpdate = false;
            };
            Body.prototype.updateBoundingRadius = function() {
                var shapes = this.shapes, shapeOffsets = this.shapeOffsets, N = shapes.length, radius = 0;
                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i], offset = vec2.length(shapeOffsets[i]), r = shape.boundingRadius;
                    if (offset + r > radius) {
                        radius = offset + r;
                    }
                }
                this.boundingRadius = radius;
            };
            Body.prototype.addShape = function(shape, offset, angle) {
                angle = angle || 0;
                if (offset) {
                    offset = vec2.fromValues(offset[0], offset[1]);
                } else {
                    offset = vec2.fromValues(0, 0);
                }
                this.shapes.push(shape);
                this.shapeOffsets.push(offset);
                this.shapeAngles.push(angle);
                this.updateMassProperties();
                this.updateBoundingRadius();
                this.aabbNeedsUpdate = true;
            };
            Body.prototype.removeShape = function(shape) {
                var idx = this.shapes.indexOf(shape);
                if (idx !== -1) {
                    this.shapes.splice(idx, 1);
                    this.shapeOffsets.splice(idx, 1);
                    this.shapeAngles.splice(idx, 1);
                    this.aabbNeedsUpdate = true;
                    return true;
                } else {
                    return false;
                }
            };
            Body.prototype.updateMassProperties = function() {
                if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
                    this.mass = Number.MAX_VALUE;
                    this.invMass = 0;
                    this.inertia = Number.MAX_VALUE;
                    this.invInertia = 0;
                } else {
                    var shapes = this.shapes, N = shapes.length, m = this.mass / N, I = 0;
                    if (!this.fixedRotation) {
                        for (var i = 0; i < N; i++) {
                            var shape = shapes[i], r2 = vec2.squaredLength(this.shapeOffsets[i]), Icm = shape.computeMomentOfInertia(m);
                            I += Icm + m * r2;
                        }
                        this.inertia = I;
                        this.invInertia = I > 0 ? 1 / I : 0;
                    } else {
                        this.inertia = Number.MAX_VALUE;
                        this.invInertia = 0;
                    }
                    this.invMass = 1 / this.mass;
                }
            };
            var Body_applyForce_r = vec2.create();
            Body.prototype.applyForce = function(force, worldPoint) {
                var r = Body_applyForce_r;
                vec2.sub(r, worldPoint, this.position);
                vec2.add(this.force, this.force, force);
                var rotForce = vec2.crossLength(r, force);
                this.angularForce += rotForce;
            };
            Body.prototype.toLocalFrame = function(out, worldPoint) {
                vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
            };
            Body.prototype.toWorldFrame = function(out, localPoint) {
                vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
            };
            Body.prototype.fromPolygon = function(path, options) {
                options = options || {};
                for (var i = this.shapes.length; i >= 0; --i) {
                    this.removeShape(this.shapes[i]);
                }
                var p = new decomp.Polygon();
                p.vertices = path;
                p.makeCCW();
                if (typeof options.removeCollinearPoints === "number") {
                    p.removeCollinearPoints(options.removeCollinearPoints);
                }
                if (typeof options.skipSimpleCheck === "undefined") {
                    if (!p.isSimple()) {
                        return false;
                    }
                }
                this.concavePath = p.vertices.slice(0);
                for (var i = 0; i < this.concavePath.length; i++) {
                    var v = [ 0, 0 ];
                    vec2.copy(v, this.concavePath[i]);
                    this.concavePath[i] = v;
                }
                var convexes;
                if (options.optimalDecomp) {
                    convexes = p.decomp();
                } else {
                    convexes = p.quickDecomp();
                }
                var cm = vec2.create();
                for (var i = 0; i !== convexes.length; i++) {
                    var c = new Convex(convexes[i].vertices);
                    for (var j = 0; j !== c.vertices.length; j++) {
                        var v = c.vertices[j];
                        vec2.sub(v, v, c.centerOfMass);
                    }
                    vec2.scale(cm, c.centerOfMass, 1);
                    c.updateTriangles();
                    c.updateCenterOfMass();
                    c.updateBoundingRadius();
                    this.addShape(c, cm);
                }
                this.adjustCenterOfMass();
                this.aabbNeedsUpdate = true;
                return true;
            };
            var adjustCenterOfMass_tmp1 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp2 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp3 = vec2.fromValues(0, 0), adjustCenterOfMass_tmp4 = vec2.fromValues(0, 0);
            Body.prototype.adjustCenterOfMass = function() {
                var offset_times_area = adjustCenterOfMass_tmp2, sum = adjustCenterOfMass_tmp3, cm = adjustCenterOfMass_tmp4, totalArea = 0;
                vec2.set(sum, 0, 0);
                for (var i = 0; i !== this.shapes.length; i++) {
                    var s = this.shapes[i], offset = this.shapeOffsets[i];
                    vec2.scale(offset_times_area, offset, s.area);
                    vec2.add(sum, sum, offset_times_area);
                    totalArea += s.area;
                }
                vec2.scale(cm, sum, 1 / totalArea);
                for (var i = 0; i !== this.shapes.length; i++) {
                    var s = this.shapes[i], offset = this.shapeOffsets[i];
                    if (!offset) {
                        offset = this.shapeOffsets[i] = vec2.create();
                    }
                    vec2.sub(offset, offset, cm);
                }
                vec2.add(this.position, this.position, cm);
                for (var i = 0; this.concavePath && i < this.concavePath.length; i++) {
                    vec2.sub(this.concavePath[i], this.concavePath[i], cm);
                }
                this.updateMassProperties();
                this.updateBoundingRadius();
            };
            Body.prototype.setZeroForce = function() {
                vec2.set(this.force, 0, 0);
                this.angularForce = 0;
            };
            Body.prototype.resetConstraintVelocity = function() {
                var b = this, vlambda = b.vlambda;
                vec2.set(vlambda, 0, 0);
                b.wlambda = 0;
            };
            Body.prototype.addConstraintVelocity = function() {
                var b = this, v = b.velocity;
                vec2.add(v, v, b.vlambda);
                b.angularVelocity += b.wlambda;
            };
            Body.prototype.applyDamping = function(dt) {
                if (this.type === Body.DYNAMIC) {
                    var v = this.velocity;
                    vec2.scale(v, v, Math.pow(1 - this.damping, dt));
                    this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);
                }
            };
            Body.prototype.wakeUp = function() {
                var s = this.sleepState;
                this.sleepState = Body.AWAKE;
                this.idleTime = 0;
                if (s !== Body.AWAKE) {
                    this.emit(Body.wakeUpEvent);
                }
            };
            Body.prototype.sleep = function() {
                this.sleepState = Body.SLEEPING;
                this.angularVelocity = 0;
                this.angularForce = 0;
                vec2.set(this.velocity, 0, 0);
                vec2.set(this.force, 0, 0);
                this.emit(Body.sleepEvent);
            };
            Body.prototype.sleepTick = function(time, dontSleep, dt) {
                if (!this.allowSleep || this.type === Body.SLEEPING) {
                    return;
                }
                this.wantsToSleep = false;
                var sleepState = this.sleepState, speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
                if (speedSquared >= speedLimitSquared) {
                    this.idleTime = 0;
                    this.sleepState = Body.AWAKE;
                } else {
                    this.idleTime += dt;
                    this.sleepState = Body.SLEEPY;
                }
                if (this.idleTime > this.sleepTimeLimit) {
                    if (!dontSleep) {
                        this.sleep();
                    } else {
                        this.wantsToSleep = true;
                    }
                }
            };
            Body.prototype.getVelocityFromPosition = function(store, timeStep) {
                store = store || vec2.create();
                vec2.sub(store, this.position, this.previousPosition);
                vec2.scale(store, store, 1 / timeStep);
                return store;
            };
            Body.prototype.getAngularVelocityFromPosition = function(timeStep) {
                return (this.angle - this.previousAngle) / timeStep;
            };
            Body.prototype.overlaps = function(body) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
            };
            Body.sleepyEvent = {
                type: "sleepy"
            };
            Body.sleepEvent = {
                type: "sleep"
            };
            Body.wakeUpEvent = {
                type: "wakeup"
            };
            Body.DYNAMIC = 1;
            Body.STATIC = 2;
            Body.KINEMATIC = 4;
            Body.AWAKE = 0;
            Body.SLEEPY = 1;
            Body.SLEEPING = 2;
        }, {
            "../collision/AABB": 9,
            "../events/EventEmitter": 27,
            "../math/vec2": 31,
            "../shapes/Convex": 39,
            __browserify_Buffer: 1,
            __browserify_process: 2,
            "poly-decomp": 7
        } ],
        33: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\LinearSpring.js", __dirname = "/objects";
            var vec2 = require("../math/vec2");
            var Spring = require("./Spring");
            var Utils = require("../utils/Utils");
            module.exports = LinearSpring;
            function LinearSpring(bodyA, bodyB, options) {
                options = options || {};
                Spring.call(this, bodyA, bodyB, options);
                this.localAnchorA = vec2.fromValues(0, 0);
                this.localAnchorB = vec2.fromValues(0, 0);
                if (options.localAnchorA) {
                    vec2.copy(this.localAnchorA, options.localAnchorA);
                }
                if (options.localAnchorB) {
                    vec2.copy(this.localAnchorB, options.localAnchorB);
                }
                if (options.worldAnchorA) {
                    this.setWorldAnchorA(options.worldAnchorA);
                }
                if (options.worldAnchorB) {
                    this.setWorldAnchorB(options.worldAnchorB);
                }
                var worldAnchorA = vec2.create();
                var worldAnchorB = vec2.create();
                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB);
                var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);
                this.restLength = typeof options.restLength === "number" ? options.restLength : worldDistance;
            }
            LinearSpring.prototype = new Spring();
            LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA) {
                this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
            };
            LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB) {
                this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
            };
            LinearSpring.prototype.getWorldAnchorA = function(result) {
                this.bodyA.toWorldFrame(result, this.localAnchorA);
            };
            LinearSpring.prototype.getWorldAnchorB = function(result) {
                this.bodyB.toWorldFrame(result, this.localAnchorB);
            };
            var applyForce_r = vec2.create(), applyForce_r_unit = vec2.create(), applyForce_u = vec2.create(), applyForce_f = vec2.create(), applyForce_worldAnchorA = vec2.create(), applyForce_worldAnchorB = vec2.create(), applyForce_ri = vec2.create(), applyForce_rj = vec2.create(), applyForce_tmp = vec2.create();
            LinearSpring.prototype.applyForce = function() {
                var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
                var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj;
                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB);
                vec2.sub(ri, worldAnchorA, bodyA.position);
                vec2.sub(rj, worldAnchorB, bodyB.position);
                vec2.sub(r, worldAnchorB, worldAnchorA);
                var rlen = vec2.len(r);
                vec2.normalize(r_unit, r);
                vec2.sub(u, bodyB.velocity, bodyA.velocity);
                vec2.crossZV(tmp, bodyB.angularVelocity, rj);
                vec2.add(u, u, tmp);
                vec2.crossZV(tmp, bodyA.angularVelocity, ri);
                vec2.sub(u, u, tmp);
                vec2.scale(f, r_unit, -k * (rlen - l) - d * vec2.dot(u, r_unit));
                vec2.sub(bodyA.force, bodyA.force, f);
                vec2.add(bodyB.force, bodyB.force, f);
                var ri_x_f = vec2.crossLength(ri, f);
                var rj_x_f = vec2.crossLength(rj, f);
                bodyA.angularForce -= ri_x_f;
                bodyB.angularForce += rj_x_f;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Spring": 35,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        34: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\RotationalSpring.js", __dirname = "/objects";
            var vec2 = require("../math/vec2");
            var Spring = require("./Spring");
            module.exports = RotationalSpring;
            function RotationalSpring(bodyA, bodyB, options) {
                options = options || {};
                Spring.call(this, bodyA, bodyB, options);
                this.restAngle = typeof options.restAngle === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
            }
            RotationalSpring.prototype = new Spring();
            RotationalSpring.prototype.applyForce = function() {
                var k = this.stiffness, d = this.damping, l = this.restAngle, bodyA = this.bodyA, bodyB = this.bodyB, x = bodyB.angle - bodyA.angle, u = bodyB.angularVelocity - bodyA.angularVelocity;
                var torque = -k * (x - l) - d * u * 0;
                bodyA.angularForce -= torque;
                bodyB.angularForce += torque;
            };
        }, {
            "../math/vec2": 31,
            "./Spring": 35,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        35: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/objects\\Spring.js", __dirname = "/objects";
            var vec2 = require("../math/vec2");
            var Utils = require("../utils/Utils");
            module.exports = Spring;
            function Spring(bodyA, bodyB, options) {
                options = Utils.defaults(options, {
                    stiffness: 100,
                    damping: 1
                });
                this.stiffness = options.stiffness;
                this.damping = options.damping;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
            }
            Spring.prototype.applyForce = function() {};
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        36: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/p2.js", __dirname = "/";
            module.exports = {
                AABB: require("./collision/AABB"),
                AngleLockEquation: require("./equations/AngleLockEquation"),
                Body: require("./objects/Body"),
                Broadphase: require("./collision/Broadphase"),
                Capsule: require("./shapes/Capsule"),
                Circle: require("./shapes/Circle"),
                Constraint: require("./constraints/Constraint"),
                ContactEquation: require("./equations/ContactEquation"),
                ContactMaterial: require("./material/ContactMaterial"),
                Convex: require("./shapes/Convex"),
                DistanceConstraint: require("./constraints/DistanceConstraint"),
                Equation: require("./equations/Equation"),
                EventEmitter: require("./events/EventEmitter"),
                FrictionEquation: require("./equations/FrictionEquation"),
                GearConstraint: require("./constraints/GearConstraint"),
                GridBroadphase: require("./collision/GridBroadphase"),
                GSSolver: require("./solver/GSSolver"),
                Heightfield: require("./shapes/Heightfield"),
                Line: require("./shapes/Line"),
                LockConstraint: require("./constraints/LockConstraint"),
                Material: require("./material/Material"),
                Narrowphase: require("./collision/Narrowphase"),
                NaiveBroadphase: require("./collision/NaiveBroadphase"),
                Particle: require("./shapes/Particle"),
                Plane: require("./shapes/Plane"),
                RevoluteConstraint: require("./constraints/RevoluteConstraint"),
                PrismaticConstraint: require("./constraints/PrismaticConstraint"),
                Rectangle: require("./shapes/Rectangle"),
                RotationalVelocityEquation: require("./equations/RotationalVelocityEquation"),
                SAPBroadphase: require("./collision/SAPBroadphase"),
                Shape: require("./shapes/Shape"),
                Solver: require("./solver/Solver"),
                Spring: require("./objects/Spring"),
                LinearSpring: require("./objects/LinearSpring"),
                RotationalSpring: require("./objects/RotationalSpring"),
                Utils: require("./utils/Utils"),
                World: require("./world/World"),
                vec2: require("./math/vec2"),
                version: require("../package.json").version
            };
        }, {
            "../package.json": 8,
            "./collision/AABB": 9,
            "./collision/Broadphase": 10,
            "./collision/GridBroadphase": 11,
            "./collision/NaiveBroadphase": 12,
            "./collision/Narrowphase": 13,
            "./collision/SAPBroadphase": 14,
            "./constraints/Constraint": 15,
            "./constraints/DistanceConstraint": 16,
            "./constraints/GearConstraint": 17,
            "./constraints/LockConstraint": 18,
            "./constraints/PrismaticConstraint": 19,
            "./constraints/RevoluteConstraint": 20,
            "./equations/AngleLockEquation": 21,
            "./equations/ContactEquation": 22,
            "./equations/Equation": 23,
            "./equations/FrictionEquation": 24,
            "./equations/RotationalVelocityEquation": 26,
            "./events/EventEmitter": 27,
            "./material/ContactMaterial": 28,
            "./material/Material": 29,
            "./math/vec2": 31,
            "./objects/Body": 32,
            "./objects/LinearSpring": 33,
            "./objects/RotationalSpring": 34,
            "./objects/Spring": 35,
            "./shapes/Capsule": 37,
            "./shapes/Circle": 38,
            "./shapes/Convex": 39,
            "./shapes/Heightfield": 40,
            "./shapes/Line": 41,
            "./shapes/Particle": 42,
            "./shapes/Plane": 43,
            "./shapes/Rectangle": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/Utils": 50,
            "./world/World": 54,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        37: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Capsule.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Capsule;
            function Capsule(length, radius) {
                this.length = length || 1;
                this.radius = radius || 1;
                Shape.call(this, Shape.CAPSULE);
            }
            Capsule.prototype = new Shape();
            Capsule.prototype.computeMomentOfInertia = function(mass) {
                var r = this.radius, w = this.length + r, h = r * 2;
                return mass * (h * h + w * w) / 12;
            };
            Capsule.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2;
            };
            Capsule.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
            };
            var r = vec2.create();
            Capsule.prototype.computeAABB = function(out, position, angle) {
                var radius = this.radius;
                vec2.set(r, this.length / 2, 0);
                if (angle !== 0) {
                    vec2.rotate(r, r, angle);
                }
                vec2.set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));
                vec2.set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));
                vec2.add(out.lowerBound, out.lowerBound, position);
                vec2.add(out.upperBound, out.upperBound, position);
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        38: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Circle.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Circle;
            function Circle(radius) {
                this.radius = radius || 1;
                Shape.call(this, Shape.CIRCLE);
            }
            Circle.prototype = new Shape();
            Circle.prototype.computeMomentOfInertia = function(mass) {
                var r = this.radius;
                return mass * r * r / 2;
            };
            Circle.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius;
            };
            Circle.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius;
            };
            Circle.prototype.computeAABB = function(out, position, angle) {
                var r = this.radius;
                vec2.set(out.upperBound, r, r);
                vec2.set(out.lowerBound, -r, -r);
                if (position) {
                    vec2.add(out.lowerBound, out.lowerBound, position);
                    vec2.add(out.upperBound, out.upperBound, position);
                }
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        39: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Convex.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2"), polyk = require("../math/polyk"), decomp = require("poly-decomp");
            module.exports = Convex;
            function Convex(vertices, axes) {
                this.vertices = [];
                this.axes = [];
                for (var i = 0; i < vertices.length; i++) {
                    var v = vec2.create();
                    vec2.copy(v, vertices[i]);
                    this.vertices.push(v);
                }
                if (axes) {
                    for (var i = 0; i < axes.length; i++) {
                        var axis = vec2.create();
                        vec2.copy(axis, axes[i]);
                        this.axes.push(axis);
                    }
                } else {
                    for (var i = 0; i < vertices.length; i++) {
                        var worldPoint0 = vertices[i];
                        var worldPoint1 = vertices[(i + 1) % vertices.length];
                        var normal = vec2.create();
                        vec2.sub(normal, worldPoint1, worldPoint0);
                        vec2.rotate90cw(normal, normal);
                        vec2.normalize(normal, normal);
                        this.axes.push(normal);
                    }
                }
                this.centerOfMass = vec2.fromValues(0, 0);
                this.triangles = [];
                if (this.vertices.length) {
                    this.updateTriangles();
                    this.updateCenterOfMass();
                }
                this.boundingRadius = 0;
                Shape.call(this, Shape.CONVEX);
                this.updateBoundingRadius();
                this.updateArea();
                if (this.area < 0) {
                    throw new Error("Convex vertices must be given in conter-clockwise winding.");
                }
            }
            Convex.prototype = new Shape();
            var tmpVec1 = vec2.create();
            var tmpVec2 = vec2.create();
            Convex.prototype.projectOntoLocalAxis = function(localAxis, result) {
                var max = null, min = null, v, value, localAxis = tmpVec1;
                for (var i = 0; i < this.vertices.length; i++) {
                    v = this.vertices[i];
                    value = vec2.dot(v, localAxis);
                    if (max === null || value > max) {
                        max = value;
                    }
                    if (min === null || value < min) {
                        min = value;
                    }
                }
                if (min > max) {
                    var t = min;
                    min = max;
                    max = t;
                }
                vec2.set(result, min, max);
            };
            Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result) {
                var worldAxis = tmpVec2;
                this.projectOntoLocalAxis(localAxis, result);
                if (shapeAngle !== 0) {
                    vec2.rotate(worldAxis, localAxis, shapeAngle);
                } else {
                    worldAxis = localAxis;
                }
                var offset = vec2.dot(shapeOffset, worldAxis);
                vec2.set(result, result[0] + offset, result[1] + offset);
            };
            Convex.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                var polykVerts = [];
                for (var i = 0; i < this.vertices.length; i++) {
                    var v = this.vertices[i];
                    polykVerts.push(v[0], v[1]);
                }
                var triangles = polyk.Triangulate(polykVerts);
                for (var i = 0; i < triangles.length; i += 3) {
                    var id1 = triangles[i], id2 = triangles[i + 1], id3 = triangles[i + 2];
                    this.triangles.push([ id1, id2, id3 ]);
                }
            };
            var updateCenterOfMass_centroid = vec2.create(), updateCenterOfMass_centroid_times_mass = vec2.create(), updateCenterOfMass_a = vec2.create(), updateCenterOfMass_b = vec2.create(), updateCenterOfMass_c = vec2.create(), updateCenterOfMass_ac = vec2.create(), updateCenterOfMass_ca = vec2.create(), updateCenterOfMass_cb = vec2.create(), updateCenterOfMass_n = vec2.create();
            Convex.prototype.updateCenterOfMass = function() {
                var triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid = updateCenterOfMass_centroid, n = updateCenterOfMass_n, a = updateCenterOfMass_a, b = updateCenterOfMass_b, c = updateCenterOfMass_c, ac = updateCenterOfMass_ac, ca = updateCenterOfMass_ca, cb = updateCenterOfMass_cb, centroid_times_mass = updateCenterOfMass_centroid_times_mass;
                vec2.set(cm, 0, 0);
                var totalArea = 0;
                for (var i = 0; i !== triangles.length; i++) {
                    var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                    vec2.centroid(centroid, a, b, c);
                    var m = Convex.triangleArea(a, b, c);
                    totalArea += m;
                    vec2.scale(centroid_times_mass, centroid, m);
                    vec2.add(cm, cm, centroid_times_mass);
                }
                vec2.scale(cm, cm, 1 / totalArea);
            };
            Convex.prototype.computeMomentOfInertia = function(mass) {
                var denom = 0, numer = 0, N = this.vertices.length;
                for (var j = N - 1, i = 0; i < N; j = i, i++) {
                    var p0 = this.vertices[j];
                    var p1 = this.vertices[i];
                    var a = Math.abs(vec2.crossLength(p0, p1));
                    var b = vec2.dot(p1, p1) + vec2.dot(p1, p0) + vec2.dot(p0, p0);
                    denom += a * b;
                    numer += a;
                }
                return mass / 6 * (denom / numer);
            };
            Convex.prototype.updateBoundingRadius = function() {
                var verts = this.vertices, r2 = 0;
                for (var i = 0; i !== verts.length; i++) {
                    var l2 = vec2.squaredLength(verts[i]);
                    if (l2 > r2) {
                        r2 = l2;
                    }
                }
                this.boundingRadius = Math.sqrt(r2);
            };
            Convex.triangleArea = function(a, b, c) {
                return ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])) * .5;
            };
            Convex.prototype.updateArea = function() {
                this.updateTriangles();
                this.area = 0;
                var triangles = this.triangles, verts = this.vertices;
                for (var i = 0; i !== triangles.length; i++) {
                    var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
                    var m = Convex.triangleArea(a, b, c);
                    this.area += m;
                }
            };
            Convex.prototype.computeAABB = function(out, position, angle) {
                out.setFromPoints(this.vertices, position, angle, 0);
            };
        }, {
            "../math/polyk": 30,
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2,
            "poly-decomp": 7
        } ],
        40: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Heightfield.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = Heightfield;
            function Heightfield(data, options) {
                options = Utils.defaults(options, {
                    maxValue: null,
                    minValue: null,
                    elementWidth: .1
                });
                if (options.minValue === null || options.maxValue === null) {
                    options.maxValue = data[0];
                    options.minValue = data[0];
                    for (var i = 0; i !== data.length; i++) {
                        var v = data[i];
                        if (v > options.maxValue) {
                            options.maxValue = v;
                        }
                        if (v < options.minValue) {
                            options.minValue = v;
                        }
                    }
                }
                this.data = data;
                this.maxValue = options.maxValue;
                this.minValue = options.minValue;
                this.elementWidth = options.elementWidth;
                Shape.call(this, Shape.HEIGHTFIELD);
            }
            Heightfield.prototype = new Shape();
            Heightfield.prototype.computeMomentOfInertia = function(mass) {
                return Number.MAX_VALUE;
            };
            Heightfield.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            };
            Heightfield.prototype.updateArea = function() {
                var data = this.data, area = 0;
                for (var i = 0; i < data.length - 1; i++) {
                    area += (data[i] + data[i + 1]) / 2 * this.elementWidth;
                }
                this.area = area;
            };
            Heightfield.prototype.computeAABB = function(out, position, angle) {
                out.upperBound[0] = this.elementWidth * this.data.length + position[0];
                out.upperBound[1] = this.maxValue + position[1];
                out.lowerBound[0] = position[0];
                out.lowerBound[1] = -Number.MAX_VALUE;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        41: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Line.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Line;
            function Line(length) {
                this.length = length || 1;
                Shape.call(this, Shape.LINE);
            }
            Line.prototype = new Shape();
            Line.prototype.computeMomentOfInertia = function(mass) {
                return mass * Math.pow(this.length, 2) / 12;
            };
            Line.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2;
            };
            var points = [ vec2.create(), vec2.create() ];
            Line.prototype.computeAABB = function(out, position, angle) {
                var l2 = this.length / 2;
                vec2.set(points[0], -l2, 0);
                vec2.set(points[1], l2, 0);
                out.setFromPoints(points, position, angle, 0);
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        42: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Particle.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2");
            module.exports = Particle;
            function Particle() {
                Shape.call(this, Shape.PARTICLE);
            }
            Particle.prototype = new Shape();
            Particle.prototype.computeMomentOfInertia = function(mass) {
                return 0;
            };
            Particle.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0;
            };
            Particle.prototype.computeAABB = function(out, position, angle) {
                vec2.copy(out.lowerBound, position);
                vec2.copy(out.upperBound, position);
            };
        }, {
            "../math/vec2": 31,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        43: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Plane.js", __dirname = "/shapes";
            var Shape = require("./Shape"), vec2 = require("../math/vec2"), Utils = require("../utils/Utils");
            module.exports = Plane;
            function Plane() {
                Shape.call(this, Shape.PLANE);
            }
            Plane.prototype = new Shape();
            Plane.prototype.computeMomentOfInertia = function(mass) {
                return 0;
            };
            Plane.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE;
            };
            Plane.prototype.computeAABB = function(out, position, angle) {
                var a = 0, set = vec2.set;
                if (typeof angle === "number") {
                    a = angle % (2 * Math.PI);
                }
                if (a === 0) {
                    set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    set(out.upperBound, Number.MAX_VALUE, 0);
                } else if (a === Math.PI / 2) {
                    set(out.lowerBound, 0, -Number.MAX_VALUE);
                    set(out.upperBound, Number.MAX_VALUE, Number.MAX_VALUE);
                } else if (a === Math.PI) {
                    set(out.lowerBound, -Number.MAX_VALUE, 0);
                    set(out.upperBound, Number.MAX_VALUE, Number.MAX_VALUE);
                } else if (a === 3 * Math.PI / 2) {
                    set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    set(out.upperBound, 0, Number.MAX_VALUE);
                } else {
                    set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    set(out.upperBound, Number.MAX_VALUE, Number.MAX_VALUE);
                }
                vec2.add(out.lowerBound, out.lowerBound, position);
                vec2.add(out.upperBound, out.upperBound, position);
            };
            Plane.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE;
            };
        }, {
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        44: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Rectangle.js", __dirname = "/shapes";
            var vec2 = require("../math/vec2"), Shape = require("./Shape"), Convex = require("./Convex");
            module.exports = Rectangle;
            function Rectangle(width, height) {
                this.width = width || 1;
                this.height = height || 1;
                var verts = [ vec2.fromValues(-width / 2, -height / 2), vec2.fromValues(width / 2, -height / 2), vec2.fromValues(width / 2, height / 2), vec2.fromValues(-width / 2, height / 2) ];
                var axes = [ vec2.fromValues(1, 0), vec2.fromValues(0, 1) ];
                Convex.call(this, verts, axes);
                this.type = Shape.RECTANGLE;
            }
            Rectangle.prototype = new Convex([]);
            Rectangle.prototype.computeMomentOfInertia = function(mass) {
                var w = this.width, h = this.height;
                return mass * (h * h + w * w) / 12;
            };
            Rectangle.prototype.updateBoundingRadius = function() {
                var w = this.width, h = this.height;
                this.boundingRadius = Math.sqrt(w * w + h * h) / 2;
            };
            var corner1 = vec2.create(), corner2 = vec2.create(), corner3 = vec2.create(), corner4 = vec2.create();
            Rectangle.prototype.computeAABB = function(out, position, angle) {
                out.setFromPoints(this.vertices, position, angle, 0);
            };
            Rectangle.prototype.updateArea = function() {
                this.area = this.width * this.height;
            };
        }, {
            "../math/vec2": 31,
            "./Convex": 39,
            "./Shape": 45,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        45: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/shapes\\Shape.js", __dirname = "/shapes";
            module.exports = Shape;
            function Shape(type) {
                this.type = type;
                this.id = Shape.idCounter++;
                this.boundingRadius = 0;
                this.collisionGroup = 1;
                this.collisionMask = 1;
                if (type) {
                    this.updateBoundingRadius();
                }
                this.material = null;
                this.area = 0;
                this.sensor = false;
                this.updateArea();
            }
            Shape.idCounter = 0;
            Shape.CIRCLE = 1;
            Shape.PARTICLE = 2;
            Shape.PLANE = 4;
            Shape.CONVEX = 8;
            Shape.LINE = 16;
            Shape.RECTANGLE = 32;
            Shape.CAPSULE = 64;
            Shape.HEIGHTFIELD = 128;
            Shape.prototype.computeMomentOfInertia = function(mass) {
                throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
            };
            Shape.prototype.updateBoundingRadius = function() {
                throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...");
            };
            Shape.prototype.updateArea = function() {};
            Shape.prototype.computeAABB = function(out, position, angle) {};
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        46: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/solver\\GSSolver.js", __dirname = "/solver";
            var vec2 = require("../math/vec2"), Solver = require("./Solver"), Utils = require("../utils/Utils"), FrictionEquation = require("../equations/FrictionEquation");
            module.exports = GSSolver;
            function GSSolver(options) {
                Solver.call(this, options, Solver.GS);
                options = options || {};
                this.iterations = options.iterations || 10;
                this.tolerance = options.tolerance || 1e-10;
                this.arrayStep = 30;
                this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
                this.Bs = new Utils.ARRAY_TYPE(this.arrayStep);
                this.invCs = new Utils.ARRAY_TYPE(this.arrayStep);
                this.useZeroRHS = false;
                this.frictionIterations = 0;
                this.usedIterations = 0;
            }
            GSSolver.prototype = new Solver();
            function setArrayZero(array) {
                var l = array.length;
                while (l--) {
                    array[l] = +0;
                }
            }
            GSSolver.prototype.solve = function(h, world) {
                this.sortEquations();
                var iter = 0, maxIter = this.iterations, maxFrictionIter = this.frictionIterations, equations = this.equations, Neq = equations.length, tolSquared = Math.pow(this.tolerance * Neq, 2), bodies = world.bodies, Nbodies = world.bodies.length, add = vec2.add, set = vec2.set, useZeroRHS = this.useZeroRHS, lambda = this.lambda;
                this.usedIterations = 0;
                if (Neq) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        b.updateSolveMassProperties();
                    }
                }
                if (lambda.length < Neq) {
                    lambda = this.lambda = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                    this.Bs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                    this.invCs = new Utils.ARRAY_TYPE(Neq + this.arrayStep);
                }
                setArrayZero(lambda);
                var invCs = this.invCs, Bs = this.Bs, lambda = this.lambda;
                for (var i = 0; i !== equations.length; i++) {
                    var c = equations[i];
                    if (c.timeStep !== h || c.needsUpdate) {
                        c.timeStep = h;
                        c.update();
                    }
                    Bs[i] = c.computeB(c.a, c.b, h);
                    invCs[i] = c.computeInvC(c.epsilon);
                }
                var q, B, c, deltalambdaTot, i, j;
                if (Neq !== 0) {
                    for (i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        b.resetConstraintVelocity();
                    }
                    if (maxFrictionIter) {
                        for (iter = 0; iter !== maxFrictionIter; iter++) {
                            deltalambdaTot = 0;
                            for (j = 0; j !== Neq; j++) {
                                c = equations[j];
                                var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                                deltalambdaTot += Math.abs(deltalambda);
                            }
                            this.usedIterations++;
                            if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                                break;
                            }
                        }
                        GSSolver.updateMultipliers(equations, lambda, 1 / h);
                        for (j = 0; j !== Neq; j++) {
                            var eq = equations[j];
                            if (eq instanceof FrictionEquation) {
                                var f = 0;
                                for (var k = 0; k !== eq.contactEquations.length; k++) {
                                    f += eq.contactEquations[k].multiplier;
                                }
                                f *= eq.frictionCoefficient / eq.contactEquations.length;
                                eq.maxForce = f;
                                eq.minForce = -f;
                            }
                        }
                    }
                    for (iter = 0; iter !== maxIter; iter++) {
                        deltalambdaTot = 0;
                        for (j = 0; j !== Neq; j++) {
                            c = equations[j];
                            var deltalambda = GSSolver.iterateEquation(j, c, c.epsilon, Bs, invCs, lambda, useZeroRHS, h, iter);
                            deltalambdaTot += Math.abs(deltalambda);
                        }
                        this.usedIterations++;
                        if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                            break;
                        }
                    }
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].addConstraintVelocity();
                    }
                    GSSolver.updateMultipliers(equations, lambda, 1 / h);
                }
            };
            GSSolver.updateMultipliers = function(equations, lambda, invDt) {
                var l = equations.length;
                while (l--) {
                    equations[l].multiplier = lambda[l] * invDt;
                }
            };
            GSSolver.iterateEquation = function(j, eq, eps, Bs, invCs, lambda, useZeroRHS, dt, iter) {
                var B = Bs[j], invC = invCs[j], lambdaj = lambda[j], GWlambda = eq.computeGWlambda();
                var maxForce = eq.maxForce, minForce = eq.minForce;
                if (useZeroRHS) {
                    B = 0;
                }
                var deltalambda = invC * (B - GWlambda - eps * lambdaj);
                var lambdaj_plus_deltalambda = lambdaj + deltalambda;
                if (lambdaj_plus_deltalambda < minForce * dt) {
                    deltalambda = minForce * dt - lambdaj;
                } else if (lambdaj_plus_deltalambda > maxForce * dt) {
                    deltalambda = maxForce * dt - lambdaj;
                }
                lambda[j] += deltalambda;
                eq.addToWlambda(deltalambda);
                return deltalambda;
            };
        }, {
            "../equations/FrictionEquation": 24,
            "../math/vec2": 31,
            "../utils/Utils": 50,
            "./Solver": 47,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        47: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/solver\\Solver.js", __dirname = "/solver";
            var Utils = require("../utils/Utils"), EventEmitter = require("../events/EventEmitter");
            module.exports = Solver;
            function Solver(options, type) {
                options = options || {};
                EventEmitter.call(this);
                this.type = type;
                this.equations = [];
                this.equationSortFunction = options.equationSortFunction || false;
            }
            Solver.prototype = new EventEmitter();
            Solver.prototype.solve = function(dt, world) {
                throw new Error("Solver.solve should be implemented by subclasses!");
            };
            var mockWorld = {
                bodies: []
            };
            Solver.prototype.solveIsland = function(dt, island) {
                this.removeAllEquations();
                if (island.equations.length) {
                    this.addEquations(island.equations);
                    mockWorld.bodies.length = 0;
                    island.getBodies(mockWorld.bodies);
                    if (mockWorld.bodies.length) {
                        this.solve(dt, mockWorld);
                    }
                }
            };
            Solver.prototype.sortEquations = function() {
                if (this.equationSortFunction) {
                    this.equations.sort(this.equationSortFunction);
                }
            };
            Solver.prototype.addEquation = function(eq) {
                if (eq.enabled) {
                    this.equations.push(eq);
                }
            };
            Solver.prototype.addEquations = function(eqs) {
                for (var i = 0, N = eqs.length; i !== N; i++) {
                    var eq = eqs[i];
                    if (eq.enabled) {
                        this.equations.push(eq);
                    }
                }
            };
            Solver.prototype.removeEquation = function(eq) {
                var i = this.equations.indexOf(eq);
                if (i !== -1) {
                    this.equations.splice(i, 1);
                }
            };
            Solver.prototype.removeAllEquations = function() {
                this.equations.length = 0;
            };
            Solver.GS = 1;
            Solver.ISLAND = 2;
        }, {
            "../events/EventEmitter": 27,
            "../utils/Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        48: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/utils\\OverlapKeeper.js", __dirname = "/utils";
            var TupleDictionary = require("./TupleDictionary");
            var Utils = require("./Utils");
            module.exports = OverlapKeeper;
            function OverlapKeeper() {
                this.overlappingShapesLastState = new TupleDictionary();
                this.overlappingShapesCurrentState = new TupleDictionary();
                this.recordPool = [];
                this.tmpDict = new TupleDictionary();
                this.tmpArray1 = [];
            }
            OverlapKeeper.prototype.tick = function() {
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                var l = last.keys.length;
                while (l--) {
                    var key = last.keys[l];
                    var lastObject = last.getByKey(key);
                    var currentObject = current.getByKey(key);
                    if (lastObject && !currentObject) {
                        this.recordPool.push(lastObject);
                    }
                }
                last.reset();
                last.copy(current);
                current.reset();
            };
            OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                if (!current.get(shapeA.id, shapeB.id)) {
                    var data;
                    if (this.recordPool.length) {
                        data = this.recordPool.pop();
                        data.set(bodyA, shapeA, bodyB, shapeB);
                    } else {
                        data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);
                    }
                    current.set(shapeA.id, shapeB.id, data);
                }
            };
            OverlapKeeper.prototype.getNewOverlaps = function(result) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
            };
            OverlapKeeper.prototype.getEndOverlaps = function(result) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
            };
            OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB) {
                var current = this.overlappingShapesCurrentState;
                var l = current.keys.length;
                while (l--) {
                    var key = current.keys[l];
                    var data = current.data[key];
                    if (data.bodyA === bodyA && data.bodyB === bodyB || data.bodyA === bodyB && data.bodyB === bodyA) {
                        return true;
                    }
                }
                return false;
            };
            OverlapKeeper.prototype.getDiff = function(dictA, dictB, result) {
                var result = result || [];
                var last = dictA;
                var current = dictB;
                result.length = 0;
                var l = current.keys.length;
                while (l--) {
                    var key = current.keys[l];
                    var data = current.data[key];
                    if (!data) {
                        throw new Error("Key " + key + " had no data!");
                    }
                    var lastData = last.data[key];
                    if (!lastData) {
                        result.push(data);
                    }
                }
                return result;
            };
            OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB) {
                var idA = shapeA.id | 0, idB = shapeB.id | 0;
                var last = this.overlappingShapesLastState;
                var current = this.overlappingShapesCurrentState;
                return !!!last.get(idA, idB) && !!current.get(idA, idB);
            };
            OverlapKeeper.prototype.getNewBodyOverlaps = function(result) {
                this.tmpArray1.length = 0;
                var overlaps = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(overlaps, result);
            };
            OverlapKeeper.prototype.getEndBodyOverlaps = function(result) {
                this.tmpArray1.length = 0;
                var overlaps = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(overlaps, result);
            };
            OverlapKeeper.prototype.getBodyDiff = function(overlaps, result) {
                result = result || [];
                var accumulator = this.tmpDict;
                var l = overlaps.length;
                while (l--) {
                    var data = overlaps[l];
                    accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
                }
                l = accumulator.keys.length;
                while (l--) {
                    var data = accumulator.getByKey(accumulator.keys[l]);
                    if (data) {
                        result.push(data.bodyA, data.bodyB);
                    }
                }
                accumulator.reset();
                return result;
            };
            function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB) {
                this.shapeA = shapeA;
                this.shapeB = shapeB;
                this.bodyA = bodyA;
                this.bodyB = bodyB;
            }
            OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB) {
                OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
            };
        }, {
            "./TupleDictionary": 49,
            "./Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        49: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/utils\\TupleDictionary.js", __dirname = "/utils";
            var Utils = require("./Utils");
            module.exports = TupleDictionary;
            function TupleDictionary() {
                this.data = {};
                this.keys = [];
            }
            TupleDictionary.prototype.getKey = function(id1, id2) {
                id1 = id1 | 0;
                id2 = id2 | 0;
                if ((id1 | 0) === (id2 | 0)) {
                    return -1;
                }
                return ((id1 | 0) > (id2 | 0) ? id1 << 16 | id2 & 65535 : id2 << 16 | id1 & 65535) | 0;
            };
            TupleDictionary.prototype.getByKey = function(key) {
                key = key | 0;
                return this.data[key];
            };
            TupleDictionary.prototype.get = function(i, j) {
                return this.data[this.getKey(i, j)];
            };
            TupleDictionary.prototype.set = function(i, j, value) {
                if (!value) {
                    throw new Error("No data!");
                }
                var key = this.getKey(i, j);
                if (!this.data[key]) {
                    this.keys.push(key);
                }
                this.data[key] = value;
                return key;
            };
            TupleDictionary.prototype.reset = function() {
                var data = this.data, keys = this.keys;
                var l = keys.length;
                while (l--) {
                    delete data[keys[l]];
                }
                keys.length = 0;
            };
            TupleDictionary.prototype.copy = function(dict) {
                this.reset();
                Utils.appendArray(this.keys, dict.keys);
                var l = dict.keys.length;
                while (l--) {
                    var key = dict.keys[l];
                    this.data[key] = dict.data[key];
                }
            };
        }, {
            "./Utils": 50,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        50: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/utils\\Utils.js", __dirname = "/utils";
            module.exports = Utils;
            function Utils() {}
            Utils.appendArray = function(a, b) {
                if (b.length < 15e4) {
                    a.push.apply(a, b);
                } else {
                    for (var i = 0, len = b.length; i !== len; ++i) {
                        a.push(b[i]);
                    }
                }
            };
            Utils.splice = function(array, index, howmany) {
                howmany = howmany || 1;
                for (var i = index, len = array.length - howmany; i < len; i++) {
                    array[i] = array[i + howmany];
                }
                array.length = len;
            };
            Utils.ARRAY_TYPE = window.Float32Array || Array;
            Utils.extend = function(a, b) {
                for (var key in b) {
                    a[key] = b[key];
                }
            };
            Utils.defaults = function(options, defaults) {
                options = options || {};
                for (var key in defaults) {
                    if (!(key in options)) {
                        options[key] = defaults[key];
                    }
                }
                return options;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        51: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\Island.js", __dirname = "/world";
            var Body = require("../objects/Body");
            module.exports = Island;
            function Island() {
                this.equations = [];
                this.bodies = [];
            }
            Island.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0;
            };
            var bodyIds = [];
            Island.prototype.getBodies = function(result) {
                var bodies = result || [], eqs = this.equations;
                bodyIds.length = 0;
                for (var i = 0; i !== eqs.length; i++) {
                    var eq = eqs[i];
                    if (bodyIds.indexOf(eq.bodyA.id) === -1) {
                        bodies.push(eq.bodyA);
                        bodyIds.push(eq.bodyA.id);
                    }
                    if (bodyIds.indexOf(eq.bodyB.id) === -1) {
                        bodies.push(eq.bodyB);
                        bodyIds.push(eq.bodyB.id);
                    }
                }
                return bodies;
            };
            Island.prototype.wantsToSleep = function() {
                for (var i = 0; i < this.bodies.length; i++) {
                    var b = this.bodies[i];
                    if (b.type === Body.DYNAMIC && !b.wantsToSleep) {
                        return false;
                    }
                }
                return true;
            };
            Island.prototype.sleep = function() {
                for (var i = 0; i < this.bodies.length; i++) {
                    var b = this.bodies[i];
                    b.sleep();
                }
                return true;
            };
        }, {
            "../objects/Body": 32,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        52: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\IslandManager.js", __dirname = "/world";
            var vec2 = require("../math/vec2"), Island = require("./Island"), IslandNode = require("./IslandNode"), Body = require("../objects/Body");
            module.exports = IslandManager;
            function IslandManager(options) {
                this._nodePool = [];
                this._islandPool = [];
                this.equations = [];
                this.islands = [];
                this.nodes = [];
                this.queue = [];
            }
            IslandManager.getUnvisitedNode = function(nodes) {
                var Nnodes = nodes.length;
                for (var i = 0; i !== Nnodes; i++) {
                    var node = nodes[i];
                    if (!node.visited && node.body.type === Body.DYNAMIC) {
                        return node;
                    }
                }
                return false;
            };
            IslandManager.prototype.visit = function(node, bds, eqs) {
                bds.push(node.body);
                var Neqs = node.equations.length;
                for (var i = 0; i !== Neqs; i++) {
                    var eq = node.equations[i];
                    if (eqs.indexOf(eq) === -1) {
                        eqs.push(eq);
                    }
                }
            };
            IslandManager.prototype.bfs = function(root, bds, eqs) {
                var queue = this.queue;
                queue.length = 0;
                queue.push(root);
                root.visited = true;
                this.visit(root, bds, eqs);
                while (queue.length) {
                    var node = queue.pop();
                    var child;
                    while (child = IslandManager.getUnvisitedNode(node.neighbors)) {
                        child.visited = true;
                        this.visit(child, bds, eqs);
                        if (child.body.type === Body.DYNAMIC) {
                            queue.push(child);
                        }
                    }
                }
            };
            IslandManager.prototype.split = function(world) {
                var bodies = world.bodies, nodes = this.nodes, equations = this.equations;
                while (nodes.length) {
                    this._nodePool.push(nodes.pop());
                }
                for (var i = 0; i !== bodies.length; i++) {
                    if (this._nodePool.length) {
                        var node = this._nodePool.pop();
                        node.reset();
                        node.body = bodies[i];
                        nodes.push(node);
                    } else {
                        nodes.push(new IslandNode(bodies[i]));
                    }
                }
                for (var k = 0; k !== equations.length; k++) {
                    var eq = equations[k], i = bodies.indexOf(eq.bodyA), j = bodies.indexOf(eq.bodyB), ni = nodes[i], nj = nodes[j];
                    ni.neighbors.push(nj);
                    nj.neighbors.push(ni);
                    ni.equations.push(eq);
                    nj.equations.push(eq);
                }
                var islands = this.islands;
                while (islands.length) {
                    var island = islands.pop();
                    island.reset();
                    this._islandPool.push(island);
                }
                var child;
                while (child = IslandManager.getUnvisitedNode(nodes)) {
                    var island = this._islandPool.length ? this._islandPool.pop() : new Island();
                    this.bfs(child, island.bodies, island.equations);
                    islands.push(island);
                }
                return islands;
            };
        }, {
            "../math/vec2": 31,
            "../objects/Body": 32,
            "./Island": 51,
            "./IslandNode": 53,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        53: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\IslandNode.js", __dirname = "/world";
            module.exports = IslandNode;
            function IslandNode(body) {
                this.body = body;
                this.neighbors = [];
                this.equations = [];
                this.visited = false;
            }
            IslandNode.prototype.reset = function() {
                this.equations.length = 0;
                this.neighbors.length = 0;
                this.visited = false;
                this.body = null;
            };
        }, {
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ],
        54: [ function(require, module, exports) {
            var process = require("__browserify_process"), global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, Buffer = require("__browserify_Buffer"), __filename = "/world\\World.js", __dirname = "/world";
            var GSSolver = require("../solver/GSSolver"), Solver = require("../solver/Solver"), NaiveBroadphase = require("../collision/NaiveBroadphase"), vec2 = require("../math/vec2"), Circle = require("../shapes/Circle"), Rectangle = require("../shapes/Rectangle"), Convex = require("../shapes/Convex"), Line = require("../shapes/Line"), Plane = require("../shapes/Plane"), Capsule = require("../shapes/Capsule"), Particle = require("../shapes/Particle"), EventEmitter = require("../events/EventEmitter"), Body = require("../objects/Body"), Shape = require("../shapes/Shape"), LinearSpring = require("../objects/LinearSpring"), Material = require("../material/Material"), ContactMaterial = require("../material/ContactMaterial"), DistanceConstraint = require("../constraints/DistanceConstraint"), Constraint = require("../constraints/Constraint"), LockConstraint = require("../constraints/LockConstraint"), RevoluteConstraint = require("../constraints/RevoluteConstraint"), PrismaticConstraint = require("../constraints/PrismaticConstraint"), GearConstraint = require("../constraints/GearConstraint"), pkg = require("../../package.json"), Broadphase = require("../collision/Broadphase"), SAPBroadphase = require("../collision/SAPBroadphase"), Narrowphase = require("../collision/Narrowphase"), Utils = require("../utils/Utils"), OverlapKeeper = require("../utils/OverlapKeeper"), IslandManager = require("./IslandManager"), RotationalSpring = require("../objects/RotationalSpring");
            module.exports = World;
            if (typeof performance === "undefined") {
                performance = {};
            }
            if (!performance.now) {
                var nowOffset = Date.now();
                if (performance.timing && performance.timing.navigationStart) {
                    nowOffset = performance.timing.navigationStart;
                }
                performance.now = function() {
                    return Date.now() - nowOffset;
                };
            }
            function World(options) {
                EventEmitter.apply(this);
                options = options || {};
                this.springs = [];
                this.bodies = [];
                this.disabledBodyCollisionPairs = [];
                this.solver = options.solver || new GSSolver();
                this.narrowphase = new Narrowphase(this);
                this.islandManager = new IslandManager();
                this.gravity = vec2.fromValues(0, -9.78);
                if (options.gravity) {
                    vec2.copy(this.gravity, options.gravity);
                }
                this.frictionGravity = vec2.length(this.gravity) || 10;
                this.useWorldGravityAsFrictionGravity = true;
                this.useFrictionGravityOnZeroGravity = true;
                this.doProfiling = options.doProfiling || false;
                this.lastStepTime = 0;
                this.broadphase = options.broadphase || new SAPBroadphase();
                this.broadphase.setWorld(this);
                this.constraints = [];
                this.defaultMaterial = new Material();
                this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial);
                this.lastTimeStep = 1 / 60;
                this.applySpringForces = true;
                this.applyDamping = true;
                this.applyGravity = true;
                this.solveConstraints = true;
                this.contactMaterials = [];
                this.time = 0;
                this.stepping = false;
                this.bodiesToBeRemoved = [];
                this.fixedStepTime = 0;
                this.islandSplit = typeof options.islandSplit !== "undefined" ? !!options.islandSplit : false;
                this.emitImpactEvent = true;
                this._constraintIdCounter = 0;
                this._bodyIdCounter = 0;
                this.postStepEvent = {
                    type: "postStep"
                };
                this.addBodyEvent = {
                    type: "addBody",
                    body: null
                };
                this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                };
                this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                };
                this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                };
                this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                };
                this.sleepMode = World.NO_SLEEPING;
                this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                };
                this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                };
                this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                };
                this.overlappingShapesLastState = {
                    keys: []
                };
                this.overlappingShapesCurrentState = {
                    keys: []
                };
                this.overlapKeeper = new OverlapKeeper();
            }
            World.prototype = new Object(EventEmitter.prototype);
            World.NO_SLEEPING = 1;
            World.BODY_SLEEPING = 2;
            World.ISLAND_SLEEPING = 4;
            World.prototype.addConstraint = function(c) {
                this.constraints.push(c);
            };
            World.prototype.addContactMaterial = function(contactMaterial) {
                this.contactMaterials.push(contactMaterial);
            };
            World.prototype.removeContactMaterial = function(cm) {
                var idx = this.contactMaterials.indexOf(cm);
                if (idx !== -1) {
                    Utils.splice(this.contactMaterials, idx, 1);
                }
            };
            World.prototype.getContactMaterial = function(materialA, materialB) {
                var cmats = this.contactMaterials;
                for (var i = 0, N = cmats.length; i !== N; i++) {
                    var cm = cmats[i];
                    if (cm.materialA.id === materialA.id && cm.materialB.id === materialB.id || cm.materialA.id === materialB.id && cm.materialB.id === materialA.id) {
                        return cm;
                    }
                }
                return false;
            };
            World.prototype.removeConstraint = function(c) {
                var idx = this.constraints.indexOf(c);
                if (idx !== -1) {
                    Utils.splice(this.constraints, idx, 1);
                }
            };
            var step_r = vec2.create(), step_runit = vec2.create(), step_u = vec2.create(), step_f = vec2.create(), step_fhMinv = vec2.create(), step_velodt = vec2.create(), step_mg = vec2.create(), xiw = vec2.fromValues(0, 0), xjw = vec2.fromValues(0, 0), zero = vec2.fromValues(0, 0), interpvelo = vec2.fromValues(0, 0);
            World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
                maxSubSteps = maxSubSteps || 10;
                timeSinceLastCalled = timeSinceLastCalled || 0;
                if (timeSinceLastCalled === 0) {
                    this.internalStep(dt);
                    this.time += dt;
                } else {
                    var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
                    internalSteps = Math.min(internalSteps, maxSubSteps);
                    var t0 = performance.now();
                    for (var i = 0; i !== internalSteps; i++) {
                        this.internalStep(dt);
                        if (performance.now() - t0 > dt * 1e3) {
                            break;
                        }
                    }
                    this.time += timeSinceLastCalled;
                    var h = this.time % dt;
                    var h_div_dt = h / dt;
                    for (var j = 0; j !== this.bodies.length; j++) {
                        var b = this.bodies[j];
                        if (b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING) {
                            vec2.sub(interpvelo, b.position, b.previousPosition);
                            vec2.scale(interpvelo, interpvelo, h_div_dt);
                            vec2.add(b.interpolatedPosition, b.position, interpvelo);
                            b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
                        } else {
                            vec2.copy(b.interpolatedPosition, b.position);
                            b.interpolatedAngle = b.angle;
                        }
                    }
                }
            };
            var endOverlaps = [];
            World.prototype.internalStep = function(dt) {
                this.stepping = true;
                var that = this, doProfiling = this.doProfiling, Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, t0, t1, fhMinv = step_fhMinv, velodt = step_velodt, mg = step_mg, scale = vec2.scale, add = vec2.add, rotate = vec2.rotate, islandManager = this.islandManager;
                this.overlapKeeper.tick();
                this.lastTimeStep = dt;
                if (doProfiling) {
                    t0 = performance.now();
                }
                if (this.useWorldGravityAsFrictionGravity) {
                    var gravityLen = vec2.length(this.gravity);
                    if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
                        this.frictionGravity = gravityLen;
                    }
                }
                if (this.applyGravity) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i], fi = b.force;
                        if (b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING) {
                            continue;
                        }
                        vec2.scale(mg, g, b.mass * b.gravityScale);
                        add(fi, fi, mg);
                    }
                }
                if (this.applySpringForces) {
                    for (var i = 0; i !== Nsprings; i++) {
                        var s = springs[i];
                        s.applyForce();
                    }
                }
                if (this.applyDamping) {
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i];
                        if (b.type === Body.DYNAMIC) {
                            b.applyDamping(dt);
                        }
                    }
                }
                var result = broadphase.getCollisionPairs(this);
                var ignoredPairs = this.disabledBodyCollisionPairs;
                for (var i = ignoredPairs.length - 2; i >= 0; i -= 2) {
                    for (var j = result.length - 2; j >= 0; j -= 2) {
                        if (ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1] || ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1]) {
                            result.splice(j, 2);
                        }
                    }
                }
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    var c = constraints[i];
                    if (!c.collideConnected) {
                        for (var j = result.length - 2; j >= 0; j -= 2) {
                            if (c.bodyA === result[j] && c.bodyB === result[j + 1] || c.bodyB === result[j] && c.bodyA === result[j + 1]) {
                                result.splice(j, 2);
                            }
                        }
                    }
                }
                this.postBroadphaseEvent.pairs = result;
                this.emit(this.postBroadphaseEvent);
                np.reset(this);
                for (var i = 0, Nresults = result.length; i !== Nresults; i += 2) {
                    var bi = result[i], bj = result[i + 1];
                    for (var k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++) {
                        var si = bi.shapes[k], xi = bi.shapeOffsets[k], ai = bi.shapeAngles[k];
                        for (var l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++) {
                            var sj = bj.shapes[l], xj = bj.shapeOffsets[l], aj = bj.shapeAngles[l];
                            var cm = this.defaultContactMaterial;
                            if (si.material && sj.material) {
                                var tmp = this.getContactMaterial(si.material, sj.material);
                                if (tmp) {
                                    cm = tmp;
                                }
                            }
                            this.runNarrowphase(np, bi, si, xi, ai, bj, sj, xj, aj, cm, this.frictionGravity);
                        }
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    var body = bodies[i];
                    if (body._wakeUpAfterNarrowphase) {
                        body.wakeUp();
                        body._wakeUpAfterNarrowphase = false;
                    }
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(endOverlaps);
                    var e = this.endContactEvent;
                    var l = endOverlaps.length;
                    while (l--) {
                        var data = endOverlaps[l];
                        e.shapeA = data.shapeA;
                        e.shapeB = data.shapeB;
                        e.bodyA = data.bodyA;
                        e.bodyB = data.bodyB;
                        this.emit(e);
                    }
                }
                var preSolveEvent = this.preSolveEvent;
                preSolveEvent.contactEquations = np.contactEquations;
                preSolveEvent.frictionEquations = np.frictionEquations;
                this.emit(preSolveEvent);
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    constraints[i].update();
                }
                if (np.contactEquations.length || np.frictionEquations.length || constraints.length) {
                    if (this.islandSplit) {
                        islandManager.equations.length = 0;
                        Utils.appendArray(islandManager.equations, np.contactEquations);
                        Utils.appendArray(islandManager.equations, np.frictionEquations);
                        for (i = 0; i !== Nconstraints; i++) {
                            Utils.appendArray(islandManager.equations, constraints[i].equations);
                        }
                        islandManager.split(this);
                        for (var i = 0; i !== islandManager.islands.length; i++) {
                            var island = islandManager.islands[i];
                            if (island.equations.length) {
                                solver.solveIsland(dt, island);
                            }
                        }
                    } else {
                        solver.addEquations(np.contactEquations);
                        solver.addEquations(np.frictionEquations);
                        for (i = 0; i !== Nconstraints; i++) {
                            solver.addEquations(constraints[i].equations);
                        }
                        if (this.solveConstraints) {
                            solver.solve(dt, this);
                        }
                        solver.removeAllEquations();
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    var body = bodies[i];
                    if (body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC) {
                        World.integrateBody(body, dt);
                    }
                }
                for (var i = 0; i !== Nbodies; i++) {
                    bodies[i].setZeroForce();
                }
                if (doProfiling) {
                    t1 = performance.now();
                    that.lastStepTime = t1 - t0;
                }
                if (this.emitImpactEvent && this.has("impact")) {
                    var ev = this.impactEvent;
                    for (var i = 0; i !== np.contactEquations.length; i++) {
                        var eq = np.contactEquations[i];
                        if (eq.firstImpact) {
                            ev.bodyA = eq.bodyA;
                            ev.bodyB = eq.bodyB;
                            ev.shapeA = eq.shapeA;
                            ev.shapeB = eq.shapeB;
                            ev.contactEquation = eq;
                            this.emit(ev);
                        }
                    }
                }
                if (this.sleepMode === World.BODY_SLEEPING) {
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].sleepTick(this.time, false, dt);
                    }
                } else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
                    for (i = 0; i !== Nbodies; i++) {
                        bodies[i].sleepTick(this.time, true, dt);
                    }
                    for (var i = 0; i < this.islandManager.islands.length; i++) {
                        var island = this.islandManager.islands[i];
                        if (island.wantsToSleep()) {
                            island.sleep();
                        }
                    }
                }
                this.stepping = false;
                if (this.bodiesToBeRemoved.length) {
                    for (var i = 0; i !== this.bodiesToBeRemoved.length; i++) {
                        this.removeBody(this.bodiesToBeRemoved[i]);
                    }
                    this.bodiesToBeRemoved.length = 0;
                }
                this.emit(this.postStepEvent);
            };
            var ib_fhMinv = vec2.create();
            var ib_velodt = vec2.create();
            World.integrateBody = function(body, dt) {
                var minv = body.invMass, f = body.force, pos = body.position, velo = body.velocity;
                vec2.copy(body.previousPosition, body.position);
                body.previousAngle = body.angle;
                if (!body.fixedRotation) {
                    body.angularVelocity += body.angularForce * body.invInertia * dt;
                    body.angle += body.angularVelocity * dt;
                }
                vec2.scale(ib_fhMinv, f, dt * minv);
                vec2.add(velo, ib_fhMinv, velo);
                vec2.scale(ib_velodt, velo, dt);
                vec2.add(pos, pos, ib_velodt);
                body.aabbNeedsUpdate = true;
            };
            World.prototype.runNarrowphase = function(np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
                if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
                    return;
                }
                vec2.rotate(xiw, xi, bi.angle);
                vec2.rotate(xjw, xj, bj.angle);
                vec2.add(xiw, xiw, bi.position);
                vec2.add(xjw, xjw, bj.position);
                var aiw = ai + bi.angle;
                var ajw = aj + bj.angle;
                np.enableFriction = cm.friction > 0;
                np.frictionCoefficient = cm.friction;
                var reducedMass;
                if (bi.type === Body.STATIC || bi.type === Body.KINEMATIC) {
                    reducedMass = bj.mass;
                } else if (bj.type === Body.STATIC || bj.type === Body.KINEMATIC) {
                    reducedMass = bi.mass;
                } else {
                    reducedMass = bi.mass * bj.mass / (bi.mass + bj.mass);
                }
                np.slipForce = cm.friction * glen * reducedMass;
                np.restitution = cm.restitution;
                np.surfaceVelocity = cm.surfaceVelocity;
                np.frictionStiffness = cm.frictionStiffness;
                np.frictionRelaxation = cm.frictionRelaxation;
                np.stiffness = cm.stiffness;
                np.relaxation = cm.relaxation;
                np.contactSkinSize = cm.contactSkinSize;
                var resolver = np[si.type | sj.type], numContacts = 0;
                if (resolver) {
                    var sensor = si.sensor || sj.sensor;
                    var numFrictionBefore = np.frictionEquations.length;
                    if (si.type < sj.type) {
                        numContacts = resolver.call(np, bi, si, xiw, aiw, bj, sj, xjw, ajw, sensor);
                    } else {
                        numContacts = resolver.call(np, bj, sj, xjw, ajw, bi, si, xiw, aiw, sensor);
                    }
                    var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
                    if (numContacts) {
                        if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
                            var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
                            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                            if (speedSquaredB >= speedLimitSquaredB * 2) {
                                bi._wakeUpAfterNarrowphase = true;
                            }
                        }
                        if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
                            var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
                            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                            if (speedSquaredA >= speedLimitSquaredA * 2) {
                                bj._wakeUpAfterNarrowphase = true;
                            }
                        }
                        this.overlapKeeper.setOverlapping(bi, si, bj, sj);
                        if (this.has("beginContact") && this.overlapKeeper.isNewOverlap(si, sj)) {
                            var e = this.beginContactEvent;
                            e.shapeA = si;
                            e.shapeB = sj;
                            e.bodyA = bi;
                            e.bodyB = bj;
                            e.contactEquations.length = 0;
                            if (typeof numContacts === "number") {
                                for (var i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++) {
                                    e.contactEquations.push(np.contactEquations[i]);
                                }
                            }
                            this.emit(e);
                        }
                        if (typeof numContacts === "number" && numFrictionEquations > 1) {
                            for (var i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++) {
                                var f = np.frictionEquations[i];
                                f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                            }
                        }
                    }
                }
            };
            World.prototype.addSpring = function(s) {
                this.springs.push(s);
                this.addSpringEvent.spring = s;
                this.emit(this.addSpringEvent);
            };
            World.prototype.removeSpring = function(s) {
                var idx = this.springs.indexOf(s);
                if (idx !== -1) {
                    Utils.splice(this.springs, idx, 1);
                }
            };
            World.prototype.addBody = function(body) {
                if (this.bodies.indexOf(body) === -1) {
                    this.bodies.push(body);
                    body.world = this;
                    this.addBodyEvent.body = body;
                    this.emit(this.addBodyEvent);
                }
            };
            World.prototype.removeBody = function(body) {
                if (this.stepping) {
                    this.bodiesToBeRemoved.push(body);
                } else {
                    body.world = null;
                    var idx = this.bodies.indexOf(body);
                    if (idx !== -1) {
                        Utils.splice(this.bodies, idx, 1);
                        this.removeBodyEvent.body = body;
                        body.resetConstraintVelocity();
                        this.emit(this.removeBodyEvent);
                    }
                }
            };
            World.prototype.getBodyById = function(id) {
                var bodies = this.bodies;
                for (var i = 0; i < bodies.length; i++) {
                    var b = bodies[i];
                    if (b.id === id) {
                        return b;
                    }
                }
                return false;
            };
            World.prototype.disableBodyCollision = function(bodyA, bodyB) {
                this.disabledBodyCollisionPairs.push(bodyA, bodyB);
            };
            World.prototype.enableBodyCollision = function(bodyA, bodyB) {
                var pairs = this.disabledBodyCollisionPairs;
                for (var i = 0; i < pairs.length; i += 2) {
                    if (pairs[i] === bodyA && pairs[i + 1] === bodyB || pairs[i + 1] === bodyA && pairs[i] === bodyB) {
                        pairs.splice(i, 2);
                        return;
                    }
                }
            };
            function v2a(v) {
                if (!v) {
                    return v;
                }
                return [ v[0], v[1] ];
            }
            function extend(a, b) {
                for (var key in b) {
                    a[key] = b[key];
                }
            }
            function contactMaterialToJSON(cm) {
                return {
                    id: cm.id,
                    materialA: cm.materialA.id,
                    materialB: cm.materialB.id,
                    friction: cm.friction,
                    restitution: cm.restitution,
                    stiffness: cm.stiffness,
                    relaxation: cm.relaxation,
                    frictionStiffness: cm.frictionStiffness,
                    frictionRelaxation: cm.frictionRelaxation
                };
            }
            World.prototype.clear = function() {
                this.time = 0;
                this.fixedStepTime = 0;
                if (this.solver && this.solver.equations.length) {
                    this.solver.removeAllEquations();
                }
                var cs = this.constraints;
                for (var i = cs.length - 1; i >= 0; i--) {
                    this.removeConstraint(cs[i]);
                }
                var bodies = this.bodies;
                for (var i = bodies.length - 1; i >= 0; i--) {
                    this.removeBody(bodies[i]);
                }
                var springs = this.springs;
                for (var i = springs.length - 1; i >= 0; i--) {
                    this.removeSpring(springs[i]);
                }
                var cms = this.contactMaterials;
                for (var i = cms.length - 1; i >= 0; i--) {
                    this.removeContactMaterial(cms[i]);
                }
                World.apply(this);
            };
            World.prototype.clone = function() {
                var world = new World();
                world.fromJSON(this.toJSON());
                return world;
            };
            var hitTest_tmp1 = vec2.create(), hitTest_zero = vec2.fromValues(0, 0), hitTest_tmp2 = vec2.fromValues(0, 0);
            World.prototype.hitTest = function(worldPoint, bodies, precision) {
                precision = precision || 0;
                var pb = new Body({
                    position: worldPoint
                }), ps = new Particle(), px = worldPoint, pa = 0, x = hitTest_tmp1, zero = hitTest_zero, tmp = hitTest_tmp2;
                pb.addShape(ps);
                var n = this.narrowphase, result = [];
                for (var i = 0, N = bodies.length; i !== N; i++) {
                    var b = bodies[i];
                    for (var j = 0, NS = b.shapes.length; j !== NS; j++) {
                        var s = b.shapes[j], offset = b.shapeOffsets[j] || zero, angle = b.shapeAngles[j] || 0;
                        vec2.rotate(x, offset, b.angle);
                        vec2.add(x, x, b.position);
                        var a = angle + b.angle;
                        if (s instanceof Circle && n.circleParticle(b, s, x, a, pb, ps, px, pa, true) || s instanceof Convex && n.particleConvex(pb, ps, px, pa, b, s, x, a, true) || s instanceof Plane && n.particlePlane(pb, ps, px, pa, b, s, x, a, true) || s instanceof Capsule && n.particleCapsule(pb, ps, px, pa, b, s, x, a, true) || s instanceof Particle && vec2.squaredLength(vec2.sub(tmp, x, worldPoint)) < precision * precision) {
                            result.push(b);
                        }
                    }
                }
                return result;
            };
            World.prototype.setGlobalEquationParameters = function(parameters) {
                parameters = parameters || {};
                for (var i = 0; i !== this.constraints.length; i++) {
                    var c = this.constraints[i];
                    for (var j = 0; j !== c.equations.length; j++) {
                        var eq = c.equations[j];
                        if (typeof parameters.stiffness !== "undefined") {
                            eq.stiffness = parameters.stiffness;
                        }
                        if (typeof parameters.relaxation !== "undefined") {
                            eq.relaxation = parameters.relaxation;
                        }
                        eq.needsUpdate = true;
                    }
                }
                for (var i = 0; i !== this.contactMaterials.length; i++) {
                    var c = this.contactMaterials[i];
                    if (typeof parameters.stiffness !== "undefined") {
                        c.stiffness = parameters.stiffness;
                        c.frictionStiffness = parameters.stiffness;
                    }
                    if (typeof parameters.relaxation !== "undefined") {
                        c.relaxation = parameters.relaxation;
                        c.frictionRelaxation = parameters.relaxation;
                    }
                }
                var c = this.defaultContactMaterial;
                if (typeof parameters.stiffness !== "undefined") {
                    c.stiffness = parameters.stiffness;
                    c.frictionStiffness = parameters.stiffness;
                }
                if (typeof parameters.relaxation !== "undefined") {
                    c.relaxation = parameters.relaxation;
                    c.frictionRelaxation = parameters.relaxation;
                }
            };
            World.prototype.setGlobalStiffness = function(stiffness) {
                this.setGlobalEquationParameters({
                    stiffness: stiffness
                });
            };
            World.prototype.setGlobalRelaxation = function(relaxation) {
                this.setGlobalEquationParameters({
                    relaxation: relaxation
                });
            };
        }, {
            "../../package.json": 8,
            "../collision/Broadphase": 10,
            "../collision/NaiveBroadphase": 12,
            "../collision/Narrowphase": 13,
            "../collision/SAPBroadphase": 14,
            "../constraints/Constraint": 15,
            "../constraints/DistanceConstraint": 16,
            "../constraints/GearConstraint": 17,
            "../constraints/LockConstraint": 18,
            "../constraints/PrismaticConstraint": 19,
            "../constraints/RevoluteConstraint": 20,
            "../events/EventEmitter": 27,
            "../material/ContactMaterial": 28,
            "../material/Material": 29,
            "../math/vec2": 31,
            "../objects/Body": 32,
            "../objects/LinearSpring": 33,
            "../objects/RotationalSpring": 34,
            "../shapes/Capsule": 37,
            "../shapes/Circle": 38,
            "../shapes/Convex": 39,
            "../shapes/Line": 41,
            "../shapes/Particle": 42,
            "../shapes/Plane": 43,
            "../shapes/Rectangle": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 48,
            "../utils/Utils": 50,
            "./IslandManager": 52,
            __browserify_Buffer: 1,
            __browserify_process: 2
        } ]
    }, {}, [ 36 ])(36);
});

p2.Body.prototype.parent = null;

p2.Spring.prototype.parent = null;

Phaser.Physics.P2 = function(game, config) {
    this.game = game;
    if (typeof config === "undefined" || !config.hasOwnProperty("gravity") || !config.hasOwnProperty("broadphase")) {
        config = {
            gravity: [ 0, 0 ],
            broadphase: new p2.SAPBroadphase()
        };
    }
    this.config = config;
    this.world = new p2.World(this.config);
    this.frameRate = 1 / 60;
    this.useElapsedTime = false;
    this.paused = false;
    this.materials = [];
    this.gravity = new Phaser.Physics.P2.InversePointProxy(this, this.world.gravity);
    this.walls = {
        left: null,
        right: null,
        top: null,
        bottom: null
    };
    this.onBodyAdded = new Phaser.Signal();
    this.onBodyRemoved = new Phaser.Signal();
    this.onSpringAdded = new Phaser.Signal();
    this.onSpringRemoved = new Phaser.Signal();
    this.onConstraintAdded = new Phaser.Signal();
    this.onConstraintRemoved = new Phaser.Signal();
    this.onContactMaterialAdded = new Phaser.Signal();
    this.onContactMaterialRemoved = new Phaser.Signal();
    this.postBroadphaseCallback = null;
    this.callbackContext = null;
    this.onBeginContact = new Phaser.Signal();
    this.onEndContact = new Phaser.Signal();
    if (config.hasOwnProperty("mpx") && config.hasOwnProperty("pxm") && config.hasOwnProperty("mpxi") && config.hasOwnProperty("pxmi")) {
        this.mpx = config.mpx;
        this.mpxi = config.mpxi;
        this.pxm = config.pxm;
        this.pxmi = config.pxmi;
    }
    this.world.on("beginContact", this.beginContactHandler, this);
    this.world.on("endContact", this.endContactHandler, this);
    this.collisionGroups = [];
    this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1);
    this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2);
    this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648);
    this.boundsCollidesWith = [];
    this._toRemove = [];
    this._collisionGroupID = 2;
    this.setBoundsToWorld(true, true, true, true, false);
};

Phaser.Physics.P2.prototype = {
    removeBodyNextStep: function(body) {
        this._toRemove.push(body);
    },
    preUpdate: function() {
        var i = this._toRemove.length;
        while (i--) {
            this.removeBody(this._toRemove[i]);
        }
        this._toRemove.length = 0;
    },
    enable: function(object, debug, children) {
        if (typeof debug === "undefined") {
            debug = false;
        }
        if (typeof children === "undefined") {
            children = true;
        }
        var i = 1;
        if (Array.isArray(object)) {
            i = object.length;
            while (i--) {
                if (object[i] instanceof Phaser.Group) {
                    this.enable(object[i].children, debug, children);
                } else {
                    this.enableBody(object[i], debug);
                    if (children && object[i].hasOwnProperty("children") && object[i].children.length > 0) {
                        this.enable(object[i], debug, true);
                    }
                }
            }
        } else {
            if (object instanceof Phaser.Group) {
                this.enable(object.children, debug, children);
            } else {
                this.enableBody(object, debug);
                if (children && object.hasOwnProperty("children") && object.children.length > 0) {
                    this.enable(object.children, debug, true);
                }
            }
        }
    },
    enableBody: function(object, debug) {
        if (object.hasOwnProperty("body") && object.body === null) {
            object.body = new Phaser.Physics.P2.Body(this.game, object, object.x, object.y, 1);
            object.body.debug = debug;
            object.anchor.set(.5);
        }
    },
    setImpactEvents: function(state) {
        if (state) {
            this.world.on("impact", this.impactHandler, this);
        } else {
            this.world.off("impact", this.impactHandler, this);
        }
    },
    setPostBroadphaseCallback: function(callback, context) {
        this.postBroadphaseCallback = callback;
        this.callbackContext = context;
        if (callback !== null) {
            this.world.on("postBroadphase", this.postBroadphaseHandler, this);
        } else {
            this.world.off("postBroadphase", this.postBroadphaseHandler, this);
        }
    },
    postBroadphaseHandler: function(event) {
        var i = event.pairs.length;
        if (this.postBroadphaseCallback && i > 0) {
            while (i -= 2) {
                if (event.pairs[i].parent && event.pairs[i + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, event.pairs[i].parent, event.pairs[i + 1].parent)) {
                    event.pairs.splice(i, 2);
                }
            }
        }
    },
    impactHandler: function(event) {
        if (event.bodyA.parent && event.bodyB.parent) {
            var a = event.bodyA.parent;
            var b = event.bodyB.parent;
            if (a._bodyCallbacks[event.bodyB.id]) {
                a._bodyCallbacks[event.bodyB.id].call(a._bodyCallbackContext[event.bodyB.id], a, b, event.shapeA, event.shapeB);
            }
            if (b._bodyCallbacks[event.bodyA.id]) {
                b._bodyCallbacks[event.bodyA.id].call(b._bodyCallbackContext[event.bodyA.id], b, a, event.shapeB, event.shapeA);
            }
            if (a._groupCallbacks[event.shapeB.collisionGroup]) {
                a._groupCallbacks[event.shapeB.collisionGroup].call(a._groupCallbackContext[event.shapeB.collisionGroup], a, b, event.shapeA, event.shapeB);
            }
            if (b._groupCallbacks[event.shapeA.collisionGroup]) {
                b._groupCallbacks[event.shapeA.collisionGroup].call(b._groupCallbackContext[event.shapeA.collisionGroup], b, a, event.shapeB, event.shapeA);
            }
        }
    },
    beginContactHandler: function(event) {
        this.onBeginContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB, event.contactEquations);
        if (event.bodyA.parent) {
            event.bodyA.parent.onBeginContact.dispatch(event.bodyB.parent, event.shapeA, event.shapeB, event.contactEquations);
        }
        if (event.bodyB.parent) {
            event.bodyB.parent.onBeginContact.dispatch(event.bodyA.parent, event.shapeB, event.shapeA, event.contactEquations);
        }
    },
    endContactHandler: function(event) {
        this.onEndContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB);
        if (event.bodyA.parent) {
            event.bodyA.parent.onEndContact.dispatch(event.bodyB.parent, event.shapeA, event.shapeB);
        }
        if (event.bodyB.parent) {
            event.bodyB.parent.onEndContact.dispatch(event.bodyA.parent, event.shapeB, event.shapeA);
        }
    },
    setBoundsToWorld: function(left, right, top, bottom, setCollisionGroup) {
        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, left, right, top, bottom, setCollisionGroup);
    },
    setWorldMaterial: function(material, left, right, top, bottom) {
        if (typeof left === "undefined") {
            left = true;
        }
        if (typeof right === "undefined") {
            right = true;
        }
        if (typeof top === "undefined") {
            top = true;
        }
        if (typeof bottom === "undefined") {
            bottom = true;
        }
        if (left && this.walls.left) {
            this.walls.left.shapes[0].material = material;
        }
        if (right && this.walls.right) {
            this.walls.right.shapes[0].material = material;
        }
        if (top && this.walls.top) {
            this.walls.top.shapes[0].material = material;
        }
        if (bottom && this.walls.bottom) {
            this.walls.bottom.shapes[0].material = material;
        }
    },
    updateBoundsCollisionGroup: function(setCollisionGroup) {
        var mask = this.everythingCollisionGroup.mask;
        if (typeof setCollisionGroup === "undefined") {
            mask = this.boundsCollisionGroup.mask;
        }
        if (this.walls.left) {
            this.walls.left.shapes[0].collisionGroup = mask;
        }
        if (this.walls.right) {
            this.walls.right.shapes[0].collisionGroup = mask;
        }
        if (this.walls.top) {
            this.walls.top.shapes[0].collisionGroup = mask;
        }
        if (this.walls.bottom) {
            this.walls.bottom.shapes[0].collisionGroup = mask;
        }
    },
    setBounds: function(x, y, width, height, left, right, top, bottom, setCollisionGroup) {
        if (typeof left === "undefined") {
            left = true;
        }
        if (typeof right === "undefined") {
            right = true;
        }
        if (typeof top === "undefined") {
            top = true;
        }
        if (typeof bottom === "undefined") {
            bottom = true;
        }
        if (typeof setCollisionGroup === "undefined") {
            setCollisionGroup = true;
        }
        if (this.walls.left) {
            this.world.removeBody(this.walls.left);
        }
        if (this.walls.right) {
            this.world.removeBody(this.walls.right);
        }
        if (this.walls.top) {
            this.world.removeBody(this.walls.top);
        }
        if (this.walls.bottom) {
            this.world.removeBody(this.walls.bottom);
        }
        if (left) {
            this.walls.left = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x), this.pxmi(y) ],
                angle: 1.5707963267948966
            });
            this.walls.left.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.left);
        }
        if (right) {
            this.walls.right = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x + width), this.pxmi(y) ],
                angle: -1.5707963267948966
            });
            this.walls.right.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.right);
        }
        if (top) {
            this.walls.top = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x), this.pxmi(y) ],
                angle: -3.141592653589793
            });
            this.walls.top.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.top);
        }
        if (bottom) {
            this.walls.bottom = new p2.Body({
                mass: 0,
                position: [ this.pxmi(x), this.pxmi(y + height) ]
            });
            this.walls.bottom.addShape(new p2.Plane());
            if (setCollisionGroup) {
                this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
            }
            this.world.addBody(this.walls.bottom);
        }
    },
    pause: function() {
        this.paused = true;
    },
    resume: function() {
        this.paused = false;
    },
    update: function() {
        if (this.paused) {
            return;
        }
        if (this.useElapsedTime) {
            this.world.step(this.game.time.physicsElapsed);
        } else {
            this.world.step(this.frameRate);
        }
    },
    clear: function() {
        this.world.clear();
        this.world.off("beginContact", this.beginContactHandler, this);
        this.world.off("endContact", this.endContactHandler, this);
        this.postBroadphaseCallback = null;
        this.callbackContext = null;
        this.impactCallback = null;
        this.collisionGroups = [];
        this._toRemove = [];
        this._collisionGroupID = 2;
        this.boundsCollidesWith = [];
    },
    destroy: function() {
        this.clear();
        this.game = null;
    },
    addBody: function(body) {
        if (body.data.world) {
            return false;
        } else {
            this.world.addBody(body.data);
            this.onBodyAdded.dispatch(body);
            return true;
        }
    },
    removeBody: function(body) {
        if (body.data.world == this.world) {
            this.world.removeBody(body.data);
            this.onBodyRemoved.dispatch(body);
        }
        return body;
    },
    addSpring: function(spring) {
        if (spring instanceof Phaser.Physics.P2.Spring || spring instanceof Phaser.Physics.P2.RotationalSpring) {
            this.world.addSpring(spring.data);
        } else {
            this.world.addSpring(spring);
        }
        this.onSpringAdded.dispatch(spring);
        return spring;
    },
    removeSpring: function(spring) {
        if (spring instanceof Phaser.Physics.P2.Spring || spring instanceof Phaser.Physics.P2.RotationalSpring) {
            this.world.removeSpring(spring.data);
        } else {
            this.world.removeSpring(spring);
        }
        this.onSpringRemoved.dispatch(spring);
        return spring;
    },
    createDistanceConstraint: function(bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.DistanceConstraint(this, bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce));
        }
    },
    createGearConstraint: function(bodyA, bodyB, angle, ratio) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.GearConstraint(this, bodyA, bodyB, angle, ratio));
        }
    },
    createRevoluteConstraint: function(bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.RevoluteConstraint(this, bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot));
        }
    },
    createLockConstraint: function(bodyA, bodyB, offset, angle, maxForce) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.LockConstraint(this, bodyA, bodyB, offset, angle, maxForce));
        }
    },
    createPrismaticConstraint: function(bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Constraint, invalid body objects given");
        } else {
            return this.addConstraint(new Phaser.Physics.P2.PrismaticConstraint(this, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce));
        }
    },
    addConstraint: function(constraint) {
        this.world.addConstraint(constraint);
        this.onConstraintAdded.dispatch(constraint);
        return constraint;
    },
    removeConstraint: function(constraint) {
        this.world.removeConstraint(constraint);
        this.onConstraintRemoved.dispatch(constraint);
        return constraint;
    },
    addContactMaterial: function(material) {
        this.world.addContactMaterial(material);
        this.onContactMaterialAdded.dispatch(material);
        return material;
    },
    removeContactMaterial: function(material) {
        this.world.removeContactMaterial(material);
        this.onContactMaterialRemoved.dispatch(material);
        return material;
    },
    getContactMaterial: function(materialA, materialB) {
        return this.world.getContactMaterial(materialA, materialB);
    },
    setMaterial: function(material, bodies) {
        var i = bodies.length;
        while (i--) {
            bodies[i].setMaterial(material);
        }
    },
    createMaterial: function(name, body) {
        name = name || "";
        var material = new Phaser.Physics.P2.Material(name);
        this.materials.push(material);
        if (typeof body !== "undefined") {
            body.setMaterial(material);
        }
        return material;
    },
    createContactMaterial: function(materialA, materialB, options) {
        if (typeof materialA === "undefined") {
            materialA = this.createMaterial();
        }
        if (typeof materialB === "undefined") {
            materialB = this.createMaterial();
        }
        var contact = new Phaser.Physics.P2.ContactMaterial(materialA, materialB, options);
        return this.addContactMaterial(contact);
    },
    getBodies: function() {
        var output = [];
        var i = this.world.bodies.length;
        while (i--) {
            output.push(this.world.bodies[i].parent);
        }
        return output;
    },
    getBody: function(object) {
        if (object instanceof p2.Body) {
            return object;
        } else if (object instanceof Phaser.Physics.P2.Body) {
            return object.data;
        } else if (object["body"] && object["body"].type === Phaser.Physics.P2JS) {
            return object.body.data;
        }
        return null;
    },
    getSprings: function() {
        var output = [];
        var i = this.world.springs.length;
        while (i--) {
            output.push(this.world.springs[i].parent);
        }
        return output;
    },
    getConstraints: function() {
        var output = [];
        var i = this.world.constraints.length;
        while (i--) {
            output.push(this.world.constraints[i].parent);
        }
        return output;
    },
    hitTest: function(worldPoint, bodies, precision, filterStatic) {
        if (typeof bodies === "undefined") {
            bodies = this.world.bodies;
        }
        if (typeof precision === "undefined") {
            precision = 5;
        }
        if (typeof filterStatic === "undefined") {
            filterStatic = false;
        }
        var physicsPosition = [ this.pxmi(worldPoint.x), this.pxmi(worldPoint.y) ];
        var query = [];
        var i = bodies.length;
        while (i--) {
            if (bodies[i] instanceof Phaser.Physics.P2.Body && !(filterStatic && bodies[i].data.type === p2.Body.STATIC)) {
                query.push(bodies[i].data);
            } else if (bodies[i] instanceof p2.Body && bodies[i].parent && !(filterStatic && bodies[i].type === p2.Body.STATIC)) {
                query.push(bodies[i]);
            } else if (bodies[i] instanceof Phaser.Sprite && bodies[i].hasOwnProperty("body") && !(filterStatic && bodies[i].body.data.type === p2.Body.STATIC)) {
                query.push(bodies[i].body.data);
            }
        }
        return this.world.hitTest(physicsPosition, query, precision);
    },
    toJSON: function() {
        return this.world.toJSON();
    },
    createCollisionGroup: function(object) {
        var bitmask = Math.pow(2, this._collisionGroupID);
        if (this.walls.left) {
            this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | bitmask;
        }
        if (this.walls.right) {
            this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | bitmask;
        }
        if (this.walls.top) {
            this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | bitmask;
        }
        if (this.walls.bottom) {
            this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | bitmask;
        }
        this._collisionGroupID++;
        var group = new Phaser.Physics.P2.CollisionGroup(bitmask);
        this.collisionGroups.push(group);
        if (object) {
            this.setCollisionGroup(object, group);
        }
        return group;
    },
    setCollisionGroup: function(object, group) {
        if (object instanceof Phaser.Group) {
            for (var i = 0; i < object.total; i++) {
                if (object.children[i]["body"] && object.children[i]["body"].type === Phaser.Physics.P2JS) {
                    object.children[i].body.setCollisionGroup(group);
                }
            }
        } else {
            object.body.setCollisionGroup(group);
        }
    },
    createSpring: function(bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Spring, invalid body objects given");
        } else {
            return this.addSpring(new Phaser.Physics.P2.Spring(this, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB));
        }
    },
    createRotationalSpring: function(bodyA, bodyB, restAngle, stiffness, damping) {
        bodyA = this.getBody(bodyA);
        bodyB = this.getBody(bodyB);
        if (!bodyA || !bodyB) {
            console.warn("Cannot create Rotational Spring, invalid body objects given");
        } else {
            return this.addSpring(new Phaser.Physics.P2.RotationalSpring(this, bodyA, bodyB, restAngle, stiffness, damping));
        }
    },
    createBody: function(x, y, mass, addToWorld, options, data) {
        if (typeof addToWorld === "undefined") {
            addToWorld = false;
        }
        var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);
        if (data) {
            var result = body.addPolygon(options, data);
            if (!result) {
                return false;
            }
        }
        if (addToWorld) {
            this.world.addBody(body.data);
        }
        return body;
    },
    createParticle: function(x, y, mass, addToWorld, options, data) {
        if (typeof addToWorld === "undefined") {
            addToWorld = false;
        }
        var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);
        if (data) {
            var result = body.addPolygon(options, data);
            if (!result) {
                return false;
            }
        }
        if (addToWorld) {
            this.world.addBody(body.data);
        }
        return body;
    },
    convertCollisionObjects: function(map, layer, addToWorld) {
        if (typeof addToWorld === "undefined") {
            addToWorld = true;
        }
        var output = [];
        for (var i = 0, len = map.collision[layer].length; i < len; i++) {
            var object = map.collision[layer][i];
            var body = this.createBody(object.x, object.y, 0, addToWorld, {}, object.polyline);
            if (body) {
                output.push(body);
            }
        }
        return output;
    },
    clearTilemapLayerBodies: function(map, layer) {
        layer = map.getLayer(layer);
        var i = map.layers[layer].bodies.length;
        while (i--) {
            map.layers[layer].bodies[i].destroy();
        }
        map.layers[layer].bodies.length = 0;
    },
    convertTilemap: function(map, layer, addToWorld, optimize) {
        layer = map.getLayer(layer);
        if (typeof addToWorld === "undefined") {
            addToWorld = true;
        }
        if (typeof optimize === "undefined") {
            optimize = true;
        }
        this.clearTilemapLayerBodies(map, layer);
        var width = 0;
        var sx = 0;
        var sy = 0;
        for (var y = 0, h = map.layers[layer].height; y < h; y++) {
            width = 0;
            for (var x = 0, w = map.layers[layer].width; x < w; x++) {
                var tile = map.layers[layer].data[y][x];
                if (tile && tile.index > -1 && tile.collides) {
                    if (optimize) {
                        var right = map.getTileRight(layer, x, y);
                        if (width === 0) {
                            sx = tile.x * tile.width;
                            sy = tile.y * tile.height;
                            width = tile.width;
                        }
                        if (right && right.collides) {
                            width += tile.width;
                        } else {
                            var body = this.createBody(sx, sy, 0, false);
                            body.addRectangle(width, tile.height, width / 2, tile.height / 2, 0);
                            if (addToWorld) {
                                this.addBody(body);
                            }
                            map.layers[layer].bodies.push(body);
                            width = 0;
                        }
                    } else {
                        var body = this.createBody(tile.x * tile.width, tile.y * tile.height, 0, false);
                        body.addRectangle(tile.width, tile.height, tile.width / 2, tile.height / 2, 0);
                        if (addToWorld) {
                            this.addBody(body);
                        }
                        map.layers[layer].bodies.push(body);
                    }
                }
            }
        }
        return map.layers[layer].bodies;
    },
    mpx: function(v) {
        return v *= 20;
    },
    pxm: function(v) {
        return v * .05;
    },
    mpxi: function(v) {
        return v *= -20;
    },
    pxmi: function(v) {
        return v * -.05;
    }
};

Object.defineProperty(Phaser.Physics.P2.prototype, "friction", {
    get: function() {
        return this.world.defaultContactMaterial.friction;
    },
    set: function(value) {
        this.world.defaultContactMaterial.friction = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "restitution", {
    get: function() {
        return this.world.defaultContactMaterial.restitution;
    },
    set: function(value) {
        this.world.defaultContactMaterial.restitution = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "contactMaterial", {
    get: function() {
        return this.world.defaultContactMaterial;
    },
    set: function(value) {
        this.world.defaultContactMaterial = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "applySpringForces", {
    get: function() {
        return this.world.applySpringForces;
    },
    set: function(value) {
        this.world.applySpringForces = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "applyDamping", {
    get: function() {
        return this.world.applyDamping;
    },
    set: function(value) {
        this.world.applyDamping = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "applyGravity", {
    get: function() {
        return this.world.applyGravity;
    },
    set: function(value) {
        this.world.applyGravity = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "solveConstraints", {
    get: function() {
        return this.world.solveConstraints;
    },
    set: function(value) {
        this.world.solveConstraints = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "time", {
    get: function() {
        return this.world.time;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "emitImpactEvent", {
    get: function() {
        return this.world.emitImpactEvent;
    },
    set: function(value) {
        this.world.emitImpactEvent = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "sleepMode", {
    get: function() {
        return this.world.sleepMode;
    },
    set: function(value) {
        this.world.sleepMode = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.prototype, "total", {
    get: function() {
        return this.world.bodies.length;
    }
});

Phaser.Physics.P2.FixtureList = function(list) {
    if (!Array.isArray(list)) {
        list = [ list ];
    }
    this.rawList = list;
    this.init();
    this.parse(this.rawList);
};

Phaser.Physics.P2.FixtureList.prototype = {
    init: function() {
        this.namedFixtures = {};
        this.groupedFixtures = [];
        this.allFixtures = [];
    },
    setCategory: function(bit, fixtureKey) {
        var setter = function(fixture) {
            fixture.collisionGroup = bit;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    setMask: function(bit, fixtureKey) {
        var setter = function(fixture) {
            fixture.collisionMask = bit;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    setSensor: function(value, fixtureKey) {
        var setter = function(fixture) {
            fixture.sensor = value;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    setMaterial: function(material, fixtureKey) {
        var setter = function(fixture) {
            fixture.material = material;
        };
        this.getFixtures(fixtureKey).forEach(setter);
    },
    getFixtures: function(keys) {
        var fixtures = [];
        if (keys) {
            if (!(keys instanceof Array)) {
                keys = [ keys ];
            }
            var self = this;
            keys.forEach(function(key) {
                if (self.namedFixtures[key]) {
                    fixtures.push(self.namedFixtures[key]);
                }
            });
            return this.flatten(fixtures);
        } else {
            return this.allFixtures;
        }
    },
    getFixtureByKey: function(key) {
        return this.namedFixtures[key];
    },
    getGroup: function(groupID) {
        return this.groupedFixtures[groupID];
    },
    parse: function() {
        var key, value, _ref, _results;
        _ref = this.rawList;
        _results = [];
        for (key in _ref) {
            value = _ref[key];
            if (!isNaN(key - 0)) {
                this.groupedFixtures[key] = this.groupedFixtures[key] || [];
                this.groupedFixtures[key] = this.groupedFixtures[key].concat(value);
            } else {
                this.namedFixtures[key] = this.flatten(value);
            }
            _results.push(this.allFixtures = this.flatten(this.groupedFixtures));
        }
    },
    flatten: function(array) {
        var result, self;
        result = [];
        self = arguments.callee;
        array.forEach(function(item) {
            return Array.prototype.push.apply(result, Array.isArray(item) ? self(item) : [ item ]);
        });
        return result;
    }
};

Phaser.Physics.P2.PointProxy = function(world, destination) {
    this.world = world;
    this.destination = destination;
};

Phaser.Physics.P2.PointProxy.prototype.constructor = Phaser.Physics.P2.PointProxy;

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "x", {
    get: function() {
        return this.world.mpx(this.destination[0]);
    },
    set: function(value) {
        this.destination[0] = this.world.pxm(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "y", {
    get: function() {
        return this.world.mpx(this.destination[1]);
    },
    set: function(value) {
        this.destination[1] = this.world.pxm(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "mx", {
    get: function() {
        return this.destination[0];
    },
    set: function(value) {
        this.destination[0] = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.PointProxy.prototype, "my", {
    get: function() {
        return this.destination[1];
    },
    set: function(value) {
        this.destination[1] = value;
    }
});

Phaser.Physics.P2.InversePointProxy = function(world, destination) {
    this.world = world;
    this.destination = destination;
};

Phaser.Physics.P2.InversePointProxy.prototype.constructor = Phaser.Physics.P2.InversePointProxy;

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "x", {
    get: function() {
        return this.world.mpxi(this.destination[0]);
    },
    set: function(value) {
        this.destination[0] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "y", {
    get: function() {
        return this.world.mpxi(this.destination[1]);
    },
    set: function(value) {
        this.destination[1] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "mx", {
    get: function() {
        return this.destination[0];
    },
    set: function(value) {
        this.destination[0] = -value;
    }
});

Object.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, "my", {
    get: function() {
        return this.destination[1];
    },
    set: function(value) {
        this.destination[1] = -value;
    }
});

Phaser.Physics.P2.Body = function(game, sprite, x, y, mass) {
    sprite = sprite || null;
    x = x || 0;
    y = y || 0;
    if (typeof mass === "undefined") {
        mass = 1;
    }
    this.game = game;
    this.world = game.physics.p2;
    this.sprite = sprite;
    this.type = Phaser.Physics.P2JS;
    this.offset = new Phaser.Point();
    this.data = new p2.Body({
        position: [ this.world.pxmi(x), this.world.pxmi(y) ],
        mass: mass
    });
    this.data.parent = this;
    this.velocity = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.velocity);
    this.force = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.force);
    this.gravity = new Phaser.Point();
    this.onBeginContact = new Phaser.Signal();
    this.onEndContact = new Phaser.Signal();
    this.collidesWith = [];
    this.removeNextStep = false;
    this.debugBody = null;
    this._collideWorldBounds = true;
    this._bodyCallbacks = {};
    this._bodyCallbackContext = {};
    this._groupCallbacks = {};
    this._groupCallbackContext = {};
    if (sprite) {
        this.setRectangleFromSprite(sprite);
        if (sprite.exists) {
            this.game.physics.p2.addBody(this);
        }
    }
};

Phaser.Physics.P2.Body.prototype = {
    createBodyCallback: function(object, callback, callbackContext) {
        var id = -1;
        if (object["id"]) {
            id = object.id;
        } else if (object["body"]) {
            id = object.body.id;
        }
        if (id > -1) {
            if (callback === null) {
                delete this._bodyCallbacks[id];
                delete this._bodyCallbackContext[id];
            } else {
                this._bodyCallbacks[id] = callback;
                this._bodyCallbackContext[id] = callbackContext;
            }
        }
    },
    createGroupCallback: function(group, callback, callbackContext) {
        if (callback === null) {
            delete this._groupCallbacks[group.mask];
            delete this._groupCallbacksContext[group.mask];
        } else {
            this._groupCallbacks[group.mask] = callback;
            this._groupCallbackContext[group.mask] = callbackContext;
        }
    },
    getCollisionMask: function() {
        var mask = 0;
        if (this._collideWorldBounds) {
            mask = this.game.physics.p2.boundsCollisionGroup.mask;
        }
        for (var i = 0; i < this.collidesWith.length; i++) {
            mask = mask | this.collidesWith[i].mask;
        }
        return mask;
    },
    updateCollisionMask: function(shape) {
        var mask = this.getCollisionMask();
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].collisionMask = mask;
            }
        } else {
            shape.collisionMask = mask;
        }
    },
    setCollisionGroup: function(group, shape) {
        var mask = this.getCollisionMask();
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].collisionGroup = group.mask;
                this.data.shapes[i].collisionMask = mask;
            }
        } else {
            shape.collisionGroup = group.mask;
            shape.collisionMask = mask;
        }
    },
    clearCollision: function(clearGroup, clearMask, shape) {
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                if (clearGroup) {
                    this.data.shapes[i].collisionGroup = null;
                }
                if (clearMask) {
                    this.data.shapes[i].collisionMask = null;
                }
            }
        } else {
            if (clearGroup) {
                shape.collisionGroup = null;
            }
            if (clearMask) {
                shape.collisionMask = null;
            }
        }
        if (clearGroup) {
            this.collidesWith.length = 0;
        }
    },
    collides: function(group, callback, callbackContext, shape) {
        if (Array.isArray(group)) {
            for (var i = 0; i < group.length; i++) {
                if (this.collidesWith.indexOf(group[i]) === -1) {
                    this.collidesWith.push(group[i]);
                    if (callback) {
                        this.createGroupCallback(group[i], callback, callbackContext);
                    }
                }
            }
        } else {
            if (this.collidesWith.indexOf(group) === -1) {
                this.collidesWith.push(group);
                if (callback) {
                    this.createGroupCallback(group, callback, callbackContext);
                }
            }
        }
        var mask = this.getCollisionMask();
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].collisionMask = mask;
            }
        } else {
            shape.collisionMask = mask;
        }
    },
    adjustCenterOfMass: function() {
        this.data.adjustCenterOfMass();
    },
    applyDamping: function(dt) {
        this.data.applyDamping(dt);
    },
    applyForce: function(force, worldX, worldY) {
        this.data.applyForce(force, [ this.world.pxmi(worldX), this.world.pxmi(worldY) ]);
    },
    setZeroForce: function() {
        this.data.setZeroForce();
    },
    setZeroRotation: function() {
        this.data.angularVelocity = 0;
    },
    setZeroVelocity: function() {
        this.data.velocity[0] = 0;
        this.data.velocity[1] = 0;
    },
    setZeroDamping: function() {
        this.data.damping = 0;
        this.data.angularDamping = 0;
    },
    toLocalFrame: function(out, worldPoint) {
        return this.data.toLocalFrame(out, worldPoint);
    },
    toWorldFrame: function(out, localPoint) {
        return this.data.toWorldFrame(out, localPoint);
    },
    rotateLeft: function(speed) {
        this.data.angularVelocity = this.world.pxm(-speed);
    },
    rotateRight: function(speed) {
        this.data.angularVelocity = this.world.pxm(speed);
    },
    moveForward: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = magnitude * Math.cos(angle);
        this.data.velocity[1] = magnitude * Math.sin(angle);
    },
    moveBackward: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = -(magnitude * Math.cos(angle));
        this.data.velocity[1] = -(magnitude * Math.sin(angle));
    },
    thrust: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.force[0] += magnitude * Math.cos(angle);
        this.data.force[1] += magnitude * Math.sin(angle);
    },
    reverse: function(speed) {
        var magnitude = this.world.pxmi(-speed);
        var angle = this.data.angle + Math.PI / 2;
        this.data.force[0] -= magnitude * Math.cos(angle);
        this.data.force[1] -= magnitude * Math.sin(angle);
    },
    moveLeft: function(speed) {
        this.data.velocity[0] = this.world.pxmi(-speed);
    },
    moveRight: function(speed) {
        this.data.velocity[0] = this.world.pxmi(speed);
    },
    moveUp: function(speed) {
        this.data.velocity[1] = this.world.pxmi(-speed);
    },
    moveDown: function(speed) {
        this.data.velocity[1] = this.world.pxmi(speed);
    },
    preUpdate: function() {
        if (this.removeNextStep) {
            this.removeFromWorld();
            this.removeNextStep = false;
        }
    },
    postUpdate: function() {
        this.sprite.x = this.world.mpxi(this.data.position[0]);
        this.sprite.y = this.world.mpxi(this.data.position[1]);
        if (!this.fixedRotation) {
            this.sprite.rotation = this.data.angle;
        }
    },
    reset: function(x, y, resetDamping, resetMass) {
        if (typeof resetDamping === "undefined") {
            resetDamping = false;
        }
        if (typeof resetMass === "undefined") {
            resetMass = false;
        }
        this.setZeroForce();
        this.setZeroVelocity();
        this.setZeroRotation();
        if (resetDamping) {
            this.setZeroDamping();
        }
        if (resetMass) {
            this.mass = 1;
        }
        this.x = x;
        this.y = y;
    },
    addToWorld: function() {
        if (this.game.physics.p2._toRemove) {
            for (var i = 0; i < this.game.physics.p2._toRemove.length; i++) {
                if (this.game.physics.p2._toRemove[i] === this) {
                    this.game.physics.p2._toRemove.splice(i, 1);
                }
            }
        }
        if (this.data.world !== this.game.physics.p2.world) {
            this.game.physics.p2.addBody(this);
        }
    },
    removeFromWorld: function() {
        if (this.data.world === this.game.physics.p2.world) {
            this.game.physics.p2.removeBodyNextStep(this);
        }
    },
    destroy: function() {
        this.removeFromWorld();
        this.clearShapes();
        this._bodyCallbacks = {};
        this._bodyCallbackContext = {};
        this._groupCallbacks = {};
        this._groupCallbackContext = {};
        if (this.debugBody) {
            this.debugBody.destroy();
        }
        this.debugBody = null;
        this.sprite.body = null;
        this.sprite = null;
    },
    clearShapes: function() {
        var i = this.data.shapes.length;
        while (i--) {
            this.data.removeShape(this.data.shapes[i]);
        }
        this.shapeChanged();
    },
    addShape: function(shape, offsetX, offsetY, rotation) {
        if (typeof offsetX === "undefined") {
            offsetX = 0;
        }
        if (typeof offsetY === "undefined") {
            offsetY = 0;
        }
        if (typeof rotation === "undefined") {
            rotation = 0;
        }
        this.data.addShape(shape, [ this.world.pxmi(offsetX), this.world.pxmi(offsetY) ], rotation);
        this.shapeChanged();
        return shape;
    },
    addCircle: function(radius, offsetX, offsetY, rotation) {
        var shape = new p2.Circle(this.world.pxm(radius));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addRectangle: function(width, height, offsetX, offsetY, rotation) {
        var shape = new p2.Rectangle(this.world.pxm(width), this.world.pxm(height));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addPlane: function(offsetX, offsetY, rotation) {
        var shape = new p2.Plane();
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addParticle: function(offsetX, offsetY, rotation) {
        var shape = new p2.Particle();
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addLine: function(length, offsetX, offsetY, rotation) {
        var shape = new p2.Line(this.world.pxm(length));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addCapsule: function(length, radius, offsetX, offsetY, rotation) {
        var shape = new p2.Capsule(this.world.pxm(length), this.world.pxm(radius));
        return this.addShape(shape, offsetX, offsetY, rotation);
    },
    addPolygon: function(options, points) {
        options = options || {};
        if (!Array.isArray(points)) {
            points = Array.prototype.slice.call(arguments, 1);
        }
        var path = [];
        if (points.length === 1 && Array.isArray(points[0])) {
            path = points[0].slice(0);
        } else if (Array.isArray(points[0])) {
            path = points.slice();
        } else if (typeof points[0] === "number") {
            for (var i = 0, len = points.length; i < len; i += 2) {
                path.push([ points[i], points[i + 1] ]);
            }
        }
        var idx = path.length - 1;
        if (path[idx][0] === path[0][0] && path[idx][1] === path[0][1]) {
            path.pop();
        }
        for (var p = 0; p < path.length; p++) {
            path[p][0] = this.world.pxmi(path[p][0]);
            path[p][1] = this.world.pxmi(path[p][1]);
        }
        var result = this.data.fromPolygon(path, options);
        this.shapeChanged();
        return result;
    },
    removeShape: function(shape) {
        var result = this.data.removeShape(shape);
        this.shapeChanged();
        return result;
    },
    setCircle: function(radius, offsetX, offsetY, rotation) {
        this.clearShapes();
        return this.addCircle(radius, offsetX, offsetY, rotation);
    },
    setRectangle: function(width, height, offsetX, offsetY, rotation) {
        if (typeof width === "undefined") {
            width = 16;
        }
        if (typeof height === "undefined") {
            height = 16;
        }
        this.clearShapes();
        return this.addRectangle(width, height, offsetX, offsetY, rotation);
    },
    setRectangleFromSprite: function(sprite) {
        if (typeof sprite === "undefined") {
            sprite = this.sprite;
        }
        this.clearShapes();
        return this.addRectangle(sprite.width, sprite.height, 0, 0, sprite.rotation);
    },
    setMaterial: function(material, shape) {
        if (typeof shape === "undefined") {
            for (var i = this.data.shapes.length - 1; i >= 0; i--) {
                this.data.shapes[i].material = material;
            }
        } else {
            shape.material = material;
        }
    },
    shapeChanged: function() {
        if (this.debugBody) {
            this.debugBody.draw();
        }
    },
    addPhaserPolygon: function(key, object) {
        var data = this.game.cache.getPhysicsData(key, object);
        var createdFixtures = [];
        for (var i = 0; i < data.length; i++) {
            var fixtureData = data[i];
            var shapesOfFixture = this.addFixture(fixtureData);
            createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group] || [];
            createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group].concat(shapesOfFixture);
            if (fixtureData.fixtureKey) {
                createdFixtures[fixtureData.fixtureKey] = shapesOfFixture;
            }
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return createdFixtures;
    },
    addFixture: function(fixtureData) {
        var generatedShapes = [];
        if (fixtureData.circle) {
            var shape = new p2.Circle(this.world.pxm(fixtureData.circle.radius));
            shape.collisionGroup = fixtureData.filter.categoryBits;
            shape.collisionMask = fixtureData.filter.maskBits;
            shape.sensor = fixtureData.isSensor;
            var offset = p2.vec2.create();
            offset[0] = this.world.pxmi(fixtureData.circle.position[0] - this.sprite.width / 2);
            offset[1] = this.world.pxmi(fixtureData.circle.position[1] - this.sprite.height / 2);
            this.data.addShape(shape, offset);
            generatedShapes.push(shape);
        } else {
            var polygons = fixtureData.polygons;
            var cm = p2.vec2.create();
            for (var i = 0; i < polygons.length; i++) {
                var shapes = polygons[i];
                var vertices = [];
                for (var s = 0; s < shapes.length; s += 2) {
                    vertices.push([ this.world.pxmi(shapes[s]), this.world.pxmi(shapes[s + 1]) ]);
                }
                var shape = new p2.Convex(vertices);
                for (var j = 0; j !== shape.vertices.length; j++) {
                    var v = shape.vertices[j];
                    p2.vec2.sub(v, v, shape.centerOfMass);
                }
                p2.vec2.scale(cm, shape.centerOfMass, 1);
                cm[0] -= this.world.pxmi(this.sprite.width / 2);
                cm[1] -= this.world.pxmi(this.sprite.height / 2);
                shape.updateTriangles();
                shape.updateCenterOfMass();
                shape.updateBoundingRadius();
                shape.collisionGroup = fixtureData.filter.categoryBits;
                shape.collisionMask = fixtureData.filter.maskBits;
                shape.sensor = fixtureData.isSensor;
                this.data.addShape(shape, cm);
                generatedShapes.push(shape);
            }
        }
        return generatedShapes;
    },
    loadPolygon: function(key, object) {
        var data = this.game.cache.getPhysicsData(key, object);
        var cm = p2.vec2.create();
        for (var i = 0; i < data.length; i++) {
            var vertices = [];
            for (var s = 0; s < data[i].shape.length; s += 2) {
                vertices.push([ this.world.pxmi(data[i].shape[s]), this.world.pxmi(data[i].shape[s + 1]) ]);
            }
            var c = new p2.Convex(vertices);
            for (var j = 0; j !== c.vertices.length; j++) {
                var v = c.vertices[j];
                p2.vec2.sub(v, v, c.centerOfMass);
            }
            p2.vec2.scale(cm, c.centerOfMass, 1);
            cm[0] -= this.world.pxmi(this.sprite.width / 2);
            cm[1] -= this.world.pxmi(this.sprite.height / 2);
            c.updateTriangles();
            c.updateCenterOfMass();
            c.updateBoundingRadius();
            this.data.addShape(c, cm);
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return true;
    }
};

Phaser.Physics.P2.Body.prototype.constructor = Phaser.Physics.P2.Body;

Phaser.Physics.P2.Body.DYNAMIC = 1;

Phaser.Physics.P2.Body.STATIC = 2;

Phaser.Physics.P2.Body.KINEMATIC = 4;

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "static", {
    get: function() {
        return this.data.type === Phaser.Physics.P2.Body.STATIC;
    },
    set: function(value) {
        if (value && this.data.type !== Phaser.Physics.P2.Body.STATIC) {
            this.data.type = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0;
        } else if (!value && this.data.type === Phaser.Physics.P2.Body.STATIC) {
            this.data.type = Phaser.Physics.P2.Body.DYNAMIC;
            if (this.mass === 0) {
                this.mass = 1;
            }
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "dynamic", {
    get: function() {
        return this.data.type === Phaser.Physics.P2.Body.DYNAMIC;
    },
    set: function(value) {
        if (value && this.data.type !== Phaser.Physics.P2.Body.DYNAMIC) {
            this.data.type = Phaser.Physics.P2.Body.DYNAMIC;
            if (this.mass === 0) {
                this.mass = 1;
            }
        } else if (!value && this.data.type === Phaser.Physics.P2.Body.DYNAMIC) {
            this.data.type = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "kinematic", {
    get: function() {
        return this.data.type === Phaser.Physics.P2.Body.KINEMATIC;
    },
    set: function(value) {
        if (value && this.data.type !== Phaser.Physics.P2.Body.KINEMATIC) {
            this.data.type = Phaser.Physics.P2.Body.KINEMATIC;
            this.mass = 4;
        } else if (!value && this.data.type === Phaser.Physics.P2.Body.KINEMATIC) {
            this.data.type = Phaser.Physics.P2.Body.STATIC;
            this.mass = 0;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "allowSleep", {
    get: function() {
        return this.data.allowSleep;
    },
    set: function(value) {
        if (value !== this.data.allowSleep) {
            this.data.allowSleep = value;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angle", {
    get: function() {
        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.angle));
    },
    set: function(value) {
        this.data.angle = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularDamping", {
    get: function() {
        return this.data.angularDamping;
    },
    set: function(value) {
        this.data.angularDamping = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularForce", {
    get: function() {
        return this.data.angularForce;
    },
    set: function(value) {
        this.data.angularForce = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "angularVelocity", {
    get: function() {
        return this.data.angularVelocity;
    },
    set: function(value) {
        this.data.angularVelocity = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "damping", {
    get: function() {
        return this.data.damping;
    },
    set: function(value) {
        this.data.damping = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "fixedRotation", {
    get: function() {
        return this.data.fixedRotation;
    },
    set: function(value) {
        if (value !== this.data.fixedRotation) {
            this.data.fixedRotation = value;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "inertia", {
    get: function() {
        return this.data.inertia;
    },
    set: function(value) {
        this.data.inertia = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "mass", {
    get: function() {
        return this.data.mass;
    },
    set: function(value) {
        if (value !== this.data.mass) {
            this.data.mass = value;
            this.data.updateMassProperties();
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "motionState", {
    get: function() {
        return this.data.type;
    },
    set: function(value) {
        if (value !== this.data.type) {
            this.data.type = value;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "rotation", {
    get: function() {
        return this.data.angle;
    },
    set: function(value) {
        this.data.angle = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "sleepSpeedLimit", {
    get: function() {
        return this.data.sleepSpeedLimit;
    },
    set: function(value) {
        this.data.sleepSpeedLimit = value;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "x", {
    get: function() {
        return this.world.mpxi(this.data.position[0]);
    },
    set: function(value) {
        this.data.position[0] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "y", {
    get: function() {
        return this.world.mpxi(this.data.position[1]);
    },
    set: function(value) {
        this.data.position[1] = this.world.pxmi(value);
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "id", {
    get: function() {
        return this.data.id;
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "debug", {
    get: function() {
        return this.debugBody !== null;
    },
    set: function(value) {
        if (value && !this.debugBody) {
            this.debugBody = new Phaser.Physics.P2.BodyDebug(this.game, this.data);
        } else if (!value && this.debugBody) {
            this.debugBody.destroy();
            this.debugBody = null;
        }
    }
});

Object.defineProperty(Phaser.Physics.P2.Body.prototype, "collideWorldBounds", {
    get: function() {
        return this._collideWorldBounds;
    },
    set: function(value) {
        if (value && !this._collideWorldBounds) {
            this._collideWorldBounds = true;
            this.updateCollisionMask();
        } else if (!value && this._collideWorldBounds) {
            this._collideWorldBounds = false;
            this.updateCollisionMask();
        }
    }
});

Phaser.Physics.P2.BodyDebug = function(game, body, settings) {
    Phaser.Group.call(this, game);
    var defaultSettings = {
        pixelsPerLengthUnit: 20,
        debugPolygons: false,
        lineWidth: 1,
        alpha: .5
    };
    this.settings = Phaser.Utils.extend(defaultSettings, settings);
    this.ppu = this.settings.pixelsPerLengthUnit;
    this.ppu = -1 * this.ppu;
    this.body = body;
    this.canvas = new Phaser.Graphics(game);
    this.canvas.alpha = this.settings.alpha;
    this.add(this.canvas);
    this.draw();
};

Phaser.Physics.P2.BodyDebug.prototype = Object.create(Phaser.Group.prototype);

Phaser.Physics.P2.BodyDebug.prototype.constructor = Phaser.Physics.P2.BodyDebug;

Phaser.Utils.extend(Phaser.Physics.P2.BodyDebug.prototype, {
    update: function() {
        this.updateSpriteTransform();
    },
    updateSpriteTransform: function() {
        this.position.x = this.body.position[0] * this.ppu;
        this.position.y = this.body.position[1] * this.ppu;
        return this.rotation = this.body.angle;
    },
    draw: function() {
        var angle, child, color, i, j, lineColor, lw, obj, offset, sprite, v, verts, vrot, _j, _ref1;
        obj = this.body;
        sprite = this.canvas;
        sprite.clear();
        color = parseInt(this.randomPastelHex(), 16);
        lineColor = 16711680;
        lw = this.lineWidth;
        if (obj instanceof p2.Body && obj.shapes.length) {
            var l = obj.shapes.length;
            i = 0;
            while (i !== l) {
                child = obj.shapes[i];
                offset = obj.shapeOffsets[i];
                angle = obj.shapeAngles[i];
                offset = offset || 0;
                angle = angle || 0;
                if (child instanceof p2.Circle) {
                    this.drawCircle(sprite, offset[0] * this.ppu, offset[1] * this.ppu, angle, child.radius * this.ppu, color, lw);
                } else if (child instanceof p2.Convex) {
                    verts = [];
                    vrot = p2.vec2.create();
                    for (j = _j = 0, _ref1 = child.vertices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                        v = child.vertices[j];
                        p2.vec2.rotate(vrot, v, angle);
                        verts.push([ (vrot[0] + offset[0]) * this.ppu, -(vrot[1] + offset[1]) * this.ppu ]);
                    }
                    this.drawConvex(sprite, verts, child.triangles, lineColor, color, lw, this.settings.debugPolygons, [ offset[0] * this.ppu, -offset[1] * this.ppu ]);
                } else if (child instanceof p2.Plane) {
                    this.drawPlane(sprite, offset[0] * this.ppu, -offset[1] * this.ppu, color, lineColor, lw * 5, lw * 10, lw * 10, this.ppu * 100, angle);
                } else if (child instanceof p2.Line) {
                    this.drawLine(sprite, child.length * this.ppu, lineColor, lw);
                } else if (child instanceof p2.Rectangle) {
                    this.drawRectangle(sprite, offset[0] * this.ppu, -offset[1] * this.ppu, angle, child.width * this.ppu, child.height * this.ppu, lineColor, color, lw);
                }
                i++;
            }
        }
    },
    drawRectangle: function(g, x, y, angle, w, h, color, fillColor, lineWidth) {
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        g.lineStyle(lineWidth, color, 1);
        g.beginFill(fillColor);
        g.drawRect(x - w / 2, y - h / 2, w, h);
    },
    drawCircle: function(g, x, y, angle, radius, color, lineWidth) {
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 16777215;
        }
        g.lineStyle(lineWidth, 0, 1);
        g.beginFill(color, 1);
        g.drawCircle(x, y, -radius);
        g.endFill();
        g.moveTo(x, y);
        g.lineTo(x + radius * Math.cos(-angle), y + radius * Math.sin(-angle));
    },
    drawLine: function(g, len, color, lineWidth) {
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        g.lineStyle(lineWidth * 5, color, 1);
        g.moveTo(-len / 2, 0);
        g.lineTo(len / 2, 0);
    },
    drawConvex: function(g, verts, triangles, color, fillColor, lineWidth, debug, offset) {
        var colors, i, v, v0, v1, x, x0, x1, y, y0, y1;
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        if (!debug) {
            g.lineStyle(lineWidth, color, 1);
            g.beginFill(fillColor);
            i = 0;
            while (i !== verts.length) {
                v = verts[i];
                x = v[0];
                y = v[1];
                if (i === 0) {
                    g.moveTo(x, -y);
                } else {
                    g.lineTo(x, -y);
                }
                i++;
            }
            g.endFill();
            if (verts.length > 2) {
                g.moveTo(verts[verts.length - 1][0], -verts[verts.length - 1][1]);
                return g.lineTo(verts[0][0], -verts[0][1]);
            }
        } else {
            colors = [ 16711680, 65280, 255 ];
            i = 0;
            while (i !== verts.length + 1) {
                v0 = verts[i % verts.length];
                v1 = verts[(i + 1) % verts.length];
                x0 = v0[0];
                y0 = v0[1];
                x1 = v1[0];
                y1 = v1[1];
                g.lineStyle(lineWidth, colors[i % colors.length], 1);
                g.moveTo(x0, -y0);
                g.lineTo(x1, -y1);
                g.drawCircle(x0, -y0, lineWidth * 2);
                i++;
            }
            g.lineStyle(lineWidth, 0, 1);
            return g.drawCircle(offset[0], offset[1], lineWidth * 2);
        }
    },
    drawPath: function(g, path, color, fillColor, lineWidth) {
        var area, i, lastx, lasty, p1x, p1y, p2x, p2y, p3x, p3y, v, x, y;
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 0;
        }
        g.lineStyle(lineWidth, color, 1);
        if (typeof fillColor === "number") {
            g.beginFill(fillColor);
        }
        lastx = null;
        lasty = null;
        i = 0;
        while (i < path.length) {
            v = path[i];
            x = v[0];
            y = v[1];
            if (x !== lastx || y !== lasty) {
                if (i === 0) {
                    g.moveTo(x, y);
                } else {
                    p1x = lastx;
                    p1y = lasty;
                    p2x = x;
                    p2y = y;
                    p3x = path[(i + 1) % path.length][0];
                    p3y = path[(i + 1) % path.length][1];
                    area = (p2x - p1x) * (p3y - p1y) - (p3x - p1x) * (p2y - p1y);
                    if (area !== 0) {
                        g.lineTo(x, y);
                    }
                }
                lastx = x;
                lasty = y;
            }
            i++;
        }
        if (typeof fillColor === "number") {
            g.endFill();
        }
        if (path.length > 2 && typeof fillColor === "number") {
            g.moveTo(path[path.length - 1][0], path[path.length - 1][1]);
            g.lineTo(path[0][0], path[0][1]);
        }
    },
    drawPlane: function(g, x0, x1, color, lineColor, lineWidth, diagMargin, diagSize, maxLength, angle) {
        var max, xd, yd;
        if (typeof lineWidth === "undefined") {
            lineWidth = 1;
        }
        if (typeof color === "undefined") {
            color = 16777215;
        }
        g.lineStyle(lineWidth, lineColor, 11);
        g.beginFill(color);
        max = maxLength;
        g.moveTo(x0, -x1);
        xd = x0 + Math.cos(angle) * this.game.width;
        yd = x1 + Math.sin(angle) * this.game.height;
        g.lineTo(xd, -yd);
        g.moveTo(x0, -x1);
        xd = x0 + Math.cos(angle) * -this.game.width;
        yd = x1 + Math.sin(angle) * -this.game.height;
        g.lineTo(xd, -yd);
    },
    randomPastelHex: function() {
        var blue, green, mix, red;
        mix = [ 255, 255, 255 ];
        red = Math.floor(Math.random() * 256);
        green = Math.floor(Math.random() * 256);
        blue = Math.floor(Math.random() * 256);
        red = Math.floor((red + 3 * mix[0]) / 4);
        green = Math.floor((green + 3 * mix[1]) / 4);
        blue = Math.floor((blue + 3 * mix[2]) / 4);
        return this.rgbToHex(red, green, blue);
    },
    rgbToHex: function(r, g, b) {
        return this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);
    },
    componentToHex: function(c) {
        var hex;
        hex = c.toString(16);
        if (hex.len === 2) {
            return hex;
        } else {
            return hex + "0";
        }
    }
});

Phaser.Physics.P2.Spring = function(world, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {
    this.game = world.game;
    this.world = world;
    if (typeof restLength === "undefined") {
        restLength = 1;
    }
    if (typeof stiffness === "undefined") {
        stiffness = 100;
    }
    if (typeof damping === "undefined") {
        damping = 1;
    }
    restLength = world.pxm(restLength);
    var options = {
        restLength: restLength,
        stiffness: stiffness,
        damping: damping
    };
    if (typeof worldA !== "undefined" && worldA !== null) {
        options.worldAnchorA = [ world.pxm(worldA[0]), world.pxm(worldA[1]) ];
    }
    if (typeof worldB !== "undefined" && worldB !== null) {
        options.worldAnchorB = [ world.pxm(worldB[0]), world.pxm(worldB[1]) ];
    }
    if (typeof localA !== "undefined" && localA !== null) {
        options.localAnchorA = [ world.pxm(localA[0]), world.pxm(localA[1]) ];
    }
    if (typeof localB !== "undefined" && localB !== null) {
        options.localAnchorB = [ world.pxm(localB[0]), world.pxm(localB[1]) ];
    }
    this.data = new p2.LinearSpring(bodyA, bodyB, options);
    this.data.parent = this;
};

Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;

Phaser.Physics.P2.RotationalSpring = function(world, bodyA, bodyB, restAngle, stiffness, damping) {
    this.game = world.game;
    this.world = world;
    if (typeof restAngle === "undefined") {
        restAngle = null;
    }
    if (typeof stiffness === "undefined") {
        stiffness = 100;
    }
    if (typeof damping === "undefined") {
        damping = 1;
    }
    if (restAngle) {
        restAngle = world.pxm(restAngle);
    }
    var options = {
        restAngle: restAngle,
        stiffness: stiffness,
        damping: damping
    };
    this.data = new p2.RotationalSpring(bodyA, bodyB, options);
    this.data.parent = this;
};

Phaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;

Phaser.Physics.P2.Material = function(name) {
    this.name = name;
    p2.Material.call(this);
};

Phaser.Physics.P2.Material.prototype = Object.create(p2.Material.prototype);

Phaser.Physics.P2.Material.prototype.constructor = Phaser.Physics.P2.Material;

Phaser.Physics.P2.ContactMaterial = function(materialA, materialB, options) {
    p2.ContactMaterial.call(this, materialA, materialB, options);
};

Phaser.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype);

Phaser.Physics.P2.ContactMaterial.prototype.constructor = Phaser.Physics.P2.ContactMaterial;

Phaser.Physics.P2.CollisionGroup = function(bitmask) {
    this.mask = bitmask;
};

Phaser.Physics.P2.DistanceConstraint = function(world, bodyA, bodyB, distance, localAnchorA, localAnchorB, maxForce) {
    if (typeof distance === "undefined") {
        distance = 100;
    }
    if (typeof localAnchorA === "undefined") {
        localAnchorA = [ 0, 0 ];
    }
    if (typeof localAnchorB === "undefined") {
        localAnchorB = [ 0, 0 ];
    }
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    this.game = world.game;
    this.world = world;
    distance = world.pxm(distance);
    localAnchorA = [ world.pxmi(localAnchorA[0]), world.pxmi(localAnchorA[1]) ];
    localAnchorB = [ world.pxmi(localAnchorB[0]), world.pxmi(localAnchorB[1]) ];
    var options = {
        distance: distance,
        localAnchorA: localAnchorA,
        localAnchorB: localAnchorB,
        maxForce: maxForce
    };
    p2.DistanceConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype);

Phaser.Physics.P2.DistanceConstraint.prototype.constructor = Phaser.Physics.P2.DistanceConstraint;

Phaser.Physics.P2.GearConstraint = function(world, bodyA, bodyB, angle, ratio) {
    if (typeof angle === "undefined") {
        angle = 0;
    }
    if (typeof ratio === "undefined") {
        ratio = 1;
    }
    this.game = world.game;
    this.world = world;
    var options = {
        angle: angle,
        ratio: ratio
    };
    p2.GearConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype);

Phaser.Physics.P2.GearConstraint.prototype.constructor = Phaser.Physics.P2.GearConstraint;

Phaser.Physics.P2.LockConstraint = function(world, bodyA, bodyB, offset, angle, maxForce) {
    if (typeof offset === "undefined") {
        offset = [ 0, 0 ];
    }
    if (typeof angle === "undefined") {
        angle = 0;
    }
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    this.game = world.game;
    this.world = world;
    offset = [ world.pxm(offset[0]), world.pxm(offset[1]) ];
    var options = {
        localOffsetB: offset,
        localAngleB: angle,
        maxForce: maxForce
    };
    p2.LockConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype);

Phaser.Physics.P2.LockConstraint.prototype.constructor = Phaser.Physics.P2.LockConstraint;

Phaser.Physics.P2.PrismaticConstraint = function(world, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {
    if (typeof lockRotation === "undefined") {
        lockRotation = true;
    }
    if (typeof anchorA === "undefined") {
        anchorA = [ 0, 0 ];
    }
    if (typeof anchorB === "undefined") {
        anchorB = [ 0, 0 ];
    }
    if (typeof axis === "undefined") {
        axis = [ 0, 0 ];
    }
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    this.game = world.game;
    this.world = world;
    anchorA = [ world.pxmi(anchorA[0]), world.pxmi(anchorA[1]) ];
    anchorB = [ world.pxmi(anchorB[0]), world.pxmi(anchorB[1]) ];
    var options = {
        localAnchorA: anchorA,
        localAnchorB: anchorB,
        localAxisA: axis,
        maxForce: maxForce,
        disableRotationalLock: !lockRotation
    };
    p2.PrismaticConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype);

Phaser.Physics.P2.PrismaticConstraint.prototype.constructor = Phaser.Physics.P2.PrismaticConstraint;

Phaser.Physics.P2.RevoluteConstraint = function(world, bodyA, pivotA, bodyB, pivotB, maxForce, worldPivot) {
    if (typeof maxForce === "undefined") {
        maxForce = Number.MAX_VALUE;
    }
    if (typeof worldPivot === "undefined") {
        worldPivot = null;
    }
    this.game = world.game;
    this.world = world;
    pivotA = [ world.pxmi(pivotA[0]), world.pxmi(pivotA[1]) ];
    pivotB = [ world.pxmi(pivotB[0]), world.pxmi(pivotB[1]) ];
    if (worldPivot) {
        worldPivot = [ world.pxmi(worldPivot[0]), world.pxmi(worldPivot[1]) ];
    }
    var options = {
        worldPivot: worldPivot,
        localPivotA: pivotA,
        localPivotB: pivotB,
        maxForce: maxForce
    };
    p2.RevoluteConstraint.call(this, bodyA, bodyB, options);
};

Phaser.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype);

Phaser.Physics.P2.RevoluteConstraint.prototype.constructor = Phaser.Physics.P2.RevoluteConstraint;

(function(window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
            var SKIP_INDEXES = 2;
            var templateArgs = arguments, code = templateArgs[0], message = "[" + (module ? module + ":" : "") + code + "] ", template = templateArgs[1], paramPrefix, i;
            message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                if (shiftedIndex < templateArgs.length) {
                    return toDebugString(templateArgs[shiftedIndex]);
                }
                return match;
            });
            message += "\nhttp://errors.angularjs.org/1.4.0-beta.5/" + (module ? module + "/" : "") + code;
            for (i = SKIP_INDEXES, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") {
                message += paramPrefix + "p" + (i - SKIP_INDEXES) + "=" + encodeURIComponent(toDebugString(templateArgs[i]));
            }
            return new ErrorConstructor(message);
        };
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = "validity";
    var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    };
    var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
    };
    var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
    };
    if ("i" !== "I".toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }
    var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
    msie = document.documentMode;
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false;
        }
        var length = obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
            return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key != "prototype" && key != "length" && key != "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = typeof obj !== "object";
                for (key = 0, length = obj.length; key < length; key++) {
                    if (isPrimitive || key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context, obj);
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        }
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            delete obj.$$hashKey;
        }
    }
    function extend(dst) {
        var h = dst.$$hashKey;
        for (var i = 1, ii = arguments.length; i < ii; i++) {
            var obj = arguments[i];
            if (obj) {
                var keys = Object.keys(obj);
                for (var j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    dst[key] = obj[key];
                }
            }
        }
        setHashKey(dst, h);
        return dst;
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
        return $;
    }
    identity.$inject = [];
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return typeof value === "undefined";
    }
    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function isObject(value) {
        return value !== null && typeof value === "object";
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isDate(value) {
        return toString.call(value) === "[object Date]";
    }
    var isArray = Array.isArray;
    function isFunction(value) {
        return typeof value === "function";
    }
    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return toString.call(obj) === "[object File]";
    }
    function isFormData(obj) {
        return toString.call(obj) === "[object FormData]";
    }
    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
    function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    var trim = function(value) {
        return isString(value) ? value.trim() : value;
    };
    var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) {
            obj[items[i]] = true;
        }
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
            array.splice(index, 1);
        }
        return index;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (isTypedArray(destination)) {
            throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
        }
        if (!destination) {
            destination = source;
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, [], stackSource, stackDest);
                } else if (isTypedArray(source)) {
                    destination = new source.constructor(source);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isRegExp(source)) {
                    destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                    destination.lastIndex = source.lastIndex;
                } else if (isObject(source)) {
                    var emptyObject = Object.create(Object.getPrototypeOf(source));
                    destination = copy(source, emptyObject, stackSource, stackDest);
                }
            }
        } else {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            stackSource = stackSource || [];
            stackDest = stackDest || [];
            if (isObject(source)) {
                var index = stackSource.indexOf(source);
                if (index !== -1) return stackDest[index];
                stackSource.push(source);
                stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) {
                    result = copy(source[i], null, stackSource, stackDest);
                    if (isObject(source[i])) {
                        stackSource.push(source[i]);
                        stackDest.push(result);
                    }
                    destination.push(result);
                }
            } else {
                var h = destination.$$hashKey;
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function(value, key) {
                        delete destination[key];
                    });
                }
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result = copy(source[key], null, stackSource, stackDest);
                        if (isObject(source[key])) {
                            stackSource.push(source[key]);
                            stackDest.push(result);
                        }
                        destination[key] = result;
                    }
                }
                setHashKey(destination, h);
            }
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2) {
            if (t1 == "object") {
                if (isArray(o1)) {
                    if (!isArray(o2)) return false;
                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2)) return false;
                    return equals(o1.getTime(), o2.getTime());
                } else if (isRegExp(o1) && isRegExp(o2)) {
                    return o1.toString() == o2.toString();
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
                    keySet = {};
                    for (key in o1) {
                        if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                        if (!equals(o1[key], o2[key])) return false;
                        keySet[key] = true;
                    }
                    for (key in o2) {
                        if (!keySet.hasOwnProperty(key) && key.charAt(0) !== "$" && o2[key] !== undefined && !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }
    var csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !!(document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]"));
        if (!active) {
            try {
                new Function("");
            } catch (e) {
                active = true;
            }
        }
        return csp.isActive_ = active;
    };
    var jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el;
        var i, ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
            if (el = document.querySelector("[" + ngAttrPrefixes[i].replace(":", "\\:") + "jq]")) {
                break;
            }
        }
        var name;
        if (el) {
            name = getNgAttribute(el, "jq");
        }
        return jq.name_ = name;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self);
            };
        } else {
            return fn;
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
            val = undefined;
        } else if (isWindow(value)) {
            val = "$WINDOW";
        } else if (value && document === value) {
            val = "$DOCUMENT";
        } else if (isScope(value)) {
            val = "$SCOPE";
        }
        return val;
    }
    function toJson(obj, pretty) {
        if (typeof obj === "undefined") return undefined;
        if (!isNumber(pretty)) {
            pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {}, key_value, key;
        forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue) {
                key_value = keyValue.replace(/\+/g, "%20").split("=");
                key = tryDecodeURIComponent(key_value[0]);
                if (isDefined(key)) {
                    var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val;
                    } else if (isArray(obj[key])) {
                        obj[key].push(val);
                    } else {
                        obj[key] = [ obj[key], val ];
                    }
                }
            }
        });
        return obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            if (isArray(value)) {
                forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                });
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
        });
        return parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        element = jqLite(element);
        for (i = 0; i < ii; ++i) {
            attr = ngAttrPrefixes[i] + ngAttr;
            if (isString(attr = element.attr(attr))) {
                return attr;
            }
        }
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                appElement = element;
                module = element.getAttribute(name);
            }
        });
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            var candidate;
            if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                appElement = candidate;
                module = candidate.getAttribute(name);
            }
        });
        if (appElement) {
            config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        if (!isObject(config)) config = {};
        var defaultConfig = {
            strictDi: false
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            element = jqLite(element);
            if (element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [];
            modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]);
            if (config.debugInfoEnabled) {
                modules.push([ "$compileProvider", function($compileProvider) {
                    $compileProvider.debugInfoEnabled(true);
                } ]);
            }
            modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function bootstrapApply(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector);
                    compile(element)(scope);
                });
            } ]);
            return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
            config.debugInfoEnabled = true;
            window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
            angular.resumeDeferredBootstrap();
        }
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
        window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        }
        return injector.get("$$testability");
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        separator = separator || "_";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var bindJQueryFired = false;
    var skipDestroyOnNextJQueryCleanData;
    function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
            return;
        }
        var jqName = jq();
        jQuery = window.jQuery;
        if (isDefined(jqName)) {
            jQuery = jqName === null ? undefined : window[jqName];
        }
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            originalCleanData = jQuery.cleanData;
            jQuery.cleanData = function(elems) {
                var events;
                if (!skipDestroyOnNextJQueryCleanData) {
                    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                        events = jQuery._data(elem, "events");
                        if (events && events.$destroy) {
                            jQuery(elem).triggerHandler("$destroy");
                        }
                    }
                } else {
                    skipDestroyOnNextJQueryCleanData = false;
                }
                originalCleanData(elems);
            };
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
    }
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
        return arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
        }
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split(".");
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes = [ node ];
        do {
            node = node.nextSibling;
            if (!node) break;
            blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
    }
    function createMap() {
        return Object.create(null);
    }
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector");
        var ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, "angular", Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, "module", function() {
            var modules = {};
            return function module(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                    }
                };
                assertNotHasOwnProperty(name, "module");
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                    }
                    var invokeQueue = [];
                    var configBlocks = [];
                    var runBlocks = [];
                    var config = invokeLater("$injector", "invoke", "push", configBlocks);
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };
                    if (configFn) {
                        config(configFn);
                    }
                    return moduleInstance;
                    function invokeLater(provider, method, insertMethod, queue) {
                        if (!queue) queue = invokeQueue;
                        return function() {
                            queue[insertMethod || "push"]([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                });
            };
        });
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            val = toJsonReplacer(key, val);
            if (isObject(val)) {
                if (seen.indexOf(val) >= 0) return "<<already seen>>";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        if (typeof obj === "function") {
            return obj.toString().replace(/ \{[\s\S]*$/, "");
        } else if (typeof obj === "undefined") {
            return "undefined";
        } else if (typeof obj !== "string") {
            return serializeObject(obj);
        }
        return obj;
    }
    var version = {
        full: "1.4.0-beta.5",
        major: 1,
        minor: 4,
        dot: 0,
        codeName: "karmic-stabilization"
    };
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider,
                $$jqLite: $$jqLiteProvider
            });
        } ]);
    }
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, false);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, false);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
        return ++jqId;
    }
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    };
    var jqLiteMinErr = minErr("jqLite");
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
    var wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
        } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
            i = wrap[0];
            while (i--) {
                tmp = tmp.lastChild;
            }
            nodes = concat(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
            fragment.appendChild(node);
        });
        return fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [ context.createElement(parsed[1]) ];
        }
        if (parsed = jqLiteBuildFragment(html, context)) {
            return parsed.childNodes;
        }
        return [];
    }
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        var argIsString;
        if (isString(element)) {
            element = trim(element);
            argIsString = true;
        }
        if (!(this instanceof JQLite)) {
            if (argIsString && element.charAt(0) != "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element);
        }
        if (argIsString) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
            jqLiteAddNodes(this, element);
        }
    }
    function jqLiteClone(element) {
        return element.cloneNode(true);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants) jqLiteRemoveData(element);
        if (element.querySelectorAll) {
            var descendants = element.querySelectorAll("*");
            for (var i = 0, l = descendants.length; i < l; i++) {
                jqLiteRemoveData(descendants[i]);
            }
        }
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle) return;
        if (!type) {
            for (type in events) {
                if (type !== "$destroy") {
                    removeEventListenerFn(element, type, handle);
                }
                delete events[type];
            }
        } else {
            forEach(type.split(" "), function(type) {
                if (isDefined(fn)) {
                    var listenerFns = events[type];
                    arrayRemove(listenerFns || [], fn);
                    if (listenerFns && listenerFns.length > 0) {
                        return;
                    }
                }
                removeEventListenerFn(element, type, handle);
                delete events[type];
            });
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) {
                delete expandoStore.data[name];
                return;
            }
            if (expandoStore.handle) {
                if (expandoStore.events.$destroy) {
                    expandoStore.handle({}, "$destroy");
                }
                jqLiteOff(element);
            }
            delete jqCache[expandoId];
            element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
            element.ng339 = expandoId = jqNextId();
            expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: undefined
            };
        }
        return expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value);
            var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
            var massGetter = !key;
            var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
            var data = expandoStore && expandoStore.data;
            if (isSimpleSetter) {
                data[key] = value;
            } else {
                if (massGetter) {
                    return data;
                } else {
                    if (isSimpleGetter) {
                        return data && data[key];
                    } else {
                        extend(data, key);
                    }
                }
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute) return false;
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            forEach(cssClasses.split(" "), function(cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
            });
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                    existingClasses += cssClass + " ";
                }
            });
            element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            if (elements.nodeType) {
                root[root.length++] = elements;
            } else {
                var length = elements.length;
                if (typeof length === "number" && elements.window !== elements) {
                    if (length) {
                        for (var i = 0; i < length; i++) {
                            root[root.length++] = elements[i];
                        }
                    }
                } else {
                    root[root.length++] = elements;
                }
            }
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
            element = element.documentElement;
        }
        var names = isArray(name) ? name : [ name ];
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            }
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }
    function jqLiteRemove(element, keepData) {
        if (!keepData) jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent) parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === "complete") {
            win.setTimeout(action);
        } else {
            jqLite(win).on("load", action);
        }
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;
            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }
            if (document.readyState === "complete") {
                setTimeout(trigger);
            } else {
                this.on("DOMContentLoaded", trigger);
                JQLite(window).on("load", trigger);
            }
        },
        toString: function() {
            var value = [];
            forEach(this, function(e) {
                value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return (nodeName === "INPUT" || nodeName === "TEXTAREA") && ALIASED_ATTR[name];
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn;
    });
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            name = camelCase(name);
            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                return element.style[name];
            }
        },
        attr: function(element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return ret === null ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },
        text: function() {
            getText.$dv = "";
            return getText;
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && nodeName_(element) === "select") {
                    var result = [];
                    forEach(element.options, function(option) {
                        if (option.selected) {
                            result.push(option.value || option.text);
                        }
                    });
                    return result.length === 0 ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            jqLiteDealoc(element, true);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;
            var nodeCount = this.length;
            if (fn !== jqLiteEmpty && (fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    var jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount;
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue;
                    }
                    return value;
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2);
                }
                return this;
            }
        };
    });
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type];
            var eventFnsLength = eventFns ? eventFns.length : 0;
            if (!eventFnsLength) return;
            if (isUndefined(event.immediatePropagationStopped)) {
                var originalStopImmediatePropagation = event.stopImmediatePropagation;
                event.stopImmediatePropagation = function() {
                    event.immediatePropagationStopped = true;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (originalStopImmediatePropagation) {
                        originalStopImmediatePropagation.call(event);
                    }
                };
            }
            event.isImmediatePropagationStopped = function() {
                return event.immediatePropagationStopped === true;
            };
            if (eventFnsLength > 1) {
                eventFns = shallowCopy(eventFns);
            }
            for (var i = 0; i < eventFnsLength; i++) {
                if (!event.isImmediatePropagationStopped()) {
                    eventFns[i].call(element, event);
                }
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }
    forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (!jqLiteAcceptsData(element)) {
                return;
            }
            var expandoStore = jqLiteExpandoStore(element, true);
            var events = expandoStore.events;
            var handle = expandoStore.handle;
            if (!handle) {
                handle = expandoStore.handle = createEventHandler(element, events);
            }
            var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ];
            var i = types.length;
            while (i--) {
                type = types[i];
                var eventFns = events[type];
                if (!eventFns) {
                    events[type] = [];
                    if (type === "mouseenter" || type === "mouseleave") {
                        jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                            var target = this, related = event.relatedTarget;
                            if (!related || related !== target && !target.contains(related)) {
                                handle(event, type);
                            }
                        });
                    } else {
                        if (type !== "$destroy") {
                            addEventListenerFn(element, type, handle);
                        }
                    }
                    eventFns = events[type];
                }
                eventFns.push(fn);
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element);
            element.on(type, function onFn() {
                element.off(type, fn);
                element.off(type, onFn);
            });
            element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element) {
                if (element.nodeType === NODE_TYPE_ELEMENT) {
                    children.push(element);
                }
            });
            return children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
            node = new JQLite(node);
            for (var i = 0, ii = node.length; i < ii; i++) {
                var child = node[i];
                element.appendChild(child);
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            if (parent) {
                parent.replaceChild(wrapNode, element);
            }
            wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling);
                index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className);
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                });
            }
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector);
            } else {
                return [];
            }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var eventFns = events && events[eventName];
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = true;
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === true;
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = true;
                    },
                    isImmediatePropagationStopped: function() {
                        return this.immediatePropagationStopped === true;
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                };
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event);
                }
                eventFnsCopy = shallowCopy(eventFns);
                handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                forEach(eventFnsCopy, function(fn) {
                    if (!dummyEvent.isImmediatePropagationStopped()) {
                        fn.apply(element, handlerArgs);
                    }
                });
            }
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3);
                    if (isDefined(value)) {
                        value = jqLite(value);
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                }
            }
            return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
    });
    function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
            if (typeof key === "function") {
                key = obj.$$hashKey();
            }
            return key;
        }
        var objType = typeof obj;
        if (objType == "function" || objType == "object" && obj !== null) {
            key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
        } else {
            key = objType + ":" + obj;
        }
        return key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            delete this[key];
            return value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var $injectorMinErr = minErr("$injector");
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        if (args) {
            return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
        }
        return "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = [];
                if (fn.length) {
                    if (strictDi) {
                        if (!isString(name) || !name) {
                            name = fn.name || anonFn(fn);
                        }
                        throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    }
                    fnText = fn.toString().replace(STRIP_COMMENTS, "");
                    argDecl = fnText.match(FN_ARGS);
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], "fn");
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, "fn", true);
        }
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        strictDi = strictDi === true;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], true), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular.isString(caller)) {
                path.push(caller);
            }
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        });
        forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        });
        return instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            };
        }
        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function enforcedReturnValue() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) {
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                }
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value;
            instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var runBlocks = [], moduleFn;
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module);
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                        runInvokeQueue(moduleFn._invokeQueue);
                        runInvokeQueue(moduleFn._configBlocks);
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else {
                        assertArgFn(module, "module");
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1];
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                        e = e.message + "\n" + e.stack;
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                }
            });
            return runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        return cache[serviceName] = factory(serviceName, caller);
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName];
                        }
                        throw err;
                    } finally {
                        path.shift();
                    }
                }
            }
            function invoke(fn, self, locals, serviceName) {
                if (typeof locals === "string") {
                    serviceName = locals;
                    locals = null;
                }
                var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), length, i, key;
                for (i = 0, length = $inject.length; i < length; i++) {
                    key = $inject[i];
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                if (isArray(fn)) {
                    fn = fn[length];
                }
                return fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
                var returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    createInjector.$$annotate = annotate;
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };
        this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                Array.prototype.some.call(list, function(element) {
                    if (nodeName_(element) === "a") {
                        result = element;
                        return true;
                    }
                });
                return result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) {
                    offset = offset();
                } else if (isElement(offset)) {
                    var elem = offset[0];
                    var style = $window.getComputedStyle(elem);
                    if (style.position !== "fixed") {
                        offset = 0;
                    } else {
                        offset = elem.getBoundingClientRect().bottom;
                    }
                } else if (!isNumber(offset)) {
                    offset = 0;
                }
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else {
                    $window.scrollTo(0, 0);
                }
            }
            function scroll() {
                var hash = $location.hash(), elm;
                if (!hash) scrollTo(null); else if (elm = document.getElementById(hash)) scrollTo(elm); else if (elm = getFirstAnchor(document.getElementsByName(hash))) scrollTo(elm); else if (hash === "top") scrollTo(null);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction(newVal, oldVal) {
                    if (newVal === oldVal && newVal === "") return;
                    jqLiteDocumentLoaded(function() {
                        $rootScope.$evalAsync(scroll);
                    });
                });
            }
            return scroll;
        } ];
    }
    var $animateMinErr = minErr("$animate");
    var $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {};
        this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && name.charAt(0) != ".") throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
                this.$$classNameFilter = expression instanceof RegExp ? expression : null;
            }
            return this.$$classNameFilter;
        };
        this.$get = [ "$$q", "$$asyncCallback", "$rootScope", function($$q, $$asyncCallback, $rootScope) {
            var currentDefer;
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                defer.promise.$$cancelFn = function ngAnimateMaybeCancel() {
                    cancelFn && cancelFn();
                };
                $rootScope.$$postDigest(function ngAnimatePostDigest() {
                    cancelFn = fn(function ngAnimateNotifyComplete() {
                        defer.resolve();
                    });
                });
                return defer.promise;
            }
            function resolveElementClasses(element, classes) {
                var toAdd = [], toRemove = [];
                var hasClasses = createMap();
                forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = true;
                });
                forEach(classes, function(status, className) {
                    var hasClass = hasClasses[className];
                    if (status === false && hasClass) {
                        toRemove.push(className);
                    } else if (status === true && !hasClass) {
                        toAdd.push(className);
                    }
                });
                return toAdd.length + toRemove.length > 0 && [ toAdd.length ? toAdd : null, toRemove.length ? toRemove : null ];
            }
            function cachedClassManipulation(cache, classes, op) {
                for (var i = 0, ii = classes.length; i < ii; ++i) {
                    var className = classes[i];
                    cache[className] = op;
                }
            }
            function asyncPromise() {
                if (!currentDefer) {
                    currentDefer = $$q.defer();
                    $$asyncCallback(function() {
                        currentDefer.resolve();
                        currentDefer = null;
                    });
                }
                return currentDefer.promise;
            }
            function applyStyles(element, options) {
                if (angular.isObject(options)) {
                    var styles = extend(options.from || {}, options.to || {});
                    element.css(styles);
                }
            }
            return {
                animate: function(element, from, to) {
                    applyStyles(element, {
                        from: from,
                        to: to
                    });
                    return asyncPromise();
                },
                enter: function(element, parent, after, options) {
                    applyStyles(element, options);
                    after ? after.after(element) : parent.prepend(element);
                    return asyncPromise();
                },
                leave: function(element, options) {
                    element.remove();
                    return asyncPromise();
                },
                move: function(element, parent, after, options) {
                    return this.enter(element, parent, after, options);
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                $$addClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                $$removeClassImmediately: function(element, className, options) {
                    element = jqLite(element);
                    className = !isString(className) ? isArray(className) ? className.join(" ") : "" : className;
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    });
                    applyStyles(element, options);
                    return asyncPromise();
                },
                setClass: function(element, add, remove, options) {
                    var self = this;
                    var STORAGE_KEY = "$$animateClasses";
                    var createdCache = false;
                    element = jqLite(element);
                    var cache = element.data(STORAGE_KEY);
                    if (!cache) {
                        cache = {
                            classes: {},
                            options: options
                        };
                        createdCache = true;
                    } else if (options && cache.options) {
                        cache.options = angular.extend(cache.options || {}, options);
                    }
                    var classes = cache.classes;
                    add = isArray(add) ? add : add.split(" ");
                    remove = isArray(remove) ? remove : remove.split(" ");
                    cachedClassManipulation(classes, add, true);
                    cachedClassManipulation(classes, remove, false);
                    if (createdCache) {
                        cache.promise = runAnimationPostDigest(function(done) {
                            var cache = element.data(STORAGE_KEY);
                            element.removeData(STORAGE_KEY);
                            if (cache) {
                                var classes = resolveElementClasses(element, cache.classes);
                                if (classes) {
                                    self.$$setClassImmediately(element, classes[0], classes[1], cache.options);
                                }
                            }
                            done();
                        });
                        element.data(STORAGE_KEY, cache);
                    }
                    return cache.promise;
                },
                $$setClassImmediately: function(element, add, remove, options) {
                    add && this.$$addClassImmediately(element, add);
                    remove && this.$$removeClassImmediately(element, remove);
                    applyStyles(element, options);
                    return asyncPromise();
                },
                enabled: noop,
                cancel: noop
            };
        } ];
    } ];
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, false);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while (outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? "" : url.substr(index + 1);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            });
            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };
        var pollFns = [], pollTimeout;
        self.addPollFn = function(fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
            pollFns.push(fn);
            return fn;
        };
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                });
                pollTimeout = setTimeout(check, interval);
            })();
        }
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
            if (isUndefined(state)) {
                state = null;
            }
            if (location !== window.location) location = window.location;
            if (history !== window.history) history = window.history;
            if (url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                    return self;
                }
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                lastBrowserUrl = url;
                lastHistoryState = state;
                if ($sniffer.history && (!sameBase || !sameState)) {
                    history[replace ? "replaceState" : "pushState"](state, "", url);
                    cacheState();
                    lastHistoryState = cachedState;
                } else {
                    if (!sameBase) {
                        reloadLocation = url;
                    }
                    if (replace) {
                        location.replace(url);
                    } else if (!sameBase) {
                        location.href = url;
                    } else {
                        location.hash = getHash(url);
                    }
                }
                return self;
            } else {
                return reloadLocation || location.href.replace(/%27/g, "'");
            }
        };
        self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
            cacheState();
            fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
            cachedState = window.history.state;
            cachedState = isUndefined(cachedState) ? null : cachedState;
            if (equals(cachedState, lastCachedState)) {
                cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
        }
        function fireUrlChange() {
            if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                return;
            }
            lastBrowserUrl = self.url();
            lastHistoryState = cachedState;
            forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            });
        }
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {};
        var lastCookieString = "";
        var cookiePath = self.baseHref();
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
                } else {
                    if (isString(value)) {
                        cookieLength = (rawDocument.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=" + cookiePath).length + 1;
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf("=");
                        if (index > 0) {
                            name = safeDecodeURIComponent(cookie.substring(0, index));
                            if (lastCookies[name] === undefined) {
                                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            }
        };
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                }
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (isUndefined(value)) return;
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (!(key in data)) size++;
                        data[key] = value;
                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                        return value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
                            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
                            link(lruEntry.n, lruEntry.p);
                            delete lruHash[key];
                        }
                        delete data[key];
                        size--;
                    },
                    removeAll: function() {
                        data = {};
                        size = 0;
                        lruHash = {};
                        freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n;
                        }
                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }
                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry;
                        if (prevEntry) prevEntry.n = nextEntry;
                    }
                }
            }
            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };
            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };
            return cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
            var bindings = {};
            forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match) {
                    throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                }
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: match[2] === "*",
                    optional: match[3] === "?",
                    attrName: match[4] || scopeName
                };
            });
            return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope)) {
                if (directive.bindToController === true) {
                    bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                    bindings.isolateScope = {};
                } else {
                    bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                }
            }
            if (isObject(directive.bindToController)) {
                bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
            }
            if (isObject(bindings.bindToController)) {
                var controller = directive.controller;
                var controllerAs = directive.controllerAs;
                if (!controller) {
                    throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                } else if (!identifierForController(controller, controllerAs)) {
                    throw $compileMinErr("noident", "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
                }
            }
            return bindings;
        }
        this.directive = function registerDirective(name, directiveFactory) {
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
                assertArg(directiveFactory, "directiveFactory");
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = directive.require || directive.controller && directive.name;
                                directive.restrict = directive.restrict || "EA";
                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                if (isObject(bindings.isolateScope)) {
                                    directive.$$isolateBindings = bindings.isolateScope;
                                }
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    } ]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
            }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
            }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
            if (isDefined(enabled)) {
                debugInfoEnabled = enabled;
                return this;
            }
            return debugInfoEnabled;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i, l, key;
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        this[key] = attributesToCopy[key];
                    }
                } else {
                    this.$attr = {};
                }
                this.$$element = element;
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    if (toAdd && toAdd.length) {
                        $animate.addClass(this.$$element, toAdd);
                    }
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toRemove && toRemove.length) {
                        $animate.removeClass(this.$$element, toRemove);
                    }
                },
                $set: function(key, value, writeAttr, attrName) {
                    var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    } else if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-");
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === "a" && key === "href" || nodeName === "img" && key === "src") {
                        this[key] = value = $$sanitizeUri(value, key === "src");
                    } else if (nodeName === "img" && key === "srcset") {
                        var result = "";
                        var trimmedSrcset = trim(value);
                        var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                        var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                        var rawUris = trimmedSrcset.split(pattern);
                        var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                        for (var i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = i * 2;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                            result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), true);
                        if (lastTuple.length === 2) {
                            result += " " + trim(lastTuple[1]);
                        }
                        this[key] = value = result;
                    }
                    if (writeAttr !== false) {
                        if (value === null || value === undefined) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            this.$$element.attr(attrName, value);
                        }
                    }
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function() {
                        if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
                            fn(attrs[key]);
                        }
                    });
                    return function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == "{{" || endSymbol == "}}" ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data("$binding") || [];
                if (isArray(binding)) {
                    bindings = bindings.concat(binding);
                } else {
                    bindings.push(binding);
                }
                $element.data("$binding", bindings);
            } : noop;
            compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, "ng-binding");
            } : noop;
            compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop;
            compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop;
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                forEach($compileNodes, function(node, index) {
                    if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                        $compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0];
                    }
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope");
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    if (!namespace) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    if (namespace !== "html") {
                        $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html()));
                    } else if (cloneConnectFn) {
                        $linkNode = JQLitePrototype.clone.call($compileNodes);
                    } else {
                        $linkNode = $compileNodes;
                    }
                    if (transcludeControllers) {
                        for (var controllerName in transcludeControllers) {
                            $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        }
                    }
                    compile.$$addScopeInfo($linkNode, scope);
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    return $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                    return "html";
                } else {
                    return nodeName_(node) !== "foreignobject" && node.toString().match(/SVG/) ? "svg" : "html";
                }
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        compile.$$addScopeClass(attrs.$$element);
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    if (nodeLinkFn || childLinkFn) {
                        linkFns.push(i, nodeLinkFn, childLinkFn);
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        for (i = 0; i < linkFns.length; i += 3) {
                            idx = linkFns[i];
                            stableNodeList[idx] = nodeList[idx];
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    for (i = 0, ii = linkFns.length; i < ii; ) {
                        node = stableNodeList[linkFns[i++]];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                compile.$$addScopeInfo(jqLite(node), childScope);
                                var destroyBindings = nodeLinkFn.$$destroyBindings;
                                if (destroyBindings) {
                                    nodeLinkFn.$$destroyBindings = null;
                                    childScope.$on("$destroyed", destroyBindings);
                                }
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn, nodeLinkFn.elementTranscludeOnThisElement);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    if (!transcludedScope) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    return transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = trim(attr.value);
                        ngAttrName = directiveNormalize(name);
                        if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                            name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                                return letter.toUpperCase();
                            });
                        }
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        if (directiveIsMultiElement(directiveNName)) {
                            if (ngAttrName === directiveNName + "Start") {
                                attrStartName = name;
                                attrEndName = name.substr(0, name.length - 5) + "end";
                                name = name.substr(0, name.length - 6);
                            }
                        }
                        nName = directiveNormalize(name.toLowerCase());
                        attrsMap[nName] = name;
                        if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                            attrs[nName] = value;
                            if (getBooleanAttrName(node, nName)) {
                                attrs[nName] = true;
                            }
                        }
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    className = node.className;
                    if (isObject(className)) {
                        className = className.animVal;
                    }
                    if (isString(className) && className !== "") {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                        if (match) {
                            nName = directiveNormalize(match[1]);
                            if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[2]);
                            }
                        }
                    } catch (e) {}
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        }
                        if (node.nodeType == NODE_TYPE_ELEMENT) {
                            if (node.hasAttribute(attrStart)) depth++;
                            if (node.hasAttribute(attrEnd)) depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    if (directiveValue = directive.scope) {
                        if (!directive.templateUrl) {
                            if (isObject(directiveValue)) {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                newIsolateScopeDirective = directive;
                            } else {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    if (!directive.templateUrl && directive.controller) {
                        directiveValue = directive.controller;
                        controllerDirectives = controllerDirectives || createMap();
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    if (directiveValue = directive.transclude) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue == "element") {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " "));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            $template = jqLite(jqLiteClone(compileNode)).contents();
                            $compileNode.empty();
                            childTranscludeFn = compile($template, transcludeFn);
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                            }
                            compileNode = $template[0];
                            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective) {
                                markDirectivesAsIsolate(templateDirectives);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            if (isFunction(linkFn)) {
                                addLinkFns(null, linkFn, attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value;
                    if (isString(require)) {
                        var match = require.match(REQUIRE_PREFIX_REGEXP);
                        var name = require.substring(match[0].length);
                        var inheritType = match[1] || match[3];
                        var optional = match[2] === "?";
                        if (inheritType === "^^") {
                            $element = $element.parent();
                        } else {
                            value = elementControllers && elementControllers[name];
                            value = value && value.instance;
                        }
                        if (!value) {
                            var dataName = "$" + name + "Controller";
                            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                        }
                        if (!value && !optional) {
                            throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                        }
                    } else if (isArray(require)) {
                        value = [];
                        for (var i = 0, ii = require.length; i < ii; i++) {
                            value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                        }
                    }
                    return value || null;
                }
                function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
                    var elementControllers = createMap();
                    for (var controllerKey in controllerDirectives) {
                        var directive = controllerDirectives[controllerKey];
                        var locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        };
                        var controller = directive.controller;
                        if (controller == "@") {
                            controller = attrs[directive.name];
                        }
                        var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                        elementControllers[directive.name] = controllerInstance;
                        if (!hasElementTranscludeDirective) {
                            $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                        }
                    }
                    return elementControllers;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                    }
                    if (controllerDirectives) {
                        elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
                    }
                    if (newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                        compile.$$addScopeClass($element, true);
                        isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                        initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
                    }
                    if (elementControllers) {
                        var scopeDirective = newIsolateScopeDirective || newScopeDirective;
                        var bindings;
                        var controllerForBindings;
                        if (scopeDirective && elementControllers[scopeDirective.name]) {
                            bindings = scopeDirective.$$bindings.bindToController;
                            controller = elementControllers[scopeDirective.name];
                            if (controller && controller.identifier && bindings) {
                                controllerForBindings = controller;
                                thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                            }
                        }
                        for (i in elementControllers) {
                            controller = elementControllers[i];
                            var controllerResult = controller();
                            if (controllerResult !== controller.instance && controller === controllerForBindings) {
                                thisLinkFn.$$destroyBindings();
                                thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                            }
                        }
                    }
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        linkFn = preLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        linkFn = postLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        if (!isScope(scope)) {
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        if (!futureParentElement) {
                            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                        }
                        return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                }
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: true
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        try {
                            directive = directives[i];
                            if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                if (startAttrName) {
                                    directive = inherit(directive, {
                                        $$start: startAttrName,
                                        $$end: endAttrName
                                    });
                                }
                                tDirectives.push(directive);
                                match = directive;
                            }
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if (directive.multiElement) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    if (key.charAt(0) != "$") {
                        if (src[key] && src[key] !== value) {
                            value += (key === "style" ? ";" : " ") + src[key];
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function(value, key) {
                    if (key == "class") {
                        safeAddClass($element, value);
                        dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value;
                    } else if (key == "style") {
                        $element.attr("style", $element.attr("style") + ";" + value);
                        dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value;
                    } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
                        dst[key] = value;
                        dstAttr[key] = srcAttr[key];
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest($sce.getTrustedResourceUrl(templateUrl)).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                        }
                        compileNode = $template[0];
                        if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectivesAsIsolate(templateDirectives);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function(node, i) {
                        if (node == compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (scope.$$destroyed) continue;
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
                    }
                    linkQueue = null;
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (scope.$$destroyed) return;
                    if (linkQueue) {
                        linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0) return diff;
                if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent();
                                if (!hasCompileParent) compile.$$addBindingClass(parent);
                                compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function wrapTemplate(type, template) {
                type = lowercase(type || "html");
                switch (type) {
                  case "svg":
                  case "math":
                    var wrapper = document.createElement("div");
                    wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                    return wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName == "srcdoc") {
                    return $sce.HTML;
                }
                var tag = nodeName_(node);
                if (attrNormalizedName == "xlinkHref" || tag == "form" && attrNormalizedName == "action" || tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc")) {
                    return $sce.RESOURCE_URL;
                }
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var trustedContext = getTrustedContext(node, name);
                allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
                if (!interpolateFn) return;
                if (name === "multiple" && nodeName_(node) === "select") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                directives.push({
                    priority: 100,
                    compile: function() {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = {});
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                                }
                                var newValue = attr[name];
                                if (newValue !== value) {
                                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                    value = newValue;
                                }
                                if (!interpolateFn) return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue != oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] == firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            if ($rootElement.context === firstElementToRemove) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove);
                jqLite(newNode).data(jqLite(firstElementToRemove).data());
                if (!jQuery) {
                    delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                } else {
                    skipDestroyOnNextJQueryCleanData = true;
                    jQuery.cleanData([ firstElementToRemove ]);
                }
                for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove();
                    fragment.appendChild(element);
                    delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
                var onNewScopeDestroyed;
                forEach(bindings, function(definition, scopeName) {
                    var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare;
                    switch (mode) {
                      case "@":
                        attrs.$observe(attrName, function(value) {
                            destination[scopeName] = value;
                        });
                        attrs.$$observers[attrName].$$scope = scope;
                        if (attrs[attrName]) {
                            destination[scopeName] = $interpolate(attrs[attrName])(scope);
                        }
                        break;

                      case "=":
                        if (optional && !attrs[attrName]) {
                            return;
                        }
                        parentGet = $parse(attrs[attrName]);
                        if (parentGet.literal) {
                            compare = equals;
                        } else {
                            compare = function(a, b) {
                                return a === b || a !== a && b !== b;
                            };
                        }
                        parentSet = parentGet.assign || function() {
                            lastValue = destination[scopeName] = parentGet(scope);
                            throw $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                        };
                        lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function parentValueWatch(parentValue) {
                            if (!compare(parentValue, destination[scopeName])) {
                                if (!compare(parentValue, lastValue)) {
                                    destination[scopeName] = parentValue;
                                } else {
                                    parentSet(scope, parentValue = destination[scopeName]);
                                }
                            }
                            return lastValue = parentValue;
                        };
                        parentValueWatch.$stateful = true;
                        var unwatch;
                        if (definition.collection) {
                            unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                        } else {
                            unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                        }
                        onNewScopeDestroyed = onNewScopeDestroyed || [];
                        onNewScopeDestroyed.push(unwatch);
                        break;

                      case "&":
                        if (!attrs.hasOwnProperty(attrName) && optional) break;
                        parentGet = $parse(attrs[attrName]);
                        if (parentGet === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                        break;
                    }
                });
                var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
                    for (var i = 0, ii = onNewScopeDestroyed.length; i < ii; ++i) {
                        onNewScopeDestroyed[i]();
                    }
                } : noop;
                if (newScope && destroyBindings !== noop) {
                    newScope.$on("$destroy", destroyBindings);
                    return noop;
                }
                return destroyBindings;
            }
        } ];
    }
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j]) continue outer;
            }
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
            return jqNodes;
        }
        while (i--) {
            var node = jqNodes[i];
            if (node.nodeType === NODE_TYPE_COMMENT) {
                splice.call(jqNodes, i, 1);
            }
        }
        return jqNodes;
    }
    var $controllerMinErr = minErr("$controller");
    var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {}, globals = false;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject(name)) {
                extend(controllers, name);
            } else {
                controllers[name] = constructor;
            }
        };
        this.allowGlobals = function() {
            globals = true;
        };
        this.$get = [ "$injector", "$window", function($injector, $window) {
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                later = later === true;
                if (ident && isString(ident)) {
                    identifier = ident;
                }
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG);
                    if (!match) {
                        throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
                    }
                    constructor = match[1], identifier = identifier || match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                    assertArgFn(expression, constructor, true);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null);
                    if (identifier) {
                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                    var instantiate;
                    return instantiate = extend(function() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        if (result !== instance && (isObject(result) || isFunction(result))) {
                            instance = result;
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                        }
                        return instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!(locals && isObject(locals.$scope))) {
                    throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                }
                locals.$scope[identifier] = instance;
            }
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    var APPLICATION_JSON = "application/json";
    var CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    };
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    };
    var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                    data = fromJson(tempData);
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        var parsed = createMap(), i;
        function fillInParsed(key, val) {
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        }
        if (isString(headers)) {
            forEach(headers.split("\n"), function(line) {
                i = line.indexOf(":");
                fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
            });
        } else if (isObject(headers)) {
            forEach(headers, function(headerVal, headerKey) {
                fillInParsed(lowercase(headerKey), trim(headerVal));
            });
        }
        return parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (!headersObj) headersObj = parseHeaders(headers);
            if (name) {
                var value = headersObj[lowercase(name)];
                if (value === void 0) {
                    value = null;
                }
                return value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
            return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
            data = fn(data, headers, status);
        });
        return data;
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
            if (isDefined(value)) {
                useApplyAsync = !!value;
                return this;
            }
            return useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            var defaultCache = $cacheFactory("$http");
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            function $http(requestConfig) {
                if (!angular.isObject(requestConfig)) {
                    throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                }
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig);
                config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    var headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function(value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData).then(transformResponse, transformResponse);
                };
                var chain = [ serverRequest, undefined ];
                var promise = $q.when(config);
                forEach(reversedInterceptors, function(interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        chain.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        chain.push(interceptor.response, interceptor.responseError);
                    }
                });
                while (chain.length) {
                    var thenFn = chain.shift();
                    var rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                promise.success = function(fn) {
                    promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                promise.error = function(fn) {
                    promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    });
                    return promise;
                };
                return promise;
                function transformResponse(response) {
                    var resp = extend({}, response);
                    if (!response.data) {
                        resp.data = response.data;
                    } else {
                        resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                    }
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    forEach(headers, function(headerFn, header) {
                        if (isFunction(headerFn)) {
                            headerContent = headerFn(config);
                            if (headerContent != null) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    });
                    return processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head", "jsonp");
            createShortMethodsWithData("post", "put", "patch");
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.params);
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK");
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [ status, response, parseHeaders(headersString), statusText ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    if (useApplyAsync) {
                        $rootScope.$applyAsync(resolveHttpPromise);
                    } else {
                        resolveHttpPromise();
                        if (!$rootScope.$$phase) $rootScope.$apply();
                    }
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0);
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || isUndefined(value)) return;
                    if (!isArray(value)) value = [ value ];
                    forEach(value, function(v) {
                        if (isObject(v)) {
                            if (isDate(v)) {
                                v = v.toISOString();
                            } else {
                                v = toJson(v);
                            }
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                if (parts.length > 0) {
                    url += (url.indexOf("?") == -1 ? "?" : "&") + parts.join("&");
                }
                return url;
            }
        } ];
    }
    function createXhr() {
        return new window.XMLHttpRequest();
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();
            if (lowercase(method) == "jsonp") {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data;
                    callbacks[callbackId].called = true;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text);
                    callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr();
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value);
                    }
                });
                xhr.onload = function requestLoaded() {
                    var statusText = xhr.statusText || "";
                    var response = "response" in xhr ? xhr.response : xhr.responseText;
                    var status = xhr.status === 1223 ? 204 : xhr.status;
                    if (status === 0) {
                        status = response ? 200 : urlResolve(url).protocol == "file" ? 404 : 0;
                    }
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                xhr.onerror = requestError;
                xhr.onabort = requestError;
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e;
                        }
                    }
                }
                xhr.send(post || null);
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            } else if (isPromiseLike(timeout)) {
                timeout.then(timeoutRequest);
            }
            function timeoutRequest() {
                jsonpDone && jsonpDone();
                xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                if (timeoutId !== undefined) {
                    $browserDefer.cancel(timeoutId);
                }
                jsonpDone = xhr = null;
                callback(status, response, headersString, statusText);
                $browser.$$completeOutstandingRequest(noop);
            }
        };
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
                removeEventListenerFn(script, "load", callback);
                removeEventListenerFn(script, "error", callback);
                rawDocument.body.removeChild(script);
                script = null;
                var status = -1;
                var text = "unknown";
                if (event) {
                    if (event.type === "load" && !callbacks[callbackId].called) {
                        event = {
                            type: "error"
                        };
                    }
                    text = event.type;
                    status = event.type === "error" ? 404 : 200;
                }
                if (done) {
                    done(status, text);
                }
            };
            addEventListenerFn(script, "load", callback);
            addEventListenerFn(script, "error", callback);
            rawDocument.body.appendChild(script);
            return callback;
        }
    }
    var $interpolateMinErr = minErr("$interpolate");
    function $InterpolateProvider() {
        var startSymbol = "{{";
        var endSymbol = "}}";
        this.startSymbol = function(value) {
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };
        this.endSymbol = function(value) {
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return endSymbol;
            }
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function stringify(value) {
                if (value == null) {
                    return "";
                }
                switch (typeof value) {
                  case "string":
                    break;

                  case "number":
                    value = "" + value;
                    break;

                  default:
                    value = toJson(value);
                }
                return value;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                allOrNothing = !!allOrNothing;
                var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                while (index < textLength) {
                    if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                        if (index !== startIndex) {
                            concat.push(unescapeText(text.substring(index, startIndex)));
                        }
                        exp = text.substring(startIndex + startSymbolLength, endIndex);
                        expressions.push(exp);
                        parseFns.push($parse(exp, parseStringifyInterceptor));
                        index = endIndex + endSymbolLength;
                        expressionPositions.push(concat.length);
                        concat.push("");
                    } else {
                        if (index !== textLength) {
                            concat.push(unescapeText(text.substring(index)));
                        }
                        break;
                    }
                }
                if (trustedContext && concat.length > 1) {
                    throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
                }
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    };
                    var getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    return extend(function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            for (;i < ii; i++) {
                                values[i] = parseFns[i](context);
                            }
                            return compute(values);
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr);
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener, objectEquality) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                var currValue = compute(values);
                                if (isFunction(listener)) {
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                }
                                lastValue = currValue;
                            }, objectEquality);
                        }
                    });
                }
                function parseStringifyInterceptor(value) {
                    try {
                        value = getValue(value);
                        return allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr);
                    }
                }
            }
            $interpolate.startSymbol = function() {
                return startSymbol;
            };
            $interpolate.endSymbol = function() {
                return endSymbol;
            };
            return $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            var intervals = {};
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                count = isDefined(count) ? count : 0;
                promise.then(null, null, fn);
                promise.$$intervalId = setInterval(function tick() {
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration);
                        clearInterval(promise.$$intervalId);
                        delete intervals[promise.$$intervalId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                intervals[promise.$$intervalId] = deferred;
                return promise;
            }
            interval.cancel = function(promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].reject("canceled");
                    $window.clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                    return true;
                }
                return false;
            };
            return interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function(num) {
                    if (num === 1) {
                        return "one";
                    }
                    return "other";
                }
            };
        };
    }
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    };
    var $locationMinErr = minErr("$location");
    function encodePath(path) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = relativeUrl.charAt(0) !== "/";
        if (prefixed) {
            relativeUrl = "/" + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
            locationObj.$$path = "/" + locationObj.$$path;
        }
    }
    function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
            return whole.substr(begin.length);
        }
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return index == -1 ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this);
            if (!this.$$path) {
                this.$$path = "/";
            }
            this.$$compose();
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var appUrl, prevAppUrl;
            var rewrittenUrl;
            if ((appUrl = beginsWith(appBase, url)) !== undefined) {
                prevAppUrl = appUrl;
                if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
                    rewrittenUrl = appBaseNoFile + (beginsWith("/", appUrl) || appUrl);
                } else {
                    rewrittenUrl = appBase + prevAppUrl;
                }
            } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
                rewrittenUrl = appBaseNoFile + appUrl;
            } else if (appBaseNoFile == url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            var withoutHashUrl;
            if (withoutBaseUrl.charAt(0) === "#") {
                withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
                if (isUndefined(withoutHashUrl)) {
                    withoutHashUrl = withoutBaseUrl;
                }
            } else {
                withoutHashUrl = this.$$html5 ? withoutBaseUrl : "";
            }
            parseAppUrl(withoutHashUrl, this);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                if (url.indexOf(base) === 0) {
                    url = url.replace(base, "");
                }
                if (windowsFilePathExp.exec(url)) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (stripHash(appBase) == stripHash(url)) {
                this.$$parse(url);
                return true;
            }
            return false;
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var rewrittenUrl;
            var appUrl;
            if (appBase == stripHash(url)) {
                rewrittenUrl = url;
            } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                rewrittenUrl = appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
        this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
            this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) {
                return this.$$url;
            }
            var match = PATH_MATCH.exec(url);
            if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1] || url === "") this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            path = path !== null ? path.toString() : "";
            return path.charAt(0) == "/" ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) {
                    search = search.toString();
                    this.$$search = parseKeyValue(search);
                } else if (isObject(search)) {
                    search = copy(search, {});
                    forEach(search, function(value, key) {
                        if (value == null) delete search[key];
                    });
                    this.$$search = search;
                } else {
                    throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;

              default:
                if (isUndefined(paramValue) || paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return hash !== null ? hash.toString() : "";
        }),
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
            if (!arguments.length) {
                return this.$$state;
            }
            if (Location !== LocationHtml5Url || !this.$$html5) {
                throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
            }
            this.$$state = isUndefined(state) ? null : state;
            return this;
        };
    });
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value)) {
                return this[property];
            }
            this[property] = preprocess(value);
            this.$$compose();
            return this;
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
        };
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.html5Mode = function(mode) {
            if (isBoolean(mode)) {
                html5Mode.enabled = mode;
                return this;
            } else if (isObject(mode)) {
                if (isBoolean(mode.enabled)) {
                    html5Mode.enabled = mode.enabled;
                }
                if (isBoolean(mode.requireBase)) {
                    html5Mode.requireBase = mode.requireBase;
                }
                if (isBoolean(mode.rewriteLinks)) {
                    html5Mode.rewriteLinks = mode.rewriteLinks;
                }
                return this;
            } else {
                return html5Mode;
            }
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                    throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                }
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            $location = new LocationMode(appBase, "#" + hashPrefix);
            $location.$$parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state);
                    $location.$$state = $browser.state();
                } catch (e) {
                    $location.url(oldUrl);
                    $location.$$state = oldState;
                    throw e;
                }
            }
            $rootElement.on("click", function(event) {
                if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                }
                var absHref = elm.prop("href");
                var relHref = elm.attr("href") || elm.attr("xlink:href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault();
                        if ($location.absUrl() != $browser.url()) {
                            $rootScope.$apply();
                            $window.angular["ff-684208-preventDefault"] = true;
                        }
                    }
                }
            });
            if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
                $browser.url($location.absUrl(), true);
            }
            var initializing = true;
            $browser.onUrlChange(function(newUrl, newState) {
                $rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    $location.$$parse(newUrl);
                    $location.$$state = newState;
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                    if ($location.absUrl() !== newUrl) return;
                    if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                        setBrowserUrlWithFallback(oldUrl, false, oldState);
                    } else {
                        initializing = false;
                        afterLocationChange(oldUrl, oldState);
                    }
                });
                if (!$rootScope.$$phase) $rootScope.$digest();
            });
            $rootScope.$watch(function $locationWatch() {
                var oldUrl = trimEmptyHash($browser.url());
                var newUrl = trimEmptyHash($location.absUrl());
                var oldState = $browser.state();
                var currentReplace = $location.$$replace;
                var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                if (initializing || urlOrStateChanged) {
                    initializing = false;
                    $rootScope.$evalAsync(function() {
                        var newUrl = $location.absUrl();
                        var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        if ($location.absUrl() !== newUrl) return;
                        if (defaultPrevented) {
                            $location.$$parse(oldUrl);
                            $location.$$state = oldState;
                        } else {
                            if (urlOrStateChanged) {
                                setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                            }
                            afterLocationChange(oldUrl, oldState);
                        }
                    });
                }
                $location.$$replace = false;
            });
            return $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        } ];
    }
    function $LogProvider() {
        var debug = true, self = this;
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.$get = [ "$window", function($window) {
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                if (hasApply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }
                return function(arg1, arg2) {
                    logFn(arg1, arg2 == null ? "" : arg2);
                };
            }
        } ];
    }
    var $parseMinErr = minErr("$parse");
    function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression);
        }
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.window === obj) {
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === Object) {
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
        return obj;
    }
    var CALL = Function.prototype.call;
    var APPLY = Function.prototype.apply;
    var BIND = Function.prototype.bind;
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            } else if (obj === CALL || obj === APPLY || obj === BIND) {
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
            }
        }
    }
    var OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = true;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    };
    var Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            this.text = text;
            this.index = 0;
            this.tokens = [];
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (ch === '"' || ch === "'") {
                    this.readString(ch);
                } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                    this.readNumber();
                } else if (this.isIdent(ch)) {
                    this.readIdent();
                } else if (this.is(ch, "(){}[].,;:?")) {
                    this.tokens.push({
                        index: this.index,
                        text: ch
                    });
                    this.index++;
                } else if (this.isWhitespace(ch)) {
                    this.index++;
                } else {
                    var ch2 = ch + this.peek();
                    var ch3 = ch2 + this.peek(2);
                    var op1 = OPERATORS[ch];
                    var op2 = OPERATORS[ch2];
                    var op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: true
                        });
                        this.index += token.length;
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1);
                    }
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && typeof ch === "string";
        },
        isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "" || ch === " ";
        },
        isIdent: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
        },
        isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index));
                if (ch == "." || this.isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = this.peek();
                    if (ch == "e" && this.isExpOperator(peekCh)) {
                        number += ch;
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == "e") {
                        number += ch;
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == "e") {
                        this.throwError("Invalid exponent");
                    } else {
                        break;
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: true,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (!(this.isIdent(ch) || this.isNumber(ch))) {
                    break;
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: true
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                rawString += ch;
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        if (!hex.match(/[\da-f]{4}/i)) {
                            this.throwError("Invalid unicode escape [\\u" + hex + "]");
                        }
                        this.index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string = string + (rep || ch);
                    }
                    escape = false;
                } else if (ch === "\\") {
                    escape = true;
                } else if (ch === quote) {
                    this.index++;
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: true,
                        value: string
                    });
                    return;
                } else {
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
    };
    AST.Program = "Program";
    AST.ExpressionStatement = "ExpressionStatement";
    AST.AssignmentExpression = "AssignmentExpression";
    AST.ConditionalExpression = "ConditionalExpression";
    AST.LogicalExpression = "LogicalExpression";
    AST.BinaryExpression = "BinaryExpression";
    AST.UnaryExpression = "UnaryExpression";
    AST.CallExpression = "CallExpression";
    AST.MemberExpression = "MemberExpression";
    AST.Identifier = "Identifier";
    AST.Literal = "Literal";
    AST.ArrayExpression = "ArrayExpression";
    AST.Property = "Property";
    AST.ObjectExpression = "ObjectExpression";
    AST.ThisExpression = "ThisExpression";
    AST.NGValueParameter = "NGValueParameter";
    AST.prototype = {
        ast: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.program();
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0]);
            }
            return value;
        },
        program: function() {
            var body = [];
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) body.push(this.expressionStatement());
                if (!this.expect(";")) {
                    return {
                        type: AST.Program,
                        body: body
                    };
                }
            }
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            var left = this.expression();
            var token;
            while (token = this.expect("|")) {
                left = this.filter(left);
            }
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
                result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                };
            }
            return result;
        },
        ternary: function() {
            var test = this.logicalOR();
            var alternate;
            var consequent;
            if (this.expect("?")) {
                alternate = this.expression();
                if (this.consume(":")) {
                    consequent = this.expression();
                    return {
                        type: AST.ConditionalExpression,
                        test: test,
                        alternate: alternate,
                        consequent: consequent
                    };
                }
            }
            return test;
        },
        logicalOR: function() {
            var left = this.logicalAND();
            while (this.expect("||")) {
                left = {
                    type: AST.LogicalExpression,
                    operator: "||",
                    left: left,
                    right: this.logicalAND()
                };
            }
            return left;
        },
        logicalAND: function() {
            var left = this.equality();
            while (this.expect("&&")) {
                left = {
                    type: AST.LogicalExpression,
                    operator: "&&",
                    left: left,
                    right: this.equality()
                };
            }
            return left;
        },
        equality: function() {
            var left = this.relational();
            var token;
            while (token = this.expect("==", "!=", "===", "!==")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.relational()
                };
            }
            return left;
        },
        relational: function() {
            var left = this.additive();
            var token;
            while (token = this.expect("<", ">", "<=", ">=")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.additive()
                };
            }
            return left;
        },
        additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.multiplicative()
                };
            }
            return left;
        },
        multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.unary()
                };
            }
            return left;
        },
        unary: function() {
            var token;
            if (token = this.expect("+", "-", "!")) {
                return {
                    type: AST.UnaryExpression,
                    operator: token.text,
                    prefix: true,
                    argument: this.unary()
                };
            } else {
                return this.primary();
            }
        },
        primary: function() {
            var primary;
            if (this.expect("(")) {
                primary = this.filterChain();
                this.consume(")");
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
                primary = this.object();
            } else if (this.constants.hasOwnProperty(this.peek().text)) {
                primary = copy(this.constants[this.consume().text]);
            } else if (this.peek().identifier) {
                primary = this.identifier();
            } else if (this.peek().constant) {
                primary = this.constant();
            } else {
                this.throwError("not a primary expression", this.peek());
            }
            var next;
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = {
                        type: AST.CallExpression,
                        callee: primary,
                        arguments: this.parseArguments()
                    };
                    this.consume(")");
                } else if (next.text === "[") {
                    primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.expression(),
                        computed: true
                    };
                    this.consume("]");
                } else if (next.text === ".") {
                    primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.identifier(),
                        computed: false
                    };
                } else {
                    this.throwError("IMPOSSIBLE");
                }
            }
            return primary;
        },
        filter: function(baseExpression) {
            var args = [ baseExpression ];
            var result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: true
            };
            while (this.expect(":")) {
                args.push(this.expression());
            }
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (this.peekToken().text !== ")") {
                do {
                    args.push(this.expression());
                } while (this.expect(","));
            }
            return args;
        },
        identifier: function() {
            var token = this.consume();
            if (!token.identifier) {
                this.throwError("is not a valid identifier", token);
            }
            return {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break;
                    }
                    elements.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("]");
            return {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var properties = [], property;
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break;
                    }
                    property = {
                        type: AST.Property,
                        kind: "init"
                    };
                    if (this.peek().constant) {
                        property.key = this.constant();
                    } else if (this.peek().identifier) {
                        property.key = this.identifier();
                    } else {
                        this.throwError("invalid key", this.peek());
                    }
                    this.consume(":");
                    property.value = this.expression();
                    properties.push(property);
                } while (this.expect(","));
            }
            this.consume("}");
            return {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            var token = this.expect(e1);
            if (!token) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
            return token;
        },
        peekToken: function() {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i];
                var t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token;
                }
            }
            return false;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
                this.tokens.shift();
                return token;
            }
            return false;
        },
        constants: {
            "true": {
                type: AST.Literal,
                value: true
            },
            "false": {
                type: AST.Literal,
                value: false
            },
            "null": {
                type: AST.Literal,
                value: null
            },
            undefined: {
                type: AST.Literal,
                value: undefined
            },
            "this": {
                type: AST.ThisExpression
            }
        }
    };
    function ifDefined(v, d) {
        return typeof v !== "undefined" ? v : d;
    }
    function plusFn(l, r) {
        if (typeof l === "undefined") return r;
        if (typeof r === "undefined") return l;
        return l + r;
    }
    function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
    }
    function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter);
                allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
                findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ ast ];
            break;

          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter);
                allConstants = allConstants && expr.constant;
                if (!expr.constant) {
                    argsToWatch.push.apply(argsToWatch, expr.toWatch);
                }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter);
                allConstants = allConstants && expr.constant;
                if (!expr.constant) {
                    argsToWatch.push.apply(argsToWatch, expr.toWatch);
                }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter);
                allConstants = allConstants && property.value.constant;
                if (!property.value.constant) {
                    argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
    }
    function getInputs(body) {
        if (body.length != 1) return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1) return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
            return {
                type: AST.AssignmentExpression,
                left: ast.body[0].expression,
                right: {
                    type: AST.NGValueParameter
                },
                operator: "="
            };
        }
    }
    function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
    }
    ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this;
            var ast = this.astBuilder.ast(expression);
            this.state = {
                nextId: 0,
                filters: {},
                expensiveChecks: expensiveChecks,
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            };
            findConstantAndWatchExpressions(ast, self.$filter);
            var extra = "";
            var assignable;
            this.stage = "assign";
            if (assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result);
                extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs";
            forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                };
                self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId);
                self.return(intoId);
                self.state.inputs.push(fnKey);
                watch.watchId = key;
            });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;";
            var fn = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "ifDefined", "plus", "text", fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, ifDefined, plusFn, expression);
            this.state = this.stage = undefined;
            fn.literal = isLiteral(ast);
            fn.constant = isConstant(ast);
            return fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [];
            var fns = this.state.inputs;
            var self = this;
            forEach(fns, function(name) {
                result.push("var " + name + "=" + self.generateFunction(name, "s"));
            });
            if (fns.length) {
                result.push("fn.inputs=[" + fns.join(",") + "];");
            }
            return result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [];
            var self = this;
            forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            });
            if (parts.length) return "var " + parts.join(",") + ";";
            return "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, self = this, args, expression;
            recursionFn = recursionFn || noop;
            if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                intoId = intoId || this.nextId();
                this.if("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                return;
            }
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, undefined, undefined, function(expr) {
                        right = expr;
                    });
                    if (pos !== ast.body.length - 1) {
                        self.current().body.push(right, ";");
                    } else {
                        self.return(right);
                    }
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value);
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, undefined, undefined, function(expr) {
                    right = expr;
                });
                expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, undefined, undefined, function(expr) {
                    left = expr;
                });
                this.recurse(ast.right, undefined, undefined, function(expr) {
                    right = expr;
                });
                if (ast.operator === "+") {
                    expression = this.plus(left, right);
                } else if (ast.operator === "-") {
                    expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                } else {
                    expression = "(" + left + ")" + ast.operator + "(" + right + ")";
                }
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId();
                self.recurse(ast.left, intoId);
                self.if(ast.operator === "&&" ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId();
                self.recurse(ast.test, intoId);
                self.if(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId();
                if (nameId) {
                    nameId.context = self.stage === "inputs" ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s");
                    nameId.computed = false;
                    nameId.name = ast.name;
                }
                ensureSafeMemberName(ast.name);
                self.if(self.stage === "inputs" || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if(self.stage === "inputs" || "s", function() {
                        if (create && create !== 1) {
                            self.if(self.not(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}"));
                        }
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name)));
                if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                    self.addEnsureSafeObject(intoId);
                }
                recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId();
                intoId = intoId || this.nextId();
                self.recurse(ast.object, left, undefined, function() {
                    self.if(self.notNull(left), function() {
                        if (ast.computed) {
                            right = self.nextId();
                            self.recurse(ast.property, right);
                            self.addEnsureSafeMemberName(right);
                            if (create && create !== 1) {
                                self.if(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}"));
                            }
                            expression = self.ensureSafeObject(self.computedMember(left, right));
                            self.assign(intoId, expression);
                            if (nameId) {
                                nameId.computed = true;
                                nameId.name = right;
                            }
                        } else {
                            ensureSafeMemberName(ast.property.name);
                            if (create && create !== 1) {
                                self.if(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}"));
                            }
                            expression = self.nonComputedMember(left, ast.property.name);
                            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                                expression = self.ensureSafeObject(expression);
                            }
                            self.assign(intoId, expression);
                            if (nameId) {
                                nameId.computed = false;
                                nameId.name = ast.property.name;
                            }
                        }
                        recursionFn(intoId);
                    });
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId();
                if (ast.filter) {
                    right = self.filter(ast.callee.name);
                    args = [];
                    forEach(ast.arguments, function(expr) {
                        var argument = self.nextId();
                        self.recurse(expr, argument);
                        args.push(argument);
                    });
                    expression = right + "(" + args.join(",") + ")";
                    self.assign(intoId, expression);
                    recursionFn(intoId);
                } else {
                    right = self.nextId();
                    left = {};
                    args = [];
                    self.recurse(ast.callee, right, left, function() {
                        self.if(self.notNull(right), function() {
                            self.addEnsureSafeFunction(right);
                            forEach(ast.arguments, function(expr) {
                                self.recurse(expr, self.nextId(), undefined, function(argument) {
                                    args.push(self.ensureSafeObject(argument));
                                });
                            });
                            if (left.name) {
                                if (!self.state.expensiveChecks) {
                                    self.addEnsureSafeObject(left.context);
                                }
                                expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")";
                            } else {
                                expression = right + "(" + args.join(",") + ")";
                            }
                            expression = self.ensureSafeObject(expression);
                            self.assign(intoId, expression);
                            recursionFn(intoId);
                        });
                    });
                }
                break;

              case AST.AssignmentExpression:
                right = this.nextId();
                left = {};
                if (!isAssignable(ast.left)) {
                    throw $parseMinErr("lval", "Trying to assing a value to a non l-value");
                }
                this.recurse(ast.left, undefined, left, function() {
                    self.if(self.notNull(left.context), function() {
                        self.recurse(ast.right, right);
                        self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                        expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                        self.assign(intoId, expression);
                        recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                    self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(argument);
                    });
                });
                expression = "[" + args.join(",") + "]";
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.ObjectExpression:
                args = [];
                forEach(ast.properties, function(property) {
                    self.recurse(property.value, self.nextId(), undefined, function(expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                });
                expression = "{" + args.join(",") + "}";
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s");
                recursionFn("s");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v");
                recursionFn("v");
                break;
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property;
            var own = this.current().own;
            if (!own.hasOwnProperty(key)) {
                own[key] = this.nextId(false, element + "&&(" + this.escape(property) + " in " + element + ")");
            }
            return own[key];
        },
        assign: function(id, value) {
            if (!id) return;
            this.current().body.push(id, "=", value, ";");
            return id;
        },
        filter: function(filterName) {
            if (!this.state.filters.hasOwnProperty(filterName)) {
                this.state.filters[filterName] = this.nextId(true);
            }
            return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        "return": function(id) {
            this.current().body.push("return ", id, ";");
        },
        "if": function(test, alternate, consequent) {
            if (test === true) {
                alternate();
            } else {
                var body = this.current().body;
                body.push("if(", test, "){");
                alternate();
                body.push("}");
                if (consequent) {
                    body.push("else{");
                    consequent();
                    body.push("}");
                }
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            return left + "." + right;
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            if (computed) return this.computedMember(left, right);
            return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
            this.current().body.push(this.ensureSafeObject(item), ";");
        },
        addEnsureSafeMemberName: function(item) {
            this.current().body.push(this.ensureSafeMemberName(item), ";");
        },
        addEnsureSafeFunction: function(item) {
            this.current().body.push(this.ensureSafeFunction(item), ";");
        },
        ensureSafeObject: function(item) {
            return "ensureSafeObject(" + item + ",text)";
        },
        ensureSafeMemberName: function(item) {
            return "ensureSafeMemberName(" + item + ",text)";
        },
        ensureSafeFunction: function(item) {
            return "ensureSafeFunction(" + item + ",text)";
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (value === true) return "true";
            if (value === false) return "false";
            if (value === null) return "null";
            if (typeof value === "undefined") return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            if (!skip) {
                this.current().vars.push(id + (init ? "=" + init : ""));
            }
            return id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    };
    function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
    }
    ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this;
            var ast = this.astBuilder.ast(expression);
            this.expression = expression;
            this.expensiveChecks = expensiveChecks;
            findConstantAndWatchExpressions(ast, self.$filter);
            var assignable;
            var assign;
            if (assignable = assignableAST(ast)) {
                assign = this.recurse(assignable);
            }
            var toWatch = getInputs(ast.body);
            var inputs;
            if (toWatch) {
                inputs = [];
                forEach(toWatch, function(watch, key) {
                    var input = self.recurse(watch);
                    watch.input = input;
                    inputs.push(input);
                    watch.watchId = key;
                });
            }
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
                var lastValue;
                forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                });
                return lastValue;
            };
            if (assign) {
                fn.assign = function(scope, value, locals) {
                    return assign(scope, locals, value);
                };
            }
            if (inputs) {
                fn.inputs = inputs;
            }
            fn.literal = isLiteral(ast);
            fn.constant = isConstant(ast);
            return fn;
        },
        recurse: function(ast, context, create) {
            var left, right, self = this, args, expression;
            if (ast.input) {
                return this.inputs(ast.input, ast.watchId);
            }
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                right = this.recurse(ast.argument);
                return this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);

              case AST.LogicalExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                ensureSafeMemberName(ast.name, self.expression);
                return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);

              case AST.MemberExpression:
                left = this.recurse(ast.object, false, !!create);
                if (!ast.computed) {
                    ensureSafeMemberName(ast.property.name, self.expression);
                    right = ast.property.name;
                }
                if (ast.computed) right = this.recurse(ast.property);
                return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);

              case AST.CallExpression:
                args = [];
                forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                });
                if (ast.filter) right = this.$filter(ast.callee.name);
                if (!ast.filter) right = this.recurse(ast.callee, true);
                return ast.filter ? function(scope, locals, assign, inputs) {
                    var values = [];
                    for (var i = 0; i < args.length; ++i) {
                        values.push(args[i](scope, locals, assign, inputs));
                    }
                    var value = right.apply(undefined, values, inputs);
                    return context ? {
                        context: undefined,
                        name: undefined,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var rhs = right(scope, locals, assign, inputs);
                    var value;
                    if (rhs.value != null) {
                        ensureSafeObject(rhs.context, self.expression);
                        ensureSafeFunction(rhs.value, self.expression);
                        var values = [];
                        for (var i = 0; i < args.length; ++i) {
                            values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                        }
                        value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                left = this.recurse(ast.left, true, 1);
                right = this.recurse(ast.right);
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    ensureSafeObject(lhs.value, self.expression);
                    lhs.context[lhs.name] = rhs;
                    return context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                });
                return function(scope, locals, assign, inputs) {
                    var value = [];
                    for (var i = 0; i < args.length; ++i) {
                        value.push(args[i](scope, locals, assign, inputs));
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                args = [];
                forEach(ast.properties, function(property) {
                    args.push({
                        key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                        value: self.recurse(property.value)
                    });
                });
                return function(scope, locals, assign, inputs) {
                    var value = {};
                    for (var i = 0; i < args.length; ++i) {
                        value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign, inputs) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                if (isDefined(arg)) {
                    arg = +arg;
                } else {
                    arg = 0;
                }
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                if (isDefined(arg)) {
                    arg = -arg;
                } else {
                    arg = 0;
                }
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                var arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: undefined,
                    name: undefined,
                    value: value
                } : value;
            };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var base = locals && name in locals ? locals : scope;
                if (create && create !== 1 && base && !base[name]) {
                    base[name] = {};
                }
                var value = base ? base[name] : undefined;
                if (expensiveChecks) {
                    ensureSafeObject(value, expression);
                }
                if (context) {
                    return {
                        context: base,
                        name: name,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        computedMember: function(left, right, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs;
                var value;
                if (lhs != null) {
                    rhs = right(scope, locals, assign, inputs);
                    ensureSafeMemberName(rhs, expression);
                    if (create && create !== 1 && lhs && !lhs[rhs]) {
                        lhs[rhs] = {};
                    }
                    value = lhs[rhs];
                    ensureSafeObject(value, expression);
                }
                if (context) {
                    return {
                        context: lhs,
                        name: rhs,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                if (create && create !== 1 && lhs && !lhs[right]) {
                    lhs[right] = {};
                }
                var value = lhs != null ? lhs[right] : undefined;
                if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
                    ensureSafeObject(value, expression);
                }
                if (context) {
                    return {
                        context: lhs,
                        name: right,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                if (inputs) return inputs[watchId];
                return input(scope, value, locals);
            };
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
    };
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
    };
    function setter(obj, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp);
        var element = path.split("."), key;
        for (var i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = ensureSafeObject(obj[key], fullExp);
            if (!propertyObj) {
                propertyObj = {};
                obj[key] = propertyObj;
            }
            obj = propertyObj;
        }
        key = ensureSafeMemberName(element.shift(), fullExp);
        ensureSafeObject(obj[key], fullExp);
        obj[key] = setValue;
        return setValue;
    }
    var getterFnCacheDefault = createMap();
    var getterFnCacheExpensive = createMap();
    function isPossiblyDangerousMemberName(name) {
        return name == "constructor";
    }
    var objectValueOf = Object.prototype.valueOf;
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = [ "$filter", "$sniffer", function($filter, $sniffer) {
            var $parseOptions = {
                csp: $sniffer.csp,
                expensiveChecks: false
            }, $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: true
            };
            return function $parse(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    exp = exp.trim();
                    cacheKey = exp;
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    parsedExpression = cache[cacheKey];
                    if (!parsedExpression) {
                        if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                            oneTime = true;
                            exp = exp.substring(2);
                        }
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                        var lexer = new Lexer(parseOptions);
                        var parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp);
                        if (parsedExpression.constant) {
                            parsedExpression.$$watchDelegate = constantWatchDelegate;
                        } else if (oneTime) {
                            parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                        } else if (parsedExpression.inputs) {
                            parsedExpression.$$watchDelegate = inputsWatchDelegate;
                        }
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return noop;
                }
            };
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                if (newValue == null || oldValueOfValue == null) {
                    return newValue === oldValueOfValue;
                }
                if (typeof newValue === "object") {
                    newValue = getValueOf(newValue);
                    if (typeof newValue === "object") {
                        return false;
                    }
                }
                return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var inputExpressions = parsedExpression.inputs;
                var lastResult;
                if (inputExpressions.length === 1) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    return scope.$watch(function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                            lastResult = parsedExpression(scope, undefined, undefined, [ newInputValue ]);
                            oldInputValueOf = newInputValue && getValueOf(newInputValue);
                        }
                        return lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                var oldInputValueOfValues = [];
                var oldInputValues = [];
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                    oldInputValues[i] = null;
                }
                return scope.$watch(function expressionInputsWatch(scope) {
                    var changed = false;
                    for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                            oldInputValues[i] = newInputValue;
                            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                        }
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                    }
                    return lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    if (isDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isDefined(lastValue)) {
                                unwatch();
                            }
                        });
                    }
                }, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener.call(this, value, old, scope);
                    }
                    if (isAllDefined(value)) {
                        scope.$$postDigest(function() {
                            if (isAllDefined(lastValue)) unwatch();
                        });
                    }
                }, objectEquality);
                function isAllDefined(value) {
                    var allDefined = true;
                    forEach(value, function(val) {
                        if (!isDefined(val)) allDefined = false;
                    });
                    return allDefined;
                }
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function constantWatch(scope) {
                    return parsedExpression(scope);
                }, function constantListener(value, old, scope) {
                    if (isFunction(listener)) {
                        listener.apply(this, arguments);
                    }
                    unwatch();
                }, objectEquality);
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate;
                var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value, scope, locals);
                } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs);
                    var result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                    fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                } else if (!interceptorFn.$stateful) {
                    fn.$$watchDelegate = inputsWatchDelegate;
                    fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ];
                }
                return fn;
            }
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr("$q", TypeError);
        function callOnce(self, resolveFn, rejectFn) {
            var called = false;
            function wrap(fn) {
                return function(value) {
                    if (called) return;
                    called = true;
                    fn.call(self, value);
                };
            }
            return [ wrap(resolveFn), wrap(rejectFn) ];
        }
        var defer = function() {
            return new Deferred();
        };
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        Promise.prototype = {
            then: function(onFulfilled, onRejected, progressBack) {
                var result = new Deferred();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]);
                if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                return result.promise;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, true, callback);
                }, function(error) {
                    return handleCallback(error, false, callback);
                }, progressBack);
            }
        };
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, deferred, pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = undefined;
            for (var i = 0, ii = pending.length; i < ii; ++i) {
                deferred = pending[i][0];
                fn = pending[i][state.status];
                try {
                    if (isFunction(fn)) {
                        deferred.resolve(fn(state.value));
                    } else if (state.status === 1) {
                        deferred.resolve(state.value);
                    } else {
                        deferred.reject(state.value);
                    }
                } catch (e) {
                    deferred.reject(e);
                    exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            if (state.processScheduled || !state.pending) return;
            state.processScheduled = true;
            nextTick(function() {
                processQueue(state);
            });
        }
        function Deferred() {
            this.promise = new Promise();
            this.resolve = simpleBind(this, this.resolve);
            this.reject = simpleBind(this, this.reject);
            this.notify = simpleBind(this, this.notify);
        }
        Deferred.prototype = {
            resolve: function(val) {
                if (this.promise.$$state.status) return;
                if (val === this.promise) {
                    this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
                } else {
                    this.$$resolve(val);
                }
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    if (isObject(val) || isFunction(val)) then = val && val.then;
                    if (isFunction(then)) {
                        this.promise.$$state.status = -1;
                        then.call(val, fns[0], fns[1], this.notify);
                    } else {
                        this.promise.$$state.value = val;
                        this.promise.$$state.status = 1;
                        scheduleProcessQueue(this.promise.$$state);
                    }
                } catch (e) {
                    fns[1](e);
                    exceptionHandler(e);
                }
            },
            reject: function(reason) {
                if (this.promise.$$state.status) return;
                this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason;
                this.promise.$$state.status = 2;
                scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                    nextTick(function() {
                        var callback, result;
                        for (var i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0];
                            callback = callbacks[i][3];
                            try {
                                result.notify(isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    });
                }
            }
        };
        var reject = function(reason) {
            var result = new Deferred();
            result.reject(reason);
            return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
            var result = new Deferred();
            if (resolved) {
                result.resolve(value);
            } else {
                result.reject(value);
            }
            return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                if (isFunction(callback)) callbackOutput = callback();
            } catch (e) {
                return makePromise(e, false);
            }
            if (isPromiseLike(callbackOutput)) {
                return callbackOutput.then(function() {
                    return makePromise(value, isResolved);
                }, function(error) {
                    return makePromise(error, false);
                });
            } else {
                return makePromise(value, isResolved);
            }
        };
        var when = function(value, callback, errback, progressBack) {
            var result = new Deferred();
            result.resolve(value);
            return result.promise.then(callback, errback, progressBack);
        };
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            forEach(promises, function(promise, key) {
                counter++;
                when(promise).then(function(value) {
                    if (results.hasOwnProperty(key)) return;
                    results[key] = value;
                    if (!--counter) deferred.resolve(results);
                }, function(reason) {
                    if (results.hasOwnProperty(key)) return;
                    deferred.reject(reason);
                });
            });
            if (counter === 0) {
                deferred.resolve(results);
            }
            return deferred.promise;
        }
        var $Q = function Q(resolver) {
            if (!isFunction(resolver)) {
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            }
            if (!(this instanceof Q)) {
                return new Q(resolver);
            }
            var deferred = new Deferred();
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            resolver(resolveFn, rejectFn);
            return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.all = all;
        return $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr("$rootScope");
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    parent = parent || this;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                    } else {
                        if (!this.$$ChildScope) {
                            this.$$ChildScope = function ChildScope() {
                                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                                this.$$listeners = {};
                                this.$$listenerCount = {};
                                this.$$watchersCount = 0;
                                this.$id = nextUid();
                                this.$$ChildScope = null;
                            };
                            this.$$ChildScope.prototype = this;
                        }
                        child = new this.$$ChildScope();
                    }
                    child.$parent = parent;
                    child.$$prevSibling = parent.$$childTail;
                    if (parent.$$childHead) {
                        parent.$$childTail.$$nextSibling = child;
                        parent.$$childTail = child;
                    } else {
                        parent.$$childHead = parent.$$childTail = child;
                    }
                    if (isolate || parent != this) child.$on("$destroy", destroyChild);
                    return child;
                    function destroyChild() {
                        child.$$destroyed = true;
                    }
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) {
                        return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                    }
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    lastDirtyWatch = null;
                    if (!isFunction(listener)) {
                        watcher.fn = noop;
                    }
                    if (!array) {
                        array = scope.$$watchers = [];
                    }
                    array.unshift(watcher);
                    incrementWatchersCount(this, 1);
                    return function deregisterWatch() {
                        if (arrayRemove(array, watcher) >= 0) {
                            incrementWatchersCount(scope, -1);
                        }
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length);
                    var newValues = new Array(watchExpressions.length);
                    var deregisterFns = [];
                    var self = this;
                    var changeReactionScheduled = false;
                    var firstRun = true;
                    if (!watchExpressions.length) {
                        var shouldCall = true;
                        self.$evalAsync(function() {
                            if (shouldCall) listener(newValues, newValues, self);
                        });
                        return function deregisterWatchGroup() {
                            shouldCall = false;
                        };
                    }
                    if (watchExpressions.length === 1) {
                        return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                            newValues[0] = value;
                            oldValues[0] = oldValue;
                            listener(newValues, value === oldValue ? newValues : oldValues, scope);
                        });
                    }
                    forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                            newValues[i] = value;
                            oldValues[i] = oldValue;
                            if (!changeReactionScheduled) {
                                changeReactionScheduled = true;
                                self.$evalAsync(watchGroupAction);
                            }
                        });
                        deregisterFns.push(unwatchFn);
                    });
                    function watchGroupAction() {
                        changeReactionScheduled = false;
                        if (firstRun) {
                            firstRun = false;
                            listener(newValues, newValues, self);
                        } else {
                            listener(newValues, oldValues, self);
                        }
                    }
                    return function deregisterWatchGroup() {
                        while (deregisterFns.length) {
                            deregisterFns.shift()();
                        }
                    };
                },
                $watchCollection: function(obj, listener) {
                    $watchCollectionInterceptor.$stateful = true;
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var changeDetector = $parse(obj, $watchCollectionInterceptor);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (isUndefined(newValue)) return;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                if (!bothNaN && oldItem !== newItem) {
                                    changeDetected++;
                                    oldValue[i] = newItem;
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (newValue.hasOwnProperty(key)) {
                                    newLength++;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    if (key in oldValue) {
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newItem;
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (!newValue.hasOwnProperty(key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
                    beginPhase("$digest");
                    $browser.$$checkUrlChange();
                    if (this === $rootScope && applyAsyncId !== null) {
                        $browser.defer.cancel(applyAsyncId);
                        flushApplyAsync();
                    }
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        while (asyncQueue.length) {
                            try {
                                asyncTask = asyncQueue.shift();
                                asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) {
                                length = watchers.length;
                                while (length--) {
                                    try {
                                        watch = watchers[length];
                                        if (watch) {
                                            if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === "number" && typeof last === "number" && isNaN(value) && isNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                watch.fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    watchLog[logIdx].push({
                                                        msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                        newVal: value,
                                                        oldVal: last
                                                    });
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueue.length) {
                        try {
                            postDigestQueue.shift()();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                },
                $destroy: function() {
                    if (this.$$destroyed) return;
                    var parent = this.$parent;
                    this.$broadcast("$destroy");
                    this.$$destroyed = true;
                    if (this === $rootScope) return;
                    incrementWatchersCount(this, -this.$$watchersCount);
                    for (var eventName in this.$$listenerCount) {
                        decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                    }
                    if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
                    if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                    this.$on = this.$watch = this.$watchGroup = function() {
                        return noop;
                    };
                    this.$$listeners = {};
                    this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    if (!$rootScope.$$phase && !asyncQueue.length) {
                        $browser.defer(function() {
                            if (asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        });
                    }
                    asyncQueue.push({
                        scope: this,
                        expression: expr,
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        return this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression);
                    scheduleApplyAsync();
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        if (indexOfListener !== -1) {
                            namedListeners[indexOfListener] = null;
                            decrementListenerCount(self, 1, name);
                        }
                    };
                },
                $emit: function(name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = true;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) {
                            event.currentScope = null;
                            return event;
                        }
                        scope = scope.$parent;
                    } while (scope);
                    event.currentScope = null;
                    return event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    };
                    if (!target.$$listenerCount[name]) return event;
                    var listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    event.currentScope = null;
                    return event;
                }
            };
            var $rootScope = new Scope();
            var asyncQueue = $rootScope.$$asyncQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do {
                    current.$$watchersCount += count;
                } while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                    try {
                        applyAsyncQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                    applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync);
                    });
                }
            }
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
            return function sanitizeUri(uri, isImage) {
                var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                var normalizedVal;
                normalizedVal = urlResolve(uri).href;
                if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                    return "unsafe:" + normalizedVal;
                }
                return uri;
            };
        };
    }
    var $sceMinErr = minErr("$sce");
    var SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    };
    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher;
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
        }
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher));
            });
        }
        return adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.$get = [ "$injector", function($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                }
                if (trustedValue === null || trustedValue === undefined || trustedValue === "") {
                    return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === "") {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
            if (arguments.length) {
                enabled = !!value;
            }
            return enabled;
        };
        this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function(type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return $parse(expr, function(value) {
                        return sce.getTrusted(type, value);
                    });
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                };
                sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                };
                sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
            if (bodyStyle) {
                for (var prop in bodyStyle) {
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0];
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                        break;
                    }
                }
                if (!vendorPrefix) {
                    vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
                }
                transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle);
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle);
                if (android && (!transitions || !animations)) {
                    transitions = isString(bodyStyle.webkitTransition);
                    animations = isString(bodyStyle.webkitAnimation);
                }
            }
            return {
                history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                hasEvent: function(event) {
                    if (event === "input" && msie <= 11) return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    var $compileMinErr = minErr("$compile");
    function $TemplateRequestProvider() {
        this.$get = [ "$templateCache", "$http", "$q", function($templateCache, $http, $q) {
            function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++;
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    transformResponse = transformResponse.filter(function(transformer) {
                        return transformer !== defaultHttpResponseTransform;
                    });
                } else if (transformResponse === defaultHttpResponseTransform) {
                    transformResponse = null;
                }
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions)["finally"](function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    $templateCache.put(tpl, response.data);
                    return response.data;
                }, handleError);
                function handleError(resp) {
                    if (!ignoreRequestError) {
                        throw $compileMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                    }
                    return $q.reject(resp);
                }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding");
                var matches = [];
                forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    if (dataBinding) {
                        forEach(dataBinding, function(bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                if (matcher.test(bindingName)) {
                                    matches.push(binding);
                                }
                            } else {
                                if (bindingName.indexOf(expression) != -1) {
                                    matches.push(binding);
                                }
                            }
                        });
                    }
                });
                return matches;
            };
            testability.findModels = function(element, expression, opt_exactMatch) {
                var prefixes = [ "ng-", "data-ng-", "ng\\:" ];
                for (var p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=";
                    var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                    var elements = element.querySelectorAll(selector);
                    if (elements.length) {
                        return elements;
                    }
                }
            };
            testability.getLocation = function() {
                return $location.url();
            };
            testability.setLocation = function(url) {
                if (url !== $location.url()) {
                    $location.url(url);
                    $rootScope.$digest();
                }
            };
            testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            };
            return testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                if (!isFunction(fn)) {
                    invokeApply = delay;
                    delay = fn;
                    fn = noop;
                }
                var skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay);
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function(promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].reject("canceled");
                    delete deferreds[promise.$$timeoutId];
                    return $browser.defer.cancel(promise.$$timeoutId);
                }
                return false;
            };
            return timeout;
        } ];
    }
    var urlParsingNode = document.createElement("a");
    var originUrl = urlResolve(window.location.href);
    function urlResolve(url) {
        var href = url;
        if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    $FilterProvider.$inject = [ "$provide" ];
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                });
                return filters;
            } else {
                return $provide.factory(name + suffix, factory);
            }
        }
        this.register = register;
        this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ];
        register("currency", currencyFilter);
        register("date", dateFilter);
        register("filter", filterFilter);
        register("json", jsonFilter);
        register("limitTo", limitToFilter);
        register("lowercase", lowercaseFilter);
        register("number", numberFilter);
        register("orderBy", orderByFilter);
        register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) {
                if (array == null) {
                    return array;
                } else {
                    throw minErr("filter")("notarray", "Expected array but received: {0}", array);
                }
            }
            var predicateFn;
            var matchAgainstAnyProp;
            switch (typeof expression) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "number":
              case "string":
                matchAgainstAnyProp = true;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return array.filter(predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && "$" in expression;
        var predicateFn;
        if (comparator === true) {
            comparator = equals;
        } else if (!isFunction(comparator)) {
            comparator = function(actual, expected) {
                if (isObject(actual) || isObject(expected)) {
                    return false;
                }
                actual = lowercase("" + actual);
                expected = lowercase("" + expected);
                return actual.indexOf(expected) !== -1;
            };
        }
        predicateFn = function(item) {
            if (shouldMatchPrimitives && !isObject(item)) {
                return deepCompare(item, expression.$, comparator, false);
            }
            return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = typeof actual;
        var expectedType = typeof expected;
        if (expectedType === "string" && expected.charAt(0) === "!") {
            return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
            return actual.some(function(item) {
                return deepCompare(item, expected, comparator, matchAgainstAnyProp);
            });
        }
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) {
                    if (key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, true)) {
                        return true;
                    }
                }
                return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === "object") {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (isFunction(expectedVal)) {
                        continue;
                    }
                    var matchAnyProperty = key === "$";
                    var actualVal = matchAnyProperty ? actual : actual[key];
                    if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                        return false;
                    }
                }
                return true;
            } else {
                return comparator(actual, expected);
            }
            break;

          case "function":
            return false;

          default:
            return comparator(actual, expected);
        }
    }
    currencyFilter.$inject = [ "$locale" ];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            if (isUndefined(currencySymbol)) {
                currencySymbol = formats.CURRENCY_SYM;
            }
            if (isUndefined(fractionSize)) {
                fractionSize = formats.PATTERNS[1].maxFrac;
            }
            return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    numberFilter.$inject = [ "$locale" ];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    var DECIMAL_SEP = ".";
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number)) return "";
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number)) return "";
        var numStr = number + "", formatedText = "", hasExponent = false, parts = [];
        if (isInfinity) formatedText = "∞";
        if (!isInfinity && numStr.indexOf("e") !== -1) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            if (match && match[2] == "-" && match[3] > fractionSize + 1) {
                number = 0;
            } else {
                formatedText = numStr;
                hasExponent = true;
            }
        }
        if (!isInfinity && !hasExponent) {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
            }
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP);
            var whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) {
                pos = whole.length - lgroup;
                for (i = 0; i < pos; i++) {
                    if ((pos - i) % group === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
            }
            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i) % lgroup === 0 && i !== 0) {
                    formatedText += groupSep;
                }
                formatedText += whole.charAt(i);
            }
            while (fraction.length < fractionSize) {
                fraction += "0";
            }
            if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
            if (fractionSize > 0 && number < 1) {
                formatedText = number.toFixed(fractionSize);
                number = parseFloat(formatedText);
            }
        }
        if (number === 0) {
            isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        if (num < 0) {
            neg = "-";
            num = -num;
        }
        num = "" + num;
        while (num.length < digits) num = "0" + num;
        if (trim) {
            num = num.substr(num.length - digits);
        }
        return neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) {
                value += offset;
            }
            if (value === 0 && offset == -12) value = 12;
            return padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name]();
            var get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = zone >= 0 ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
            var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, true),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1)
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                if (match[9]) {
                    tzHour = toInt(match[9] + match[10]);
                    tzMin = toInt(match[9] + match[11]);
                }
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour;
                var m = toInt(match[5] || 0) - tzMin;
                var s = toInt(match[6] || 0);
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }
        return function(date, format, timezone) {
            var text = "", parts = [], fn, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
                date = new Date(date);
            }
            if (!isDate(date) || !isFinite(date.getTime())) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }
            var dateTimezoneOffset = date.getTimezoneOffset();
            if (timezone) {
                var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
                if (!isNaN(requestedTimezoneOffset)) {
                    date = new Date(date.getTime());
                    date.setMinutes(date.getMinutes() + dateTimezoneOffset - requestedTimezoneOffset);
                    dateTimezoneOffset = requestedTimezoneOffset;
                }
            }
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            if (isUndefined(spacing)) {
                spacing = 2;
            }
            return toJson(object, spacing);
        };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit, begin) {
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit);
            } else {
                limit = toInt(limit);
            }
            if (isNaN(limit)) return input;
            if (isNumber(input)) input = input.toString();
            if (!isArray(input) && !isString(input)) return input;
            begin = !begin || isNaN(begin) ? 0 : toInt(begin);
            begin = begin < 0 && begin >= -input.length ? input.length + begin : begin;
            if (limit >= 0) {
                return input.slice(begin, begin + limit);
            } else {
                if (begin === 0) {
                    return input.slice(limit, input.length);
                } else {
                    return input.slice(Math.max(0, begin + limit), begin);
                }
            }
        };
    }
    orderByFilter.$inject = [ "$parse" ];
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            if (!isArrayLike(array)) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ];
            if (sortPredicate.length === 0) {
                sortPredicate = [ "+" ];
            }
            sortPredicate = sortPredicate.map(function(predicate) {
                var descending = false, get = predicate || identity;
                if (isString(predicate)) {
                    if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
                        descending = predicate.charAt(0) == "-";
                        predicate = predicate.substring(1);
                    }
                    if (predicate === "") {
                        return reverseComparator(compare, descending);
                    }
                    get = $parse(predicate);
                    if (get.constant) {
                        var key = get();
                        return reverseComparator(function(a, b) {
                            return compare(a[key], b[key]);
                        }, descending);
                    }
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            });
            return slice.call(array).sort(reverseComparator(comparator, reverseOrder));
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (comp !== 0) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return descending ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function isPrimitive(value) {
                switch (typeof value) {
                  case "number":
                  case "boolean":
                  case "string":
                    return true;

                  default:
                    return false;
                }
            }
            function objectToString(value) {
                if (value === null) return "null";
                if (typeof value.valueOf === "function") {
                    value = value.valueOf();
                    if (isPrimitive(value)) return value;
                }
                if (typeof value.toString === "function") {
                    value = value.toString();
                    if (isPrimitive(value)) return value;
                }
                return "";
            }
            function compare(v1, v2) {
                var t1 = typeof v1;
                var t2 = typeof v2;
                if (t1 === t2 && t1 === "object") {
                    v1 = objectToString(v1);
                    v2 = objectToString(v2);
                }
                if (t1 === t2) {
                    if (t1 === "string") {
                        v1 = v1.toLowerCase();
                        v2 = v2.toLowerCase();
                    }
                    if (v1 === v2) return 0;
                    return v1 < v2 ? -1 : 1;
                } else {
                    return t1 < t2 ? -1 : 1;
                }
            }
        };
    }
    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            };
        }
        directive.restrict = directive.restrict || "AC";
        return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref) {
                return function(scope, element) {
                    if (element[0].nodeName.toLowerCase() !== "a") return;
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        if (!element.attr(href)) {
                            event.preventDefault();
                        }
                    });
                };
            }
        }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple") return;
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                attr.$set(attrName, !!value);
            });
        }
        var normalized = directiveNormalize("ng-" + attrName);
        var linkFn = defaultLinkFn;
        if (propName === "checked") {
            linkFn = function(scope, element, attr) {
                if (attr.ngModel !== attr[normalized]) {
                    defaultLinkFn(scope, element, attr);
                }
            };
        }
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                restrict: "A",
                priority: 100,
                link: linkFn
            };
        };
    });
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) {
                            attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            return;
                        }
                    }
                    scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    });
    forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref";
                        attr.$attr[name] = "xlink:href";
                        propName = null;
                    }
                    attr.$observe(normalized, function(value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null);
                            }
                            return;
                        }
                        attr.$set(name, value);
                        if (msie && propName) element.prop(propName, attr[name]);
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [];
        var parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        parentForm.$addControl(form);
        form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        };
        form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        };
        form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            controls.push(control);
            if (control.$name) {
                form[control.$name] = control;
            }
        };
        form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            if (form[oldName] === control) {
                delete form[oldName];
            }
            form[newName] = control;
            control.$name = newName;
        };
        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            });
            forEach(form.$$success, function(value, name) {
                form.$setValidity(name, null, control);
            });
            arrayRemove(controls, control);
        };
        addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    object[property] = [ controller ];
                } else {
                    var index = list.indexOf(controller);
                    if (index === -1) {
                        list.push(controller);
                    }
                }
            },
            unset: function(object, property, controller) {
                var list = object[property];
                if (!list) {
                    return;
                }
                arrayRemove(list, controller);
                if (list.length === 0) {
                    delete object[property];
                }
            },
            parentForm: parentForm,
            $animate: $animate
        });
        form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS);
            $animate.addClass(element, DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
            parentForm.$setDirty();
        };
        form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
            form.$dirty = false;
            form.$pristine = true;
            form.$submitted = false;
            forEach(controls, function(control) {
                control.$setPristine();
            });
        };
        form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        };
        form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS);
            form.$submitted = true;
            parentForm.$setSubmitted();
        };
    }
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function ngFormCompile(formElement) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    return {
                        pre: function ngFormPreLink(scope, formElement, attr, controller) {
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue();
                                        controller.$setSubmitted();
                                    });
                                    event.preventDefault();
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = controller.$$parentForm, alias = controller.$name;
                            if (alias) {
                                setter(scope, alias, controller, alias);
                                attr.$observe(attr.name ? "name" : "ngForm", function(newValue) {
                                    if (alias === newValue) return;
                                    setter(scope, alias, undefined, alias);
                                    alias = newValue;
                                    setter(scope, alias, controller, alias);
                                    parentFormCtrl.$$renameControl(controller, alias);
                                });
                            }
                            formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller);
                                if (alias) {
                                    setter(scope, alias, undefined, alias);
                                }
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
    var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = false;
            element.on("compositionstart", function(data) {
                composing = true;
            });
            element.on("compositionend", function() {
                composing = false;
                listener();
            });
        }
        var listener = function(ev) {
            if (timeout) {
                $browser.defer.cancel(timeout);
                timeout = null;
            }
            if (composing) return;
            var value = element.val(), event = ev && ev.type;
            if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                value = trim(value);
            }
            if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
                ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener);
        } else {
            var timeout;
            var deferListener = function(ev, input, origValue) {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (!input || input.value !== origValue) {
                            listener(ev);
                        }
                    });
                }
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                deferListener(event, this, this.value);
            });
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut", deferListener);
            }
        }
        element.on("change", listener);
        ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
            return isoWeek;
        }
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                if (existingDate) {
                    hours = existingDate.getHours();
                    minutes = existingDate.getMinutes();
                    seconds = existingDate.getSeconds();
                    milliseconds = existingDate.getMilliseconds();
                }
                return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) {
                return iso;
            }
            if (isString(iso)) {
                if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
                    iso = iso.substring(1, iso.length - 1);
                }
                if (ISO_DATE_REGEXP.test(iso)) {
                    return new Date(iso);
                }
                regexp.lastIndex = 0;
                parts = regexp.exec(iso);
                if (parts) {
                    parts.shift();
                    if (date) {
                        map = {
                            yyyy: date.getFullYear(),
                            MM: date.getMonth() + 1,
                            dd: date.getDate(),
                            HH: date.getHours(),
                            mm: date.getMinutes(),
                            ss: date.getSeconds(),
                            sss: date.getMilliseconds() / 1e3
                        };
                    } else {
                        map = {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        };
                    }
                    forEach(parts, function(part, index) {
                        if (index < mapping.length) {
                            map[mapping[index]] = +part;
                        }
                    });
                    return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                }
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            badInputChecker(scope, element, attr, ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            var previousDate;
            ctrl.$$parserName = type;
            ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    if (timezone === "UTC") {
                        parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset());
                    }
                    return parsedDate;
                }
                return undefined;
            });
            ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) {
                    throw $ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                }
                if (isValidDate(value)) {
                    previousDate = value;
                    if (previousDate && timezone === "UTC") {
                        var timezoneOffset = 6e4 * previousDate.getTimezoneOffset();
                        previousDate = new Date(previousDate.getTime() + timezoneOffset);
                    }
                    return $filter("date")(value, format, timezone);
                } else {
                    previousDate = null;
                    return "";
                }
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                };
                attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                };
                attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val);
                    ctrl.$validate();
                });
            }
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined;
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
            ctrl.$parsers.push(function(value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                return validity.badInput && !validity.typeMismatch ? undefined : value;
            });
        }
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = "number";
        ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value)) return null;
            if (NUMBER_REGEXP.test(value)) return parseFloat(value);
            return undefined;
        });
        ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) {
                    throw $ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                }
                value = value.toString();
            }
            return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            };
            attr.$observe("min", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                minVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
            };
            attr.$observe("max", function(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val, 10);
                }
                maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
                ctrl.$validate();
            });
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "url";
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = "email";
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid());
        }
        var listener = function(ev) {
            if (element[0].checked) {
                ctrl.$setViewValue(attr.value, ev && ev.type);
            }
        };
        element.on("click", listener);
        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        };
        attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            parseFn = $parse(expression);
            if (!parseFn.constant) {
                throw minErr("ngModel")("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
            }
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
        var listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener);
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
            return value === false;
        };
        ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    if (ctrls[0]) {
                        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                    }
                }
            }
        };
    } ];
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        attr.$set("value", scope.$eval(attr.ngValue));
                    };
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set("value", value);
                        });
                    };
                }
            }
        };
    };
    var ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function ngBindCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind);
                    element = element[0];
                    scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function ngBindTemplateCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindTemplateLink(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions);
                    element = element[0];
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
                    return (value || "").toString();
                });
                $compile.$$addBindingClass(tElement);
                return function ngBindHtmlLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml);
                    scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "");
                    });
                };
            }
        };
    } ];
    var ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    function classDirective(name, selector) {
        name = "ngClass" + name;
        return [ "$animate", function($animate) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, true);
                    attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    });
                    if (name !== "ngClass") {
                        scope.$watch("$index", function($index, old$index) {
                            var mod = $index & 1;
                            if (mod !== (old$index & 1)) {
                                var classes = arrayClasses(scope.$eval(attr[name]));
                                mod === selector ? addClasses(classes) : removeClasses(classes);
                            }
                        });
                    }
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {};
                        var classesToUpdate = [];
                        forEach(classes, function(className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        element.data("$classCounts", classCounts);
                        return classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses);
                        var toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1);
                        toRemove = digestClassCounts(toRemove, -1);
                        if (toAdd && toAdd.length) {
                            $animate.addClass(element, toAdd);
                        }
                        if (toRemove && toRemove.length) {
                            $animate.removeClass(element, toRemove);
                        }
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === true || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (!oldVal) {
                                addClasses(newClasses);
                            } else if (!equals(newVal, oldVal)) {
                                var oldClasses = arrayClasses(oldVal);
                                updateClasses(oldClasses, newClasses);
                            }
                        }
                        oldVal = shallowCopy(newVal);
                    }
                }
            };
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j]) continue outer;
                    }
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) {
                    return classVal.join(" ").split(" ");
                } else if (isString(classVal)) {
                    return classVal.split(" ");
                } else if (isObject(classVal)) {
                    var classes = [];
                    forEach(classVal, function(v, k) {
                        if (v) {
                            classes = classes.concat(k.split(" "));
                        }
                    });
                    return classes;
                }
                return classVal;
            }
        } ];
    }
    var ngClassDirective = classDirective("", true);
    var ngClassOddDirective = classDirective("Odd", 0);
    var ngClassEvenDirective = classDirective("Even", 1);
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined);
            element.removeClass("ng-cloak");
        }
    });
    var ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: true,
            controller: "@",
            priority: 500
        };
    } ];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
        blur: true,
        focus: true
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, true);
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback);
                            } else {
                                scope.$apply(callback);
                            }
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            multiElement: true,
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (value) {
                        if (!childScope) {
                            $transclude(function(clone, newScope) {
                                childScope = newScope;
                                clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " ");
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockNodes(block.clone);
                            $animate.leave(previousElements).then(function() {
                                previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    } ];
    var ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", "$sce", function($templateRequest, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function() {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).then(function() {
                                previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
                        var afterAnimation = function() {
                            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function(response) {
                                if (thisChangeId !== changeCounter) return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element).then(afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit("$includeContentLoaded", src);
                                scope.$eval(onloadExp);
                            }, function() {
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit("$includeContentError", src);
                                }
                            });
                            scope.$emit("$includeContentRequested", src);
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    } ];
    var ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (/SVG/.test($element[0].toString())) {
                    $element.empty();
                    $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                        $element.append(clone);
                    }, {
                        futureParentElement: $element
                    });
                    return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    } ];
    var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    });
    var ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ";
                var trimValues = attr.ngTrim !== "false";
                var separator = trimValues ? trim(ngList) : ngList;
                var parse = function(viewValue) {
                    if (isUndefined(viewValue)) return;
                    var list = [];
                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trimValues ? trim(value) : value);
                        });
                    }
                    return list;
                };
                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(ngList);
                    }
                    return undefined;
                });
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    };
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending";
    var $ngModelMinErr = new minErr("ngModel");
    var NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || "", false)($scope);
        var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, parserValid, ctrl = this;
        this.$$setOptions = function(options) {
            ctrl.$options = options;
            if (options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    if (isFunction(modelValue)) {
                        modelValue = invokeModelGetter($scope);
                    }
                    return modelValue;
                };
                ngModelSet = function($scope, newValue) {
                    if (isFunction(parsedNgModel($scope))) {
                        invokeModelSetter($scope, {
                            $$$p: ctrl.$modelValue
                        });
                    } else {
                        parsedNgModelAssign($scope, ctrl.$modelValue);
                    }
                };
            } else if (!parsedNgModel.assign) {
                throw $ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
            }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = true;
            },
            unset: function(object, property) {
                delete object[property];
            },
            parentForm: parentForm,
            $animate: $animate
        });
        this.$setPristine = function() {
            ctrl.$dirty = false;
            ctrl.$pristine = true;
            $animate.removeClass($element, DIRTY_CLASS);
            $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
            ctrl.$dirty = true;
            ctrl.$pristine = false;
            $animate.removeClass($element, PRISTINE_CLASS);
            $animate.addClass($element, DIRTY_CLASS);
            parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            ctrl.$touched = false;
            ctrl.$untouched = true;
            $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
            ctrl.$touched = true;
            ctrl.$untouched = false;
            $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
            ctrl.$render();
        };
        this.$validate = function() {
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                return;
            }
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = ctrl.$$rawModelValue;
            var prevValid = ctrl.$valid;
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
                if (!allowInvalid && prevValid !== allValid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    if (ctrl.$modelValue !== prevModelValue) {
                        ctrl.$$writeModelToScope();
                    }
                }
            });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            if (!processParseErrors()) {
                validationDone(false);
                return;
            }
            if (!processSyncValidators()) {
                validationDone(false);
                return;
            }
            processAsyncValidators();
            function processParseErrors() {
                var errorKey = ctrl.$$parserName || "parse";
                if (parserValid === undefined) {
                    setValidity(errorKey, null);
                } else {
                    if (!parserValid) {
                        forEach(ctrl.$validators, function(v, name) {
                            setValidity(name, null);
                        });
                        forEach(ctrl.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        });
                    }
                    setValidity(errorKey, parserValid);
                    return parserValid;
                }
                return true;
            }
            function processSyncValidators() {
                var syncValidatorsValid = true;
                forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result;
                    setValidity(name, result);
                });
                if (!syncValidatorsValid) {
                    forEach(ctrl.$asyncValidators, function(v, name) {
                        setValidity(name, null);
                    });
                    return false;
                }
                return true;
            }
            function processAsyncValidators() {
                var validatorPromises = [];
                var allValid = true;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) {
                        throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    }
                    setValidity(name, undefined);
                    validatorPromises.push(promise.then(function() {
                        setValidity(name, true);
                    }, function(error) {
                        allValid = false;
                        setValidity(name, false);
                    }));
                });
                if (!validatorPromises.length) {
                    validationDone(true);
                } else {
                    $q.all(validatorPromises).then(function() {
                        validationDone(allValid);
                    }, noop);
                }
            }
            function setValidity(name, isValid) {
                if (localValidationRunId === currentValidationRunId) {
                    ctrl.$setValidity(name, isValid);
                }
            }
            function validationDone(allValid) {
                if (localValidationRunId === currentValidationRunId) {
                    doneCallback(allValid);
                }
            }
        };
        this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce);
            if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !ctrl.$$hasNativeValidators)) {
                return;
            }
            ctrl.$$lastCommittedViewValue = viewValue;
            if (ctrl.$pristine) {
                this.$setDirty();
            }
            this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
            var viewValue = ctrl.$$lastCommittedViewValue;
            var modelValue = viewValue;
            parserValid = isUndefined(modelValue) ? undefined : true;
            if (parserValid) {
                for (var i = 0; i < ctrl.$parsers.length; i++) {
                    modelValue = ctrl.$parsers[i](modelValue);
                    if (isUndefined(modelValue)) {
                        parserValid = false;
                        break;
                    }
                }
            }
            if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                ctrl.$modelValue = ngModelGet($scope);
            }
            var prevModelValue = ctrl.$modelValue;
            var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue;
            if (allowInvalid) {
                ctrl.$modelValue = modelValue;
                writeToModelIfNeeded();
            }
            ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                if (!allowInvalid) {
                    ctrl.$modelValue = allValid ? modelValue : undefined;
                    writeToModelIfNeeded();
                }
            });
            function writeToModelIfNeeded() {
                if (ctrl.$modelValue !== prevModelValue) {
                    ctrl.$$writeModelToScope();
                }
            }
        };
        this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue);
            forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        };
        this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value;
            if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                ctrl.$$debounceViewValueCommit(trigger);
            }
        };
        this.$$debounceViewValueCommit = function(trigger) {
            var debounceDelay = 0, options = ctrl.$options, debounce;
            if (options && isDefined(options.debounce)) {
                debounce = options.debounce;
                if (isNumber(debounce)) {
                    debounceDelay = debounce;
                } else if (isNumber(debounce[trigger])) {
                    debounceDelay = debounce[trigger];
                } else if (isNumber(debounce["default"])) {
                    debounceDelay = debounce["default"];
                }
            }
            $timeout.cancel(pendingDebounce);
            if (debounceDelay) {
                pendingDebounce = $timeout(function() {
                    ctrl.$commitViewValue();
                }, debounceDelay);
            } else if ($rootScope.$$phase) {
                ctrl.$commitViewValue();
            } else {
                $scope.$apply(function() {
                    ctrl.$commitViewValue();
                });
            }
        };
        $scope.$watch(function ngModelWatch() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                parserValid = undefined;
                var formatters = ctrl.$formatters, idx = formatters.length;
                var viewValue = modelValue;
                while (idx--) {
                    viewValue = formatters[idx](viewValue);
                }
                if (ctrl.$viewValue !== viewValue) {
                    ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                    ctrl.$render();
                    ctrl.$$runValidators(modelValue, viewValue, noop);
                }
            }
            return modelValue;
        });
    } ];
    var ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element) {
                element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                return {
                    pre: function ngModelPreLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                        formCtrl.$addControl(modelCtrl);
                        attr.$observe("name", function(newValue) {
                            if (modelCtrl.$name !== newValue) {
                                formCtrl.$$renameControl(modelCtrl, newValue);
                            }
                        });
                        scope.$on("$destroy", function() {
                            formCtrl.$removeControl(modelCtrl);
                        });
                    },
                    post: function ngModelPostLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                            element.on(modelCtrl.$options.updateOn, function(ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                            });
                        }
                        element.on("blur", function(ev) {
                            if (modelCtrl.$touched) return;
                            if ($rootScope.$$phase) {
                                scope.$evalAsync(modelCtrl.$setTouched);
                            } else {
                                scope.$apply(modelCtrl.$setTouched);
                            }
                        });
                    }
                };
            }
        };
    } ];
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    var ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = copy($scope.$eval($attrs.ngModelOptions));
                if (this.$options.updateOn !== undefined) {
                    this.$options.updateOnDefault = false;
                    this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                        that.$options.updateOnDefault = true;
                        return " ";
                    }));
                } else {
                    this.$options.updateOnDefault = true;
                }
            } ]
        };
    };
    function addSetValidityMethod(context) {
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, parentForm = context.parentForm, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
            if (state === undefined) {
                createAndSet("$pending", validationErrorKey, controller);
            } else {
                unsetAndCleanup("$pending", validationErrorKey, controller);
            }
            if (!isBoolean(state)) {
                unset(ctrl.$error, validationErrorKey, controller);
                unset(ctrl.$$success, validationErrorKey, controller);
            } else {
                if (state) {
                    unset(ctrl.$error, validationErrorKey, controller);
                    set(ctrl.$$success, validationErrorKey, controller);
                } else {
                    set(ctrl.$error, validationErrorKey, controller);
                    unset(ctrl.$$success, validationErrorKey, controller);
                }
            }
            if (ctrl.$pending) {
                cachedToggleClass(PENDING_CLASS, true);
                ctrl.$valid = ctrl.$invalid = undefined;
                toggleValidationCss("", null);
            } else {
                cachedToggleClass(PENDING_CLASS, false);
                ctrl.$valid = isObjectEmpty(ctrl.$error);
                ctrl.$invalid = !ctrl.$valid;
                toggleValidationCss("", ctrl.$valid);
            }
            var combinedState;
            if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                combinedState = undefined;
            } else if (ctrl.$error[validationErrorKey]) {
                combinedState = false;
            } else if (ctrl.$$success[validationErrorKey]) {
                combinedState = true;
            } else {
                combinedState = null;
            }
            toggleValidationCss(validationErrorKey, combinedState);
            parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
            if (!ctrl[name]) {
                ctrl[name] = {};
            }
            set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
            if (ctrl[name]) {
                unset(ctrl[name], value, controller);
            }
            if (isObjectEmpty(ctrl[name])) {
                ctrl[name] = undefined;
            }
        }
        function cachedToggleClass(className, switchValue) {
            if (switchValue && !classCache[className]) {
                $animate.addClass($element, className);
                classCache[className] = true;
            } else if (!switchValue && classCache[className]) {
                $animate.removeClass($element, className);
                classCache[className] = false;
            }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
            cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
    }
    function isObjectEmpty(obj) {
        if (obj) {
            for (var prop in obj) {
                return false;
            }
        }
        return true;
    }
    var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1e3
    });
    var ngOptionsMinErr = minErr("ngOptions");
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    var ngOptionsDirective = [ "$compile", "$parse", function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) {
                throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            }
            var valueName = match[5] || match[7];
            var keyName = match[6];
            var selectAs = / as /.test(match[0]) && match[1];
            var trackBy = match[9];
            var valueFn = $parse(match[2] ? match[1] : valueName);
            var selectAsFn = selectAs && $parse(selectAs);
            var viewValueFn = selectAsFn || valueFn;
            var trackByFn = trackBy && $parse(trackBy);
            var getTrackByValue = trackBy ? function(viewValue, locals) {
                return trackByFn(scope, locals);
            } : function getHashOfValue(viewValue) {
                return hashKey(viewValue);
            };
            var displayFn = $parse(match[2] || match[1]);
            var groupByFn = $parse(match[3] || "");
            var disableWhenFn = $parse(match[4] || "");
            var valuesFn = $parse(match[8]);
            var locals = {};
            var getLocals = keyName ? function(value, key) {
                locals[keyName] = key;
                locals[valueName] = value;
                return locals;
            } : function(value) {
                locals[valueName] = value;
                return locals;
            };
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue;
                this.viewValue = viewValue;
                this.label = label;
                this.group = group;
                this.disabled = disabled;
            }
            return {
                getWatchables: $parse(valuesFn, function(values) {
                    var watchedArray = [];
                    values = values || [];
                    Object.keys(values).forEach(function getWatchable(key) {
                        var locals = getLocals(values[key], key);
                        var selectValue = getTrackByValue(values[key], locals);
                        watchedArray.push(selectValue);
                        if (match[2]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    });
                    return watchedArray;
                }),
                getOptions: function() {
                    var optionItems = [];
                    var selectValueMap = {};
                    var optionValues = valuesFn(scope) || [];
                    var keys = Object.keys(optionValues);
                    keys.forEach(function getOption(key) {
                        if (key.charAt(0) === "$") return;
                        var value = optionValues[key];
                        var locals = getLocals(value, key);
                        var viewValue = viewValueFn(scope, locals);
                        var selectValue = getTrackByValue(viewValue, locals);
                        var label = displayFn(scope, locals);
                        var group = groupByFn(scope, locals);
                        var disabled = disableWhenFn(scope, locals);
                        var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem);
                        selectValueMap[selectValue] = optionItem;
                    });
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value, getLocals(value))];
                        }
                    };
                }
            };
        }
        var optionTemplate = document.createElement("option"), optGroupTemplate = document.createElement("optgroup");
        return {
            restrict: "A",
            terminal: true,
            require: [ "select", "?ngModel" ],
            link: function(scope, selectElement, attr, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) return;
                var selectCtrl = ctrls[0];
                var multiple = attr.multiple;
                var emptyOption = selectCtrl.emptyOption;
                var providedEmptyOption = !!emptyOption;
                var unknownOption = jqLite(optionTemplate.cloneNode(false));
                unknownOption.val("?");
                var options;
                var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
                var renderEmptyOption = function() {
                    if (!providedEmptyOption) {
                        selectElement.prepend(emptyOption);
                    }
                    selectElement.val("");
                    emptyOption.prop("selected", true);
                    emptyOption.attr("selected", true);
                };
                var removeEmptyOption = function() {
                    if (!providedEmptyOption) {
                        emptyOption.remove();
                    }
                };
                var renderUnknownOption = function() {
                    selectElement.prepend(unknownOption);
                    selectElement.val("?");
                    unknownOption.prop("selected", true);
                    unknownOption.attr("selected", true);
                };
                var removeUnknownOption = function() {
                    unknownOption.remove();
                };
                selectCtrl.writeValue = function writeNgOptionsValue(value) {
                    var option = options.getOptionFromViewValue(value);
                    if (option && !option.disabled) {
                        if (selectElement[0].value !== option.selectValue) {
                            removeUnknownOption();
                            removeEmptyOption();
                            selectElement[0].value = option.selectValue;
                            option.element.selected = true;
                            option.element.setAttribute("selected", "selected");
                        }
                    } else {
                        if (value === null || providedEmptyOption) {
                            removeUnknownOption();
                            renderEmptyOption();
                        } else {
                            removeEmptyOption();
                            renderUnknownOption();
                        }
                    }
                };
                selectCtrl.readValue = function readNgOptionsValue() {
                    var selectedOption = options.selectValueMap[selectElement.val()];
                    if (selectedOption && !selectedOption.disabled) {
                        removeEmptyOption();
                        removeUnknownOption();
                        return selectedOption.viewValue;
                    }
                    return null;
                };
                if (multiple) {
                    ngModelCtrl.$isEmpty = function(value) {
                        return !value || value.length === 0;
                    };
                    selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                        options.items.forEach(function(option) {
                            option.element.selected = false;
                        });
                        if (value) {
                            value.forEach(function(item) {
                                var option = options.getOptionFromViewValue(item);
                                if (option && !option.disabled) option.element.selected = true;
                            });
                        }
                    };
                    selectCtrl.readValue = function readNgOptionsMultiple() {
                        var selectedValues = selectElement.val() || [], selections = [];
                        forEach(selectedValues, function(value) {
                            var option = options.selectValueMap[value];
                            if (!option.disabled) selections.push(option.viewValue);
                        });
                        return selections;
                    };
                }
                if (providedEmptyOption) {
                    emptyOption.remove();
                    $compile(emptyOption)(scope);
                    emptyOption.removeClass("ng-scope");
                } else {
                    emptyOption = jqLite(optionTemplate.cloneNode(false));
                }
                updateOptions();
                scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                function updateOptionElement(option, element) {
                    option.element = element;
                    element.disabled = option.disabled;
                    if (option.value !== element.value) element.value = option.selectValue;
                    if (option.label !== element.label) {
                        element.label = option.label;
                        element.textContent = option.label;
                    }
                }
                function addOrReuseElement(parent, current, type, templateElement) {
                    var element;
                    if (current && lowercase(current.nodeName) === type) {
                        element = current;
                    } else {
                        element = templateElement.cloneNode(false);
                        if (!current) {
                            parent.appendChild(element);
                        } else {
                            parent.insertBefore(element, current);
                        }
                    }
                    return element;
                }
                function removeExcessElements(current) {
                    var next;
                    while (current) {
                        next = current.nextSibling;
                        jqLiteRemove(current);
                        current = next;
                    }
                }
                function skipEmptyAndUnknownOptions(current) {
                    var emptyOption_ = emptyOption && emptyOption[0];
                    var unknownOption_ = unknownOption && unknownOption[0];
                    if (emptyOption_ || unknownOption_) {
                        while (current && (current === emptyOption_ || current === unknownOption_)) {
                            current = current.nextSibling;
                        }
                    }
                    return current;
                }
                function updateOptions() {
                    var previousValue = options && selectCtrl.readValue();
                    options = ngOptions.getOptions();
                    var groupMap = {};
                    var currentElement = selectElement[0].firstChild;
                    if (providedEmptyOption) {
                        selectElement.prepend(emptyOption);
                    }
                    currentElement = skipEmptyAndUnknownOptions(currentElement);
                    options.items.forEach(function updateOption(option) {
                        var group;
                        var groupElement;
                        var optionElement;
                        if (option.group) {
                            group = groupMap[option.group];
                            if (!group) {
                                groupElement = addOrReuseElement(selectElement[0], currentElement, "optgroup", optGroupTemplate);
                                currentElement = groupElement.nextSibling;
                                groupElement.label = option.group;
                                group = groupMap[option.group] = {
                                    groupElement: groupElement,
                                    currentOptionElement: groupElement.firstChild
                                };
                            }
                            optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, "option", optionTemplate);
                            updateOptionElement(option, optionElement);
                            group.currentOptionElement = optionElement.nextSibling;
                        } else {
                            optionElement = addOrReuseElement(selectElement[0], currentElement, "option", optionTemplate);
                            updateOptionElement(option, optionElement);
                            currentElement = optionElement.nextSibling;
                        }
                    });
                    Object.keys(groupMap).forEach(function(key) {
                        removeExcessElements(groupMap[key].currentOptionElement);
                    });
                    removeExcessElements(currentElement);
                    ngModelCtrl.$render();
                    if (!ngModelCtrl.$isEmpty(previousValue)) {
                        var nextValue = selectCtrl.readValue();
                        if (!equals(previousValue, nextValue)) {
                            ngModelCtrl.$setViewValue(nextValue);
                        }
                    }
                }
            }
        };
    } ];
    var ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop, lastCount;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                });
                scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                    var count = parseFloat(newVal);
                    var countIsNaN = isNaN(count);
                    if (!countIsNaN && !(count in whens)) {
                        count = $locale.pluralCat(count - offset);
                    }
                    if (count !== lastCount && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        if (isUndefined(whenExpFn)) {
                            if (newVal != null) {
                                $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                            }
                            watchRemover = noop;
                            updateElementText();
                        } else {
                            watchRemover = scope.$watch(whenExpFn, updateElementText);
                        }
                        lastCount = count;
                    }
                });
                function updateElementText(newText) {
                    element.text(newText || "");
                }
            }
        };
    } ];
    var ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED";
        var ngRepeatMinErr = minErr("ngRepeat");
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier) scope[keyIdentifier] = key;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
            return block.clone[0];
        };
        var getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: true,
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
                var expression = $attr.ngRepeat;
                var ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " ");
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                var lhs = match[1];
                var rhs = match[2];
                var aliasAs = match[3];
                var trackByExp = match[4];
                match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                var valueIdentifier = match[3] || match[1];
                var keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                    throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                }
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                var hashFnLocals = {
                    $id: hashKey
                };
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                    if (trackByExpGetter) {
                        trackByIdExpFn = function(key, value, index) {
                            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                            hashFnLocals[valueIdentifier] = value;
                            hashFnLocals.$index = index;
                            return trackByExpGetter($scope, hashFnLocals);
                        };
                    }
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                        var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                        if (aliasAs) {
                            $scope[aliasAs] = collection;
                        }
                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        } else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                            collectionKeys = [];
                            for (var itemKey in collection) {
                                if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) !== "$") {
                                    collectionKeys.push(itemKey);
                                }
                            }
                        }
                        collectionLength = collectionKeys.length;
                        nextBlockOrder = new Array(collectionLength);
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn(key, value, index);
                            if (lastBlockMap[trackById]) {
                                block = lastBlockMap[trackById];
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap[trackById]) {
                                forEach(nextBlockOrder, function(block) {
                                    if (block && block.scope) lastBlockMap[block.id] = block;
                                });
                                throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            } else {
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                };
                                nextBlockMap[trackById] = true;
                            }
                        }
                        for (var blockKey in lastBlockMap) {
                            block = lastBlockMap[blockKey];
                            elementsToRemove = getBlockNodes(block.clone);
                            $animate.leave(elementsToRemove);
                            if (elementsToRemove[0].parentNode) {
                                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                    elementsToRemove[index][NG_REMOVED] = true;
                                }
                            }
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];
                            if (block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling;
                                } while (nextNode && nextNode[NG_REMOVED]);
                                if (getBlockStart(block) != nextNode) {
                                    $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                                }
                                previousNode = getBlockEnd(block);
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            } else {
                                $transclude(function ngRepeatTransclude(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(false);
                                    clone[clone.length++] = endNode;
                                    $animate.enter(clone, null, jqLite(previousNode));
                                    previousNode = endNode;
                                    block.clone = clone;
                                    nextBlockMap[block.id] = block;
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ];
    var NG_HIDE_CLASS = "ng-hide";
    var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
    var ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watchCollection(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function(val, style) {
                    element.css(style, "");
                });
            }
            if (newStyles) element.css(newStyles);
        });
    });
    var ngSwitchDirective = [ "$animate", function($animate) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function ngSwitchController() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                var spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                        $animate.cancel(previousLeaveAnimations[i]);
                    }
                    previousLeaveAnimations.length = 0;
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                        promise.then(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            selectedTransclude.transclude(function(caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                                var block = {
                                    clone: caseElement
                                };
                                selectedElements.push(block);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    } ];
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [];
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) {
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
            }
            $transclude(function(clone) {
                $element.empty();
                $element.append(clone);
            });
        }
    });
    var scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: true,
            compile: function(element, attr) {
                if (attr.type == "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ];
    var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    };
    var SelectController = [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
        var self = this, optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement("option"));
        self.renderUnknownOption = function(val) {
            var unknownVal = "? " + hashKey(val) + " ?";
            self.unknownOption.val(unknownVal);
            $element.prepend(self.unknownOption);
            $element.val(unknownVal);
        };
        $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
            if (self.unknownOption.parent()) self.unknownOption.remove();
        };
        for (var i = 0, children = $element.children(), ii = children.length; i < ii; i++) {
            if (children[i].value === "") {
                self.emptyOption = children.eq(i);
                break;
            }
        }
        self.readValue = function readSingleValue() {
            self.removeUnknownOption();
            return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
            if (self.hasOption(value)) {
                self.removeUnknownOption();
                $element.val(value);
                if (value === "") self.emptyOption.prop("selected", true);
            } else {
                if (isUndefined(value) && self.emptyOption) {
                    self.removeUnknownOption();
                    $element.val("");
                } else {
                    self.renderUnknownOption(value);
                }
            }
        };
        self.addOption = function(value) {
            assertNotHasOwnProperty(value, '"option value"');
            var count = optionsMap.get(value) || 0;
            optionsMap.put(value, count + 1);
        };
        self.removeOption = function(value) {
            var count = optionsMap.get(value);
            if (count) {
                if (count === 1) {
                    optionsMap.remove(value);
                } else {
                    optionsMap.put(value, count - 1);
                }
            }
        };
        self.hasOption = function(value) {
            return !!optionsMap.get(value);
        };
    } ];
    var selectDirective = function() {
        var lastView;
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            link: function(scope, element, attr, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (!ngModelCtrl) return;
                var selectCtrl = ctrls[0];
                selectCtrl.ngModelCtrl = ngModelCtrl;
                ngModelCtrl.$render = function() {
                    selectCtrl.writeValue(ngModelCtrl.$viewValue);
                };
                element.on("change", function() {
                    scope.$apply(function() {
                        ngModelCtrl.$setViewValue(selectCtrl.readValue());
                    });
                });
                if (attr.multiple) {
                    selectCtrl.readValue = function readMultipleValue() {
                        var array = [];
                        forEach(element.find("option"), function(option) {
                            if (option.selected) {
                                array.push(option.value);
                            }
                        });
                        return array;
                    };
                    selectCtrl.writeValue = function writeMultipleValue(value) {
                        var items = new HashMap(value);
                        forEach(element.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };
                    scope.$watch(function selectMultipleWatch() {
                        if (!equals(lastView, ngModelCtrl.$viewValue)) {
                            lastView = shallowCopy(ngModelCtrl.$viewValue);
                            ngModelCtrl.$render();
                        }
                    });
                    ngModelCtrl.$isEmpty = function(value) {
                        return !value || value.length === 0;
                    };
                }
            }
        };
    };
    var optionDirective = [ "$interpolate", function($interpolate) {
        function chromeHack(optionElement) {
            if (optionElement[0].hasAttribute("selected")) {
                optionElement[0].selected = true;
            }
        }
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true);
                    if (!interpolateFn) {
                        attr.$set("value", element.text());
                    }
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (selectCtrl && selectCtrl.ngModelCtrl) {
                        if (interpolateFn) {
                            scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                                attr.$set("value", newVal);
                                if (oldVal !== newVal) {
                                    selectCtrl.removeOption(oldVal);
                                }
                                selectCtrl.addOption(newVal, element);
                                selectCtrl.ngModelCtrl.$render();
                                chromeHack(element);
                            });
                        } else {
                            selectCtrl.addOption(attr.value, element);
                            selectCtrl.ngModelCtrl.$render();
                            chromeHack(element);
                        }
                        element.on("$destroy", function() {
                            selectCtrl.removeOption(attr.value);
                            selectCtrl.ngModelCtrl.$render();
                        });
                    }
                };
            }
        };
    } ];
    var styleDirective = valueFn({
        restrict: "E",
        terminal: false
    });
    var requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                attr.required = true;
                ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                };
                attr.$observe("required", function() {
                    ctrl.$validate();
                });
            }
        };
    };
    var patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var regexp, patternExp = attr.ngPattern || attr.pattern;
                attr.$observe("pattern", function(regex) {
                    if (isString(regex) && regex.length > 0) {
                        regex = new RegExp("^" + regex + "$");
                    }
                    if (regex && !regex.test) {
                        throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                    }
                    regexp = regex || undefined;
                    ctrl.$validate();
                });
                ctrl.$validators.pattern = function(value) {
                    return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
                };
            }
        };
    };
    var maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var maxlength = -1;
                attr.$observe("maxlength", function(value) {
                    var intVal = toInt(value);
                    maxlength = isNaN(intVal) ? -1 : intVal;
                    ctrl.$validate();
                });
                ctrl.$validators.maxlength = function(modelValue, viewValue) {
                    return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                };
            }
        };
    };
    var minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var minlength = 0;
                attr.$observe("minlength", function(value) {
                    minlength = toInt(value) || 0;
                    ctrl.$validate();
                });
                ctrl.$validators.minlength = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                };
            }
        };
    };
    if (window.angular.bootstrap) {
        console.log("WARNING: Tried to load angular more than once.");
        return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    });
})(window, document);

!window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>');

if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = "ui.router";
}

(function(window, angular, undefined) {
    "use strict";
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        forEach(arguments, function(obj) {
            if (obj !== dst) {
                forEach(obj, function(value, key) {
                    if (!dst.hasOwnProperty(key)) dst[key] = value;
                });
            }
        });
        return dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];
        angular.forEach(object, function(val, key) {
            result.push(key);
        });
        return result;
    }
    function indexOf(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        from = from < 0 ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (;from < len; from++) {
            if (from in array && array[from] === value) return from;
        }
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i].params) continue;
            parentParams = objectKeys(parents[i].params);
            if (!parentParams.length) continue;
            for (var j in parentParams) {
                if (indexOf(inheritList, parentParams[j]) >= 0) continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return false;
        }
        return true;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
            filtered[name] = values[name];
        });
        return filtered;
    }
    function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
            result[item[propName]] = item;
        });
        return result;
    }
    function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
            if (key in obj) copy[key] = obj[key];
        });
        return copy;
    }
    function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
            if (indexOf(keys, key) == -1) copy[key] = obj[key];
        }
        return copy;
    }
    function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
    }
    function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
            if (callback(val, i)) {
                result[array ? result.length : i] = val;
            }
        });
        return result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        });
        return result;
    }
    angular.module("ui.router.util", [ "ng" ]);
    angular.module("ui.router.router", [ "ui.router.util" ]);
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]);
    angular.module("ui.router", [ "ui.router.state" ]);
    angular.module("ui.router.compat", [ "ui.router" ]);
    $Resolve.$inject = [ "$q", "$injector" ];
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {});
            var plan = [], cycle = [], visited = {};
            function visit(value, key) {
                if (visited[key] === VISIT_DONE) return;
                cycle.push(key);
                if (visited[key] === VISIT_IN_PROGRESS) {
                    cycle.splice(0, indexOf(cycle, key));
                    throw new Error("Cyclic dependency: " + cycle.join(" -> "));
                }
                visited[key] = VISIT_IN_PROGRESS;
                if (isString(value)) {
                    plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES);
                } else {
                    var params = $injector.annotate(value);
                    forEach(params, function(param) {
                        if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
                    });
                    plan.push(key, value, params);
                }
                cycle.pop();
                visited[key] = VISIT_DONE;
            }
            forEach(invocables, visit);
            invocables = cycle = visited = null;
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            return function(locals, parent, self) {
                if (isResolve(locals) && self === undefined) {
                    self = parent;
                    parent = locals;
                    locals = null;
                }
                if (!locals) locals = NO_LOCALS; else if (!isObject(locals)) {
                    throw new Error("'locals' must be an object");
                }
                if (!parent) parent = NO_PARENT; else if (!isResolve(parent)) {
                    throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                }
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = false;
                function done() {
                    if (!--wait) {
                        if (!merged) merge(values, parent.$$values);
                        result.$$values = values;
                        result.$$promises = result.$$promises || true;
                        delete result.$$inheritedValues;
                        resolution.resolve(values);
                    }
                }
                function fail(reason) {
                    result.$$failure = reason;
                    resolution.reject(reason);
                }
                if (isDefined(parent.$$failure)) {
                    fail(parent.$$failure);
                    return result;
                }
                if (parent.$$inheritedValues) {
                    merge(values, omit(parent.$$inheritedValues, invocableKeys));
                }
                extend(promises, parent.$$promises);
                if (parent.$$values) {
                    merged = merge(values, omit(parent.$$values, invocableKeys));
                    result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                    done();
                } else {
                    if (parent.$$inheritedValues) {
                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                    }
                    parent.then(done, fail);
                }
                for (var i = 0, ii = plan.length; i < ii; i += 3) {
                    if (locals.hasOwnProperty(plan[i])) done(); else invoke(plan[i], plan[i + 1], plan[i + 2]);
                }
                function invoke(key, invocable, params) {
                    var invocation = $q.defer(), waitParams = 0;
                    function onfailure(reason) {
                        invocation.reject(reason);
                        fail(reason);
                    }
                    forEach(params, function(dep) {
                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                            waitParams++;
                            promises[dep].then(function(result) {
                                values[dep] = result;
                                if (!--waitParams) proceed();
                            }, onfailure);
                        }
                    });
                    if (!waitParams) proceed();
                    function proceed() {
                        if (isDefined(result.$$failure)) return;
                        try {
                            invocation.resolve($injector.invoke(invocable, self, values));
                            invocation.promise.then(function(result) {
                                values[key] = result;
                                done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    promises[key] = invocation.promise;
                }
                return result;
            };
        };
        this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    angular.module("ui.router.util").service("$resolve", $Resolve);
    $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ];
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        };
        this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
            if (isFunction(url)) url = url(params);
            if (url == null) return null; else return $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
    var $$UMFP;
    function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, m, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        function addParameter(id, type, config, location) {
            paramNames.push(id);
            if (parentParams[id]) return parentParams[id];
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            params[id] = new $$UMFP.Param(id, type, config, location);
            return params[id];
        }
        function quoteRegExp(string, pattern, squash) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case false:
                surroundPattern = [ "(", ")" ];
                break;

              case true:
                surroundPattern = [ "?(", ")?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
                break;
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg, arrayMode;
            id = m[2] || m[3];
            cfg = config.params[id];
            segment = pattern.substring(last, m.index);
            regexp = isSearch ? m[4] : m[4] || (m[1] == "*" ? ".*" : null);
            type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {
                pattern: new RegExp(regexp)
            });
            return {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        var p, param, segment;
        while (m = placeholder.exec(pattern)) {
            p = matchDetails(m, false);
            if (p.segment.indexOf("?") >= 0) break;
            param = addParameter(p.id, p.type, p.cfg, "path");
            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash);
            segments.push(p.segment);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            segment = segment.substring(0, i);
            this.sourcePath = pattern.substring(0, last + i);
            if (search.length > 0) {
                last = 0;
                while (m = searchPlaceholder.exec(search)) {
                    p = matchDetails(m, true);
                    param = addParameter(p.id, p.type, p.cfg, "search");
                    last = placeholder.lastIndex;
                }
            }
        } else {
            this.sourcePath = pattern;
            this.sourceSearch = "";
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? "/?" : "") + "$";
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
        return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {}, i, j, cfg, paramName;
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
            paramName = paramNames[i];
            var param = this.params[paramName];
            var paramVal = m[i + 1];
            for (j = 0; j < param.replace; j++) {
                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
            }
            if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
            values[paramName] = param.value(paramVal);
        }
        for (;i < nTotal; i++) {
            paramName = paramNames[i];
            values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param)) return this.$$paramNames;
        return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        for (i = 0; i < nTotal; i++) {
            var isPathParam = i < nPath;
            var name = params[i], param = paramset[name], value = param.value(values[name]);
            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
            var squash = isDefaultValue ? param.squash : false;
            var encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1];
                if (squash === false) {
                    if (encoded != null) {
                        if (isArray(encoded)) {
                            result += map(encoded, encodeDashes).join("-");
                        } else {
                            result += encodeURIComponent(encoded);
                        }
                    }
                    result += nextSegment;
                } else if (squash === true) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else if (isString(squash)) {
                    result += squash + nextSegment;
                }
            } else {
                if (encoded == null || isDefaultValue && squash !== false) continue;
                if (!isArray(encoded)) encoded = [ encoded ];
                encoded = map(encoded, encodeURIComponent).join("&" + name + "=");
                result += (search ? "&" : "?") + (name + "=" + encoded);
                search = true;
            }
        }
        return result;
    };
    function Type(config) {
        extend(this, config);
    }
    Type.prototype.is = function(val, key) {
        return true;
    };
    Type.prototype.encode = function(val, key) {
        return val;
    };
    Type.prototype.decode = function(val, key) {
        return val;
    };
    Type.prototype.equals = function(a, b) {
        return a == b;
    };
    Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    };
    Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode) return this;
        if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return mode === "auto" ? val[0] : val;

                  default:
                    return val;
                }
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    if (allTruthyMode === true) return filter(result, falsey).length === 0;
                    return arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return false;
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i])) return false;
                    }
                    return true;
                };
            }
            this.encode = arrayHandler(bindTo(type, "encode"));
            this.decode = arrayHandler(bindTo(type, "decode"));
            this.is = arrayHandler(bindTo(type, "is"), true);
            this.equals = arrayEqualsHandler(bindTo(type, "equals"));
            this.pattern = type.pattern;
            this.$arrayMode = mode;
        }
    };
    function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;
        function valToString(val) {
            return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
            return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        function regexpMatches(val) {
            return this.pattern.test(val);
        }
        var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                is: regexpMatches,
                pattern: /[^/]*/
            },
            "int": {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                    return val === true || val === false;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    if (!this.is(val)) return undefined;
                    return [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-");
                },
                decode: function(val) {
                    if (this.is(val)) return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                is: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
            if (isDefined(value)) isCaseInsensitive = value;
            return isCaseInsensitive;
        };
        this.strictMode = function(value) {
            if (isDefined(value)) isStrictMode = value;
            return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== true && value !== false && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            defaultSquashPolicy = value;
            return value;
        };
        this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
            if (!isObject(o)) return false;
            var result = true;
            forEach(UrlMatcher.prototype, function(val, name) {
                if (isFunction(val)) {
                    result = result && (isDefined(o[name]) && isFunction(o[name]));
                }
            });
            return result;
        };
        this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            $types[name] = new Type(extend({
                name: name
            }, definition));
            if (definitionFn) {
                typeQueue.push({
                    name: name,
                    def: definitionFn
                });
                if (!enqueue) flushTypeQueue();
            }
            return this;
        };
        function flushTypeQueue() {
            while (typeQueue.length) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        });
        $types = inherit($types, {});
        this.$get = [ "$injector", function($injector) {
            injector = $injector;
            enqueue = false;
            flushTypeQueue();
            forEach(defaultTypes, function(type, name) {
                if (!$types[name]) $types[name] = new Type(type);
            });
            return this;
        } ];
        this.Param = function Param(id, type, config, location) {
            var self = this;
            config = unwrapShorthand(config);
            type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
            if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = "";
            var isOptional = config.value !== undefined;
            var squash = getSquashPolicy(config, isOptional);
            var replace = getReplace(config, arrayMode, isOptional, squash);
            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [];
                var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                if (isShorthand) config = {
                    value: config
                };
                config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                };
                return config;
            }
            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                if (urlType) return urlType;
                if (!config.type) return location === "config" ? $types.any : $types.string;
                return config.type instanceof Type ? config.type : new Type(config.type);
            }
            function getArrayMode() {
                var arrayDefaults = {
                    array: location === "search" ? "auto" : false
                };
                var arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: true
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === false) return false;
                if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
                if (squash === true || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || arrayMode ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || arrayMode ? undefined : ""
                } ];
                replace = isArray(config.replace) ? config.replace : [];
                if (isString(squash)) replace.push({
                    from: squash,
                    to: undefined
                });
                configuredKeys = map(replace, function(item) {
                    return item.from;
                });
                return filter(defaultPolicy, function(item) {
                    return indexOf(configuredKeys, item.from) === -1;
                }).concat(replace);
            }
            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                return injector.invoke(config.$$fn);
            }
            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                value = $replace(value);
                return isDefined(value) ? self.type.decode(value) : $$getDefaultValue();
            }
            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        };
        function ParamSet(params) {
            extend(this, params || {});
        }
        ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype);
                while (parent) {
                    chain.push(parent);
                    parent = parent.$$parent;
                }
                chain.reverse();
                forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
                    });
                });
                return keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                });
                return values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = true, self = this;
                forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    if (!self[key].type.equals(left, right)) equal = false;
                });
                return equal;
            },
            $$validates: function $$validate(paramValues) {
                var result = true, isOptional, val, param, self = this;
                forEach(this.$$keys(), function(key) {
                    param = self[key];
                    val = paramValues[key];
                    isOptional = !val && param.isOptional;
                    result = result && (isOptional || !!param.type.is(val));
                });
                return result;
            },
            $$parent: undefined
        };
        this.ParamSet = ParamSet;
    }
    angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory);
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]);
    $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [], otherwise = null, interceptDeferred = false, listener;
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match[what === "$" ? 0 : Number(what)];
            });
        }
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            rules.push(rule);
            return this;
        };
        this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            otherwise = rule;
            return this;
        };
        function handleIfMatch($injector, handler, match) {
            if (!match) return false;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what)) what = $urlMatcherFactory.compile(what);
            if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    if (handlerIsString) {
                        redirect = $urlMatcherFactory.compile(handler);
                        handler = [ "$match", function($match) {
                            return redirect.format($match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    if (handlerIsString) {
                        redirect = handler;
                        handler = [ "$match", function($match) {
                            return interpolate(redirect, $match);
                        } ];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            };
            var check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) {
                if (check[n]) return this.rule(strategies[n](what, handler));
            }
            throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
            if (defer === undefined) defer = true;
            interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = [ "$location", "$rootScope", "$injector", "$browser" ];
        function $get($location, $rootScope, $injector, $browser) {
            var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;
            function appendBasePath(url, isHtml5, absolute) {
                if (baseHref === "/") return url;
                if (isHtml5) return baseHref.slice(0, -1) + url;
                if (absolute) return baseHref.slice(1) + url;
                return url;
            }
            function update(evt) {
                if (evt && evt.defaultPrevented) return;
                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                lastPushedUrl = undefined;
                if (ignoreUpdate) return true;
                function check(rule) {
                    var handled = rule($injector, $location);
                    if (!handled) return false;
                    if (isString(handled)) $location.replace().url(handled);
                    return true;
                }
                var n = rules.length, i;
                for (i = 0; i < n; i++) {
                    if (check(rules[i])) return;
                }
                if (otherwise) check(otherwise);
            }
            function listen() {
                listener = listener || $rootScope.$on("$locationChangeSuccess", update);
                return listener;
            }
            if (!interceptDeferred) listen();
            return {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    if (read) {
                        location = $location.url();
                        return;
                    }
                    if ($location.url() === location) return;
                    $location.url(location);
                    $location.replace();
                },
                push: function(urlMatcher, params, options) {
                    $location.url(urlMatcher.format(params || {}));
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                    if (options && options.replace) $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    if (angular.isObject(isHtml5)) {
                        isHtml5 = isHtml5.enabled;
                    }
                    var url = urlMatcher.format(params);
                    options = options || {};
                    if (!isHtml5 && url !== null) {
                        url = "#" + $locationProvider.hashPrefix() + url;
                    }
                    url = appendBasePath(url, isHtml5, options.absolute);
                    if (!options.absolute || !url) {
                        return url;
                    }
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port();
                    port = port === 80 || port === 443 ? "" : ":" + port;
                    return [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
    }
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider);
    $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root, states = {}, $state, queue = {}, abstractKey = "abstract";
        var stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                if (state.parent && state.parent.data) {
                    state.data = state.self.data = extend({}, state.parent.data, state.data);
                }
                return state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) {
                    if (url.charAt(0) == "^") return $urlMatcherFactory.compile(url.substring(1), config);
                    return (state.parent.navigable || root).url.concat(url, config);
                }
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                forEach(state.params || {}, function(config, id) {
                    if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
                });
                return params;
            },
            params: function(state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    if (name.indexOf("@") < 0) name += "@" + state.parent.name;
                    views[name] = view;
                });
                return views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                includes[state.name] = true;
                return includes;
            },
            $delegates: {}
        };
        function isRelative(stateName) {
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                var rel = name.split("."), i = 0, pathLength = rel.length, current = base;
                for (;i < pathLength; i++) {
                    if (rel[i] === "" && i === 0) {
                        current = base;
                        continue;
                    }
                    if (rel[i] === "^") {
                        if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                        current = current.parent;
                        continue;
                    }
                    break;
                }
                rel = rel.slice(i).join(".");
                name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                return state;
            }
            return undefined;
        }
        function queueState(parentName, state) {
            if (!queue[parentName]) {
                queue[parentName] = [];
            }
            queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
            var queued = queue[parentName] || [];
            while (queued.length) {
                registerState(queued.shift());
            }
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
            var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) {
                return queueState(parentName, state.self);
            }
            for (var key in stateBuilder) {
                if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
            }
            states[name] = state;
            if (!state[abstractKey] && state.url) {
                $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                    if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                        $state.transitionTo(state, $match, {
                            inherit: true,
                            location: false
                        });
                    }
                } ]);
            }
            flushQueuedChildren(name);
            return state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            var globSegments = glob.split("."), segments = $state.$current.name.split(".");
            if (globSegments[0] === "**") {
                segments = segments.slice(indexOf(segments, globSegments[1]));
                segments.unshift("**");
            }
            if (globSegments[globSegments.length - 1] === "**") {
                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                segments.push("**");
            }
            if (globSegments.length != segments.length) {
                return false;
            }
            for (var i = 0, l = globSegments.length; i < l; i++) {
                if (globSegments[i] === "*") {
                    segments[i] = "*";
                }
            }
            return segments.join("") === globSegments.join("");
        }
        root = registerState({
            name: "",
            url: "^",
            views: null,
            "abstract": true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
            if (isString(name) && !isDefined(func)) {
                return stateBuilder[name];
            }
            if (!isFunction(func) || !isString(name)) {
                return this;
            }
            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                stateBuilder.$delegates[name] = stateBuilder[name];
            }
            stateBuilder[name] = func;
            return this;
        }
        this.state = state;
        function state(name, definition) {
            if (isObject(name)) definition = name; else definition.name = name;
            registerState(definition);
            return this;
        }
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            var TransitionSuperseded = $q.reject(new Error("transition superseded"));
            var TransitionPrevented = $q.reject(new Error("transition prevented"));
            var TransitionAborted = $q.reject(new Error("transition aborted"));
            var TransitionFailed = $q.reject(new Error("transition failed"));
            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                if (evt.defaultPrevented) {
                    $urlRouter.update();
                    return TransitionAborted;
                }
                if (!evt.retry) {
                    return null;
                }
                if (options.$retry) {
                    $urlRouter.update();
                    return TransitionFailed;
                }
                var retryTransition = $state.transition = $q.when(evt.retry);
                retryTransition.then(function() {
                    if (retryTransition !== $state.transition) return TransitionSuperseded;
                    redirect.options.$retry = true;
                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                }, function() {
                    return TransitionAborted;
                });
                $urlRouter.update();
                return retryTransition;
            }
            root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            };
            $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            };
            $state.reload = function reload() {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: true,
                    inherit: false,
                    notify: true
                });
            };
            $state.go = function go(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: true,
                    relative: $state.$current
                }, options));
            };
            $state.transitionTo = function transitionTo(to, toParams, options) {
                toParams = toParams || {};
                options = extend({
                    location: true,
                    inherit: false,
                    relative: null,
                    notify: true,
                    reload: false,
                    $retry: false
                }, options || {});
                var from = $state.$current, fromParams = $state.params, fromPath = from.path;
                var evt, toState = findState(to, options.relative);
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    };
                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) {
                        return redirectResult;
                    }
                    to = redirect.to;
                    toParams = redirect.toParams;
                    options = redirect.options;
                    toState = findState(to, options.relative);
                    if (!isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                if (!toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams);
                to = toState;
                var toPath = to.path;
                var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                if (!options.reload) {
                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                }
                if (shouldTriggerReload(to, from, locals, options)) {
                    if (to.self.reloadOnSearch !== false) $urlRouter.update();
                    $state.transition = null;
                    return $q.when($state.current);
                }
                toParams = filterByKeys(to.params.$$keys(), toParams || {});
                if (options.notify) {
                    if ($rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams).defaultPrevented) {
                        $urlRouter.update();
                        return TransitionPrevented;
                    }
                }
                var resolved = $q.when(locals);
                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                    locals = toLocals[l] = inherit(locals);
                    resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                }
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) {
                        exiting = fromPath[l];
                        if (exiting.self.onExit) {
                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                        }
                        exiting.locals = null;
                    }
                    for (l = keep; l < toPath.length; l++) {
                        entering = toPath[l];
                        entering.locals = toLocals[l];
                        if (entering.self.onEnter) {
                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                        }
                    }
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.$current = to;
                    $state.current = to.self;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    $state.transition = null;
                    if (options.location && to.navigable) {
                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: true,
                            replace: options.location === "replace"
                        });
                    }
                    if (options.notify) {
                        $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams);
                    }
                    $urlRouter.update(true);
                    return $state.current;
                }, function(error) {
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.transition = null;
                    evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error);
                    if (!evt.defaultPrevented) {
                        $urlRouter.update();
                    }
                    return $q.reject(error);
                });
                return transition;
            };
            $state.is = function is(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if ($state.$current !== state) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
            };
            $state.includes = function includes(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) {
                        return false;
                    }
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if (!isDefined($state.$current.includes[state.name])) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
            };
            $state.href = function href(stateOrName, params, options) {
                options = extend({
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
                var nav = state && options.lossy ? state.navigable : state;
                if (!nav || nav.url === undefined || nav.url === null) {
                    return null;
                }
                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {
                    absolute: options.absolute
                });
            };
            $state.get = function(stateOrName, context) {
                if (arguments.length === 0) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return state && state.self ? state.self : null;
            };
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
                var locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                if (inherited) promises.push(inherited);
                forEach(state.views, function(view, name) {
                    var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                    injectables.$template = [ function() {
                        return $view.load(name, {
                            view: view,
                            locals: locals,
                            params: $stateParams,
                            notify: options.notify
                        }) || "";
                    } ];
                    promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
                        if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                            var injectLocals = angular.extend({}, injectables, locals);
                            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                        } else {
                            result.$$controller = view.controller;
                        }
                        result.$$state = state;
                        result.$$controllerAs = view.controllerAs;
                        dst[name] = result;
                    }));
                });
                return $q.all(promises).then(function(values) {
                    return dst;
                });
            }
            return $state;
        }
        function shouldTriggerReload(to, from, locals, options) {
            if (to === from && (locals === from.locals && !options.reload || to.self.reloadOnSearch === false)) {
                return true;
            }
        }
    }
    angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider);
    $ViewProvider.$inject = [];
    function $ViewProvider() {
        this.$get = $get;
        $get.$inject = [ "$rootScope", "$templateFactory" ];
        function $get($rootScope, $templateFactory) {
            return {
                load: function load(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: true,
                        async: true,
                        params: {}
                    };
                    options = extend(defaults, options);
                    if (options.view) {
                        result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                    }
                    if (result && options.notify) {
                        $rootScope.$broadcast("$viewContentLoading", options);
                    }
                    return result;
                }
            };
        }
    }
    angular.module("ui.router.state").provider("$view", $ViewProvider);
    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
            useAnchorScroll = true;
        };
        this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            if (useAnchorScroll) {
                return $anchorScroll;
            }
            return function($element) {
                $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, false);
            };
        } ];
    }
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate");
        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element);
                        cb();
                    },
                    leave: function(element, cb) {
                        element.remove();
                        cb();
                    }
                };
            };
            if ($animate) {
                return {
                    enter: function(element, target, cb) {
                        var promise = $animate.enter(element, null, target, cb);
                        if (promise && promise.then) promise.then(cb);
                    },
                    leave: function(element, cb) {
                        var promise = $animate.leave(element, cb);
                        if (promise && promise.then) promise.then(cb);
                    }
                };
            }
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target);
                        cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element);
                        cb();
                    }
                };
            }
            return statics();
        }
        var directive = {
            restrict: "ECA",
            terminal: true,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(false);
                    });
                    scope.$on("$viewContentLoading", function() {
                        updateView(false);
                    });
                    updateView(true);
                    function cleanupLastView() {
                        if (previousEl) {
                            previousEl.remove();
                            previousEl = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentEl) {
                            renderer.leave(currentEl, function() {
                                previousEl = null;
                            });
                            previousEl = currentEl;
                            currentEl = null;
                        }
                    }
                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (!firstTime && previousLocals === latestLocals) return;
                        newScope = scope.$new();
                        latestLocals = $state.$current.locals[name];
                        var clone = $transclude(newScope, function(clone) {
                            renderer.enter(clone, $element, function onUiViewEnter() {
                                if (currentScope) {
                                    currentScope.$emit("$viewContentAnimationEnded");
                                }
                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone);
                                }
                            });
                            cleanupLastView();
                        });
                        currentEl = clone;
                        currentScope = newScope;
                        currentScope.$emit("$viewContentLoaded");
                        currentScope.$eval(onloadExp);
                    }
                };
            }
        };
        return directive;
    }
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                    if (!locals) {
                        return;
                    }
                    $element.data("$uiView", {
                        name: name,
                        state: locals.$$state
                    });
                    $element.html(locals.$template ? locals.$template : initial);
                    var link = $compile($element.contents());
                    if (locals.$$controller) {
                        locals.$scope = scope;
                        var controller = $controller(locals.$$controller, locals);
                        if (locals.$$controllerAs) {
                            scope[locals.$$controllerAs] = controller;
                        }
                        $element.data("$ngControllerController", controller);
                        $element.children().data("$ngControllerController", controller);
                    }
                    link(scope);
                };
            }
        };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope);
        var inherited = element.inheritedData("$uiView");
        return name.indexOf("@") >= 0 ? name : name + "@" + (inherited ? inherited.state.name : "");
    }
    angular.module("ui.router.state").directive("uiView", $ViewDirective);
    angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
    function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
        if (preparsed) ref = current + "(" + preparsed[1] + ")";
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        if (stateData && stateData.state && stateData.state.name) {
            return stateData.state;
        }
    }
    $StateRefDirective.$inject = [ "$state", "$timeout" ];
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = [ "location", "inherit", "reload" ];
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name);
                var params = null, url = null, base = stateContext(element) || $state.$current;
                var newHref = null, isAnchor = element.prop("tagName") === "A";
                var isForm = element[0].nodeName === "FORM";
                var attr = isForm ? "action" : "href", nav = true;
                var options = {
                    relative: base,
                    inherit: true
                };
                var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
                angular.forEach(allowedOptions, function(option) {
                    if (option in optionsOverride) {
                        options[option] = optionsOverride[option];
                    }
                });
                var update = function(newVal) {
                    if (newVal) params = angular.copy(newVal);
                    if (!nav) return;
                    newHref = $state.href(ref.state, params, options);
                    var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                    if (activeDirective) {
                        activeDirective.$$setStateInfo(ref.state, params);
                    }
                    if (newHref === null) {
                        nav = false;
                        return false;
                    }
                    attrs.$set(attr, newHref);
                };
                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                        if (newVal !== params) update(newVal);
                    }, true);
                    params = angular.copy(scope.$eval(ref.paramExpr));
                }
                update();
                if (isForm) return;
                element.bind("click", function(e) {
                    var button = e.which || e.button;
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target"))) {
                        var transition = $timeout(function() {
                            $state.go(ref.state, params, options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                        e.preventDefault = function() {
                            if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
                        };
                    }
                });
            }
        };
    }
    $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                var state, params, activeClass;
                activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || "", false)($scope);
                this.$$setStateInfo = function(newState, newParams) {
                    state = $state.get(newState, stateContext($element));
                    params = newParams;
                    update();
                };
                $scope.$on("$stateChangeSuccess", update);
                function update() {
                    if (isMatch()) {
                        $element.addClass(activeClass);
                    } else {
                        $element.removeClass(activeClass);
                    }
                }
                function isMatch() {
                    if (typeof $attrs.uiSrefActiveEq !== "undefined") {
                        return state && $state.is(state.name, params);
                    } else {
                        return state && $state.includes(state.name, params);
                    }
                }
            } ]
        };
    }
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective);
    $IsStateFilter.$inject = [ "$state" ];
    function $IsStateFilter($state) {
        var isFilter = function(state) {
            return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    $IncludedByStateFilter.$inject = [ "$state" ];
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
            return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
})(window, window.angular);

angular.module("ngMaterial", [ "ng", "ngAnimate", "ngAria", "material.core", "material.core.theming.palette", "material.core.theming", "material.components.autocomplete", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.content", "material.components.dialog", "material.components.divider", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.textField", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.whiteframe" ]);

(function() {
    "use strict";
    angular.module("material.core", [ "material.core.theming" ]).config(MdCoreConfigure);
    function MdCoreConfigure($provide, $mdThemingProvider) {
        $provide.decorator("$$rAF", [ "$delegate", rAFDecorator ]);
        $mdThemingProvider.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("red").backgroundPalette("grey");
    }
    MdCoreConfigure.$inject = [ "$provide", "$mdThemingProvider" ];
    function rAFDecorator($delegate) {
        $delegate.throttle = function(cb) {
            var queueArgs, alreadyQueued, queueCb, context;
            return function debounced() {
                queueArgs = arguments;
                context = this;
                queueCb = cb;
                if (!alreadyQueued) {
                    alreadyQueued = true;
                    $delegate(function() {
                        queueCb.apply(context, queueArgs);
                        alreadyQueued = false;
                    });
                }
            };
        };
        return $delegate;
    }
})();

(function() {
    "use strict";
    angular.module("material.core").factory("$mdConstant", MdConstantFactory);
    function MdConstantFactory($$rAF, $sniffer) {
        var webkit = /webkit/i.test($sniffer.vendorPrefix);
        function vendorProperty(name) {
            return webkit ? "webkit" + name.charAt(0).toUpperCase() + name.substring(1) : name;
        }
        return {
            KEY_CODE: {
                ENTER: 13,
                ESCAPE: 27,
                SPACE: 32,
                LEFT_ARROW: 37,
                UP_ARROW: 38,
                RIGHT_ARROW: 39,
                DOWN_ARROW: 40,
                TAB: 9
            },
            CSS: {
                TRANSITIONEND: "transitionend" + (webkit ? " webkitTransitionEnd" : ""),
                ANIMATIONEND: "animationend" + (webkit ? " webkitAnimationEnd" : ""),
                TRANSFORM: vendorProperty("transform"),
                TRANSFORM_ORIGIN: vendorProperty("transformOrigin"),
                TRANSITION: vendorProperty("transition"),
                TRANSITION_DURATION: vendorProperty("transitionDuration"),
                ANIMATION_PLAY_STATE: vendorProperty("animationPlayState"),
                ANIMATION_DURATION: vendorProperty("animationDuration"),
                ANIMATION_NAME: vendorProperty("animationName"),
                ANIMATION_TIMING: vendorProperty("animationTimingFunction"),
                ANIMATION_DIRECTION: vendorProperty("animationDirection")
            },
            MEDIA: {
                sm: "(max-width: 600px)",
                "gt-sm": "(min-width: 600px)",
                md: "(min-width: 600px) and (max-width: 960px)",
                "gt-md": "(min-width: 960px)",
                lg: "(min-width: 960px) and (max-width: 1200px)",
                "gt-lg": "(min-width: 1200px)"
            },
            MEDIA_PRIORITY: [ "gt-lg", "lg", "gt-md", "md", "gt-sm", "sm" ]
        };
    }
    MdConstantFactory.$inject = [ "$$rAF", "$sniffer" ];
})();

(function() {
    angular.module("material.core").config([ "$provide", function($provide) {
        $provide.decorator("$mdUtil", [ "$delegate", function($delegate) {
            $delegate.iterator = Iterator;
            return $delegate;
        } ]);
    } ]);
    function Iterator(items, reloop) {
        var trueFn = function() {
            return true;
        };
        if (items && !angular.isArray(items)) {
            items = Array.prototype.slice.call(items);
        }
        reloop = !!reloop;
        var _items = items || [];
        return {
            items: getItems,
            count: count,
            inRange: inRange,
            contains: contains,
            indexOf: indexOf,
            itemAt: itemAt,
            findBy: findBy,
            add: add,
            remove: remove,
            first: first,
            last: last,
            next: angular.bind(null, findSubsequentItem, false),
            previous: angular.bind(null, findSubsequentItem, true),
            hasPrevious: hasPrevious,
            hasNext: hasNext
        };
        function getItems() {
            return [].concat(_items);
        }
        function count() {
            return _items.length;
        }
        function inRange(index) {
            return _items.length && index > -1 && index < _items.length;
        }
        function hasNext(item) {
            return item ? inRange(indexOf(item) + 1) : false;
        }
        function hasPrevious(item) {
            return item ? inRange(indexOf(item) - 1) : false;
        }
        function itemAt(index) {
            return inRange(index) ? _items[index] : null;
        }
        function findBy(key, val) {
            return _items.filter(function(item) {
                return item[key] === val;
            });
        }
        function add(item, index) {
            if (!item) return -1;
            if (!angular.isNumber(index)) {
                index = _items.length;
            }
            _items.splice(index, 0, item);
            return indexOf(item);
        }
        function remove(item) {
            if (contains(item)) {
                _items.splice(indexOf(item), 1);
            }
        }
        function indexOf(item) {
            return _items.indexOf(item);
        }
        function contains(item) {
            return item && indexOf(item) > -1;
        }
        function first() {
            return _items.length ? _items[0] : null;
        }
        function last() {
            return _items.length ? _items[_items.length - 1] : null;
        }
        function findSubsequentItem(backwards, item, validate, limit) {
            validate = validate || trueFn;
            var curIndex = indexOf(item);
            while (true) {
                if (!inRange(curIndex)) return null;
                var nextIndex = curIndex + (backwards ? -1 : 1);
                var foundItem = null;
                if (inRange(nextIndex)) {
                    foundItem = _items[nextIndex];
                } else if (reloop) {
                    foundItem = backwards ? last() : first();
                    nextIndex = indexOf(foundItem);
                }
                if (foundItem === null || nextIndex === limit) return null;
                if (validate(foundItem)) return foundItem;
                if (angular.isUndefined(limit)) limit = nextIndex;
                curIndex = nextIndex;
            }
        }
    }
})();

(function() {
    angular.module("material.core").factory("$mdMedia", mdMediaFactory);
    function mdMediaFactory($mdConstant, $rootScope, $window) {
        var queries = {};
        var mqls = {};
        var results = {};
        var normalizeCache = {};
        $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
        $mdMedia.getQuery = getQuery;
        $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
        return $mdMedia;
        function $mdMedia(query) {
            var validated = queries[query];
            if (angular.isUndefined(validated)) {
                validated = queries[query] = validate(query);
            }
            var result = results[validated];
            if (angular.isUndefined(result)) {
                result = add(validated);
            }
            return result;
        }
        function validate(query) {
            return $mdConstant.MEDIA[query] || (query.charAt(0) !== "(" ? "(" + query + ")" : query);
        }
        function add(query) {
            var result = mqls[query] = $window.matchMedia(query);
            result.addListener(onQueryChange);
            return results[result.media] = !!result.matches;
        }
        function onQueryChange(query) {
            $rootScope.$evalAsync(function() {
                results[query.media] = !!query.matches;
            });
        }
        function getQuery(name) {
            return mqls[name];
        }
        function getResponsiveAttribute(attrs, attrName) {
            for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
                var mediaName = $mdConstant.MEDIA_PRIORITY[i];
                if (!mqls[queries[mediaName]].matches) {
                    continue;
                }
                var normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
                if (attrs[normalizedName]) {
                    return attrs[normalizedName];
                }
            }
            return attrs[getNormalizedName(attrs, attrName)];
        }
        function watchResponsiveAttributes(attrNames, attrs, watchFn) {
            var unwatchFns = [];
            attrNames.forEach(function(attrName) {
                var normalizedName = getNormalizedName(attrs, attrName);
                if (attrs[normalizedName]) {
                    unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
                }
                for (var mediaName in $mdConstant.MEDIA) {
                    normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
                    if (!attrs[normalizedName]) {
                        return;
                    }
                    unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                }
            });
            return function unwatch() {
                unwatchFns.forEach(function(fn) {
                    fn();
                });
            };
        }
        function getNormalizedName(attrs, attrName) {
            return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
        }
    }
    mdMediaFactory.$inject = [ "$mdConstant", "$rootScope", "$window" ];
})();

(function() {
    "use strict";
    var nextUniqueId = [ "0", "0", "0" ];
    angular.module("material.core").factory("$mdUtil", [ "$cacheFactory", "$document", "$timeout", "$q", "$window", "$mdConstant", function($cacheFactory, $document, $timeout, $q, $window, $mdConstant) {
        var Util;
        function getNode(el) {
            return el[0] || el;
        }
        return Util = {
            now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now,
            clientRect: function(element, offsetParent, isOffsetRect) {
                var node = getNode(element);
                offsetParent = getNode(offsetParent || node.offsetParent || document.body);
                var nodeRect = node.getBoundingClientRect();
                var offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                };
                return {
                    left: nodeRect.left - offsetRect.left + offsetParent.scrollLeft,
                    top: nodeRect.top - offsetRect.top + offsetParent.scrollTop,
                    width: nodeRect.width,
                    height: nodeRect.height
                };
            },
            offsetRect: function(element, offsetParent) {
                return Util.clientRect(element, offsetParent, true);
            },
            floatingScrollbars: function() {
                if (this.floatingScrollbars.cached === undefined) {
                    var tempNode = angular.element('<div style="z-index: -1; position: absolute; height: 1px; overflow-y: scroll"><div style="height: 2px;"></div></div>');
                    $document[0].body.appendChild(tempNode[0]);
                    this.floatingScrollbars.cached = tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth;
                    tempNode.remove();
                }
                return this.floatingScrollbars.cached;
            },
            forceFocus: function(element) {
                var node = element[0] || element;
                document.addEventListener("click", function focusOnClick(ev) {
                    if (ev.target === node && ev.$focus) {
                        node.focus();
                        ev.stopImmediatePropagation();
                        ev.preventDefault();
                        node.removeEventListener("click", focusOnClick);
                    }
                }, true);
                var newEvent = document.createEvent("MouseEvents");
                newEvent.initMouseEvent("click", false, true, window, {}, 0, 0, 0, 0, false, false, false, false, 0, null);
                newEvent.$material = true;
                newEvent.$focus = true;
                node.dispatchEvent(newEvent);
            },
            transitionEndPromise: function(element, opts) {
                opts = opts || {};
                var deferred = $q.defer();
                element.on($mdConstant.CSS.TRANSITIONEND, finished);
                function finished(ev) {
                    if (!ev || ev.target === element[0]) {
                        element.off($mdConstant.CSS.TRANSITIONEND, finished);
                        deferred.resolve();
                    }
                }
                if (opts.timeout) $timeout(finished, opts.timeout);
                return deferred.promise;
            },
            fakeNgModel: function() {
                return {
                    $fake: true,
                    $setTouched: angular.noop,
                    $setViewValue: function(value) {
                        this.$viewValue = value;
                        this.$render(value);
                        this.$viewChangeListeners.forEach(function(cb) {
                            cb();
                        });
                    },
                    $isEmpty: function(value) {
                        return ("" + value).length === 0;
                    },
                    $parsers: [],
                    $formatters: [],
                    $viewChangeListeners: [],
                    $render: angular.noop
                };
            },
            debounce: function(func, wait, scope, invokeApply) {
                var timer;
                return function debounced() {
                    var context = scope, args = Array.prototype.slice.call(arguments);
                    $timeout.cancel(timer);
                    timer = $timeout(function() {
                        timer = undefined;
                        func.apply(context, args);
                    }, wait || 10, invokeApply);
                };
            },
            throttle: function throttle(func, delay) {
                var recent;
                return function throttled() {
                    var context = this;
                    var args = arguments;
                    var now = Util.now();
                    if (!recent || now - recent > delay) {
                        func.apply(context, args);
                        recent = now;
                    }
                };
            },
            time: function time(cb) {
                var start = Util.now();
                cb();
                return Util.now() - start;
            },
            nextUid: function() {
                var index = nextUniqueId.length;
                var digit;
                while (index) {
                    index--;
                    digit = nextUniqueId[index].charCodeAt(0);
                    if (digit == 57) {
                        nextUniqueId[index] = "A";
                        return nextUniqueId.join("");
                    }
                    if (digit == 90) {
                        nextUniqueId[index] = "0";
                    } else {
                        nextUniqueId[index] = String.fromCharCode(digit + 1);
                        return nextUniqueId.join("");
                    }
                }
                nextUniqueId.unshift("0");
                return nextUniqueId.join("");
            },
            disconnectScope: function disconnectScope(scope) {
                if (!scope) return;
                if (scope.$root === scope) return;
                if (scope.$$destroyed) return;
                var parent = scope.$parent;
                scope.$$disconnected = true;
                if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;
                if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;
                if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
                if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
                scope.$$nextSibling = scope.$$prevSibling = null;
            },
            reconnectScope: function reconnectScope(scope) {
                if (!scope) return;
                if (scope.$root === scope) return;
                if (!scope.$$disconnected) return;
                var child = scope;
                var parent = child.$parent;
                child.$$disconnected = false;
                child.$$prevSibling = parent.$$childTail;
                if (parent.$$childHead) {
                    parent.$$childTail.$$nextSibling = child;
                    parent.$$childTail = child;
                } else {
                    parent.$$childHead = parent.$$childTail = child;
                }
            },
            getClosest: function getClosest(el, tagName) {
                tagName = tagName.toUpperCase();
                do {
                    if (el.nodeName === tagName) {
                        return el;
                    }
                } while (el = el.parentNode);
                return null;
            }
        };
    } ]);
    angular.element.prototype.focus = angular.element.prototype.focus || function() {
        if (this.length) {
            this[0].focus();
        }
        return this;
    };
    angular.element.prototype.blur = angular.element.prototype.blur || function() {
        if (this.length) {
            this[0].blur();
        }
        return this;
    };
})();

(function() {
    "use strict";
    angular.module("material.core").service("$mdAria", AriaService);
    function AriaService($$rAF, $log, $window) {
        return {
            expect: expect,
            expectAsync: expectAsync,
            expectWithText: expectWithText
        };
        function expect(element, attrName, defaultValue) {
            var node = element[0];
            if (!node.hasAttribute(attrName) && !childHasAttribute(node, attrName)) {
                defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : "";
                if (defaultValue.length) {
                    element.attr(attrName, defaultValue);
                } else {
                    $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
                }
            }
        }
        function expectAsync(element, attrName, defaultValueGetter) {
            $$rAF(function() {
                expect(element, attrName, defaultValueGetter());
            });
        }
        function expectWithText(element, attrName) {
            expectAsync(element, attrName, function() {
                return getText(element);
            });
        }
        function getText(element) {
            return element.text().trim();
        }
        function childHasAttribute(node, attrName) {
            var hasChildren = node.hasChildNodes(), hasAttr = false;
            function isHidden(el) {
                var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
                return style.display === "none";
            }
            if (hasChildren) {
                var children = node.childNodes;
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child.nodeType === 1 && child.hasAttribute(attrName)) {
                        if (!isHidden(child)) {
                            hasAttr = true;
                        }
                    }
                }
            }
            return hasAttr;
        }
    }
    AriaService.$inject = [ "$$rAF", "$log", "$window" ];
})();

(function() {
    "use strict";
    angular.module("material.core").service("$mdCompiler", mdCompilerService);
    function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
        this.compile = function(options) {
            var templateUrl = options.templateUrl;
            var template = options.template || "";
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = options.resolve || {};
            var locals = options.locals || {};
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            angular.forEach(resolve, function(value, key) {
                if (angular.isString(value)) {
                    resolve[key] = $injector.get(value);
                } else {
                    resolve[key] = $injector.invoke(value);
                }
            });
            angular.extend(resolve, locals);
            if (templateUrl) {
                resolve.$template = $http.get(templateUrl, {
                    cache: $templateCache
                }).then(function(response) {
                    return response.data;
                });
            } else {
                resolve.$template = $q.when(template);
            }
            return $q.all(resolve).then(function(locals) {
                var template = transformTemplate(locals.$template);
                var element = options.element || angular.element("<div>").html(template.trim()).contents();
                var linkFn = $compile(element);
                return {
                    locals: locals,
                    element: element,
                    link: function link(scope) {
                        locals.$scope = scope;
                        if (controller) {
                            var ctrl = $controller(controller, locals);
                            if (bindToController) {
                                angular.extend(ctrl, locals);
                            }
                            element.data("$ngControllerController", ctrl);
                            element.children().data("$ngControllerController", ctrl);
                            if (controllerAs) {
                                scope[controllerAs] = ctrl;
                            }
                        }
                        return linkFn(scope);
                    }
                };
            });
        };
    }
    mdCompilerService.$inject = [ "$q", "$http", "$injector", "$compile", "$controller", "$templateCache" ];
})();

(function() {
    "use strict";
    var START_EVENTS = "mousedown touchstart pointerdown";
    var MOVE_EVENTS = "mousemove touchmove pointermove";
    var END_EVENTS = "mouseup mouseleave touchend touchcancel pointerup pointercancel";
    var HANDLERS;
    document.contains || (document.contains = function(node) {
        return document.body.contains(node);
    });
    var userAgent = navigator.userAgent || navigator.vendor || window.opera;
    var isIos = userAgent.match(/iPad/i) || userAgent.match(/iPhone/i) || userAgent.match(/iPod/i);
    var isAndroid = userAgent.match(/Android/i);
    var shouldHijackClicks = isIos || isAndroid;
    if (shouldHijackClicks) {
        document.addEventListener("click", function(ev) {
            var isKeyClick = ev.clientX === 0 && ev.clientY === 0;
            if (window.jQuery || isKeyClick || ev.$material) return;
            ev.preventDefault();
            ev.stopPropagation();
        }, true);
    }
    angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on("$$mdGestureReset", function() {
        lastPointer = pointer = null;
    });
    var pointer, lastPointer;
    function runHandlers(handlerEvent, event) {
        var handler;
        for (var handlerName in HANDLERS) {
            handler = HANDLERS[handlerName];
            if (handlerEvent === "start") {
                handler.cancel();
            }
            handler[handlerEvent](event, pointer);
        }
    }
    function gestureStart(ev) {
        if (pointer) return;
        var now = +Date.now();
        if (lastPointer && !typesMatch(ev, lastPointer) && now - lastPointer.endTime < 1500) {
            return;
        }
        pointer = makeStartPointer(ev);
        runHandlers("start", ev);
    }
    function gestureMove(ev) {
        if (!pointer || !typesMatch(ev, pointer)) return;
        updatePointerState(ev, pointer);
        runHandlers("move", ev);
    }
    function gestureEnd(ev) {
        if (!pointer || !typesMatch(ev, pointer)) return;
        updatePointerState(ev, pointer);
        pointer.endTime = +Date.now();
        runHandlers("end", ev);
        lastPointer = pointer;
        pointer = null;
    }
    function typesMatch(ev, pointer) {
        return ev && pointer && ev.type.charAt(0) === pointer.type;
    }
    function getEventPoint(ev) {
        ev = ev.originalEvent || ev;
        return ev.touches && ev.touches[0] || ev.changedTouches && ev.changedTouches[0] || ev;
    }
    function updatePointerState(ev, pointer) {
        var point = getEventPoint(ev);
        var x = pointer.x = point.pageX;
        var y = pointer.y = point.pageY;
        pointer.distanceX = x - pointer.startX;
        pointer.distanceY = y - pointer.startY;
        pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
        pointer.directionX = pointer.distanceX > 0 ? "right" : pointer.distanceX < 0 ? "left" : "";
        pointer.directionY = pointer.distanceY > 0 ? "up" : pointer.distanceY < 0 ? "down" : "";
        pointer.duration = +Date.now() - pointer.startTime;
        pointer.velocityX = pointer.distanceX / pointer.duration;
        pointer.velocityY = pointer.distanceY / pointer.duration;
    }
    function makeStartPointer(ev) {
        var point = getEventPoint(ev);
        var startPointer = {
            startTime: +Date.now(),
            target: ev.target,
            type: ev.type.charAt(0)
        };
        startPointer.startX = startPointer.x = point.pageX;
        startPointer.startY = startPointer.y = point.pageY;
        return startPointer;
    }
    angular.module("material.core").run([ "$mdGesture", function($mdGesture) {} ]).factory("$mdGesture", [ "$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
        HANDLERS = {};
        if (shouldHijackClicks) {
            addHandler("click", {
                options: {
                    maxDistance: 6
                },
                onEnd: function(ev, pointer) {
                    if (pointer.distance < this.state.options.maxDistance) {
                        this.dispatchEvent(ev, "click");
                    }
                }
            });
        }
        addHandler("press", {
            onStart: function(ev, pointer) {
                this.dispatchEvent(ev, "$md.pressdown");
            },
            onEnd: function(ev, pointer) {
                this.dispatchEvent(ev, "$md.pressup");
            }
        });
        addHandler("hold", {
            options: {
                maxDistance: 6,
                delay: 500
            },
            onCancel: function() {
                $timeout.cancel(this.state.timeout);
            },
            onStart: function(ev, pointer) {
                if (!this.state.registeredParent) return this.cancel();
                this.state.pos = {
                    x: pointer.x,
                    y: pointer.y
                };
                this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {
                    this.dispatchEvent(ev, "$md.hold");
                    this.cancel();
                }), this.state.options.delay, false);
            },
            onMove: function(ev, pointer) {
                ev.preventDefault();
                var dx = this.state.pos.x - pointer.x;
                var dy = this.state.pos.y - pointer.y;
                if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {
                    this.cancel();
                }
            },
            onEnd: function() {
                this.onCancel();
            }
        });
        addHandler("drag", {
            options: {
                minDistance: 6,
                horizontal: true
            },
            onStart: function(ev) {
                if (!this.state.registeredParent) this.cancel();
            },
            onMove: function(ev, pointer) {
                var shouldStartDrag, shouldCancel;
                ev.preventDefault();
                if (!this.state.dragPointer) {
                    if (this.state.options.horizontal) {
                        shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
                        shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * 1.5;
                    } else {
                        shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
                        shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * 1.5;
                    }
                    if (shouldStartDrag) {
                        this.state.dragPointer = makeStartPointer(ev);
                        updatePointerState(ev, this.state.dragPointer);
                        this.dispatchEvent(ev, "$md.dragstart", this.state.dragPointer);
                    } else if (shouldCancel) {
                        this.cancel();
                    }
                } else {
                    this.dispatchDragMove(ev);
                }
            },
            dispatchDragMove: $$rAF.throttle(function(ev) {
                if (this.state.isRunning) {
                    updatePointerState(ev, this.state.dragPointer);
                    this.dispatchEvent(ev, "$md.drag", this.state.dragPointer);
                }
            }),
            onEnd: function(ev, pointer) {
                if (this.state.dragPointer) {
                    updatePointerState(ev, this.state.dragPointer);
                    this.dispatchEvent(ev, "$md.dragend", this.state.dragPointer);
                }
            }
        });
        addHandler("swipe", {
            options: {
                minVelocity: .65,
                minDistance: 10
            },
            onEnd: function(ev, pointer) {
                if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {
                    var eventType = pointer.directionX == "left" ? "$md.swipeleft" : "$md.swiperight";
                    this.dispatchEvent(ev, eventType);
                }
            }
        });
        var self;
        return self = {
            handler: addHandler,
            register: register
        };
        function addHandler(name, definition) {
            var handler = new $$MdGestureHandler(name);
            angular.extend(handler, definition);
            HANDLERS[name] = handler;
            return self;
        }
        function register(element, handlerName, options) {
            var handler = HANDLERS[handlerName.replace(/^\$md./, "")];
            if (!handler) {
                throw new Error("Failed to register element with handler " + handlerName + ". " + "Available handlers: " + Object.keys(HANDLERS).join(", "));
            }
            return handler.registerElement(element, options);
        }
    } ]).factory("$$MdGestureHandler", [ "$$rAF", function($$rAF) {
        function GestureHandler(name) {
            this.name = name;
            this.state = {};
        }
        GestureHandler.prototype = {
            onStart: angular.noop,
            onMove: angular.noop,
            onEnd: angular.noop,
            onCancel: angular.noop,
            options: {},
            dispatchEvent: typeof window.jQuery !== "undefined" && angular.element === window.jQuery ? jQueryDispatchEvent : nativeDispatchEvent,
            start: function(ev, pointer) {
                if (this.state.isRunning) return;
                var parentTarget = this.getNearestParent(ev.target);
                var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
                this.state = {
                    isRunning: true,
                    options: angular.extend({}, this.options, parentTargetOptions),
                    registeredParent: parentTarget
                };
                this.onStart(ev, pointer);
            },
            move: function(ev, pointer) {
                if (!this.state.isRunning) return;
                this.onMove(ev, pointer);
            },
            end: function(ev, pointer) {
                if (!this.state.isRunning) return;
                this.onEnd(ev, pointer);
                this.state.isRunning = false;
            },
            cancel: function(ev, pointer) {
                this.onCancel(ev, pointer);
                this.state = {};
            },
            getNearestParent: function(node) {
                var current = node;
                while (current) {
                    if ((current.$mdGesture || {})[this.name]) {
                        return current;
                    }
                    current = current.parentNode;
                }
            },
            registerElement: function(element, options) {
                var self = this;
                element[0].$mdGesture = element[0].$mdGesture || {};
                element[0].$mdGesture[this.name] = options || {};
                element.on("$destroy", onDestroy);
                return onDestroy;
                function onDestroy() {
                    delete element[0].$mdGesture[self.name];
                    element.off("$destroy", onDestroy);
                }
            }
        };
        function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj = new angular.element.Event(eventType);
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            angular.extend(eventObj, {
                clientX: eventPointer.x,
                clientY: eventPointer.y,
                screenX: eventPointer.x,
                screenY: eventPointer.y,
                pageX: eventPointer.x,
                pageY: eventPointer.y,
                ctrlKey: srcEvent.ctrlKey,
                altKey: srcEvent.altKey,
                shiftKey: srcEvent.shiftKey,
                metaKey: srcEvent.metaKey
            });
            angular.element(eventPointer.target).trigger(eventObj);
        }
        function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
            eventPointer = eventPointer || pointer;
            var eventObj;
            if (eventType === "click") {
                eventObj = document.createEvent("MouseEvents");
                eventObj.initMouseEvent("click", true, true, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null);
            } else {
                eventObj = document.createEvent("CustomEvent");
                eventObj.initCustomEvent(eventType, true, true, {});
            }
            eventObj.$material = true;
            eventObj.pointer = eventPointer;
            eventObj.srcEvent = srcEvent;
            eventPointer.target.dispatchEvent(eventObj);
        }
        return GestureHandler;
    } ]);
})();

(function() {
    "use strict";
    angular.module("material.core").provider("$$interimElement", InterimElementProvider);
    function InterimElementProvider() {
        createInterimElementProvider.$get = InterimElementFactory;
        InterimElementFactory.$inject = [ "$document", "$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$interpolate", "$mdCompiler", "$mdTheming" ];
        return createInterimElementProvider;
        function createInterimElementProvider(interimFactoryName) {
            var EXPOSED_METHODS = [ "onHide", "onShow", "onRemove" ];
            var customMethods = {};
            var providerConfig = {
                presets: {}
            };
            var provider = {
                setDefaults: setDefaults,
                addPreset: addPreset,
                addMethod: addMethod,
                $get: factory
            };
            provider.addPreset("build", {
                methods: [ "controller", "controllerAs", "resolve", "template", "templateUrl", "themable", "transformTemplate", "parent" ]
            });
            factory.$inject = [ "$$interimElement", "$animate", "$injector" ];
            return provider;
            function setDefaults(definition) {
                providerConfig.optionsFactory = definition.options;
                providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
                return provider;
            }
            function addMethod(name, fn) {
                customMethods[name] = fn;
                return provider;
            }
            function addPreset(name, definition) {
                definition = definition || {};
                definition.methods = definition.methods || [];
                definition.options = definition.options || function() {
                    return {};
                };
                if (/^cancel|hide|show$/.test(name)) {
                    throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
                }
                if (definition.methods.indexOf("_options") > -1) {
                    throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
                }
                providerConfig.presets[name] = {
                    methods: definition.methods.concat(EXPOSED_METHODS),
                    optionsFactory: definition.options,
                    argOption: definition.argOption
                };
                return provider;
            }
            function factory($$interimElement, $animate, $injector) {
                var defaultMethods;
                var defaultOptions;
                var interimElementService = $$interimElement();
                var publicService = {
                    hide: interimElementService.hide,
                    cancel: interimElementService.cancel,
                    show: showInterimElement
                };
                defaultMethods = providerConfig.methods || [];
                defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
                angular.forEach(customMethods, function(fn, name) {
                    publicService[name] = fn;
                });
                angular.forEach(providerConfig.presets, function(definition, name) {
                    var presetDefaults = invokeFactory(definition.optionsFactory, {});
                    var presetMethods = (definition.methods || []).concat(defaultMethods);
                    angular.extend(presetDefaults, {
                        $type: name
                    });
                    function Preset(opts) {
                        this._options = angular.extend({}, presetDefaults, opts);
                    }
                    angular.forEach(presetMethods, function(name) {
                        Preset.prototype[name] = function(value) {
                            this._options[name] = value;
                            return this;
                        };
                    });
                    if (definition.argOption) {
                        var methodName = "show" + name.charAt(0).toUpperCase() + name.slice(1);
                        publicService[methodName] = function(arg) {
                            var config = publicService[name](arg);
                            return publicService.show(config);
                        };
                    }
                    publicService[name] = function(arg) {
                        if (arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg)) {
                            return new Preset()[definition.argOption](arg);
                        } else {
                            return new Preset(arg);
                        }
                    };
                });
                return publicService;
                function showInterimElement(opts) {
                    if (opts && opts._options) opts = opts._options;
                    return interimElementService.show(angular.extend({}, defaultOptions, opts));
                }
                function invokeFactory(factory, defaultVal) {
                    var locals = {};
                    locals[interimFactoryName] = publicService;
                    return $injector.invoke(factory || function() {
                        return defaultVal;
                    }, {}, locals);
                }
            }
        }
        function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate, $interpolate, $mdCompiler, $mdTheming) {
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), usesStandardSymbols = startSymbol === "{{" && endSymbol === "}}", processTemplate = usesStandardSymbols ? angular.identity : replaceInterpolationSymbols;
            return function createInterimElementService() {
                var stack = [];
                var service;
                return service = {
                    show: show,
                    hide: hide,
                    cancel: cancel
                };
                function show(options) {
                    if (stack.length) {
                        return service.cancel().then(function() {
                            return show(options);
                        });
                    } else {
                        var interimElement = new InterimElement(options);
                        stack.push(interimElement);
                        return interimElement.show().then(function() {
                            return interimElement.deferred.promise;
                        });
                    }
                }
                function hide(response) {
                    var interimElement = stack.shift();
                    return interimElement && interimElement.remove().then(function() {
                        interimElement.deferred.resolve(response);
                    });
                }
                function cancel(reason) {
                    var interimElement = stack.shift();
                    return $q.when(interimElement && interimElement.remove().then(function() {
                        interimElement.deferred.reject(reason);
                    }));
                }
                function InterimElement(options) {
                    var self;
                    var hideTimeout, element, showDone, removeDone;
                    options = options || {};
                    options = angular.extend({
                        preserveScope: false,
                        scope: options.scope || $rootScope.$new(options.isolateScope),
                        onShow: function(scope, element, options) {
                            return $animate.enter(element, options.parent);
                        },
                        onRemove: function(scope, element, options) {
                            return element && $animate.leave(element) || $q.when();
                        }
                    }, options);
                    if (options.template) {
                        options.template = processTemplate(options.template);
                    }
                    return self = {
                        options: options,
                        deferred: $q.defer(),
                        show: function() {
                            var compilePromise;
                            if (options.skipCompile) {
                                compilePromise = $q(function(resolve) {
                                    resolve({
                                        locals: {},
                                        link: function() {
                                            return options.element;
                                        }
                                    });
                                });
                            } else {
                                compilePromise = $mdCompiler.compile(options);
                            }
                            return showDone = compilePromise.then(function(compileData) {
                                angular.extend(compileData.locals, self.options);
                                element = compileData.link(options.scope);
                                if (angular.isFunction(options.parent)) {
                                    options.parent = options.parent(options.scope, element, options);
                                } else if (angular.isString(options.parent)) {
                                    options.parent = angular.element($document[0].querySelector(options.parent));
                                }
                                if (!(options.parent || {}).length) {
                                    options.parent = $rootElement.find("body");
                                    if (!options.parent.length) options.parent = $rootElement;
                                }
                                if (options.themable) $mdTheming(element);
                                var ret = options.onShow(options.scope, element, options);
                                return $q.when(ret).then(function() {
                                    (options.onComplete || angular.noop)(options.scope, element, options);
                                    startHideTimeout();
                                });
                                function startHideTimeout() {
                                    if (options.hideDelay) {
                                        hideTimeout = $timeout(service.cancel, options.hideDelay);
                                    }
                                }
                            }, function(reason) {
                                showDone = true;
                                self.deferred.reject(reason);
                            });
                        },
                        cancelTimeout: function() {
                            if (hideTimeout) {
                                $timeout.cancel(hideTimeout);
                                hideTimeout = undefined;
                            }
                        },
                        remove: function() {
                            self.cancelTimeout();
                            return removeDone = $q.when(showDone).then(function() {
                                var ret = element ? options.onRemove(options.scope, element, options) : true;
                                return $q.when(ret).then(function() {
                                    if (!options.preserveScope) options.scope.$destroy();
                                    removeDone = true;
                                });
                            });
                        }
                    };
                }
            };
            function replaceInterpolationSymbols(text) {
                if (!text || !angular.isString(text)) return text;
                return text.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }
        }
    }
})();

(function() {
    "use strict";
    angular.module("material.core").factory("$mdComponentRegistry", ComponentRegistry);
    function ComponentRegistry($log, $q) {
        var self;
        var instances = [];
        var pendings = {};
        return self = {
            notFoundError: function(handle) {
                $log.error("No instance found for handle", handle);
            },
            getInstances: function() {
                return instances;
            },
            get: function(handle) {
                if (!isValidID(handle)) return null;
                var i, j, instance;
                for (i = 0, j = instances.length; i < j; i++) {
                    instance = instances[i];
                    if (instance.$$mdHandle === handle) {
                        return instance;
                    }
                }
                return null;
            },
            register: function(instance, handle) {
                if (!handle) return angular.noop;
                instance.$$mdHandle = handle;
                instances.push(instance);
                resolveWhen();
                return deregister;
                function deregister() {
                    var index = instances.indexOf(instance);
                    if (index !== -1) {
                        instances.splice(index, 1);
                    }
                }
                function resolveWhen() {
                    var dfd = pendings[handle];
                    if (dfd) {
                        dfd.resolve(instance);
                        delete pendings[handle];
                    }
                }
            },
            when: function(handle) {
                if (isValidID(handle)) {
                    var deferred = $q.defer();
                    var instance = self.get(handle);
                    if (instance) {
                        deferred.resolve(instance);
                    } else {
                        pendings[handle] = deferred;
                    }
                    return deferred.promise;
                }
                return $q.reject("Invalid `md-component-id` value.");
            }
        };
        function isValidID(handle) {
            return handle && handle !== "";
        }
    }
    ComponentRegistry.$inject = [ "$log", "$q" ];
})();

(function() {
    "use strict";
    angular.module("material.core").factory("$mdInkRipple", InkRippleService).directive("mdInkRipple", InkRippleDirective).directive("mdNoInk", attrNoDirective()).directive("mdNoBar", attrNoDirective()).directive("mdNoStretch", attrNoDirective());
    function InkRippleDirective($mdInkRipple) {
        return {
            controller: angular.noop,
            link: function(scope, element, attr) {
                if (attr.hasOwnProperty("mdInkRippleCheckbox")) {
                    $mdInkRipple.attachCheckboxBehavior(scope, element);
                } else {
                    $mdInkRipple.attachButtonBehavior(scope, element);
                }
            }
        };
    }
    InkRippleDirective.$inject = [ "$mdInkRipple" ];
    function InkRippleService($window, $timeout) {
        return {
            attachButtonBehavior: attachButtonBehavior,
            attachCheckboxBehavior: attachCheckboxBehavior,
            attachTabBehavior: attachTabBehavior,
            attach: attach
        };
        function attachButtonBehavior(scope, element, options) {
            return attach(scope, element, angular.extend({
                fullRipple: true,
                isMenuItem: element.hasClass("md-menu-item"),
                center: false,
                dimBackground: true
            }, options));
        }
        function attachCheckboxBehavior(scope, element, options) {
            return attach(scope, element, angular.extend({
                center: true,
                dimBackground: false,
                fitRipple: true
            }, options));
        }
        function attachTabBehavior(scope, element, options) {
            return attach(scope, element, angular.extend({
                center: false,
                dimBackground: true,
                outline: false,
                rippleSize: "full"
            }, options));
        }
        function attach(scope, element, options) {
            if (element.controller("mdNoInk")) return angular.noop;
            options = angular.extend({
                colorElement: element,
                mousedown: true,
                hover: true,
                focus: true,
                center: false,
                mousedownPauseTime: 150,
                dimBackground: false,
                outline: false,
                fullRipple: true,
                isMenuItem: false,
                fitRipple: false
            }, options);
            var rippleSize, controller = element.controller("mdInkRipple") || {}, counter = 0, ripples = [], states = [], isActiveExpr = element.attr("md-highlight"), isActive = false, isHeld = false, node = element[0], rippleSizeSetting = element.attr("md-ripple-size"), color = parseColor(element.attr("md-ink-ripple")) || parseColor($window.getComputedStyle(options.colorElement[0]).color || "rgb(0, 0, 0)");
            switch (rippleSizeSetting) {
              case "full":
                options.fullRipple = true;
                break;

              case "partial":
                options.fullRipple = false;
                break;
            }
            if (options.mousedown) {
                element.on("$md.pressdown", onPressDown).on("$md.pressup", onPressUp);
            }
            controller.createRipple = createRipple;
            if (isActiveExpr) {
                scope.$watch(isActiveExpr, function watchActive(newValue) {
                    isActive = newValue;
                    if (isActive && !ripples.length) {
                        $timeout(function() {
                            createRipple(0, 0);
                        }, 0, false);
                    }
                    angular.forEach(ripples, updateElement);
                });
            }
            return function detach() {
                element.off("$md.pressdown", onPressDown).off("$md.pressup", onPressUp);
                getRippleContainer().remove();
            };
            function getRippleContainer() {
                var container = element.data("$mdRippleContainer");
                if (container) return container;
                container = angular.element('<div class="md-ripple-container">');
                element.append(container);
                element.data("$mdRippleContainer", container);
                return container;
            }
            function parseColor(color) {
                if (!color) return;
                if (color.indexOf("rgba") === 0) return color.replace(/\d?\.?\d*\s*\)\s*$/, "0.1)");
                if (color.indexOf("rgb") === 0) return rgbToRGBA(color);
                if (color.indexOf("#") === 0) return hexToRGBA(color);
                function hexToRGBA(color) {
                    var hex = color.charAt(0) === "#" ? color.substr(1) : color, dig = hex.length / 3, red = hex.substr(0, dig), grn = hex.substr(dig, dig), blu = hex.substr(dig * 2);
                    if (dig === 1) {
                        red += red;
                        grn += grn;
                        blu += blu;
                    }
                    return "rgba(" + parseInt(red, 16) + "," + parseInt(grn, 16) + "," + parseInt(blu, 16) + ",0.1)";
                }
                function rgbToRGBA(color) {
                    return color.replace(")", ", 0.1)").replace("(", "a(");
                }
            }
            function removeElement(elem, wait) {
                ripples.splice(ripples.indexOf(elem), 1);
                if (ripples.length === 0) {
                    getRippleContainer().css({
                        backgroundColor: ""
                    });
                }
                $timeout(function() {
                    elem.remove();
                }, wait, false);
            }
            function updateElement(elem) {
                var index = ripples.indexOf(elem), state = states[index] || {}, elemIsActive = ripples.length > 1 ? false : isActive, elemIsHeld = ripples.length > 1 ? false : isHeld;
                if (elemIsActive || state.animating || elemIsHeld) {
                    elem.addClass("md-ripple-visible");
                } else if (elem) {
                    elem.removeClass("md-ripple-visible");
                    if (options.outline) {
                        elem.css({
                            width: rippleSize + "px",
                            height: rippleSize + "px",
                            marginLeft: rippleSize * -1 + "px",
                            marginTop: rippleSize * -1 + "px"
                        });
                    }
                    removeElement(elem, options.outline ? 450 : 650);
                }
            }
            function createRipple(left, top) {
                color = parseColor(element.attr("md-ink-ripple")) || parseColor($window.getComputedStyle(options.colorElement[0]).color || "rgb(0, 0, 0)");
                var container = getRippleContainer(), size = getRippleSize(left, top), css = getRippleCss(size, left, top), elem = getRippleElement(css), index = ripples.indexOf(elem), state = states[index] || {};
                rippleSize = size;
                state.animating = true;
                $timeout(function() {
                    if (options.dimBackground) {
                        container.css({
                            backgroundColor: color
                        });
                    }
                    elem.addClass("md-ripple-placed md-ripple-scaled");
                    if (options.outline) {
                        elem.css({
                            borderWidth: size * .5 + "px",
                            marginLeft: size * -.5 + "px",
                            marginTop: size * -.5 + "px"
                        });
                    } else {
                        elem.css({
                            left: "50%",
                            top: "50%"
                        });
                    }
                    updateElement(elem);
                    $timeout(function() {
                        state.animating = false;
                        updateElement(elem);
                    }, options.outline ? 450 : 225, false);
                }, 0, false);
                return elem;
                function getRippleElement(css) {
                    var elem = angular.element('<div class="md-ripple" data-counter="' + counter++ + '">');
                    ripples.unshift(elem);
                    states.unshift({
                        animating: true
                    });
                    container.append(elem);
                    css && elem.css(css);
                    return elem;
                }
                function getRippleSize(left, top) {
                    var width = container.prop("offsetWidth"), height = container.prop("offsetHeight"), multiplier, size, rect;
                    if (options.isMenuItem) {
                        size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
                    } else if (options.outline) {
                        rect = node.getBoundingClientRect();
                        left -= rect.left;
                        top -= rect.top;
                        width = Math.max(left, width - left);
                        height = Math.max(top, height - top);
                        size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
                    } else {
                        multiplier = options.fullRipple ? 1.1 : .8;
                        size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) * multiplier;
                        if (options.fitRipple) {
                            size = Math.min(height, width, size);
                        }
                    }
                    return size;
                }
                function getRippleCss(size, left, top) {
                    var rect, css = {
                        backgroundColor: rgbaToRGB(color),
                        borderColor: rgbaToRGB(color),
                        width: size + "px",
                        height: size + "px"
                    };
                    if (options.outline) {
                        css.width = 0;
                        css.height = 0;
                    } else {
                        css.marginLeft = css.marginTop = size * -.5 + "px";
                    }
                    if (options.center) {
                        css.left = css.top = "50%";
                    } else {
                        rect = node.getBoundingClientRect();
                        css.left = Math.round((left - rect.left) / container.prop("offsetWidth") * 100) + "%";
                        css.top = Math.round((top - rect.top) / container.prop("offsetHeight") * 100) + "%";
                    }
                    return css;
                    function rgbaToRGB(color) {
                        return color.replace("rgba", "rgb").replace(/,[^\),]+\)/, ")");
                    }
                }
            }
            function onPressDown(ev) {
                if (!isRippleAllowed()) return;
                createRipple(ev.pointer.x, ev.pointer.y);
                isHeld = true;
            }
            function onPressUp() {
                isHeld = false;
                var ripple = ripples[ripples.length - 1];
                $timeout(function() {
                    updateElement(ripple);
                }, 0, false);
            }
            function isRippleAllowed() {
                var parent = node.parentNode;
                var grandparent = parent && parent.parentNode;
                var ancestor = grandparent && grandparent.parentNode;
                return !isDisabled(node) && !isDisabled(parent) && !isDisabled(grandparent) && !isDisabled(ancestor);
                function isDisabled(elem) {
                    return elem && elem.hasAttribute && elem.hasAttribute("disabled");
                }
            }
        }
    }
    InkRippleService.$inject = [ "$window", "$timeout" ];
    function attrNoDirective() {
        return function() {
            return {
                controller: angular.noop
            };
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.core.theming.palette", []).constant("$mdColorPalette", {
        red: {
            "50": "#ffebee",
            "100": "#ffcdd2",
            "200": "#ef9a9a",
            "300": "#e57373",
            "400": "#ef5350",
            "500": "#f44336",
            "600": "#e53935",
            "700": "#d32f2f",
            "800": "#c62828",
            "900": "#b71c1c",
            A100: "#ff8a80",
            A200: "#ff5252",
            A400: "#ff1744",
            A700: "#d50000",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300 400 A100",
            contrastStrongLightColors: "500 600 700 A200 A400 A700"
        },
        pink: {
            "50": "#fce4ec",
            "100": "#f8bbd0",
            "200": "#f48fb1",
            "300": "#f06292",
            "400": "#ec407a",
            "500": "#e91e63",
            "600": "#d81b60",
            "700": "#c2185b",
            "800": "#ad1457",
            "900": "#880e4f",
            A100: "#ff80ab",
            A200: "#ff4081",
            A400: "#f50057",
            A700: "#c51162",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300 400 A100",
            contrastStrongLightColors: "500 600 A200 A400 A700"
        },
        purple: {
            "50": "#f3e5f5",
            "100": "#e1bee7",
            "200": "#ce93d8",
            "300": "#ba68c8",
            "400": "#ab47bc",
            "500": "#9c27b0",
            "600": "#8e24aa",
            "700": "#7b1fa2",
            "800": "#6a1b9a",
            "900": "#4a148c",
            A100: "#ea80fc",
            A200: "#e040fb",
            A400: "#d500f9",
            A700: "#aa00ff",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 A100",
            contrastStrongLightColors: "300 400 A200 A400 A700"
        },
        "deep-purple": {
            "50": "#ede7f6",
            "100": "#d1c4e9",
            "200": "#b39ddb",
            "300": "#9575cd",
            "400": "#7e57c2",
            "500": "#673ab7",
            "600": "#5e35b1",
            "700": "#512da8",
            "800": "#4527a0",
            "900": "#311b92",
            A100: "#b388ff",
            A200: "#7c4dff",
            A400: "#651fff",
            A700: "#6200ea",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 A100",
            contrastStrongLightColors: "300 400 A200"
        },
        indigo: {
            "50": "#e8eaf6",
            "100": "#c5cae9",
            "200": "#9fa8da",
            "300": "#7986cb",
            "400": "#5c6bc0",
            "500": "#3f51b5",
            "600": "#3949ab",
            "700": "#303f9f",
            "800": "#283593",
            "900": "#1a237e",
            A100: "#8c9eff",
            A200: "#536dfe",
            A400: "#3d5afe",
            A700: "#304ffe",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 A100",
            contrastStrongLightColors: "300 400 A200 A400"
        },
        blue: {
            "50": "#e3f2fd",
            "100": "#bbdefb",
            "200": "#90caf9",
            "300": "#64b5f6",
            "400": "#42a5f5",
            "500": "#2196f3",
            "600": "#1e88e5",
            "700": "#1976d2",
            "800": "#1565c0",
            "900": "#0d47a1",
            A100: "#82b1ff",
            A200: "#448aff",
            A400: "#2979ff",
            A700: "#2962ff",
            contrastDefaultColor: "light",
            contrastDarkColors: "100 200 300 400 A100",
            contrastStrongLightColors: "500 600 700 A200 A400 A700"
        },
        "light-blue": {
            "50": "#e1f5fe",
            "100": "#b3e5fc",
            "200": "#81d4fa",
            "300": "#4fc3f7",
            "400": "#29b6f6",
            "500": "#03a9f4",
            "600": "#039be5",
            "700": "#0288d1",
            "800": "#0277bd",
            "900": "#01579b",
            A100: "#80d8ff",
            A200: "#40c4ff",
            A400: "#00b0ff",
            A700: "#0091ea",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900 A700",
            contrastStrongLightColors: "500 600 700 800 A700"
        },
        cyan: {
            "50": "#e0f7fa",
            "100": "#b2ebf2",
            "200": "#80deea",
            "300": "#4dd0e1",
            "400": "#26c6da",
            "500": "#00bcd4",
            "600": "#00acc1",
            "700": "#0097a7",
            "800": "#00838f",
            "900": "#006064",
            A100: "#84ffff",
            A200: "#18ffff",
            A400: "#00e5ff",
            A700: "#00b8d4",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900",
            contrastStrongLightColors: "500 600 700 800"
        },
        teal: {
            "50": "#e0f2f1",
            "100": "#b2dfdb",
            "200": "#80cbc4",
            "300": "#4db6ac",
            "400": "#26a69a",
            "500": "#009688",
            "600": "#00897b",
            "700": "#00796b",
            "800": "#00695c",
            "900": "#004d40",
            A100: "#a7ffeb",
            A200: "#64ffda",
            A400: "#1de9b6",
            A700: "#00bfa5",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900",
            contrastStrongLightColors: "500 600 700"
        },
        green: {
            "50": "#e8f5e9",
            "100": "#c8e6c9",
            "200": "#a5d6a7",
            "300": "#81c784",
            "400": "#66bb6a",
            "500": "#4caf50",
            "600": "#43a047",
            "700": "#388e3c",
            "800": "#2e7d32",
            "900": "#1b5e20",
            A100: "#b9f6ca",
            A200: "#69f0ae",
            A400: "#00e676",
            A700: "#00c853",
            contrastDefaultColor: "dark",
            contrastLightColors: "500 600 700 800 900",
            contrastStrongLightColors: "500 600 700"
        },
        "light-green": {
            "50": "#f1f8e9",
            "100": "#dcedc8",
            "200": "#c5e1a5",
            "300": "#aed581",
            "400": "#9ccc65",
            "500": "#8bc34a",
            "600": "#7cb342",
            "700": "#689f38",
            "800": "#558b2f",
            "900": "#33691e",
            A100: "#ccff90",
            A200: "#b2ff59",
            A400: "#76ff03",
            A700: "#64dd17",
            contrastDefaultColor: "dark",
            contrastLightColors: "800 900",
            contrastStrongLightColors: "800 900"
        },
        lime: {
            "50": "#f9fbe7",
            "100": "#f0f4c3",
            "200": "#e6ee9c",
            "300": "#dce775",
            "400": "#d4e157",
            "500": "#cddc39",
            "600": "#c0ca33",
            "700": "#afb42b",
            "800": "#9e9d24",
            "900": "#827717",
            A100: "#f4ff81",
            A200: "#eeff41",
            A400: "#c6ff00",
            A700: "#aeea00",
            contrastDefaultColor: "dark",
            contrastLightColors: "900",
            contrastStrongLightColors: "900"
        },
        yellow: {
            "50": "#fffde7",
            "100": "#fff9c4",
            "200": "#fff59d",
            "300": "#fff176",
            "400": "#ffee58",
            "500": "#ffeb3b",
            "600": "#fdd835",
            "700": "#fbc02d",
            "800": "#f9a825",
            "900": "#f57f17",
            A100: "#ffff8d",
            A200: "#ffff00",
            A400: "#ffea00",
            A700: "#ffd600",
            contrastDefaultColor: "dark"
        },
        amber: {
            "50": "#fff8e1",
            "100": "#ffecb3",
            "200": "#ffe082",
            "300": "#ffd54f",
            "400": "#ffca28",
            "500": "#ffc107",
            "600": "#ffb300",
            "700": "#ffa000",
            "800": "#ff8f00",
            "900": "#ff6f00",
            A100: "#ffe57f",
            A200: "#ffd740",
            A400: "#ffc400",
            A700: "#ffab00",
            contrastDefaultColor: "dark"
        },
        orange: {
            "50": "#fff3e0",
            "100": "#ffe0b2",
            "200": "#ffcc80",
            "300": "#ffb74d",
            "400": "#ffa726",
            "500": "#ff9800",
            "600": "#fb8c00",
            "700": "#f57c00",
            "800": "#ef6c00",
            "900": "#e65100",
            A100: "#ffd180",
            A200: "#ffab40",
            A400: "#ff9100",
            A700: "#ff6d00",
            contrastDefaultColor: "dark",
            contrastLightColors: "800 900",
            contrastStrongLightColors: "800 900"
        },
        "deep-orange": {
            "50": "#fbe9e7",
            "100": "#ffccbc",
            "200": "#ffab91",
            "300": "#ff8a65",
            "400": "#ff7043",
            "500": "#ff5722",
            "600": "#f4511e",
            "700": "#e64a19",
            "800": "#d84315",
            "900": "#bf360c",
            A100: "#ff9e80",
            A200: "#ff6e40",
            A400: "#ff3d00",
            A700: "#dd2c00",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300 400 A100 A200",
            contrastStrongLightColors: "500 600 700 800 900 A400 A700"
        },
        brown: {
            "50": "#efebe9",
            "100": "#d7ccc8",
            "200": "#bcaaa4",
            "300": "#a1887f",
            "400": "#8d6e63",
            "500": "#795548",
            "600": "#6d4c41",
            "700": "#5d4037",
            "800": "#4e342e",
            "900": "#3e2723",
            A100: "#d7ccc8",
            A200: "#bcaaa4",
            A400: "#8d6e63",
            A700: "#5d4037",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200",
            contrastStrongLightColors: "300 400"
        },
        grey: {
            "0": "#ffffff",
            "50": "#fafafa",
            "100": "#f5f5f5",
            "200": "#eeeeee",
            "300": "#e0e0e0",
            "400": "#bdbdbd",
            "500": "#9e9e9e",
            "600": "#757575",
            "700": "#616161",
            "800": "#424242",
            "900": "#212121",
            "1000": "#000000",
            A100: "#ffffff",
            A200: "#eeeeee",
            A400: "#bdbdbd",
            A700: "#616161",
            contrastDefaultColor: "dark",
            contrastLightColors: "600 700 800 900"
        },
        "blue-grey": {
            "50": "#eceff1",
            "100": "#cfd8dc",
            "200": "#b0bec5",
            "300": "#90a4ae",
            "400": "#78909c",
            "500": "#607d8b",
            "600": "#546e7a",
            "700": "#455a64",
            "800": "#37474f",
            "900": "#263238",
            A100: "#cfd8dc",
            A200: "#b0bec5",
            A400: "#78909c",
            A700: "#455a64",
            contrastDefaultColor: "light",
            contrastDarkColors: "50 100 200 300",
            contrastStrongLightColors: "400 500"
        }
    });
})();

(function() {
    "use strict";
    angular.module("material.core.theming", [ "material.core.theming.palette" ]).directive("mdTheme", ThemingDirective).directive("mdThemable", ThemableDirective).provider("$mdTheming", ThemingProvider).run(generateThemes);
    var PALETTES;
    var THEMES;
    var themingProvider;
    var generationIsDone;
    var DARK_FOREGROUND = {
        name: "dark",
        "1": "rgba(0,0,0,0.87)",
        "2": "rgba(0,0,0,0.54)",
        "3": "rgba(0,0,0,0.26)",
        "4": "rgba(0,0,0,0.12)"
    };
    var LIGHT_FOREGROUND = {
        name: "light",
        "1": "rgba(255,255,255,1.0)",
        "2": "rgba(255,255,255,0.7)",
        "3": "rgba(255,255,255,0.3)",
        "4": "rgba(255,255,255,0.12)"
    };
    var DARK_SHADOW = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)";
    var LIGHT_SHADOW = "";
    var DARK_CONTRAST_COLOR = colorToRgbaArray("rgba(0,0,0,0.87)");
    var LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgba(255,255,255,0.87");
    var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgb(255,255,255)");
    var THEME_COLOR_TYPES = [ "primary", "accent", "warn", "background" ];
    var DEFAULT_COLOR_TYPE = "primary";
    var LIGHT_DEFAULT_HUES = {
        accent: {
            "default": "A200",
            "hue-1": "A100",
            "hue-2": "A400",
            "hue-3": "A700"
        }
    };
    var DARK_DEFAULT_HUES = {
        background: {
            "default": "500",
            "hue-1": "300",
            "hue-2": "600",
            "hue-3": "800"
        }
    };
    THEME_COLOR_TYPES.forEach(function(colorType) {
        var defaultDefaultHues = {
            "default": "500",
            "hue-1": "300",
            "hue-2": "800",
            "hue-3": "A100"
        };
        if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
        if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
    });
    var VALID_HUE_VALUES = [ "50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700" ];
    function ThemingProvider($mdColorPalette) {
        PALETTES = {};
        THEMES = {};
        var defaultTheme = "default";
        var alwaysWatchTheme = false;
        angular.extend(PALETTES, $mdColorPalette);
        ThemingService.$inject = [ "$rootScope", "$log" ];
        return themingProvider = {
            definePalette: definePalette,
            extendPalette: extendPalette,
            theme: registerTheme,
            setDefaultTheme: function(theme) {
                defaultTheme = theme;
            },
            alwaysWatchTheme: function(alwaysWatch) {
                alwaysWatchTheme = alwaysWatch;
            },
            $get: ThemingService,
            _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
            _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
            _PALETTES: PALETTES,
            _THEMES: THEMES,
            _parseRules: parseRules,
            _rgba: rgba
        };
        function definePalette(name, map) {
            map = map || {};
            PALETTES[name] = checkPaletteValid(name, map);
            return themingProvider;
        }
        function extendPalette(name, map) {
            return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
        }
        function checkPaletteValid(name, map) {
            var missingColors = VALID_HUE_VALUES.filter(function(field) {
                return !map[field];
            });
            if (missingColors.length) {
                throw new Error("Missing colors %1 in palette %2!".replace("%1", missingColors.join(", ")).replace("%2", name));
            }
            return map;
        }
        function registerTheme(name, inheritFrom) {
            inheritFrom = inheritFrom || "default";
            if (THEMES[name]) return THEMES[name];
            var parentTheme = typeof inheritFrom === "string" ? THEMES[inheritFrom] : inheritFrom;
            var theme = new Theme(name);
            if (parentTheme) {
                angular.forEach(parentTheme.colors, function(color, colorType) {
                    theme.colors[colorType] = {
                        name: color.name,
                        hues: angular.extend({}, color.hues)
                    };
                });
            }
            THEMES[name] = theme;
            return theme;
        }
        function Theme(name) {
            var self = this;
            self.name = name;
            self.colors = {};
            self.dark = setDark;
            setDark(false);
            function setDark(isDark) {
                isDark = arguments.length === 0 ? true : !!isDark;
                if (isDark === self.isDark) return;
                self.isDark = isDark;
                self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
                self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
                var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
                var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
                angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                    var color = self.colors[colorType];
                    var oldDefaults = oldDefaultHues[colorType];
                    if (color) {
                        for (var hueName in color.hues) {
                            if (color.hues[hueName] === oldDefaults[hueName]) {
                                color.hues[hueName] = newDefaults[hueName];
                            }
                        }
                    }
                });
                return self;
            }
            THEME_COLOR_TYPES.forEach(function(colorType) {
                var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
                self[colorType + "Palette"] = function setPaletteType(paletteName, hues) {
                    var color = self.colors[colorType] = {
                        name: paletteName,
                        hues: angular.extend({}, defaultHues, hues)
                    };
                    Object.keys(color.hues).forEach(function(name) {
                        if (!defaultHues[name]) {
                            throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", name).replace("%2", self.name).replace("%3", paletteName).replace("%4", Object.keys(defaultHues).join(", ")));
                        }
                    });
                    Object.keys(color.hues).map(function(key) {
                        return color.hues[key];
                    }).forEach(function(hueValue) {
                        if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
                            throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", hueValue).replace("%2", self.name).replace("%3", colorType).replace("%4", paletteName).replace("%5", VALID_HUE_VALUES.join(", ")));
                        }
                    });
                    return self;
                };
                self[colorType + "Color"] = function() {
                    var args = Array.prototype.slice.call(arguments);
                    console.warn("$mdThemingProviderTheme." + colorType + "Color() has been deprecated. " + "Use $mdThemingProviderTheme." + colorType + "Palette() instead.");
                    return self[colorType + "Palette"].apply(self, args);
                };
            });
        }
        function ThemingService($rootScope, $log) {
            applyTheme.inherit = function(el, parent) {
                var ctrl = parent.controller("mdTheme");
                var attrThemeValue = el.attr("md-theme-watch");
                if ((alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != "false") {
                    var deregisterWatch = $rootScope.$watch(function() {
                        return ctrl && ctrl.$mdTheme || defaultTheme;
                    }, changeTheme);
                    el.on("$destroy", deregisterWatch);
                } else {
                    var theme = ctrl && ctrl.$mdTheme || defaultTheme;
                    changeTheme(theme);
                }
                function changeTheme(theme) {
                    if (!registered(theme)) {
                        $log.warn("Attempted to use unregistered theme '" + theme + "'. " + "Register it with $mdThemingProvider.theme().");
                    }
                    var oldTheme = el.data("$mdThemeName");
                    if (oldTheme) el.removeClass("md-" + oldTheme + "-theme");
                    el.addClass("md-" + theme + "-theme");
                    el.data("$mdThemeName", theme);
                }
            };
            applyTheme.registered = registered;
            applyTheme.defaultTheme = function() {
                return defaultTheme;
            };
            return applyTheme;
            function registered(theme) {
                if (theme === undefined || theme === "") return true;
                return THEMES[theme] !== undefined;
            }
            function applyTheme(scope, el) {
                if (el === undefined) {
                    el = scope;
                    scope = undefined;
                }
                if (scope === undefined) {
                    scope = $rootScope;
                }
                applyTheme.inherit(el, el);
            }
        }
    }
    ThemingProvider.$inject = [ "$mdColorPalette" ];
    function ThemingDirective($mdTheming, $interpolate, $log) {
        return {
            priority: 100,
            link: {
                pre: function(scope, el, attrs) {
                    var ctrl = {
                        $setTheme: function(theme) {
                            if (!$mdTheming.registered(theme)) {
                                $log.warn("attempted to use unregistered theme '" + theme + "'");
                            }
                            ctrl.$mdTheme = theme;
                        }
                    };
                    el.data("$mdThemeController", ctrl);
                    ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                    attrs.$observe("mdTheme", ctrl.$setTheme);
                }
            }
        };
    }
    ThemingDirective.$inject = [ "$mdTheming", "$interpolate", "$log" ];
    function ThemableDirective($mdTheming) {
        return $mdTheming;
    }
    ThemableDirective.$inject = [ "$mdTheming" ];
    function parseRules(theme, colorType, rules) {
        checkValidPalette(theme, colorType);
        rules = rules.replace(/THEME_NAME/g, theme.name);
        var generatedRules = [];
        var color = theme.colors[colorType];
        var themeNameRegex = new RegExp(".md-" + theme.name + "-theme", "g");
        var hueRegex = new RegExp("('|\")?{{\\s*(" + colorType + ")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g");
        var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?\s*\}\}'?"?/g;
        var palette = PALETTES[color.name];
        rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity) {
            if (colorType === "foreground") {
                if (hue == "shadow") {
                    return theme.foregroundShadow;
                } else {
                    return theme.foregroundPalette[hue] || theme.foregroundPalette["1"];
                }
            }
            if (hue.indexOf("hue") === 0) {
                hue = theme.colors[colorType].hues[hue];
            }
            return rgba((PALETTES[theme.colors[colorType].name][hue] || "").value, opacity);
        });
        angular.forEach(color.hues, function(hueValue, hueName) {
            var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
                return rgba(palette[hueValue][hueType === "color" ? "value" : "contrast"], opacity);
            });
            if (hueName !== "default") {
                newRule = newRule.replace(themeNameRegex, ".md-" + theme.name + "-theme.md-" + hueName);
            }
            generatedRules.push(newRule);
        });
        return generatedRules.join("");
    }
    function generateThemes($injector) {
        var themeCss = $injector.has("$MD_THEME_CSS") ? $injector.get("$MD_THEME_CSS") : "";
        angular.forEach(PALETTES, sanitizePalette);
        var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
            return rule && rule.length;
        }).map(function(rule) {
            return rule.trim() + "}";
        });
        var rulesByType = {};
        THEME_COLOR_TYPES.forEach(function(type) {
            rulesByType[type] = "";
        });
        var ruleMatchRegex = new RegExp("md-(" + THEME_COLOR_TYPES.join("|") + ")", "g");
        rules.forEach(function(rule) {
            var match = rule.match(ruleMatchRegex);
            for (var i = 0, type; type = THEME_COLOR_TYPES[i]; i++) {
                if (rule.indexOf(".md-" + type) > -1) {
                    return rulesByType[type] += rule;
                }
            }
            for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
                if (rule.indexOf(type) > -1) {
                    return rulesByType[type] += rule;
                }
            }
            return rulesByType[DEFAULT_COLOR_TYPE] += rule;
        });
        var styleString = "";
        angular.forEach(THEMES, function(theme) {
            THEME_COLOR_TYPES.forEach(function(colorType) {
                styleString += parseRules(theme, colorType, rulesByType[colorType] + "");
            });
            if (theme.colors.primary.name == theme.colors.accent.name) {
                console.warn("$mdThemingProvider: Using the same palette for primary and" + " accent. This violates the material design spec.");
            }
        });
        if (!generationIsDone) {
            var style = document.createElement("style");
            style.innerHTML = styleString;
            var head = document.getElementsByTagName("head")[0];
            head.insertBefore(style, head.firstElementChild);
            generationIsDone = true;
        }
        function sanitizePalette(palette) {
            var defaultContrast = palette.contrastDefaultColor;
            var lightColors = palette.contrastLightColors || [];
            var strongLightColors = palette.contrastStrongLightColors || [];
            var darkColors = palette.contrastDarkColors || [];
            if (typeof lightColors === "string") lightColors = lightColors.split(" ");
            if (typeof strongLightColors === "string") strongLightColors = strongLightColors.split(" ");
            if (typeof darkColors === "string") darkColors = darkColors.split(" ");
            delete palette.contrastDefaultColor;
            delete palette.contrastLightColors;
            delete palette.contrastStrongLightColors;
            delete palette.contrastDarkColors;
            angular.forEach(palette, function(hueValue, hueName) {
                if (angular.isObject(hueValue)) return;
                var rgbValue = colorToRgbaArray(hueValue);
                if (!rgbValue) {
                    throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", hueValue).replace("%2", palette.name).replace("%3", hueName));
                }
                palette[hueName] = {
                    value: rgbValue,
                    contrast: getContrastColor()
                };
                function getContrastColor() {
                    if (defaultContrast === "light") {
                        if (darkColors.indexOf(hueName) > -1) {
                            return DARK_CONTRAST_COLOR;
                        } else {
                            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                        }
                    } else {
                        if (lightColors.indexOf(hueName) > -1) {
                            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR;
                        } else {
                            return DARK_CONTRAST_COLOR;
                        }
                    }
                }
            });
        }
    }
    generateThemes.$inject = [ "$injector" ];
    function checkValidPalette(theme, colorType) {
        if (!PALETTES[(theme.colors[colorType] || {}).name]) {
            throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", theme.name).replace("%2", colorType).replace("%3", Object.keys(PALETTES).join(", ")));
        }
    }
    function colorToRgbaArray(clr) {
        if (angular.isArray(clr) && clr.length == 3) return clr;
        if (/^rgb/.test(clr)) {
            return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function(value, i) {
                return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);
            });
        }
        if (clr.charAt(0) == "#") clr = clr.substring(1);
        if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;
        var dig = clr.length / 3;
        var red = clr.substr(0, dig);
        var grn = clr.substr(dig, dig);
        var blu = clr.substr(dig * 2);
        if (dig === 1) {
            red += red;
            grn += grn;
            blu += blu;
        }
        return [ parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16) ];
    }
    function rgba(rgbArray, opacity) {
        if (rgbArray.length == 4) {
            rgbArray = angular.copy(rgbArray);
            opacity ? rgbArray.pop() : opacity = rgbArray.pop();
        }
        return opacity && (typeof opacity == "number" || typeof opacity == "string" && opacity.length) ? "rgba(" + rgbArray.join(",") + "," + opacity + ")" : "rgb(" + rgbArray.join(",") + ")";
    }
})();

(function() {
    "use strict";
    angular.module("material.components.autocomplete", [ "material.core", "material.components.icon" ]);
})();

(function() {
    "use strict";
    angular.module("material.components.backdrop", [ "material.core" ]).directive("mdBackdrop", BackdropDirective);
    function BackdropDirective($mdTheming) {
        return $mdTheming;
    }
    BackdropDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.bottomSheet", [ "material.core", "material.components.backdrop" ]).directive("mdBottomSheet", MdBottomSheetDirective).provider("$mdBottomSheet", MdBottomSheetProvider);
    function MdBottomSheetDirective() {
        return {
            restrict: "E"
        };
    }
    function MdBottomSheetProvider($$interimElementProvider) {
        var CLOSING_VELOCITY = .5;
        var PADDING = 80;
        bottomSheetDefaults.$inject = [ "$animate", "$mdConstant", "$timeout", "$$rAF", "$compile", "$mdTheming", "$mdBottomSheet", "$rootElement", "$rootScope", "$mdGesture" ];
        return $$interimElementProvider("$mdBottomSheet").setDefaults({
            methods: [ "disableParentScroll", "escapeToClose", "targetEvent" ],
            options: bottomSheetDefaults
        });
        function bottomSheetDefaults($animate, $mdConstant, $timeout, $$rAF, $compile, $mdTheming, $mdBottomSheet, $rootElement, $rootScope, $mdGesture) {
            var backdrop;
            return {
                themable: true,
                targetEvent: null,
                onShow: onShow,
                onRemove: onRemove,
                escapeToClose: true,
                disableParentScroll: true
            };
            function onShow(scope, element, options) {
                backdrop = $compile('<md-backdrop class="md-opaque md-bottom-sheet-backdrop">')(scope);
                backdrop.on("click", function() {
                    $timeout($mdBottomSheet.cancel);
                });
                $mdTheming.inherit(backdrop, options.parent);
                $animate.enter(backdrop, options.parent, null);
                var bottomSheet = new BottomSheet(element, options.parent);
                options.bottomSheet = bottomSheet;
                options.targetEvent && angular.element(options.targetEvent.target).blur();
                $mdTheming.inherit(bottomSheet.element, options.parent);
                if (options.disableParentScroll) {
                    options.lastOverflow = options.parent.css("overflow");
                    options.parent.css("overflow", "hidden");
                }
                return $animate.enter(bottomSheet.element, options.parent).then(function() {
                    var focusable = angular.element(element[0].querySelector("button") || element[0].querySelector("a") || element[0].querySelector("[ng-click]"));
                    focusable.focus();
                    if (options.escapeToClose) {
                        options.rootElementKeyupCallback = function(e) {
                            if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                                $timeout($mdBottomSheet.cancel);
                            }
                        };
                        $rootElement.on("keyup", options.rootElementKeyupCallback);
                    }
                });
            }
            function onRemove(scope, element, options) {
                var bottomSheet = options.bottomSheet;
                $animate.leave(backdrop);
                return $animate.leave(bottomSheet.element).then(function() {
                    if (options.disableParentScroll) {
                        options.parent.css("overflow", options.lastOverflow);
                        delete options.lastOverflow;
                    }
                    bottomSheet.cleanup();
                    options.targetEvent && angular.element(options.targetEvent.target).focus();
                });
            }
            function BottomSheet(element, parent) {
                var deregister = $mdGesture.register(parent, "drag", {
                    horizontal: false
                });
                parent.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                return {
                    element: element,
                    cleanup: function cleanup() {
                        deregister();
                        parent.off("$md.dragstart", onDragStart).off("$md.drag", onDrag).off("$md.dragend", onDragEnd);
                    }
                };
                function onDragStart(ev) {
                    element.css($mdConstant.CSS.TRANSITION_DURATION, "0ms");
                }
                function onDrag(ev) {
                    var transform = ev.pointer.distanceY;
                    if (transform < 5) {
                        transform = Math.max(-PADDING, transform / 2);
                    }
                    element.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + (PADDING + transform) + "px,0)");
                }
                function onDragEnd(ev) {
                    if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                        var distanceRemaining = element.prop("offsetHeight") - ev.pointer.distanceY;
                        var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * .75, 500);
                        element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + "ms");
                        $timeout($mdBottomSheet.cancel);
                    } else {
                        element.css($mdConstant.CSS.TRANSITION_DURATION, "");
                        element.css($mdConstant.CSS.TRANSFORM, "");
                    }
                }
            }
        }
    }
    MdBottomSheetProvider.$inject = [ "$$interimElementProvider" ];
})();

(function() {
    "use strict";
    angular.module("material.components.button", [ "material.core" ]).directive("mdButton", MdButtonDirective);
    function MdButtonDirective($mdInkRipple, $mdTheming, $mdAria) {
        return {
            restrict: "EA",
            replace: true,
            transclude: true,
            template: getTemplate,
            link: postLink
        };
        function isAnchor(attr) {
            return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref);
        }
        function getTemplate(element, attr) {
            return isAnchor(attr) ? '<a class="md-button" ng-transclude></a>' : '<button class="md-button" ng-transclude></button>';
        }
        function postLink(scope, element, attr) {
            var node = element[0];
            $mdTheming(element);
            $mdInkRipple.attachButtonBehavior(scope, element);
            var elementHasText = node.textContent.trim();
            if (!elementHasText) {
                $mdAria.expect(element, "aria-label");
            }
            if (isAnchor(attr) && angular.isDefined(attr.ngDisabled)) {
                scope.$watch(attr.ngDisabled, function(isDisabled) {
                    element.attr("tabindex", isDisabled ? -1 : 0);
                });
            }
        }
    }
    MdButtonDirective.$inject = [ "$mdInkRipple", "$mdTheming", "$mdAria" ];
})();

(function() {
    "use strict";
    angular.module("material.components.card", [ "material.core" ]).directive("mdCard", mdCardDirective);
    function mdCardDirective($mdTheming) {
        return {
            restrict: "E",
            link: function($scope, $element, $attr) {
                $mdTheming($element);
            }
        };
    }
    mdCardDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.checkbox", [ "material.core" ]).directive("mdCheckbox", MdCheckboxDirective);
    function MdCheckboxDirective(inputDirective, $mdInkRipple, $mdAria, $mdConstant, $mdTheming, $mdUtil) {
        inputDirective = inputDirective[0];
        var CHECKED_CSS = "md-checked";
        return {
            restrict: "E",
            transclude: true,
            require: "?ngModel",
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + "</div>" + '<div ng-transclude class="md-label"></div>',
            compile: compile
        };
        function compile(tElement, tAttrs) {
            tAttrs.type = "checkbox";
            tAttrs.tabIndex = 0;
            tElement.attr("role", tAttrs.type);
            return function postLink(scope, element, attr, ngModelCtrl) {
                ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
                var checked = false;
                $mdTheming(element);
                if (attr.ngChecked) {
                    scope.$watch(scope.$eval.bind(scope, attr.ngChecked), ngModelCtrl.$setViewValue.bind(ngModelCtrl));
                }
                $mdAria.expectWithText(element, "aria-label");
                inputDirective.link.pre(scope, {
                    on: angular.noop,
                    0: {}
                }, attr, [ ngModelCtrl ]);
                element.on("click", listener).on("keypress", keypressHandler);
                ngModelCtrl.$render = render;
                function keypressHandler(ev) {
                    if (ev.which === $mdConstant.KEY_CODE.SPACE) {
                        ev.preventDefault();
                        listener(ev);
                    }
                }
                function listener(ev) {
                    if (element[0].hasAttribute("disabled")) return;
                    scope.$apply(function() {
                        checked = !checked;
                        ngModelCtrl.$setViewValue(checked, ev && ev.type);
                        ngModelCtrl.$render();
                    });
                }
                function render() {
                    checked = ngModelCtrl.$viewValue;
                    if (checked) {
                        element.addClass(CHECKED_CSS);
                    } else {
                        element.removeClass(CHECKED_CSS);
                    }
                }
            };
        }
    }
    MdCheckboxDirective.$inject = [ "inputDirective", "$mdInkRipple", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil" ];
})();

(function() {
    "use strict";
    angular.module("material.components.content", [ "material.core" ]).directive("mdContent", mdContentDirective);
    function mdContentDirective($mdTheming) {
        return {
            restrict: "E",
            controller: [ "$scope", "$element", ContentController ],
            link: function(scope, element, attr) {
                var node = element[0];
                $mdTheming(element);
                scope.$broadcast("$mdContentLoaded", element);
                iosScrollFix(element[0]);
            }
        };
        function ContentController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
        }
    }
    mdContentDirective.$inject = [ "$mdTheming" ];
    function iosScrollFix(node) {
        angular.element(node).on("$md.pressdown", function(ev) {
            if (ev.pointer.type !== "t") return;
            if (ev.$materialScrollFixed) return;
            ev.$materialScrollFixed = true;
            if (node.scrollTop === 0) {
                node.scrollTop = 1;
            } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {
                node.scrollTop -= 1;
            }
        });
    }
})();

(function() {
    "use strict";
    angular.module("material.components.dialog", [ "material.core", "material.components.backdrop" ]).directive("mdDialog", MdDialogDirective).provider("$mdDialog", MdDialogProvider);
    function MdDialogDirective($$rAF, $mdTheming) {
        return {
            restrict: "E",
            link: function(scope, element, attr) {
                $mdTheming(element);
                $$rAF(function() {
                    var content = element[0].querySelector("md-content");
                    if (content && content.scrollHeight > content.clientHeight) {
                        element.addClass("md-content-overflow");
                    }
                });
            }
        };
    }
    MdDialogDirective.$inject = [ "$$rAF", "$mdTheming" ];
    function MdDialogProvider($$interimElementProvider) {
        var alertDialogMethods = [ "title", "content", "ariaLabel", "ok" ];
        advancedDialogOptions.$inject = [ "$mdDialog", "$mdTheming" ];
        dialogDefaultOptions.$inject = [ "$timeout", "$rootElement", "$compile", "$animate", "$mdAria", "$document", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$q", "$mdDialog" ];
        return $$interimElementProvider("$mdDialog").setDefaults({
            methods: [ "disableParentScroll", "hasBackdrop", "clickOutsideToClose", "escapeToClose", "targetEvent" ],
            options: dialogDefaultOptions
        }).addPreset("alert", {
            methods: [ "title", "content", "ariaLabel", "ok", "theme" ],
            options: advancedDialogOptions
        }).addPreset("confirm", {
            methods: [ "title", "content", "ariaLabel", "ok", "cancel", "theme" ],
            options: advancedDialogOptions
        });
        function advancedDialogOptions($mdDialog, $mdTheming) {
            return {
                template: [ '<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}">', "<md-content>", "<h2>{{ dialog.title }}</h2>", "<p>{{ dialog.content }}</p>", "</md-content>", '<div class="md-actions">', '<md-button ng-if="dialog.$type == \'confirm\'" ng-click="dialog.abort()">', "{{ dialog.cancel }}", "</md-button>", '<md-button ng-click="dialog.hide()" class="md-primary">', "{{ dialog.ok }}", "</md-button>", "</div>", "</md-dialog>" ].join(""),
                controller: function mdDialogCtrl() {
                    this.hide = function() {
                        $mdDialog.hide(true);
                    };
                    this.abort = function() {
                        $mdDialog.cancel();
                    };
                },
                controllerAs: "dialog",
                bindToController: true,
                theme: $mdTheming.defaultTheme()
            };
        }
        function dialogDefaultOptions($timeout, $rootElement, $compile, $animate, $mdAria, $document, $mdUtil, $mdConstant, $mdTheming, $$rAF, $q, $mdDialog) {
            return {
                hasBackdrop: true,
                isolateScope: true,
                onShow: onShow,
                onRemove: onRemove,
                clickOutsideToClose: true,
                escapeToClose: true,
                targetEvent: null,
                disableParentScroll: true,
                transformTemplate: function(template) {
                    return '<div class="md-dialog-container">' + template + "</div>";
                }
            };
            function onShow(scope, element, options) {
                options.parent = angular.element(options.parent);
                options.popInTarget = angular.element((options.targetEvent || {}).target);
                var closeButton = findCloseButton();
                configureAria(element.find("md-dialog"));
                if (options.hasBackdrop) {
                    var computeFrom = options.parent[0] == $document[0].body && $document[0].documentElement && $document[0].scrollTop ? angular.element($document[0].documentElement) : options.parent;
                    var parentOffset = computeFrom.prop("scrollTop");
                    options.backdrop = angular.element('<md-backdrop class="md-dialog-backdrop md-opaque">');
                    $mdTheming.inherit(options.backdrop, options.parent);
                    $animate.enter(options.backdrop, options.parent);
                    element.css("top", parentOffset + "px");
                }
                if (options.disableParentScroll) {
                    options.lastOverflow = options.parent.css("overflow");
                    options.parent.css("overflow", "hidden");
                }
                return dialogPopIn(element, options.parent, options.popInTarget && options.popInTarget.length && options.popInTarget).then(function() {
                    if (options.escapeToClose) {
                        options.rootElementKeyupCallback = function(e) {
                            if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                                $timeout($mdDialog.cancel);
                            }
                        };
                        $rootElement.on("keyup", options.rootElementKeyupCallback);
                    }
                    if (options.clickOutsideToClose) {
                        options.dialogClickOutsideCallback = function(ev) {
                            if (ev.target === element[0]) {
                                $timeout($mdDialog.cancel);
                            }
                        };
                        element.on("click", options.dialogClickOutsideCallback);
                    }
                    closeButton.focus();
                });
                function findCloseButton() {
                    var closeButton = element[0].querySelector(".dialog-close");
                    if (!closeButton) {
                        var actionButtons = element[0].querySelectorAll(".md-actions button");
                        closeButton = actionButtons[actionButtons.length - 1];
                    }
                    return angular.element(closeButton);
                }
            }
            function onRemove(scope, element, options) {
                if (options.backdrop) {
                    $animate.leave(options.backdrop);
                }
                if (options.disableParentScroll) {
                    options.parent.css("overflow", options.lastOverflow);
                    delete options.lastOverflow;
                }
                if (options.escapeToClose) {
                    $rootElement.off("keyup", options.rootElementKeyupCallback);
                }
                if (options.clickOutsideToClose) {
                    element.off("click", options.dialogClickOutsideCallback);
                }
                return dialogPopOut(element, options.parent, options.popInTarget && options.popInTarget.length && options.popInTarget).then(function() {
                    options.scope.$destroy();
                    element.remove();
                    options.popInTarget && options.popInTarget.focus();
                });
            }
            function configureAria(element) {
                element.attr({
                    role: "dialog"
                });
                var dialogContent = element.find("md-content");
                if (dialogContent.length === 0) {
                    dialogContent = element;
                }
                $mdAria.expectAsync(element, "aria-label", function() {
                    var words = dialogContent.text().split(/\s+/);
                    if (words.length > 3) words = words.slice(0, 3).concat("...");
                    return words.join(" ");
                });
            }
            function dialogPopIn(container, parentElement, clickElement) {
                var dialogEl = container.find("md-dialog");
                parentElement.append(container);
                transformToClickElement(dialogEl, clickElement);
                $$rAF(function() {
                    dialogEl.addClass("transition-in").css($mdConstant.CSS.TRANSFORM, "");
                });
                return $mdUtil.transitionEndPromise(dialogEl);
            }
            function dialogPopOut(container, parentElement, clickElement) {
                var dialogEl = container.find("md-dialog");
                dialogEl.addClass("transition-out").removeClass("transition-in");
                transformToClickElement(dialogEl, clickElement);
                return $mdUtil.transitionEndPromise(dialogEl);
            }
            function transformToClickElement(dialogEl, clickElement) {
                if (clickElement) {
                    var clickRect = clickElement[0].getBoundingClientRect();
                    var dialogRect = dialogEl[0].getBoundingClientRect();
                    var scaleX = Math.min(.5, clickRect.width / dialogRect.width);
                    var scaleY = Math.min(.5, clickRect.height / dialogRect.height);
                    dialogEl.css($mdConstant.CSS.TRANSFORM, "translate3d(" + (-dialogRect.left + clickRect.left + clickRect.width / 2 - dialogRect.width / 2) + "px," + (-dialogRect.top + clickRect.top + clickRect.height / 2 - dialogRect.height / 2) + "px," + "0) scale(" + scaleX + "," + scaleY + ")");
                }
            }
            function dialogTransitionEnd(dialogEl) {
                var deferred = $q.defer();
                dialogEl.on($mdConstant.CSS.TRANSITIONEND, finished);
                function finished(ev) {
                    if (ev.target === dialogEl[0]) {
                        dialogEl.off($mdConstant.CSS.TRANSITIONEND, finished);
                        deferred.resolve();
                    }
                }
                return deferred.promise;
            }
        }
    }
    MdDialogProvider.$inject = [ "$$interimElementProvider" ];
})();

(function() {
    "use strict";
    angular.module("material.components.divider", [ "material.core" ]).directive("mdDivider", MdDividerDirective);
    function MdDividerController() {}
    function MdDividerDirective($mdTheming) {
        return {
            restrict: "E",
            link: $mdTheming,
            controller: [ MdDividerController ]
        };
    }
    MdDividerDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.gridList", [ "material.core" ]).directive("mdGridList", GridListDirective).directive("mdGridTile", GridTileDirective).directive("mdGridTileFooter", GridTileCaptionDirective).directive("mdGridTileHeader", GridTileCaptionDirective).factory("$mdGridLayout", GridLayoutFactory);
    function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia, $mdUtil) {
        return {
            restrict: "E",
            controller: GridListController,
            scope: {
                mdOnLayout: "&"
            },
            link: postLink
        };
        function postLink(scope, element, attrs, ctrl) {
            element.attr("role", "list");
            ctrl.layoutDelegate = layoutDelegate;
            var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout), unwatchAttrs = watchMedia();
            scope.$on("$destroy", unwatchMedia);
            function watchMedia() {
                for (var mediaName in $mdConstant.MEDIA) {
                    $mdMedia(mediaName);
                    $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
                }
                return $mdMedia.watchResponsiveAttributes([ "md-cols", "md-row-height" ], attrs, layoutIfMediaMatch);
            }
            function unwatchMedia() {
                unwatchAttrs();
                for (var mediaName in $mdConstant.MEDIA) {
                    $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
                }
            }
            function layoutIfMediaMatch(mediaName) {
                if (mediaName == null) {
                    ctrl.invalidateLayout();
                } else if ($mdMedia(mediaName)) {
                    ctrl.invalidateLayout();
                }
            }
            function layoutDelegate() {
                var tiles = getTileElements(), colCount = getColumnCount(), rowMode = getRowMode(), rowHeight = getRowHeight(), gutter = getGutter(), performance = $mdGridLayout(colCount, getTileSpans(), getTileElements()).map(function(tilePositions, rowCount) {
                    return {
                        grid: {
                            element: element,
                            style: getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight)
                        },
                        tiles: tilePositions.map(function(ps, i) {
                            return {
                                element: angular.element(tiles[i]),
                                style: getTileStyle(ps.position, ps.spans, colCount, rowCount, gutter, rowMode, rowHeight)
                            };
                        })
                    };
                }).reflow().performance();
                scope.mdOnLayout({
                    $event: {
                        performance: performance
                    }
                });
            }
            var UNIT = $interpolate("{{ share }}% - ({{ gutter }} * {{ gutterShare }})");
            var POSITION = $interpolate("calc(({{ unit }}) * {{ offset }} + {{ offset }} * {{ gutter }})");
            var DIMENSION = $interpolate("calc(({{ unit }}) * {{ span }} + ({{ span }} - 1) * {{ gutter }})");
            function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
                var hShare = 1 / colCount * 100, hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount, hUnit = UNIT({
                    share: hShare,
                    gutterShare: hGutterShare,
                    gutter: gutter
                });
                var style = {
                    left: POSITION({
                        unit: hUnit,
                        offset: position.col,
                        gutter: gutter
                    }),
                    width: DIMENSION({
                        unit: hUnit,
                        span: spans.col,
                        gutter: gutter
                    }),
                    paddingTop: "",
                    marginTop: "",
                    top: "",
                    height: ""
                };
                switch (rowMode) {
                  case "fixed":
                    style.top = POSITION({
                        unit: rowHeight,
                        offset: position.row,
                        gutter: gutter
                    });
                    style.height = DIMENSION({
                        unit: rowHeight,
                        span: spans.row,
                        gutter: gutter
                    });
                    break;

                  case "ratio":
                    var vShare = hShare * (1 / rowHeight), vUnit = UNIT({
                        share: vShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                    });
                    style.paddingTop = DIMENSION({
                        unit: vUnit,
                        span: spans.row,
                        gutter: gutter
                    });
                    style.marginTop = POSITION({
                        unit: vUnit,
                        offset: position.row,
                        gutter: gutter
                    });
                    break;

                  case "fit":
                    var vGutterShare = rowCount === 1 ? 0 : (rowCount - 1) / rowCount, vShare = 1 / rowCount * 100, vUnit = UNIT({
                        share: vShare,
                        gutterShare: vGutterShare,
                        gutter: gutter
                    });
                    style.top = POSITION({
                        unit: vUnit,
                        offset: position.row,
                        gutter: gutter
                    });
                    style.height = DIMENSION({
                        unit: vUnit,
                        span: spans.row,
                        gutter: gutter
                    });
                    break;
                }
                return style;
            }
            function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
                var style = {
                    height: "",
                    paddingBottom: ""
                };
                switch (rowMode) {
                  case "fixed":
                    style.height = DIMENSION({
                        unit: rowHeight,
                        span: rowCount,
                        gutter: gutter
                    });
                    break;

                  case "ratio":
                    var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount, hShare = 1 / colCount * 100, vShare = hShare * (1 / rowHeight), vUnit = UNIT({
                        share: vShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                    });
                    style.paddingBottom = DIMENSION({
                        unit: vUnit,
                        span: rowCount,
                        gutter: gutter
                    });
                    break;

                  case "fit":
                    break;
                }
                return style;
            }
            function getTileElements() {
                return ctrl.tiles.map(function(tile) {
                    return tile.element;
                });
            }
            function getTileSpans() {
                return ctrl.tiles.map(function(tile) {
                    return {
                        row: parseInt($mdMedia.getResponsiveAttribute(tile.attrs, "md-rowspan"), 10) || 1,
                        col: parseInt($mdMedia.getResponsiveAttribute(tile.attrs, "md-colspan"), 10) || 1
                    };
                });
            }
            function getColumnCount() {
                var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, "md-cols"), 10);
                if (isNaN(colCount)) {
                    throw "md-grid-list: md-cols attribute was not found, or contained a non-numeric value";
                }
                return colCount;
            }
            function getGutter() {
                return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, "md-gutter") || 1);
            }
            function getRowHeight() {
                var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                switch (getRowMode()) {
                  case "fixed":
                    return applyDefaultUnit(rowHeight);

                  case "ratio":
                    var whRatio = rowHeight.split(":");
                    return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);

                  case "fit":
                    return 0;
                }
            }
            function getRowMode() {
                var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                if (rowHeight == "fit") {
                    return "fit";
                } else if (rowHeight.indexOf(":") !== -1) {
                    return "ratio";
                } else {
                    return "fixed";
                }
            }
            function applyDefaultUnit(val) {
                return /\D$/.test(val) ? val : val + "px";
            }
        }
    }
    GridListDirective.$inject = [ "$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia", "$mdUtil" ];
    function GridListController($timeout) {
        this.invalidated = false;
        this.$timeout_ = $timeout;
        this.tiles = [];
        this.layoutDelegate = angular.noop;
    }
    GridListController.$inject = [ "$timeout" ];
    GridListController.prototype = {
        addTile: function(tileElement, tileAttrs, idx) {
            var tile = {
                element: tileElement,
                attrs: tileAttrs
            };
            if (angular.isUndefined(idx)) {
                this.tiles.push(tile);
            } else {
                this.tiles.splice(idx, 0, tile);
            }
            this.invalidateLayout();
        },
        removeTile: function(tileElement, tileAttrs) {
            var idx = this._findTileIndex(tileAttrs);
            if (idx === -1) {
                return;
            }
            this.tiles.splice(idx, 1);
            this.invalidateLayout();
        },
        invalidateLayout: function() {
            if (this.invalidated) {
                return;
            }
            this.invalidated = true;
            this.$timeout_(angular.bind(this, this.layout));
        },
        layout: function() {
            try {
                this.layoutDelegate();
            } finally {
                this.invalidated = false;
            }
        },
        _findTileIndex: function(tileAttrs) {
            for (var i = 0; i < this.tiles.length; i++) {
                if (this.tiles[i].attrs == tileAttrs) {
                    return i;
                }
            }
            return -1;
        }
    };
    function GridLayoutFactory($mdUtil) {
        var defaultAnimator = GridTileAnimator;
        GridLayout.animateWith = function(customAnimator) {
            defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;
        };
        return GridLayout;
        function GridLayout(colCount, tileSpans) {
            var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime, layoutInfo;
            layoutTime = $mdUtil.time(function() {
                layoutInfo = calculateGridFor(colCount, tileSpans);
            });
            return self = {
                layoutInfo: function() {
                    return layoutInfo;
                },
                map: function(updateFn) {
                    mapTime = $mdUtil.time(function() {
                        var info = self.layoutInfo();
                        gridStyles = updateFn(info.positioning, info.rowCount);
                    });
                    return self;
                },
                reflow: function(animatorFn) {
                    reflowTime = $mdUtil.time(function() {
                        var animator = animatorFn || defaultAnimator;
                        animator(gridStyles.grid, gridStyles.tiles);
                    });
                    return self;
                },
                performance: function() {
                    return {
                        tileCount: tileSpans.length,
                        layoutTime: layoutTime,
                        mapTime: mapTime,
                        reflowTime: reflowTime,
                        totalTime: layoutTime + mapTime + reflowTime
                    };
                }
            };
        }
        function GridTileAnimator(grid, tiles) {
            grid.element.css(grid.style);
            tiles.forEach(function(t) {
                t.element.css(t.style);
            });
        }
        function calculateGridFor(colCount, tileSpans) {
            var curCol = 0, curRow = 0, spaceTracker = newSpaceTracker();
            return {
                positioning: tileSpans.map(function(spans, i) {
                    return {
                        spans: spans,
                        position: reserveSpace(spans, i)
                    };
                }),
                rowCount: curRow + Math.max.apply(Math, spaceTracker)
            };
            function reserveSpace(spans, i) {
                if (spans.col > colCount) {
                    throw "md-grid-list: Tile at position " + i + " has a colspan " + "(" + spans.col + ") that exceeds the column count " + "(" + colCount + ")";
                }
                var start = 0, end = 0;
                while (end - start < spans.col) {
                    if (curCol >= colCount) {
                        nextRow();
                        continue;
                    }
                    start = spaceTracker.indexOf(0, curCol);
                    if (start === -1 || (end = findEnd(start + 1)) === -1) {
                        start = end = 0;
                        nextRow();
                        continue;
                    }
                    curCol = end + 1;
                }
                adjustRow(start, spans.col, spans.row);
                curCol = start + spans.col;
                return {
                    col: start,
                    row: curRow
                };
            }
            function nextRow() {
                curCol = 0;
                curRow++;
                adjustRow(0, colCount, -1);
            }
            function adjustRow(from, cols, by) {
                for (var i = from; i < from + cols; i++) {
                    spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
                }
            }
            function findEnd(start) {
                var i;
                for (i = start; i < spaceTracker.length; i++) {
                    if (spaceTracker[i] !== 0) {
                        return i;
                    }
                }
                if (i === spaceTracker.length) {
                    return i;
                }
            }
            function newSpaceTracker() {
                var tracker = [];
                for (var i = 0; i < colCount; i++) {
                    tracker.push(0);
                }
                return tracker;
            }
        }
    }
    GridLayoutFactory.$inject = [ "$mdUtil" ];
    function GridTileDirective($mdMedia) {
        return {
            restrict: "E",
            require: "^mdGridList",
            template: "<figure ng-transclude></figure>",
            transclude: true,
            scope: {},
            link: postLink
        };
        function postLink(scope, element, attrs, gridCtrl) {
            element.attr("role", "listitem");
            var unwatchAttrs = $mdMedia.watchResponsiveAttributes([ "md-colspan", "md-rowspan" ], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
            gridCtrl.addTile(element, attrs, scope.$parent.$index);
            scope.$on("$destroy", function() {
                unwatchAttrs();
                gridCtrl.removeTile(element, attrs);
            });
        }
    }
    GridTileDirective.$inject = [ "$mdMedia" ];
    function GridTileCaptionDirective() {
        return {
            template: "<figcaption ng-transclude></figcaption>",
            transclude: true
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.components.icon", [ "material.core" ]).directive("mdIcon", mdIconDirective);
    function mdIconDirective($mdIcon, $mdTheming, $mdAria) {
        return {
            scope: {
                fontIcon: "@mdFontIcon",
                svgIcon: "@mdSvgIcon",
                svgSrc: "@mdSvgSrc"
            },
            restrict: "E",
            template: getTemplate,
            link: postLink
        };
        function getTemplate(element, attr) {
            return attr.mdFontIcon ? '<span class="md-font" ng-class="fontIcon"></span>' : "";
        }
        function postLink(scope, element, attr) {
            $mdTheming(element);
            var ariaLabel = attr.alt || scope.fontIcon || scope.svgIcon;
            var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || "");
            if (attr.alt != "" && !parentsHaveText()) {
                $mdAria.expect(element, "aria-label", ariaLabel);
                $mdAria.expect(element, "role", "img");
            } else {
                $mdAria.expect(element, "aria-hidden", "true");
            }
            if (attrName) {
                attr.$observe(attrName, function(attrVal) {
                    element.empty();
                    if (attrVal) {
                        $mdIcon(attrVal).then(function(svg) {
                            element.append(svg);
                        });
                    }
                });
            }
            function parentsHaveText() {
                var parent = element.parent();
                if (parent.attr("aria-label") || parent.text()) {
                    return true;
                } else if (parent.parent().attr("aria-label") || parent.parent().text()) {
                    return true;
                }
                return false;
            }
        }
    }
    mdIconDirective.$inject = [ "$mdIcon", "$mdTheming", "$mdAria" ];
})();

(function() {
    "use strict";
    angular.module("material.components.icon").provider("$mdIcon", MdIconProvider);
    var config = {
        defaultIconSize: 24
    };
    function MdIconProvider() {}
    MdIconProvider.prototype = {
        icon: function icon(id, url, iconSize) {
            if (id.indexOf(":") == -1) id = "$default:" + id;
            config[id] = new ConfigurationItem(url, iconSize);
            return this;
        },
        iconSet: function iconSet(id, url, iconSize) {
            config[id] = new ConfigurationItem(url, iconSize);
            return this;
        },
        defaultIconSet: function defaultIconSet(url, iconSize) {
            var setName = "$default";
            if (!config[setName]) {
                config[setName] = new ConfigurationItem(url, iconSize);
            }
            config[setName].iconSize = iconSize || config.defaultIconSize;
            return this;
        },
        defaultIconSize: function defaultIconSize(iconSize) {
            config.defaultIconSize = iconSize;
            return this;
        },
        preloadIcons: function($templateCache) {
            var iconProvider = this;
            var svgRegistry = [ {
                id: "tabs-arrow",
                url: "tabs-arrow.svg",
                svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g id="tabs-arrow"><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>'
            }, {
                id: "close",
                url: "close.svg",
                svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g id="close"><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>'
            }, {
                id: "cancel",
                url: "cancel.svg",
                svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g id="cancel"><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>'
            } ];
            svgRegistry.forEach(function(asset) {
                iconProvider.icon(asset.id, asset.url);
                $templateCache.put(asset.url, asset.svg);
            });
        },
        $get: [ "$http", "$q", "$log", "$templateCache", function($http, $q, $log, $templateCache) {
            this.preloadIcons($templateCache);
            return new MdIconService(config, $http, $q, $log, $templateCache);
        } ]
    };
    function ConfigurationItem(url, iconSize) {
        this.url = url;
        this.iconSize = iconSize || config.defaultIconSize;
    }
    function MdIconService(config, $http, $q, $log, $templateCache) {
        var iconCache = {};
        var urlRegex = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/i;
        Icon.prototype = {
            clone: cloneSVG,
            prepare: prepareAndStyle
        };
        return function getIcon(id) {
            id = id || "";
            if (iconCache[id]) return $q.when(iconCache[id].clone());
            if (urlRegex.test(id)) return loadByURL(id).then(cacheIcon(id));
            if (id.indexOf(":") == -1) id = "$default:" + id;
            return loadByID(id).catch(loadFromIconSet).catch(announceIdNotFound).catch(announceNotFound).then(cacheIcon(id));
        };
        function cacheIcon(id) {
            return function updateCache(icon) {
                iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
                return iconCache[id].clone();
            };
        }
        function loadByID(id) {
            var iconConfig = config[id];
            return !iconConfig ? $q.reject(id) : loadByURL(iconConfig.url).then(function(icon) {
                return new Icon(icon, iconConfig);
            });
        }
        function loadFromIconSet(id) {
            var setName = id.substring(0, id.lastIndexOf(":")) || "$default";
            var iconSetConfig = config[setName];
            return !iconSetConfig ? $q.reject(id) : loadByURL(iconSetConfig.url).then(extractFromSet);
            function extractFromSet(set) {
                var iconName = id.slice(id.lastIndexOf(":") + 1);
                var icon = set.querySelector("#" + iconName);
                return !icon ? $q.reject(id) : new Icon(icon, iconSetConfig);
            }
        }
        function loadByURL(url) {
            return $http.get(url, {
                cache: $templateCache
            }).then(function(response) {
                var els = angular.element(response.data);
                for (var i = 0; i < els.length; ++i) {
                    if (els[i].nodeName == "svg") {
                        return els[i];
                    }
                }
            });
        }
        function announceIdNotFound(id) {
            var msg;
            if (angular.isString(id)) {
                msg = "icon " + id + " not found";
                $log.warn(msg);
            }
            return $q.reject(msg || id);
        }
        function announceNotFound(err) {
            var msg = angular.isString(err) ? err : err.message || err.data || err.statusText;
            $log.warn(msg);
            return $q.reject(msg);
        }
        function isIcon(target) {
            return angular.isDefined(target.element) && angular.isDefined(target.config);
        }
        function Icon(el, config) {
            if (el.tagName != "svg") {
                el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el)[0];
            }
            el = angular.element(el);
            if (!el.attr("xmlns")) {
                el.attr("xmlns", "http://www.w3.org/2000/svg");
            }
            this.element = el;
            this.config = config;
            this.prepare();
        }
        function prepareAndStyle() {
            var iconSize = this.config ? this.config.iconSize : config.defaultIconSize;
            var svg = angular.element(this.element);
            svg.attr({
                fit: "",
                height: "100%",
                width: "100%",
                preserveAspectRatio: "xMidYMid meet",
                viewBox: svg.attr("viewBox") || "0 0 " + iconSize + " " + iconSize
            }).css({
                "pointer-events": "none",
                display: "block"
            });
            this.element = svg;
        }
        function cloneSVG() {
            return angular.element(this.element[0].cloneNode(true));
        }
    }
})();

(function() {
    angular.module("material.components.input", [ "material.core" ]).directive("mdInputContainer", mdInputContainerDirective).directive("label", labelDirective).directive("input", inputTextareaDirective).directive("textarea", inputTextareaDirective).directive("mdMaxlength", mdMaxlengthDirective).directive("placeholder", placeholderDirective);
    function mdInputContainerDirective($mdTheming, $parse) {
        ContainerCtrl.$inject = [ "$scope", "$element", "$attrs" ];
        return {
            restrict: "E",
            link: postLink,
            controller: ContainerCtrl
        };
        function postLink(scope, element, attr) {
            $mdTheming(element);
        }
        function ContainerCtrl($scope, $element, $attrs) {
            var self = this;
            self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
            self.element = $element;
            self.setFocused = function(isFocused) {
                $element.toggleClass("md-input-focused", !!isFocused);
            };
            self.setHasValue = function(hasValue) {
                $element.toggleClass("md-input-has-value", !!hasValue);
            };
            self.setInvalid = function(isInvalid) {
                $element.toggleClass("md-input-invalid", !!isInvalid);
            };
            $scope.$watch(function() {
                return self.label && self.input;
            }, function(hasLabelAndInput) {
                if (hasLabelAndInput && !self.label.attr("for")) {
                    self.label.attr("for", self.input.attr("id"));
                }
            });
        }
    }
    mdInputContainerDirective.$inject = [ "$mdTheming", "$parse" ];
    function labelDirective() {
        return {
            restrict: "E",
            require: "^?mdInputContainer",
            link: function(scope, element, attr, containerCtrl) {
                if (!containerCtrl || attr.mdNoFloat) return;
                containerCtrl.label = element;
                scope.$on("$destroy", function() {
                    containerCtrl.label = null;
                });
            }
        };
    }
    function inputTextareaDirective($mdUtil, $window) {
        return {
            restrict: "E",
            require: [ "^?mdInputContainer", "?ngModel" ],
            link: postLink
        };
        function postLink(scope, element, attr, ctrls) {
            var containerCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            var isReadonly = angular.isDefined(attr.readonly);
            if (!containerCtrl) return;
            if (containerCtrl.input) {
                throw new Error("<md-input-container> can only have *one* <input> or <textarea> child element!");
            }
            containerCtrl.input = element;
            element.addClass("md-input");
            if (!element.attr("id")) {
                element.attr("id", "input_" + $mdUtil.nextUid());
            }
            if (element[0].tagName.toLowerCase() === "textarea") {
                setupTextarea();
            }
            var touched = false;
            var isErrorGetter = containerCtrl.isErrorGetter || function() {
                return ngModelCtrl.$invalid && (touched || ngModelCtrl.$touched);
            };
            scope.$watch(isErrorGetter, containerCtrl.setInvalid);
            ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
            ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
            element.on("input", inputCheckValue);
            if (!isReadonly) {
                element.on("focus", function(ev) {
                    touched = true;
                    containerCtrl.setFocused(true);
                    scope.$evalAsync();
                }).on("blur", function(ev) {
                    containerCtrl.setFocused(false);
                    inputCheckValue();
                });
            }
            scope.$on("$destroy", function() {
                containerCtrl.setFocused(false);
                containerCtrl.setHasValue(false);
                containerCtrl.input = null;
            });
            function ngModelPipelineCheckValue(arg) {
                containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
                return arg;
            }
            function inputCheckValue() {
                containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
            }
            function setupTextarea() {
                var node = element[0];
                var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);
                function pipelineListener(value) {
                    onChangeTextarea();
                    return value;
                }
                if (ngModelCtrl) {
                    ngModelCtrl.$formatters.push(pipelineListener);
                    ngModelCtrl.$viewChangeListeners.push(pipelineListener);
                } else {
                    onChangeTextarea();
                }
                element.on("keydown input", onChangeTextarea);
                element.on("scroll", onScroll);
                angular.element($window).on("resize", onChangeTextarea);
                scope.$on("$destroy", function() {
                    angular.element($window).off("resize", onChangeTextarea);
                });
                function growTextarea() {
                    node.style.height = "auto";
                    node.scrollTop = 0;
                    var height = getHeight();
                    if (height) node.style.height = height + "px";
                }
                function getHeight() {
                    var line = node.scrollHeight - node.offsetHeight;
                    return node.offsetHeight + (line > 0 ? line : 0);
                }
                function onScroll(e) {
                    node.scrollTop = 0;
                    var line = node.scrollHeight - node.offsetHeight;
                    var height = node.offsetHeight + line;
                    node.style.height = height + "px";
                }
            }
        }
    }
    inputTextareaDirective.$inject = [ "$mdUtil", "$window" ];
    function mdMaxlengthDirective($animate) {
        return {
            restrict: "A",
            require: [ "ngModel", "^mdInputContainer" ],
            link: postLink
        };
        function postLink(scope, element, attr, ctrls) {
            var maxlength;
            var ngModelCtrl = ctrls[0];
            var containerCtrl = ctrls[1];
            var charCountEl = angular.element('<div class="md-char-counter">');
            attr.$set("ngTrim", "false");
            containerCtrl.element.append(charCountEl);
            ngModelCtrl.$formatters.push(renderCharCount);
            ngModelCtrl.$viewChangeListeners.push(renderCharCount);
            element.on("input keydown", function() {
                renderCharCount();
            });
            scope.$watch(attr.mdMaxlength, function(value) {
                maxlength = value;
                if (angular.isNumber(value) && value > 0) {
                    if (!charCountEl.parent().length) {
                        $animate.enter(charCountEl, containerCtrl.element, angular.element(containerCtrl.element[0].lastElementChild));
                    }
                    renderCharCount();
                } else {
                    $animate.leave(charCountEl);
                }
            });
            ngModelCtrl.$validators["md-maxlength"] = function(modelValue, viewValue) {
                if (!angular.isNumber(maxlength) || maxlength < 0) {
                    return true;
                }
                return (modelValue || element.val() || viewValue || "").length <= maxlength;
            };
            function renderCharCount(value) {
                charCountEl.text((element.val() || value || "").length + "/" + maxlength);
                return value;
            }
        }
    }
    mdMaxlengthDirective.$inject = [ "$animate" ];
    function placeholderDirective() {
        return {
            restrict: "A",
            require: "^^?mdInputContainer",
            link: postLink
        };
        function postLink(scope, element, attr, inputContainer) {
            if (!inputContainer) return;
            if (angular.isDefined(inputContainer.element.attr("md-no-float"))) return;
            var placeholderText = attr.placeholder;
            element.removeAttr("placeholder");
            inputContainer.element.append('<div class="md-placeholder">' + placeholderText + "</div>");
        }
    }
})();

(function() {
    "use strict";
    angular.module("material.components.list", [ "material.core" ]).directive("mdList", mdListDirective).directive("mdItem", mdItemDirective).directive("mdListItem", mdItemDirective);
    function mdListDirective() {
        return {
            restrict: "E",
            link: function($scope, $element, $attr) {
                $element.attr({
                    role: "list"
                });
            }
        };
    }
    function mdItemDirective() {
        return {
            restrict: "E",
            link: function($scope, $element, $attr) {
                $element.attr({
                    role: "listitem"
                });
            }
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.components.progressCircular", [ "material.core" ]).directive("mdProgressCircular", MdProgressCircularDirective);
    function MdProgressCircularDirective($$rAF, $mdConstant, $mdTheming) {
        var fillRotations = new Array(101), fixRotations = new Array(101);
        for (var i = 0; i < 101; i++) {
            var percent = i / 100;
            var rotation = Math.floor(percent * 180);
            fillRotations[i] = "rotate(" + rotation.toString() + "deg)";
            fixRotations[i] = "rotate(" + (rotation * 2).toString() + "deg)";
        }
        return {
            restrict: "E",
            template: '<div class="md-spinner-wrapper">' + '<div class="md-inner">' + '<div class="md-gap"></div>' + '<div class="md-left">' + '<div class="md-half-circle"></div>' + "</div>" + '<div class="md-right">' + '<div class="md-half-circle"></div>' + "</div>" + "</div>" + "</div>",
            compile: compile
        };
        function compile(tElement, tAttrs, transclude) {
            tElement.attr("aria-valuemin", 0);
            tElement.attr("aria-valuemax", 100);
            tElement.attr("role", "progressbar");
            return postLink;
        }
        function postLink(scope, element, attr) {
            $mdTheming(element);
            var circle = element[0], fill = circle.querySelectorAll(".md-fill, .md-mask.md-full"), fix = circle.querySelectorAll(".md-fill.md-fix"), i, clamped, fillRotation, fixRotation;
            var diameter = attr.mdDiameter || 48;
            var scale = diameter / 48;
            circle.style[$mdConstant.CSS.TRANSFORM] = "scale(" + scale.toString() + ")";
            attr.$observe("value", function(value) {
                clamped = clamp(value);
                fillRotation = fillRotations[clamped];
                fixRotation = fixRotations[clamped];
                element.attr("aria-valuenow", clamped);
                for (i = 0; i < fill.length; i++) {
                    fill[i].style[$mdConstant.CSS.TRANSFORM] = fillRotation;
                }
                for (i = 0; i < fix.length; i++) {
                    fix[i].style[$mdConstant.CSS.TRANSFORM] = fixRotation;
                }
            });
        }
        function clamp(value) {
            if (value > 100) {
                return 100;
            }
            if (value < 0) {
                return 0;
            }
            return Math.ceil(value || 0);
        }
    }
    MdProgressCircularDirective.$inject = [ "$$rAF", "$mdConstant", "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.progressLinear", [ "material.core" ]).directive("mdProgressLinear", MdProgressLinearDirective);
    function MdProgressLinearDirective($$rAF, $mdConstant, $mdTheming) {
        return {
            restrict: "E",
            template: '<div class="md-container">' + '<div class="md-dashed"></div>' + '<div class="md-bar md-bar1"></div>' + '<div class="md-bar md-bar2"></div>' + "</div>",
            compile: compile
        };
        function compile(tElement, tAttrs, transclude) {
            tElement.attr("aria-valuemin", 0);
            tElement.attr("aria-valuemax", 100);
            tElement.attr("role", "progressbar");
            return postLink;
        }
        function postLink(scope, element, attr) {
            $mdTheming(element);
            var bar1Style = element[0].querySelector(".md-bar1").style, bar2Style = element[0].querySelector(".md-bar2").style, container = angular.element(element[0].querySelector(".md-container"));
            attr.$observe("value", function(value) {
                if (attr.mdMode == "query") {
                    return;
                }
                var clamped = clamp(value);
                element.attr("aria-valuenow", clamped);
                bar2Style[$mdConstant.CSS.TRANSFORM] = transforms[clamped];
            });
            attr.$observe("mdBufferValue", function(value) {
                bar1Style[$mdConstant.CSS.TRANSFORM] = transforms[clamp(value)];
            });
            $$rAF(function() {
                container.addClass("md-ready");
            });
        }
        function clamp(value) {
            if (value > 100) {
                return 100;
            }
            if (value < 0) {
                return 0;
            }
            return Math.ceil(value || 0);
        }
    }
    MdProgressLinearDirective.$inject = [ "$$rAF", "$mdConstant", "$mdTheming" ];
    var transforms = function() {
        var values = new Array(101);
        for (var i = 0; i < 101; i++) {
            values[i] = makeTransform(i);
        }
        return values;
        function makeTransform(value) {
            var scale = value / 100;
            var translateX = (value - 100) / 2;
            return "translateX(" + translateX.toString() + "%) scale(" + scale.toString() + ", 1)";
        }
    }();
})();

(function() {
    "use strict";
    angular.module("material.components.radioButton", [ "material.core" ]).directive("mdRadioGroup", mdRadioGroupDirective).directive("mdRadioButton", mdRadioButtonDirective);
    function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming) {
        RadioGroupController.prototype = createRadioGroupControllerProto();
        return {
            restrict: "E",
            controller: [ "$element", RadioGroupController ],
            require: [ "mdRadioGroup", "?ngModel" ],
            link: {
                pre: linkRadioGroup
            }
        };
        function linkRadioGroup(scope, element, attr, ctrls) {
            $mdTheming(element);
            var rgCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
            function keydownListener(ev) {
                switch (ev.keyCode) {
                  case $mdConstant.KEY_CODE.LEFT_ARROW:
                  case $mdConstant.KEY_CODE.UP_ARROW:
                    ev.preventDefault();
                    rgCtrl.selectPrevious();
                    break;

                  case $mdConstant.KEY_CODE.RIGHT_ARROW:
                  case $mdConstant.KEY_CODE.DOWN_ARROW:
                    ev.preventDefault();
                    rgCtrl.selectNext();
                    break;

                  case $mdConstant.KEY_CODE.ENTER:
                    var form = angular.element($mdUtil.getClosest(element[0], "form"));
                    if (form.length > 0) {
                        form.triggerHandler("submit");
                    }
                    break;
                }
            }
            rgCtrl.init(ngModelCtrl);
            element.attr({
                role: "radiogroup",
                tabIndex: element.attr("tabindex") || "0"
            }).on("keydown", keydownListener);
        }
        function RadioGroupController($element) {
            this._radioButtonRenderFns = [];
            this.$element = $element;
        }
        function createRadioGroupControllerProto() {
            return {
                init: function(ngModelCtrl) {
                    this._ngModelCtrl = ngModelCtrl;
                    this._ngModelCtrl.$render = angular.bind(this, this.render);
                },
                add: function(rbRender) {
                    this._radioButtonRenderFns.push(rbRender);
                },
                remove: function(rbRender) {
                    var index = this._radioButtonRenderFns.indexOf(rbRender);
                    if (index !== -1) {
                        this._radioButtonRenderFns.splice(index, 1);
                    }
                },
                render: function() {
                    this._radioButtonRenderFns.forEach(function(rbRender) {
                        rbRender();
                    });
                },
                setViewValue: function(value, eventType) {
                    this._ngModelCtrl.$setViewValue(value, eventType);
                    this.render();
                },
                getViewValue: function() {
                    return this._ngModelCtrl.$viewValue;
                },
                selectNext: function() {
                    return changeSelectedButton(this.$element, 1);
                },
                selectPrevious: function() {
                    return changeSelectedButton(this.$element, -1);
                },
                setActiveDescendant: function(radioId) {
                    this.$element.attr("aria-activedescendant", radioId);
                }
            };
        }
        function changeSelectedButton(parent, increment) {
            var buttons = $mdUtil.iterator(parent[0].querySelectorAll("md-radio-button"), true);
            if (buttons.count()) {
                var validate = function(button) {
                    return !angular.element(button).attr("disabled");
                };
                var selected = parent[0].querySelector("md-radio-button.md-checked");
                var target = buttons[increment < 0 ? "previous" : "next"](selected, validate) || buttons.first();
                angular.element(target).triggerHandler("click");
            }
        }
    }
    mdRadioGroupDirective.$inject = [ "$mdUtil", "$mdConstant", "$mdTheming" ];
    function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
        var CHECKED_CSS = "md-checked";
        return {
            restrict: "E",
            require: "^mdRadioGroup",
            transclude: true,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-off"></div>' + '<div class="md-on"></div>' + "</div>" + '<div ng-transclude class="md-label"></div>',
            link: link
        };
        function link(scope, element, attr, rgCtrl) {
            var lastChecked;
            $mdTheming(element);
            configureAria(element, scope);
            rgCtrl.add(render);
            attr.$observe("value", render);
            element.on("click", listener).on("$destroy", function() {
                rgCtrl.remove(render);
            });
            function listener(ev) {
                if (element[0].hasAttribute("disabled")) return;
                scope.$apply(function() {
                    rgCtrl.setViewValue(attr.value, ev && ev.type);
                });
            }
            function render() {
                var checked = rgCtrl.getViewValue() == attr.value;
                if (checked === lastChecked) {
                    return;
                }
                lastChecked = checked;
                element.attr("aria-checked", checked);
                if (checked) {
                    element.addClass(CHECKED_CSS);
                    rgCtrl.setActiveDescendant(element.attr("id"));
                } else {
                    element.removeClass(CHECKED_CSS);
                }
            }
            function configureAria(element, scope) {
                scope.ariaId = buildAriaID();
                element.attr({
                    id: scope.ariaId,
                    role: "radio",
                    "aria-checked": "false"
                });
                $mdAria.expectWithText(element, "aria-label");
                function buildAriaID() {
                    return attr.id || "radio" + "_" + $mdUtil.nextUid();
                }
            }
        }
    }
    mdRadioButtonDirective.$inject = [ "$mdAria", "$mdUtil", "$mdTheming" ];
})();

(function() {
    "use strict";
    var SELECT_EDGE_MARGIN = 8;
    var selectNextId = 0;
    angular.module("material.components.select", [ "material.core", "material.components.backdrop" ]).directive("mdSelect", SelectDirective).directive("mdSelectMenu", SelectMenuDirective).directive("mdOption", OptionDirective).directive("mdOptgroup", OptgroupDirective).provider("$mdSelect", SelectProvider);
    function SelectDirective($mdSelect, $mdUtil, $mdTheming, $interpolate, $compile, $parse) {
        var intStart = $interpolate.startSymbol();
        var intEnd = $interpolate.endSymbol();
        return {
            restrict: "E",
            require: [ "mdSelect", "ngModel" ],
            compile: compile,
            controller: function() {}
        };
        function compile(element, attr) {
            var labelEl = element.find("md-select-label").remove();
            if (!labelEl.length) {
                labelEl = angular.element("<md-select-label><span></span></md-select-label>");
            }
            labelEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
            labelEl.addClass("md-select-label");
            labelEl.attr("id", "select_label_" + $mdUtil.nextUid());
            if (!element.find("md-content").length) {
                element.append(angular.element("<md-content>").append(element.contents()));
            }
            if (attr.mdOnOpen) {
                element.find("md-content").prepend(angular.element("<md-progress-circular>").attr("md-mode", "indeterminate").attr("ng-hide", "$$loadingAsyncDone").wrap("<div>").parent());
            }
            var selectTemplate = '<div class="md-select-menu-container">' + "<md-select-menu " + (angular.isDefined(attr.multiple) ? "multiple" : "") + ">" + element.html() + "</md-select-menu></div>";
            element.empty().append(labelEl);
            $mdTheming(element);
            return function postLink(scope, element, attr, ctrls) {
                var isOpen;
                var mdSelectCtrl = ctrls[0];
                var ngModel = ctrls[1];
                var labelEl = element.find("md-select-label");
                var customLabel = labelEl.text().length !== 0;
                var selectContainer, selectScope;
                createSelect();
                var originalRender = ngModel.$render;
                ngModel.$render = function() {
                    originalRender();
                    syncLabelText();
                };
                mdSelectCtrl.setLabelText = function(text) {
                    if (customLabel) return;
                    mdSelectCtrl.setIsPlaceholder(!text);
                    var newText = text || attr.placeholder || "";
                    var target = customLabel ? labelEl : labelEl.children().eq(0);
                    target.text(newText);
                };
                mdSelectCtrl.setIsPlaceholder = function(val) {
                    val ? labelEl.addClass("md-placeholder") : labelEl.removeClass("md-placeholder");
                };
                scope.$$postDigest(syncLabelText);
                function syncLabelText() {
                    if (selectContainer) {
                        var selectMenuCtrl = selectContainer.find("md-select-menu").controller("mdSelectMenu");
                        mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
                    }
                }
                attr.$observe("disabled", function(disabled) {
                    if (typeof disabled == "string") {
                        disabled = true;
                    }
                    if (disabled) {
                        element.attr("tabindex", -1);
                        element.off("click", openSelect);
                        element.off("keydown", openOnKeypress);
                    } else {
                        element.attr("tabindex", 0);
                        element.on("click", openSelect);
                        element.on("keydown", openOnKeypress);
                    }
                });
                if (!attr.disabled && !attr.ngDisabled) {
                    element.attr("tabindex", 0);
                    element.on("click", openSelect);
                    element.on("keydown", openOnKeypress);
                }
                element.attr({
                    role: "combobox",
                    id: "select_" + $mdUtil.nextUid(),
                    "aria-haspopup": true,
                    "aria-expanded": "false",
                    "aria-labelledby": labelEl.attr("id")
                });
                scope.$on("$destroy", function() {
                    if (isOpen) {
                        $mdSelect.cancel().then(function() {
                            selectContainer.remove();
                        });
                    } else {
                        selectContainer.remove();
                    }
                });
                function createSelect() {
                    selectContainer = angular.element(selectTemplate);
                    var selectEl = selectContainer.find("md-select-menu");
                    selectEl.data("$ngModelController", ngModel);
                    selectEl.data("$mdSelectController", mdSelectCtrl);
                    selectScope = scope.$new();
                    selectContainer = $compile(selectContainer)(selectScope);
                }
                function openOnKeypress(e) {
                    var allowedCodes = [ 32, 13, 38, 40 ];
                    if (allowedCodes.indexOf(e.keyCode) != -1) {
                        e.preventDefault();
                        openSelect(e);
                    }
                }
                function openSelect() {
                    scope.$evalAsync(function() {
                        isOpen = true;
                        $mdSelect.show({
                            scope: selectScope,
                            preserveScope: true,
                            skipCompile: true,
                            element: selectContainer,
                            target: element[0],
                            hasBackdrop: true,
                            loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) : false
                        }).then(function(selectedText) {
                            isOpen = false;
                        });
                    });
                }
            };
        }
    }
    SelectDirective.$inject = [ "$mdSelect", "$mdUtil", "$mdTheming", "$interpolate", "$compile", "$parse" ];
    function SelectMenuDirective($parse, $mdUtil, $mdTheming) {
        SelectMenuController.$inject = [ "$scope", "$attrs", "$element" ];
        return {
            restrict: "E",
            require: [ "mdSelectMenu", "?ngModel" ],
            controller: SelectMenuController,
            link: {
                pre: preLink
            }
        };
        function preLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModel = ctrls[1];
            $mdTheming(element);
            element.on("click", clickListener);
            element.on("keypress", keyListener);
            if (ngModel) selectCtrl.init(ngModel);
            configureAria();
            function configureAria() {
                element.attr({
                    id: "select_menu_" + $mdUtil.nextUid(),
                    role: "listbox",
                    "aria-multiselectable": selectCtrl.isMultiple ? "true" : "false"
                });
            }
            function keyListener(e) {
                if (e.keyCode == 13 || e.keyCode == 32) {
                    clickListener(e);
                }
            }
            function clickListener(ev) {
                var option = $mdUtil.getClosest(ev.target, "md-option");
                var optionCtrl = option && angular.element(option).data("$mdOptionController");
                if (!option || !optionCtrl) return;
                var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
                var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
                scope.$apply(function() {
                    if (selectCtrl.isMultiple) {
                        if (isSelected) {
                            selectCtrl.deselect(optionHashKey);
                        } else {
                            selectCtrl.select(optionHashKey, optionCtrl.value);
                        }
                    } else {
                        if (!isSelected) {
                            selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                            selectCtrl.select(optionHashKey, optionCtrl.value);
                        }
                    }
                    selectCtrl.refreshViewValue();
                });
            }
        }
        function SelectMenuController($scope, $attrs, $element) {
            var self = this;
            self.isMultiple = angular.isDefined($attrs.multiple);
            self.selected = {};
            self.options = {};
            self.init = function(ngModel) {
                self.ngModel = ngModel;
                if (ngModel.$options && ngModel.$options.trackBy) {
                    var trackByLocals = {};
                    var trackByParsed = $parse(ngModel.$options.trackBy);
                    self.hashGetter = function(value, valueScope) {
                        trackByLocals.$value = value;
                        return trackByParsed(valueScope || $scope, trackByLocals);
                    };
                } else {
                    self.hashGetter = function getHashValue(value) {
                        if (angular.isObject(value)) {
                            return "$$object_" + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
                        }
                        return value;
                    };
                }
                if (self.isMultiple) {
                    ngModel.$validators["md-multiple"] = validateArray;
                    ngModel.$render = renderMultiple;
                    $scope.$watchCollection($attrs.ngModel, function(value) {
                        if (validateArray(value)) renderMultiple(value);
                    });
                } else {
                    ngModel.$render = renderSingular;
                }
                function validateArray(modelValue, viewValue) {
                    return angular.isArray(modelValue || viewValue || []);
                }
            };
            self.selectedLabels = function() {
                var selectedOptionEls = nodesToArray($element[0].querySelectorAll("md-option[selected]"));
                if (selectedOptionEls.length) {
                    return selectedOptionEls.map(function(el) {
                        return el.textContent;
                    }).join(", ");
                } else {
                    return "";
                }
            };
            self.select = function(hashKey, hashedValue) {
                var option = self.options[hashKey];
                option && option.setSelected(true);
                self.selected[hashKey] = hashedValue;
            };
            self.deselect = function(hashKey) {
                var option = self.options[hashKey];
                option && option.setSelected(false);
                delete self.selected[hashKey];
            };
            self.addOption = function(hashKey, optionCtrl) {
                if (angular.isDefined(self.options[hashKey])) {
                    throw new Error("Duplicate md-option values are not allowed in a select. " + 'Duplicate value "' + optionCtrl.value + '" found.');
                }
                self.options[hashKey] = optionCtrl;
                if (angular.isDefined(self.selected[hashKey])) {
                    self.select(hashKey, optionCtrl.value);
                    self.refreshViewValue();
                }
            };
            self.removeOption = function(hashKey) {
                delete self.options[hashKey];
            };
            self.refreshViewValue = function() {
                var values = [];
                var option;
                for (var hashKey in self.selected) {
                    if (option = self.options[hashKey]) {
                        values.push(option.value);
                    } else {
                        values.push(self.selected[hashKey]);
                    }
                }
                self.ngModel.$setViewValue(self.isMultiple ? values : values[0]);
            };
            function renderMultiple() {
                var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue;
                if (!angular.isArray(newSelectedValues)) return;
                var oldSelected = Object.keys(self.selected);
                var newSelectedHashes = newSelectedValues.map(self.hashGetter);
                var deselected = oldSelected.filter(function(hash) {
                    return newSelectedHashes.indexOf(hash) === -1;
                });
                deselected.forEach(self.deselect);
                newSelectedHashes.forEach(function(hashKey, i) {
                    self.select(hashKey, newSelectedValues[i]);
                });
            }
            function renderSingular() {
                var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
                Object.keys(self.selected).forEach(self.deselect);
                self.select(self.hashGetter(value), value);
            }
        }
    }
    SelectMenuDirective.$inject = [ "$parse", "$mdUtil", "$mdTheming" ];
    function OptionDirective($mdInkRipple, $mdUtil) {
        OptionController.$inject = [ "$element" ];
        return {
            restrict: "E",
            require: [ "mdOption", "^^mdSelectMenu" ],
            controller: OptionController,
            compile: compile
        };
        function compile(element, attr) {
            element.append(angular.element('<div class="md-text">').append(element.contents()));
            if (attr.tabindex === undefined) element.attr("tabindex", 0);
            return postLink;
        }
        function postLink(scope, element, attr, ctrls) {
            var optionCtrl = ctrls[0];
            var selectCtrl = ctrls[1];
            if (angular.isDefined(attr.ngValue)) {
                scope.$watch(attr.ngValue, setOptionValue);
            } else if (angular.isDefined(attr.value)) {
                setOptionValue(attr.value);
            } else {
                throw new Error("Expected either ngValue or value attr");
            }
            attr.$observe("selected", function(selected) {
                if (!angular.isDefined(selected)) return;
                if (selected) {
                    if (!selectCtrl.isMultiple) {
                        selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                    }
                    selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                } else {
                    selectCtrl.deselect(optionCtrl.hashKey);
                }
                selectCtrl.refreshViewValue();
                selectCtrl.ngModel.$render();
            });
            $mdInkRipple.attachButtonBehavior(scope, element);
            configureAria();
            function setOptionValue(newValue, oldValue) {
                var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
                var newHashKey = selectCtrl.hashGetter(newValue, scope);
                optionCtrl.hashKey = newHashKey;
                optionCtrl.value = newValue;
                selectCtrl.removeOption(oldHashKey, optionCtrl);
                selectCtrl.addOption(newHashKey, optionCtrl);
            }
            scope.$on("$destroy", function() {
                selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
            });
            function configureAria() {
                element.attr({
                    role: "option",
                    "aria-selected": "false",
                    id: "select_option_" + $mdUtil.nextUid()
                });
            }
        }
        function OptionController($element) {
            this.selected = false;
            this.setSelected = function(isSelected) {
                if (isSelected && !this.selected) {
                    $element.attr({
                        selected: "selected",
                        "aria-selected": "true"
                    });
                } else if (!isSelected && this.selected) {
                    $element.removeAttr("selected");
                    $element.attr("aria-selected", "false");
                }
                this.selected = isSelected;
            };
        }
    }
    OptionDirective.$inject = [ "$mdInkRipple", "$mdUtil" ];
    function OptgroupDirective() {
        return {
            restrict: "E",
            compile: compile
        };
        function compile(el, attrs) {
            var labelElement = el.find("label");
            if (!labelElement.length) {
                labelElement = angular.element("<label>");
                el.prepend(labelElement);
            }
            if (attrs.label) labelElement.text(attrs.label);
        }
    }
    function SelectProvider($$interimElementProvider) {
        selectDefaultOptions.$inject = [ "$mdSelect", "$mdConstant", "$$rAF", "$mdUtil", "$mdTheming", "$timeout" ];
        return $$interimElementProvider("$mdSelect").setDefaults({
            methods: [ "target" ],
            options: selectDefaultOptions
        });
        function selectDefaultOptions($mdSelect, $mdConstant, $$rAF, $mdUtil, $mdTheming, $timeout) {
            return {
                parent: "body",
                onShow: onShow,
                onRemove: onRemove,
                hasBackdrop: true,
                disableParentScroll: $mdUtil.floatingScrollbars(),
                themable: true
            };
            function onShow(scope, element, opts) {
                if (!opts.target) {
                    throw new Error("$mdSelect.show() expected a target element in options.target but got " + '"' + opts.target + '"!');
                }
                angular.extend(opts, {
                    isRemoved: false,
                    target: angular.element(opts.target),
                    parent: angular.element(opts.parent),
                    selectEl: element.find("md-select-menu"),
                    contentEl: element.find("md-content"),
                    backdrop: opts.hasBackdrop && angular.element('<md-backdrop class="md-select-backdrop">')
                });
                configureAria();
                element.removeClass("md-leave");
                var optionNodes = opts.selectEl[0].getElementsByTagName("md-option");
                if (opts.loadingAsync && opts.loadingAsync.then) {
                    opts.loadingAsync.then(function() {
                        scope.$$loadingAsyncDone = true;
                        $$rAF(function() {
                            $$rAF(function() {
                                if (opts.isRemoved) return;
                                animateSelect(scope, element, opts);
                            });
                        });
                    });
                }
                if (opts.disableParentScroll) {
                    opts.disableTarget = opts.parent.find("md-content");
                    if (!opts.disableTarget.length) opts.disableTarget = opts.parent;
                    opts.lastOverflow = opts.disableTarget.css("overflow");
                    opts.disableTarget.css("overflow", "hidden");
                }
                $timeout(activateInteraction, 75, false);
                if (opts.backdrop) {
                    $mdTheming.inherit(opts.backdrop, opts.parent);
                    opts.parent.append(opts.backdrop);
                }
                opts.parent.append(element);
                $$rAF(function() {
                    $$rAF(function() {
                        if (opts.isRemoved) return;
                        animateSelect(scope, element, opts);
                    });
                });
                return $mdUtil.transitionEndPromise(opts.selectEl, {
                    timeout: 350
                });
                function configureAria() {
                    opts.selectEl.attr("aria-labelledby", opts.target.attr("id"));
                    opts.target.attr("aria-owns", opts.selectEl.attr("id"));
                    opts.target.attr("aria-expanded", "true");
                }
                function activateInteraction() {
                    if (opts.isRemoved) return;
                    var selectCtrl = opts.selectEl.controller("mdSelectMenu") || {};
                    element.addClass("md-clickable");
                    opts.backdrop && opts.backdrop.on("click", function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        opts.restoreFocus = false;
                        scope.$apply($mdSelect.cancel);
                    });
                    opts.selectEl.on("keydown", function(ev) {
                        switch (ev.keyCode) {
                          case $mdConstant.KEY_CODE.SPACE:
                          case $mdConstant.KEY_CODE.ENTER:
                            var option = $mdUtil.getClosest(ev.target, "md-option");
                            if (option) {
                                opts.selectEl.triggerHandler({
                                    type: "click",
                                    target: option
                                });
                                ev.preventDefault();
                            }
                            break;

                          case $mdConstant.KEY_CODE.TAB:
                          case $mdConstant.KEY_CODE.ESCAPE:
                            ev.preventDefault();
                            opts.restoreFocus = true;
                            scope.$apply($mdSelect.cancel);
                        }
                    });
                    opts.selectEl.on("keydown", function(ev) {
                        switch (ev.keyCode) {
                          case $mdConstant.KEY_CODE.UP_ARROW:
                            return focusPrevOption();

                          case $mdConstant.KEY_CODE.DOWN_ARROW:
                            return focusNextOption();
                        }
                    });
                    function focusOption(direction) {
                        var optionsArray = nodesToArray(optionNodes);
                        var index = optionsArray.indexOf(opts.focusedNode);
                        if (index === -1) {
                            index = 0;
                        } else if (direction === "next" && index < optionsArray.length - 1) {
                            index++;
                        } else if (direction === "prev" && index > 0) {
                            index--;
                        }
                        var newOption = opts.focusedNode = optionsArray[index];
                        newOption && newOption.focus();
                    }
                    function focusNextOption() {
                        focusOption("next");
                    }
                    function focusPrevOption() {
                        focusOption("prev");
                    }
                    if (!selectCtrl.isMultiple) {
                        opts.selectEl.on("click", closeMenu);
                        opts.selectEl.on("keydown", function(e) {
                            if (e.keyCode == 32 || e.keyCode == 13) {
                                closeMenu();
                            }
                        });
                    }
                    function closeMenu() {
                        opts.restoreFocus = true;
                        scope.$evalAsync(function() {
                            $mdSelect.hide(selectCtrl.ngModel.$viewValue);
                        });
                    }
                }
            }
            function onRemove(scope, element, opts) {
                opts.isRemoved = true;
                element.addClass("md-leave").removeClass("md-clickable");
                opts.target.attr("aria-expanded", "false");
                if (opts.disableParentScroll && $mdUtil.floatingScrollbars()) {
                    opts.disableTarget.css("overflow", opts.lastOverflow);
                    delete opts.lastOverflow;
                    delete opts.disableTarget;
                }
                var mdSelect = opts.selectEl.controller("mdSelect");
                if (mdSelect) {
                    mdSelect.setLabelText(opts.selectEl.controller("mdSelectMenu").selectedLabels());
                }
                return $mdUtil.transitionEndPromise(element, {
                    timeout: 350
                }).then(function() {
                    element.removeClass("md-active");
                    opts.parent[0].removeChild(element[0]);
                    opts.backdrop && opts.backdrop.remove();
                    if (opts.restoreFocus) opts.target.focus();
                });
            }
            function animateSelect(scope, element, opts) {
                var containerNode = element[0], targetNode = opts.target[0], parentNode = opts.parent[0], selectNode = opts.selectEl[0], contentNode = opts.contentEl[0], parentRect = parentNode.getBoundingClientRect(), targetRect = $mdUtil.clientRect(targetNode, parentNode), shouldOpenAroundTarget = false, bounds = {
                    left: parentNode.scrollLeft + SELECT_EDGE_MARGIN,
                    top: parentNode.scrollTop + SELECT_EDGE_MARGIN,
                    bottom: parentRect.height + parentNode.scrollTop - SELECT_EDGE_MARGIN,
                    right: parentRect.width - SELECT_EDGE_MARGIN
                }, spaceAvailable = {
                    top: targetRect.top - bounds.top,
                    left: targetRect.left - bounds.left,
                    right: bounds.right - (targetRect.left + targetRect.width),
                    bottom: bounds.bottom - (targetRect.top + targetRect.height)
                }, maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2, isScrollable = contentNode.scrollHeight > contentNode.offsetHeight, selectedNode = selectNode.querySelector("md-option[selected]"), optionNodes = selectNode.getElementsByTagName("md-option"), optgroupNodes = selectNode.getElementsByTagName("md-optgroup");
                var centeredNode;
                if (selectedNode) {
                    centeredNode = selectedNode;
                } else if (optgroupNodes.length) {
                    centeredNode = optgroupNodes[0];
                } else if (optionNodes.length) {
                    centeredNode = optionNodes[0];
                } else {
                    centeredNode = contentNode.firstElementChild || contentNode;
                }
                if (contentNode.offsetWidth > maxWidth) {
                    contentNode.style["max-width"] = maxWidth + "px";
                }
                if (shouldOpenAroundTarget) {
                    contentNode.style["min-width"] = targetRect.width + "px";
                }
                if (isScrollable) {
                    selectNode.classList.add("md-overflow");
                }
                var selectMenuRect = selectNode.getBoundingClientRect();
                var centeredRect = getOffsetRect(centeredNode);
                if (centeredNode) {
                    var centeredStyle = window.getComputedStyle(centeredNode);
                    centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
                    centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
                }
                var focusedNode = centeredNode;
                if ((focusedNode.tagName || "").toUpperCase() === "MD-OPTGROUP") {
                    focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
                }
                if (focusedNode) {
                    opts.focusedNode = focusedNode;
                    focusedNode.focus();
                }
                if (isScrollable) {
                    var scrollBuffer = contentNode.offsetHeight / 2;
                    contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
                    if (spaceAvailable.top < scrollBuffer) {
                        contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top);
                    } else if (spaceAvailable.bottom < scrollBuffer) {
                        contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom);
                    }
                }
                var left, top, transformOrigin;
                if (shouldOpenAroundTarget) {
                    left = targetRect.left;
                    top = targetRect.top + targetRect.height;
                    transformOrigin = "50% 0";
                    if (top + selectMenuRect.height > bounds.bottom) {
                        top = targetRect.top - selectMenuRect.height;
                        transformOrigin = "50% 100%";
                    }
                } else {
                    left = targetRect.left + centeredRect.left - centeredRect.paddingLeft;
                    top = targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop;
                    transformOrigin = centeredRect.left + targetRect.width / 2 + "px " + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + "px 0px";
                    containerNode.style.minWidth = targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight + "px";
                }
                var containerRect = containerNode.getBoundingClientRect();
                containerNode.style.left = clamp(bounds.left, left, bounds.right - containerRect.width) + "px";
                containerNode.style.top = clamp(bounds.top, top, bounds.bottom - containerRect.height) + "px";
                selectNode.style[$mdConstant.CSS.TRANSFORM_ORIGIN] = transformOrigin;
                selectNode.style[$mdConstant.CSS.TRANSFORM] = "scale(" + Math.min(targetRect.width / selectMenuRect.width, 1) + "," + Math.min(targetRect.height / selectMenuRect.height, 1) + ")";
                $$rAF(function() {
                    element.addClass("md-active");
                    selectNode.style[$mdConstant.CSS.TRANSFORM] = "";
                });
            }
        }
        function clamp(min, n, max) {
            return Math.min(max, Math.max(n, min));
        }
        function getOffsetRect(node) {
            return node ? {
                left: node.offsetLeft,
                top: node.offsetTop,
                width: node.offsetWidth,
                height: node.offsetHeight
            } : {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
        }
    }
    SelectProvider.$inject = [ "$$interimElementProvider" ];
    function nodesToArray(nodes) {
        var results = [];
        for (var i = 0; i < nodes.length; ++i) {
            results.push(nodes.item(i));
        }
        return results;
    }
})();

(function() {
    "use strict";
    angular.module("material.components.sidenav", [ "material.core", "material.components.backdrop" ]).factory("$mdSidenav", SidenavService).directive("mdSidenav", SidenavDirective).controller("$mdSidenavController", SidenavController);
    function SidenavService($mdComponentRegistry, $q) {
        return function(handle) {
            var errorMsg = "SideNav '" + handle + "' is not available!";
            var instance = $mdComponentRegistry.get(handle);
            if (!instance) {
                $mdComponentRegistry.notFoundError(handle);
            }
            return {
                isOpen: function() {
                    return instance && instance.isOpen();
                },
                isLockedOpen: function() {
                    return instance && instance.isLockedOpen();
                },
                toggle: function() {
                    return instance ? instance.toggle() : $q.reject(errorMsg);
                },
                open: function() {
                    return instance ? instance.open() : $q.reject(errorMsg);
                },
                close: function() {
                    return instance ? instance.close() : $q.reject(errorMsg);
                }
            };
        };
    }
    SidenavService.$inject = [ "$mdComponentRegistry", "$q" ];
    function SidenavDirective($timeout, $animate, $parse, $log, $mdMedia, $mdConstant, $compile, $mdTheming, $q, $document) {
        return {
            restrict: "E",
            scope: {
                isOpen: "=?mdIsOpen"
            },
            controller: "$mdSidenavController",
            compile: function(element) {
                element.addClass("md-closed");
                element.attr("tabIndex", "-1");
                return postLink;
            }
        };
        function postLink(scope, element, attr, sidenavCtrl) {
            var triggeringElement = null;
            var promise = $q.when(true);
            var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
            var isLocked = function() {
                return isLockedOpenParsed(scope.$parent, {
                    $media: function(arg) {
                        $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
                        return $mdMedia(arg);
                    },
                    $mdMedia: $mdMedia
                });
            };
            var backdrop = $compile('<md-backdrop class="md-sidenav-backdrop md-opaque ng-enter">')(scope);
            element.on("$destroy", sidenavCtrl.destroy);
            $mdTheming.inherit(backdrop, element);
            scope.$watch(isLocked, updateIsLocked);
            scope.$watch("isOpen", updateIsOpen);
            sidenavCtrl.$toggleOpen = toggleOpen;
            function updateIsLocked(isLocked, oldValue) {
                scope.isLockedOpen = isLocked;
                if (isLocked === oldValue) {
                    element.toggleClass("md-locked-open", !!isLocked);
                } else {
                    $animate[isLocked ? "addClass" : "removeClass"](element, "md-locked-open");
                }
                backdrop.toggleClass("md-locked-open", !!isLocked);
            }
            function updateIsOpen(isOpen) {
                var parent = element.parent();
                parent[isOpen ? "on" : "off"]("keydown", onKeyDown);
                backdrop[isOpen ? "on" : "off"]("click", close);
                if (isOpen) {
                    triggeringElement = $document[0].activeElement;
                }
                return promise = $q.all([ $animate[isOpen ? "enter" : "leave"](backdrop, parent), $animate[isOpen ? "removeClass" : "addClass"](element, "md-closed").then(function() {
                    if (scope.isOpen) {
                        element.focus();
                    }
                }) ]);
            }
            function toggleOpen(isOpen) {
                if (scope.isOpen == isOpen) {
                    return $q.when(true);
                } else {
                    var deferred = $q.defer();
                    scope.isOpen = isOpen;
                    $timeout(function() {
                        promise.then(function(result) {
                            if (!scope.isOpen) {
                                triggeringElement && triggeringElement.focus();
                                triggeringElement = null;
                            }
                            deferred.resolve(result);
                        });
                    }, 0, false);
                    return deferred.promise;
                }
            }
            function onKeyDown(ev) {
                var isEscape = ev.keyCode === $mdConstant.KEY_CODE.ESCAPE;
                return isEscape ? close(ev) : $q.when(true);
            }
            function close(ev) {
                ev.preventDefault();
                ev.stopPropagation();
                return sidenavCtrl.close();
            }
        }
    }
    SidenavDirective.$inject = [ "$timeout", "$animate", "$parse", "$log", "$mdMedia", "$mdConstant", "$compile", "$mdTheming", "$q", "$document" ];
    function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
        var self = this;
        self.$toggleOpen = function() {
            return $q.when($scope.isOpen);
        };
        self.isOpen = function() {
            return !!$scope.isOpen;
        };
        self.isLockedOpen = function() {
            return !!$scope.isLockedOpen;
        };
        self.open = function() {
            return self.$toggleOpen(true);
        };
        self.close = function() {
            return self.$toggleOpen(false);
        };
        self.toggle = function() {
            return self.$toggleOpen(!$scope.isOpen);
        };
        self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
    }
    SidenavController.$inject = [ "$scope", "$element", "$attrs", "$mdComponentRegistry", "$q" ];
})();

(function() {
    "use strict";
    angular.module("material.components.slider", [ "material.core" ]).directive("mdSlider", SliderDirective);
    function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse) {
        return {
            scope: {},
            require: "?ngModel",
            template: '<div class="md-slider-wrapper">        <div class="md-track-container">          <div class="md-track"></div>          <div class="md-track md-track-fill"></div>          <div class="md-track-ticks"></div>        </div>        <div class="md-thumb-container">          <div class="md-thumb"></div>          <div class="md-focus-thumb"></div>          <div class="md-focus-ring"></div>          <div class="md-sign">            <span class="md-thumb-text"></span>          </div>          <div class="md-disabled-thumb"></div>        </div>      </div>',
            compile: compile
        };
        function compile(tElement, tAttrs) {
            tElement.attr({
                tabIndex: 0,
                role: "slider"
            });
            $mdAria.expect(tElement, "aria-label");
            return postLink;
        }
        function postLink(scope, element, attr, ngModelCtrl) {
            $mdTheming(element);
            ngModelCtrl = ngModelCtrl || {
                $setViewValue: function(val) {
                    this.$viewValue = val;
                    this.$viewChangeListeners.forEach(function(cb) {
                        cb();
                    });
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: []
            };
            var isDisabledParsed = attr.ngDisabled && $parse(attr.ngDisabled);
            var isDisabledGetter = isDisabledParsed ? function() {
                return isDisabledParsed(scope.$parent);
            } : angular.noop;
            var thumb = angular.element(element[0].querySelector(".md-thumb"));
            var thumbText = angular.element(element[0].querySelector(".md-thumb-text"));
            var thumbContainer = thumb.parent();
            var trackContainer = angular.element(element[0].querySelector(".md-track-container"));
            var activeTrack = angular.element(element[0].querySelector(".md-track-fill"));
            var tickContainer = angular.element(element[0].querySelector(".md-track-ticks"));
            var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5e3);
            attr.min ? attr.$observe("min", updateMin) : updateMin(0);
            attr.max ? attr.$observe("max", updateMax) : updateMax(100);
            attr.step ? attr.$observe("step", updateStep) : updateStep(1);
            var stopDisabledWatch = angular.noop;
            if (attr.ngDisabled) {
                stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);
            }
            $mdGesture.register(element, "drag");
            element.on("keydown", keydownListener).on("$md.pressdown", onPressDown).on("$md.pressup", onPressUp).on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
            function updateAll() {
                refreshSliderDimensions();
                ngModelRender();
                redrawTicks();
            }
            setTimeout(updateAll);
            var debouncedUpdateAll = $$rAF.throttle(updateAll);
            angular.element($window).on("resize", debouncedUpdateAll);
            scope.$on("$destroy", function() {
                angular.element($window).off("resize", debouncedUpdateAll);
                stopDisabledWatch();
            });
            ngModelCtrl.$render = ngModelRender;
            ngModelCtrl.$viewChangeListeners.push(ngModelRender);
            ngModelCtrl.$formatters.push(minMaxValidator);
            ngModelCtrl.$formatters.push(stepValidator);
            var min;
            var max;
            var step;
            function updateMin(value) {
                min = parseFloat(value);
                element.attr("aria-valuemin", value);
                updateAll();
            }
            function updateMax(value) {
                max = parseFloat(value);
                element.attr("aria-valuemax", value);
                updateAll();
            }
            function updateStep(value) {
                step = parseFloat(value);
                redrawTicks();
            }
            function updateAriaDisabled(isDisabled) {
                element.attr("aria-disabled", !!isDisabled);
            }
            var tickCanvas, tickCtx;
            function redrawTicks() {
                if (!angular.isDefined(attr.mdDiscrete)) return;
                var numSteps = Math.floor((max - min) / step);
                if (!tickCanvas) {
                    var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                    tickCanvas = angular.element('<canvas style="position:absolute;">');
                    tickCtx = tickCanvas[0].getContext("2d");
                    tickCtx.fillStyle = trackTicksStyle.backgroundColor || "black";
                    tickContainer.append(tickCanvas);
                }
                var dimensions = getSliderDimensions();
                tickCanvas[0].width = dimensions.width;
                tickCanvas[0].height = dimensions.height;
                var distance;
                for (var i = 0; i <= numSteps; i++) {
                    distance = Math.floor(dimensions.width * (i / numSteps));
                    tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);
                }
            }
            var sliderDimensions = {};
            refreshSliderDimensions();
            function refreshSliderDimensions() {
                sliderDimensions = trackContainer[0].getBoundingClientRect();
            }
            function getSliderDimensions() {
                throttledRefreshDimensions();
                return sliderDimensions;
            }
            function keydownListener(ev) {
                if (element[0].hasAttribute("disabled")) {
                    return;
                }
                var changeAmount;
                if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                    changeAmount = -step;
                } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                    changeAmount = step;
                }
                if (changeAmount) {
                    if (ev.metaKey || ev.ctrlKey || ev.altKey) {
                        changeAmount *= 4;
                    }
                    ev.preventDefault();
                    ev.stopPropagation();
                    scope.$evalAsync(function() {
                        setModelValue(ngModelCtrl.$viewValue + changeAmount);
                    });
                }
            }
            function setModelValue(value) {
                ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
            }
            function ngModelRender() {
                if (isNaN(ngModelCtrl.$viewValue)) {
                    ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
                }
                var percent = (ngModelCtrl.$viewValue - min) / (max - min);
                scope.modelValue = ngModelCtrl.$viewValue;
                element.attr("aria-valuenow", ngModelCtrl.$viewValue);
                setSliderPercent(percent);
                thumbText.text(ngModelCtrl.$viewValue);
            }
            function minMaxValidator(value) {
                if (angular.isNumber(value)) {
                    return Math.max(min, Math.min(max, value));
                }
            }
            function stepValidator(value) {
                if (angular.isNumber(value)) {
                    return Math.round(value / step) * step;
                }
            }
            function setSliderPercent(percent) {
                activeTrack.css("width", percent * 100 + "%");
                thumbContainer.css("left", percent * 100 + "%");
                element.toggleClass("md-min", percent === 0);
            }
            var isDragging = false;
            var isDiscrete = angular.isDefined(attr.mdDiscrete);
            function onPressDown(ev) {
                if (isDisabledGetter()) return;
                element.addClass("active");
                element[0].focus();
                refreshSliderDimensions();
                var exactVal = percentToValue(positionToPercent(ev.pointer.x));
                var closestVal = minMaxValidator(stepValidator(exactVal));
                scope.$apply(function() {
                    setModelValue(closestVal);
                    setSliderPercent(valueToPercent(closestVal));
                });
            }
            function onPressUp(ev) {
                if (isDisabledGetter()) return;
                element.removeClass("dragging active");
                var exactVal = percentToValue(positionToPercent(ev.pointer.x));
                var closestVal = minMaxValidator(stepValidator(exactVal));
                scope.$apply(function() {
                    setModelValue(closestVal);
                    ngModelRender();
                });
            }
            function onDragStart(ev) {
                if (isDisabledGetter()) return;
                isDragging = true;
                ev.stopPropagation();
                element.addClass("dragging");
                setSliderFromEvent(ev);
            }
            function onDrag(ev) {
                if (!isDragging) return;
                ev.stopPropagation();
                setSliderFromEvent(ev);
            }
            function onDragEnd(ev) {
                if (!isDragging) return;
                ev.stopPropagation();
                isDragging = false;
            }
            function setSliderFromEvent(ev) {
                if (isDiscrete) adjustThumbPosition(ev.pointer.x); else doSlide(ev.pointer.x);
            }
            function doSlide(x) {
                scope.$evalAsync(function() {
                    setModelValue(percentToValue(positionToPercent(x)));
                });
            }
            function adjustThumbPosition(x) {
                var exactVal = percentToValue(positionToPercent(x));
                var closestVal = minMaxValidator(stepValidator(exactVal));
                setSliderPercent(positionToPercent(x));
                thumbText.text(closestVal);
            }
            function positionToPercent(x) {
                return Math.max(0, Math.min(1, (x - sliderDimensions.left) / sliderDimensions.width));
            }
            function percentToValue(percent) {
                return min + percent * (max - min);
            }
            function valueToPercent(val) {
                return (val - min) / (max - min);
            }
        }
    }
    SliderDirective.$inject = [ "$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse" ];
})();

(function() {
    "use strict";
    angular.module("material.components.sticky", [ "material.core", "material.components.content" ]).factory("$mdSticky", MdSticky);
    function MdSticky($document, $mdConstant, $compile, $$rAF, $mdUtil) {
        var browserStickySupport = checkStickySupport();
        return function registerStickyElement(scope, element, stickyClone) {
            var contentCtrl = element.controller("mdContent");
            if (!contentCtrl) return;
            if (browserStickySupport) {
                element.css({
                    position: browserStickySupport,
                    top: 0,
                    "z-index": 2
                });
            } else {
                var $$sticky = contentCtrl.$element.data("$$sticky");
                if (!$$sticky) {
                    $$sticky = setupSticky(contentCtrl);
                    contentCtrl.$element.data("$$sticky", $$sticky);
                }
                var deregister = $$sticky.add(element, stickyClone || element.clone());
                scope.$on("$destroy", deregister);
            }
        };
        function setupSticky(contentCtrl) {
            var contentEl = contentCtrl.$element;
            var debouncedRefreshElements = $$rAF.throttle(refreshElements);
            setupAugmentedScrollEvents(contentEl);
            contentEl.on("$scrollstart", debouncedRefreshElements);
            contentEl.on("$scroll", onScroll);
            var self;
            var stickyBaseoffset = contentEl.prop("offsetTop");
            return self = {
                prev: null,
                current: null,
                next: null,
                items: [],
                add: add,
                refreshElements: refreshElements
            };
            function add(element, stickyClone) {
                stickyClone.addClass("md-sticky-clone");
                stickyClone.css("top", stickyBaseoffset + "px");
                var item = {
                    element: element,
                    clone: stickyClone
                };
                self.items.push(item);
                contentEl.parent().prepend(item.clone);
                debouncedRefreshElements();
                return function remove() {
                    self.items.forEach(function(item, index) {
                        if (item.element[0] === element[0]) {
                            self.items.splice(index, 1);
                            item.clone.remove();
                        }
                    });
                    debouncedRefreshElements();
                };
            }
            function refreshElements() {
                self.items.forEach(refreshPosition);
                self.items = self.items.sort(function(a, b) {
                    return a.top < b.top ? -1 : 1;
                });
                var item;
                var currentScrollTop = contentEl.prop("scrollTop");
                for (var i = self.items.length - 1; i >= 0; i--) {
                    if (currentScrollTop > self.items[i].top) {
                        item = self.items[i];
                        break;
                    }
                }
                setCurrentItem(item);
            }
            function refreshPosition(item) {
                var current = item.element[0];
                item.top = 0;
                item.left = 0;
                while (current && current !== contentEl[0]) {
                    item.top += current.offsetTop;
                    item.left += current.offsetLeft;
                    current = current.offsetParent;
                }
                item.height = item.element.prop("offsetHeight");
                item.clone.css("margin-left", item.left + "px");
            }
            function onScroll() {
                var scrollTop = contentEl.prop("scrollTop");
                var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
                onScroll.prevScrollTop = scrollTop;
                if (scrollTop === 0) {
                    setCurrentItem(null);
                } else if (isScrollingDown && self.next) {
                    if (self.next.top - scrollTop <= 0) {
                        setCurrentItem(self.next);
                    } else if (self.current) {
                        if (self.next.top - scrollTop <= self.next.height) {
                            translate(self.current, self.next.top - self.next.height - scrollTop);
                        } else {
                            translate(self.current, null);
                        }
                    }
                } else if (!isScrollingDown && self.current) {
                    if (scrollTop < self.current.top) {
                        setCurrentItem(self.prev);
                    }
                    if (self.current && self.next) {
                        if (scrollTop >= self.next.top - self.current.height) {
                            translate(self.current, self.next.top - scrollTop - self.current.height);
                        } else {
                            translate(self.current, null);
                        }
                    }
                }
            }
            function setCurrentItem(item) {
                if (self.current === item) return;
                if (self.current) {
                    translate(self.current, null);
                    setStickyState(self.current, null);
                }
                if (item) {
                    setStickyState(item, "active");
                }
                self.current = item;
                var index = self.items.indexOf(item);
                self.next = self.items[index + 1];
                self.prev = self.items[index - 1];
                setStickyState(self.next, "next");
                setStickyState(self.prev, "prev");
            }
            function setStickyState(item, state) {
                if (!item || item.state === state) return;
                if (item.state) {
                    item.clone.attr("sticky-prev-state", item.state);
                    item.element.attr("sticky-prev-state", item.state);
                }
                item.clone.attr("sticky-state", state);
                item.element.attr("sticky-state", state);
                item.state = state;
            }
            function translate(item, amount) {
                if (!item) return;
                if (amount === null || amount === undefined) {
                    if (item.translateY) {
                        item.translateY = null;
                        item.clone.css($mdConstant.CSS.TRANSFORM, "");
                    }
                } else {
                    item.translateY = amount;
                    item.clone.css($mdConstant.CSS.TRANSFORM, "translate3d(" + item.left + "px," + amount + "px,0)");
                }
            }
        }
        function checkStickySupport($el) {
            var stickyProp;
            var testEl = angular.element("<div>");
            $document[0].body.appendChild(testEl[0]);
            var stickyProps = [ "sticky", "-webkit-sticky" ];
            for (var i = 0; i < stickyProps.length; ++i) {
                testEl.css({
                    position: stickyProps[i],
                    top: 0,
                    "z-index": 2
                });
                if (testEl.css("position") == stickyProps[i]) {
                    stickyProp = stickyProps[i];
                    break;
                }
            }
            testEl.remove();
            return stickyProp;
        }
        function setupAugmentedScrollEvents(element) {
            var SCROLL_END_DELAY = 200;
            var isScrolling;
            var lastScrollTime;
            element.on("scroll touchmove", function() {
                if (!isScrolling) {
                    isScrolling = true;
                    $$rAF(loopScrollEvent);
                    element.triggerHandler("$scrollstart");
                }
                element.triggerHandler("$scroll");
                lastScrollTime = +$mdUtil.now();
            });
            function loopScrollEvent() {
                if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                    isScrolling = false;
                    element.triggerHandler("$scrollend");
                } else {
                    element.triggerHandler("$scroll");
                    $$rAF(loopScrollEvent);
                }
            }
        }
    }
    MdSticky.$inject = [ "$document", "$mdConstant", "$compile", "$$rAF", "$mdUtil" ];
})();

(function() {
    "use strict";
    angular.module("material.components.subheader", [ "material.core", "material.components.sticky" ]).directive("mdSubheader", MdSubheaderDirective);
    function MdSubheaderDirective($mdSticky, $compile, $mdTheming) {
        return {
            restrict: "E",
            replace: true,
            transclude: true,
            template: '<h2 class="md-subheader">' + '<span class="md-subheader-content"></span>' + "</h2>",
            compile: function(element, attr, transclude) {
                var outerHTML = element[0].outerHTML;
                return function postLink(scope, element, attr) {
                    $mdTheming(element);
                    function getContent(el) {
                        return angular.element(el[0].querySelector(".md-subheader-content"));
                    }
                    transclude(scope, function(clone) {
                        getContent(element).append(clone);
                    });
                    transclude(scope, function(clone) {
                        var stickyClone = $compile(angular.element(outerHTML))(scope);
                        $mdTheming(stickyClone);
                        getContent(stickyClone).append(clone);
                        $mdSticky(scope, element, stickyClone);
                    });
                };
            }
        };
    }
    MdSubheaderDirective.$inject = [ "$mdSticky", "$compile", "$mdTheming" ];
})();

(function() {
    "use strict";
    var module = angular.module("material.components.swipe", []);
    [ "SwipeLeft", "SwipeRight" ].forEach(function(name) {
        var directiveName = "md" + name;
        var eventName = "$md." + name.toLowerCase();
        module.directive(directiveName, [ "$parse", function($parse) {
            return {
                restrict: "A",
                link: postLink
            };
            function postLink(scope, element, attr) {
                var fn = $parse(attr[directiveName]);
                element.on(eventName, function(ev) {
                    scope.$apply(function() {
                        fn(scope, {
                            $event: ev
                        });
                    });
                });
            }
        } ]);
    });
})();

(function() {
    "use strict";
    angular.module("material.components.switch", [ "material.core", "material.components.checkbox" ]).directive("mdSwitch", MdSwitch);
    function MdSwitch(mdCheckboxDirective, $mdTheming, $mdUtil, $document, $mdConstant, $parse, $$rAF, $mdGesture) {
        var checkboxDirective = mdCheckboxDirective[0];
        return {
            restrict: "E",
            transclude: true,
            template: '<div class="md-container">' + '<div class="md-bar"></div>' + '<div class="md-thumb-container">' + '<div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' + "</div>" + "</div>" + '<div ng-transclude class="md-label">' + "</div>",
            require: "?ngModel",
            compile: compile
        };
        function compile(element, attr) {
            var checkboxLink = checkboxDirective.compile(element, attr);
            element.addClass("md-dragging");
            return function(scope, element, attr, ngModel) {
                ngModel = ngModel || $mdUtil.fakeNgModel();
                var disabledGetter = $parse(attr.ngDisabled);
                var thumbContainer = angular.element(element[0].querySelector(".md-thumb-container"));
                var switchContainer = angular.element(element[0].querySelector(".md-container"));
                $$rAF(function() {
                    element.removeClass("md-dragging");
                });
                checkboxLink(scope, element, attr, ngModel);
                if (angular.isDefined(attr.ngDisabled)) {
                    scope.$watch(disabledGetter, function(isDisabled) {
                        element.attr("tabindex", isDisabled ? -1 : 0);
                    });
                }
                $mdGesture.register(switchContainer, "drag");
                switchContainer.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                var drag;
                function onDragStart(ev) {
                    if (disabledGetter(scope)) return;
                    ev.stopPropagation();
                    element.addClass("md-dragging");
                    drag = {
                        width: thumbContainer.prop("offsetWidth")
                    };
                    element.removeClass("transition");
                }
                function onDrag(ev) {
                    if (!drag) return;
                    ev.stopPropagation();
                    ev.srcEvent && ev.srcEvent.preventDefault();
                    var percent = ev.pointer.distanceX / drag.width;
                    var translate = ngModel.$viewValue ? 1 + percent : percent;
                    translate = Math.max(0, Math.min(1, translate));
                    thumbContainer.css($mdConstant.CSS.TRANSFORM, "translate3d(" + 100 * translate + "%,0,0)");
                    drag.translate = translate;
                }
                function onDragEnd(ev) {
                    if (!drag) return;
                    ev.stopPropagation();
                    element.removeClass("md-dragging");
                    thumbContainer.css($mdConstant.CSS.TRANSFORM, "");
                    var isChanged = ngModel.$viewValue ? drag.translate < .5 : drag.translate > .5;
                    if (isChanged) {
                        applyModelValue(!ngModel.$viewValue);
                    }
                    drag = null;
                }
                function applyModelValue(newValue) {
                    scope.$apply(function() {
                        ngModel.$setViewValue(newValue);
                        ngModel.$render();
                    });
                }
            };
        }
    }
    MdSwitch.$inject = [ "mdCheckboxDirective", "$mdTheming", "$mdUtil", "$document", "$mdConstant", "$parse", "$$rAF", "$mdGesture" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs", [ "material.core", "material.components.icon" ]);
})();

(function() {
    "use strict";
    angular.module("material.components.textField", [ "material.core" ]).directive("mdInputGroup", mdInputGroupDirective).directive("mdInput", mdInputDirective).directive("mdTextFloat", mdTextFloatDirective);
    function mdTextFloatDirective($mdTheming, $mdUtil, $parse, $log) {
        return {
            restrict: "E",
            replace: true,
            scope: {
                fid: "@?mdFid",
                label: "@?",
                value: "=ngModel"
            },
            compile: function(element, attr) {
                $log.warn("<md-text-float> is deprecated. Please use `<md-input-container>` and `<input>`." + "More information at http://material.angularjs.org/#/api/material.components.input/directive/mdInputContainer");
                if (angular.isUndefined(attr.mdFid)) {
                    attr.mdFid = $mdUtil.nextUid();
                }
                return {
                    pre: function(scope, element, attrs) {
                        var disabledParsed = $parse(attrs.ngDisabled);
                        scope.isDisabled = function() {
                            return disabledParsed(scope.$parent);
                        };
                        scope.inputType = attrs.type || "text";
                    },
                    post: $mdTheming
                };
            },
            template: '<md-input-group tabindex="-1">' + ' <label for="{{fid}}" >{{label}}</label>' + ' <md-input id="{{fid}}" ng-disabled="isDisabled()" ng-model="value" type="{{inputType}}"></md-input>' + "</md-input-group>"
        };
    }
    mdTextFloatDirective.$inject = [ "$mdTheming", "$mdUtil", "$parse", "$log" ];
    function mdInputGroupDirective($log) {
        return {
            restrict: "CE",
            controller: [ "$element", function($element) {
                $log.warn("<md-input-group> is deprecated. Please use `<md-input-container>` and `<input>`." + "More information at http://material.angularjs.org/#/api/material.components.input/directive/mdInputContainer");
                this.setFocused = function(isFocused) {
                    $element.toggleClass("md-input-focused", !!isFocused);
                };
                this.setHasValue = function(hasValue) {
                    $element.toggleClass("md-input-has-value", hasValue);
                };
            } ]
        };
    }
    mdInputGroupDirective.$inject = [ "$log" ];
    function mdInputDirective($mdUtil, $log) {
        return {
            restrict: "E",
            replace: true,
            template: "<input >",
            require: [ "^?mdInputGroup", "?ngModel" ],
            link: function(scope, element, attr, ctrls) {
                if (!ctrls[0]) return;
                $log.warn("<md-input> is deprecated. Please use `<md-input-container>` and `<input>`." + "More information at http://material.angularjs.org/#/api/material.components.input/directive/mdInputContainer");
                var inputGroupCtrl = ctrls[0];
                var ngModelCtrl = ctrls[1];
                scope.$watch(scope.isDisabled, function(isDisabled) {
                    element.attr("aria-disabled", !!isDisabled);
                    element.attr("tabindex", !!isDisabled);
                });
                element.attr("type", attr.type || element.parent().attr("type") || "text");
                if (ngModelCtrl) {
                    ngModelCtrl.$formatters.push(function(value) {
                        inputGroupCtrl.setHasValue(isNotEmpty(value));
                        return value;
                    });
                }
                element.on("input", function() {
                    inputGroupCtrl.setHasValue(isNotEmpty());
                }).on("focus", function(e) {
                    inputGroupCtrl.setFocused(true);
                }).on("blur", function(e) {
                    inputGroupCtrl.setFocused(false);
                    inputGroupCtrl.setHasValue(isNotEmpty());
                });
                scope.$on("$destroy", function() {
                    inputGroupCtrl.setFocused(false);
                    inputGroupCtrl.setHasValue(false);
                });
                function isNotEmpty(value) {
                    value = angular.isUndefined(value) ? element.val() : value;
                    return angular.isDefined(value) && value !== null && value.toString().trim() !== "";
                }
            }
        };
    }
    mdInputDirective.$inject = [ "$mdUtil", "$log" ];
})();

(function() {
    "use strict";
    angular.module("material.components.toast", [ "material.core", "material.components.button" ]).directive("mdToast", MdToastDirective).provider("$mdToast", MdToastProvider);
    function MdToastDirective() {
        return {
            restrict: "E"
        };
    }
    function MdToastProvider($$interimElementProvider) {
        var activeToastContent;
        var $mdToast = $$interimElementProvider("$mdToast").setDefaults({
            methods: [ "position", "hideDelay", "capsule" ],
            options: toastDefaultOptions
        }).addPreset("simple", {
            argOption: "content",
            methods: [ "content", "action", "highlightAction", "theme" ],
            options: [ "$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
                var opts = {
                    template: [ '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">', "<span flex>{{ toast.content }}</span>", '<md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-highlight\': toast.highlightAction}">', "{{ toast.action }}", "</md-button>", "</md-toast>" ].join(""),
                    controller: [ "$scope", function mdToastCtrl($scope) {
                        var self = this;
                        $scope.$watch(function() {
                            return activeToastContent;
                        }, function() {
                            self.content = activeToastContent;
                        });
                        this.resolve = function() {
                            $mdToast.hide();
                        };
                    } ],
                    theme: $mdTheming.defaultTheme(),
                    controllerAs: "toast",
                    bindToController: true
                };
                return opts;
            } ]
        }).addMethod("updateContent", function(newContent) {
            activeToastContent = newContent;
        });
        toastDefaultOptions.$inject = [ "$timeout", "$animate", "$mdToast" ];
        return $mdToast;
        function toastDefaultOptions($timeout, $animate, $mdToast) {
            return {
                onShow: onShow,
                onRemove: onRemove,
                position: "bottom left",
                themable: true,
                hideDelay: 3e3
            };
            function onShow(scope, element, options) {
                activeToastContent = options.content;
                element.addClass(options.position.split(" ").map(function(pos) {
                    return "md-" + pos;
                }).join(" "));
                options.parent.addClass(toastOpenClass(options.position));
                options.onSwipe = function(ev, gesture) {
                    element.addClass("md-" + ev.type.replace("$md.", ""));
                    $timeout($mdToast.cancel);
                };
                element.on("$md.swipeleft $md.swiperight", options.onSwipe);
                return $animate.enter(element, options.parent);
            }
            function onRemove(scope, element, options) {
                element.off("$md.swipeleft $md.swiperight", options.onSwipe);
                options.parent.removeClass(toastOpenClass(options.position));
                return $animate.leave(element);
            }
            function toastOpenClass(position) {
                return "md-toast-open-" + (position.indexOf("top") > -1 ? "top" : "bottom");
            }
        }
    }
    MdToastProvider.$inject = [ "$$interimElementProvider" ];
})();

(function() {
    "use strict";
    angular.module("material.components.toolbar", [ "material.core", "material.components.content" ]).directive("mdToolbar", mdToolbarDirective);
    function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming) {
        return {
            restrict: "E",
            controller: angular.noop,
            link: function(scope, element, attr) {
                $mdTheming(element);
                if (angular.isDefined(attr.mdScrollShrink)) {
                    setupScrollShrink();
                }
                function setupScrollShrink() {
                    var y = 0;
                    var prevScrollTop = 0;
                    var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || .5;
                    var toolbarHeight;
                    var contentElement;
                    var debouncedContentScroll = $$rAF.throttle(onContentScroll);
                    var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1e3);
                    scope.$on("$mdContentLoaded", onMdContentLoad);
                    function onMdContentLoad($event, newContentEl) {
                        if (element.parent()[0] === newContentEl.parent()[0]) {
                            if (contentElement) {
                                contentElement.off("scroll", debouncedContentScroll);
                            }
                            newContentEl.on("scroll", debouncedContentScroll);
                            newContentEl.attr("scroll-shrink", "true");
                            contentElement = newContentEl;
                            $$rAF(updateToolbarHeight);
                        }
                    }
                    function updateToolbarHeight() {
                        toolbarHeight = element.prop("offsetHeight");
                        contentElement.css("margin-top", -toolbarHeight * shrinkSpeedFactor + "px");
                        onContentScroll();
                    }
                    function onContentScroll(e) {
                        var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                        debouncedUpdateHeight();
                        y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                        element.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + -y * shrinkSpeedFactor + "px,0)");
                        contentElement.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + (toolbarHeight - y) * shrinkSpeedFactor + "px,0)");
                        prevScrollTop = scrollTop;
                    }
                }
            }
        };
    }
    mdToolbarDirective.$inject = [ "$$rAF", "$mdConstant", "$mdUtil", "$mdTheming" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tooltip", [ "material.core" ]).directive("mdTooltip", MdTooltipDirective);
    function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q) {
        var TOOLTIP_SHOW_DELAY = 0;
        var TOOLTIP_WINDOW_EDGE_SPACE = 8;
        return {
            restrict: "E",
            transclude: true,
            template: '<div class="md-background"></div>' + '<div class="md-content" ng-transclude></div>',
            scope: {
                visible: "=?mdVisible",
                delay: "=?mdDelay"
            },
            link: postLink
        };
        function postLink(scope, element, attr, contentCtrl) {
            $mdTheming(element);
            var parent = element.parent();
            var background = angular.element(element[0].getElementsByClassName("md-background")[0]);
            var content = angular.element(element[0].getElementsByClassName("md-content")[0]);
            var direction = attr.mdDirection;
            while ($window.getComputedStyle(parent[0])["pointer-events"] == "none") {
                parent = parent.parent();
            }
            var current = element.parent()[0];
            while (current && current !== $rootElement[0] && current !== document.body) {
                if (current.tagName && current.tagName.toLowerCase() == "md-content") break;
                current = current.parentNode;
            }
            var tooltipParent = angular.element(current || document.body);
            if (!angular.isDefined(attr.mdDelay)) {
                scope.delay = TOOLTIP_SHOW_DELAY;
            }
            element.detach();
            element.attr("role", "tooltip");
            element.attr("id", attr.id || "tooltip_" + $mdUtil.nextUid());
            parent.on("focus mouseenter touchstart", function() {
                setVisible(true);
            });
            parent.on("blur mouseleave touchend touchcancel", function() {
                if ($document[0].activeElement !== parent[0]) setVisible(false);
            });
            scope.$watch("visible", function(isVisible) {
                if (isVisible) showTooltip(); else hideTooltip();
            });
            var debouncedOnResize = $$rAF.throttle(function() {
                if (scope.visible) positionTooltip();
            });
            angular.element($window).on("resize", debouncedOnResize);
            scope.$on("$destroy", function() {
                scope.visible = false;
                element.remove();
                angular.element($window).off("resize", debouncedOnResize);
            });
            function setVisible(value) {
                setVisible.value = !!value;
                if (!setVisible.queued) {
                    if (value) {
                        setVisible.queued = true;
                        $timeout(function() {
                            scope.visible = setVisible.value;
                            setVisible.queued = false;
                        }, scope.delay);
                    } else {
                        $timeout(function() {
                            scope.visible = false;
                        });
                    }
                }
            }
            function showTooltip() {
                parent.attr("aria-describedby", element.attr("id"));
                tooltipParent.append(element);
                positionTooltip();
                $animate.addClass(element, "md-show");
                $animate.addClass(background, "md-show");
                $animate.addClass(content, "md-show");
            }
            function hideTooltip() {
                parent.removeAttr("aria-describedby");
                $q.all([ $animate.removeClass(content, "md-show"), $animate.removeClass(background, "md-show"), $animate.removeClass(element, "md-show") ]).then(function() {
                    if (!scope.visible) element.detach();
                });
            }
            function positionTooltip() {
                var tipRect = $mdUtil.offsetRect(element, tooltipParent);
                var parentRect = $mdUtil.offsetRect(parent, tooltipParent);
                var newPosition = getPosition(direction);
                if (direction) {
                    newPosition = fitInParent(newPosition);
                } else if (newPosition.top > tooltipParent.prop("scrollHeight") - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {
                    newPosition = fitInParent(getPosition("top"));
                }
                element.css({
                    top: newPosition.top + "px",
                    left: newPosition.left + "px"
                });
                positionBackground();
                function positionBackground() {
                    var size = direction === "left" || direction === "right" ? Math.sqrt(Math.pow(tipRect.width, 2) + Math.pow(tipRect.height / 2, 2)) * 2 : Math.sqrt(Math.pow(tipRect.width / 2, 2) + Math.pow(tipRect.height, 2)) * 2, position = direction === "left" ? {
                        left: 100,
                        top: 50
                    } : direction === "right" ? {
                        left: 0,
                        top: 50
                    } : direction === "top" ? {
                        left: 50,
                        top: 100
                    } : {
                        left: 50,
                        top: 0
                    };
                    background.css({
                        width: size + "px",
                        height: size + "px",
                        left: position.left + "%",
                        top: position.top + "%"
                    });
                }
                function fitInParent(pos) {
                    var newPosition = {
                        left: pos.left,
                        top: pos.top
                    };
                    newPosition.left = Math.min(newPosition.left, tooltipParent.prop("scrollWidth") - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                    newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                    newPosition.top = Math.min(newPosition.top, tooltipParent.prop("scrollHeight") - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE);
                    newPosition.top = Math.max(newPosition.top, TOOLTIP_WINDOW_EDGE_SPACE);
                    return newPosition;
                }
                function getPosition(dir) {
                    return dir === "left" ? {
                        left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,
                        top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                    } : dir === "right" ? {
                        left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,
                        top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                    } : dir === "top" ? {
                        left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                        top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE
                    } : {
                        left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                        top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE
                    };
                }
            }
        }
    }
    MdTooltipDirective.$inject = [ "$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q" ];
})();

(function() {
    "use strict";
    angular.module("material.components.whiteframe", []);
})();

(function() {
    "use strict";
    angular.module("material.components.autocomplete").controller("MdAutocompleteCtrl", MdAutocompleteCtrl);
    function MdAutocompleteCtrl($scope, $element, $q, $mdUtil, $mdConstant) {
        var self = this, itemParts = $scope.itemsExpr.split(/ in /i), itemExpr = itemParts[1], elements = {
            main: $element[0],
            ul: $element[0].getElementsByTagName("ul")[0],
            input: $element[0].getElementsByTagName("input")[0]
        }, promise = null, cache = {}, noBlur = false;
        self.scope = $scope;
        self.parent = $scope.$parent;
        self.itemName = itemParts[0];
        self.matches = [];
        self.loading = false;
        self.hidden = true;
        self.index = 0;
        self.keydown = keydown;
        self.blur = blur;
        self.clear = clearValue;
        self.select = select;
        self.getCurrentDisplayValue = getCurrentDisplayValue;
        self.fetch = $mdUtil.debounce(fetchResults);
        self.messages = [];
        self.listEnter = function() {
            noBlur = true;
        };
        self.listLeave = function() {
            noBlur = false;
        };
        self.mouseUp = function() {
            elements.input.focus();
        };
        return init();
        function init() {
            configureWatchers();
            configureAria();
        }
        function configureAria() {
            var ul = angular.element(elements.ul), input = angular.element(elements.input), id = ul.attr("id") || "ul_" + $mdUtil.nextUid();
            ul.attr("id", id);
            input.attr("aria-owns", id);
        }
        function getItemScope(item) {
            if (!item) return;
            var locals = {};
            if (self.itemName) locals[self.itemName] = item;
            return locals;
        }
        function configureWatchers() {
            var wait = parseInt($scope.delay, 10) || 0;
            $scope.$watch("searchText", wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
            $scope.$watch("selectedItem", function(selectedItem, previousSelectedItem) {
                if ($scope.itemChange && selectedItem !== previousSelectedItem) $scope.itemChange(getItemScope(selectedItem));
            });
        }
        function handleSearchText(searchText, previousSearchText) {
            self.index = -1;
            if (!searchText || searchText.length < Math.max(parseInt($scope.minLength, 10), 1)) {
                self.loading = false;
                self.matches = [];
                self.hidden = shouldHide();
                updateMessages();
                return;
            }
            var term = searchText.toLowerCase();
            if (promise && promise.cancel) {
                promise.cancel();
                promise = null;
            }
            if (!$scope.noCache && cache[term]) {
                self.matches = cache[term];
                updateMessages();
            } else {
                self.fetch(searchText);
            }
            self.hidden = shouldHide();
            if ($scope.textChange && searchText !== previousSearchText) $scope.textChange(getItemScope($scope.selectedItem));
        }
        function fetchResults(searchText) {
            var items = $scope.$parent.$eval(itemExpr), term = searchText.toLowerCase();
            if (angular.isArray(items)) {
                handleResults(items);
            } else {
                self.loading = true;
                promise = $q.when(items).then(handleResults);
            }
            function handleResults(matches) {
                cache[term] = matches;
                if (searchText !== $scope.searchText) return;
                promise = null;
                self.loading = false;
                self.matches = matches;
                self.hidden = shouldHide();
                updateMessages();
            }
        }
        function updateMessages() {
            if (self.hidden) return;
            switch (self.matches.length) {
              case 0:
                return self.messages.splice(0);

              case 1:
                return self.messages.push({
                    display: "There is 1 match available."
                });

              default:
                return self.messages.push({
                    display: "There are " + self.matches.length + " matches available."
                });
            }
        }
        function updateSelectionMessage() {
            self.messages.push({
                display: getCurrentDisplayValue()
            });
        }
        function blur() {
            if (!noBlur) self.hidden = true;
        }
        function keydown(event) {
            switch (event.keyCode) {
              case $mdConstant.KEY_CODE.DOWN_ARROW:
                if (self.loading) return;
                event.preventDefault();
                self.index = Math.min(self.index + 1, self.matches.length - 1);
                updateScroll();
                updateSelectionMessage();
                break;

              case $mdConstant.KEY_CODE.UP_ARROW:
                if (self.loading) return;
                event.preventDefault();
                self.index = Math.max(0, self.index - 1);
                updateScroll();
                updateSelectionMessage();
                break;

              case $mdConstant.KEY_CODE.ENTER:
                if (self.loading || self.index < 0) return;
                event.preventDefault();
                select(self.index);
                break;

              case $mdConstant.KEY_CODE.ESCAPE:
                self.matches = [];
                self.hidden = true;
                self.index = -1;
                break;

              case $mdConstant.KEY_CODE.TAB:
                break;

              default:            }
        }
        function clearValue() {
            $scope.searchText = "";
            select(-1);
            elements.input.focus();
        }
        function shouldHide() {
            return self.matches.length === 1 && $scope.searchText === getDisplayValue(self.matches[0]);
        }
        function getCurrentDisplayValue() {
            return getDisplayValue(self.matches[self.index]);
        }
        function getDisplayValue(item) {
            return item && $scope.itemText ? $scope.itemText(getItemScope(item)) : item;
        }
        function select(index) {
            $scope.selectedItem = self.matches[index];
            $scope.searchText = getDisplayValue($scope.selectedItem) || $scope.searchText;
            self.hidden = true;
            self.index = -1;
            self.matches = [];
        }
        function updateScroll() {
            var top = 41 * self.index, bot = top + 41, hgt = 41 * 5.5;
            if (top < elements.ul.scrollTop) {
                elements.ul.scrollTop = top;
            } else if (bot > elements.ul.scrollTop + hgt) {
                elements.ul.scrollTop = bot - hgt;
            }
        }
    }
    MdAutocompleteCtrl.$inject = [ "$scope", "$element", "$q", "$mdUtil", "$mdConstant" ];
})();

(function() {
    "use strict";
    angular.module("material.components.autocomplete").directive("mdAutocomplete", MdAutocomplete);
    function MdAutocomplete() {
        return {
            template: '        <md-autocomplete-wrap role="listbox">          <input type="text"              ng-disabled="isDisabled"              ng-model="searchText"              ng-keydown="$mdAutocompleteCtrl.keydown($event)"              ng-blur="$mdAutocompleteCtrl.blur()"              placeholder="{{placeholder}}"              aria-label="{{placeholder}}"              aria-autocomplete="list"              aria-haspopup="true"              aria-activedescendant=""              aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>          <button              type="button"              ng-if="searchText"              ng-click="$mdAutocompleteCtrl.clear()">            <md-icon md-svg-icon="cancel"></md-icon>            <span class="visually-hidden">Clear</span>          </button>          <md-progress-linear              ng-if="$mdAutocompleteCtrl.loading"              md-mode="indeterminate"></md-progress-linear>        </md-autocomplete-wrap>        <ul role="presentation"            ng-mouseenter="$mdAutocompleteCtrl.listEnter()"            ng-mouseleave="$mdAutocompleteCtrl.listLeave()"            ng-mouseup="$mdAutocompleteCtrl.mouseUp()">          <li ng-repeat="(index, item) in $mdAutocompleteCtrl.matches"              ng-class="{ selected: index === $mdAutocompleteCtrl.index }"              ng-show="searchText && !$mdAutocompleteCtrl.hidden"              ng-click="$mdAutocompleteCtrl.select(index)"              ng-transclude              md-autocomplete-list-item="$mdAutocompleteCtrl.itemName">          </li>        </ul>        <aria-status            class="visually-hidden"            role="status"            aria-live="assertive">          <p ng-repeat="message in $mdAutocompleteCtrl.messages">{{message.display}}</p>        </aria-status>',
            transclude: true,
            controller: "MdAutocompleteCtrl",
            controllerAs: "$mdAutocompleteCtrl",
            scope: {
                searchText: "=mdSearchText",
                selectedItem: "=mdSelectedItem",
                itemsExpr: "@mdItems",
                itemText: "&mdItemText",
                placeholder: "@placeholder",
                noCache: "=mdNoCache",
                itemChange: "&mdSelectedItemChange",
                textChange: "&mdSearchTextChange",
                isDisabled: "=ngDisabled",
                minLength: "=mdMinLength",
                delay: "=mdDelay"
            }
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.components.autocomplete").controller("MdHighlightCtrl", MdHighlightCtrl);
    function MdHighlightCtrl($scope, $element, $interpolate) {
        var term = $element.attr("md-highlight-text"), text = $interpolate($element.text())($scope), watcher = $scope.$watch(term, function(term) {
            var regex = new RegExp("^" + sanitize(term), "i"), html = text.replace(regex, '<span class="highlight">$&</span>');
            $element.html(html);
        });
        $element.on("$destroy", function() {
            watcher();
        });
        function sanitize(term) {
            if (!term) return term;
            return term.replace(/[\*\[\]\(\)\{\}\\\^\$]/g, "\\$&");
        }
    }
    MdHighlightCtrl.$inject = [ "$scope", "$element", "$interpolate" ];
})();

(function() {
    "use strict";
    angular.module("material.components.autocomplete").directive("mdHighlightText", MdHighlight);
    function MdHighlight() {
        return {
            terminal: true,
            scope: false,
            controller: "MdHighlightCtrl"
        };
    }
})();

(function() {
    "use strict";
    angular.module("material.components.autocomplete").directive("mdAutocompleteListItem", MdAutocompleteListItem);
    function MdAutocompleteListItem($compile, $mdUtil) {
        return {
            require: "^?mdAutocomplete",
            terminal: true,
            link: link,
            scope: false
        };
        function link(scope, element, attr, ctrl) {
            var newScope = ctrl.parent.$new(false, ctrl.parent), itemName = ctrl.scope.$eval(attr.mdAutocompleteListItem);
            newScope[itemName] = scope.item;
            $compile(element.contents())(newScope);
            element.attr({
                role: "option",
                id: "item_" + $mdUtil.nextUid()
            });
        }
    }
    MdAutocompleteListItem.$inject = [ "$compile", "$mdUtil" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTabsInkBar", MdTabInkDirective);
    function MdTabInkDirective($$rAF) {
        var lastIndex = 0;
        return {
            restrict: "E",
            require: [ "^?mdNoBar", "^mdTabs" ],
            link: postLink
        };
        function postLink(scope, element, attr, ctrls) {
            var mdNoBar = !!ctrls[0];
            var tabsCtrl = ctrls[1], debouncedUpdateBar = $$rAF.throttle(updateBar);
            tabsCtrl.inkBarElement = element;
            scope.$on("$mdTabsPaginationChanged", debouncedUpdateBar);
            function updateBar() {
                var selected = tabsCtrl.getSelectedItem();
                var hideInkBar = !selected || tabsCtrl.count() < 2 || mdNoBar;
                element.css("display", hideInkBar ? "none" : "block");
                if (hideInkBar) return;
                if (scope.pagination && scope.pagination.tabData) {
                    var index = tabsCtrl.getSelectedIndex();
                    var data = scope.pagination.tabData.tabs[index] || {
                        left: 0,
                        right: 0,
                        width: 0
                    };
                    var right = element.parent().prop("offsetWidth") - data.right;
                    var classNames = [ "md-transition-left", "md-transition-right", "md-no-transition" ];
                    var classIndex = lastIndex > index ? 0 : lastIndex < index ? 1 : 2;
                    element.removeClass(classNames.join(" ")).addClass(classNames[classIndex]).css({
                        left: data.left + "px",
                        right: right + "px"
                    });
                    lastIndex = index;
                }
            }
        }
    }
    MdTabInkDirective.$inject = [ "$$rAF" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTabsPagination", TabPaginationDirective);
    function TabPaginationDirective($mdConstant, $window, $$rAF, $$q, $timeout, $mdMedia) {
        var PAGINATORS_WIDTH = 8 * 4 * 2;
        return {
            restrict: "A",
            require: "^mdTabs",
            link: postLink
        };
        function postLink(scope, element, attr, tabsCtrl) {
            var tabs = element[0].getElementsByTagName("md-tab");
            var debouncedUpdatePagination = $$rAF.throttle(updatePagination);
            var tabsParent = element.children();
            var locked = false;
            var state = scope.pagination = {
                page: -1,
                active: false,
                clickNext: function() {
                    locked || userChangePage(+1);
                },
                clickPrevious: function() {
                    locked || userChangePage(-1);
                }
            };
            scope.$on("$mdTabsChanged", debouncedUpdatePagination);
            angular.element($window).on("resize", debouncedUpdatePagination);
            scope.$on("$destroy", function() {
                angular.element($window).off("resize", debouncedUpdatePagination);
            });
            scope.$watch(function() {
                return tabsCtrl.tabToFocus;
            }, onTabFocus);
            function onTabFocus(tab, oldTab) {
                if (!tab) return;
                var pageIndex = getPageForTab(tab);
                if (!state.active || pageIndex === state.page) {
                    tab.element.focus();
                } else {
                    oldTab && oldTab.element.blur();
                    setPage(pageIndex).then(function() {
                        locked = false;
                        tab.element.focus();
                    });
                }
            }
            function userChangePage(increment) {
                var sizeData = state.tabData;
                var newPage = Math.max(0, Math.min(sizeData.pages.length - 1, state.page + increment));
                var newTabIndex = sizeData.pages[newPage][increment > 0 ? "firstTabIndex" : "lastTabIndex"];
                var newTab = tabsCtrl.itemAt(newTabIndex);
                locked = true;
                onTabFocus(newTab);
            }
            function updatePagination() {
                if (!element.prop("offsetParent")) {
                    var watcher = waitForVisible();
                    return;
                }
                var tabs = element.find("md-tab");
                disablePagination();
                var sizeData = state.tabData = calculateTabData();
                var needPagination = state.active = sizeData.pages.length > 1;
                if (needPagination) {
                    enablePagination();
                }
                scope.$evalAsync(function() {
                    scope.$broadcast("$mdTabsPaginationChanged");
                });
                function enablePagination() {
                    tabsParent.css("width", "9999px");
                    angular.forEach(sizeData.tabs, function(tab) {
                        angular.element(tab.element).css("margin-left", tab.filler + "px");
                    });
                    setPage(getPageForTab(tabsCtrl.getSelectedItem()));
                }
                function disablePagination() {
                    slideTabButtons(0);
                    tabsParent.css("width", "");
                    tabs.css("width", "");
                    tabs.css("margin-left", "");
                    state.page = null;
                    state.active = false;
                }
                function waitForVisible() {
                    return watcher || scope.$watch(function() {
                        $timeout(function() {
                            if (element[0].offsetParent) {
                                if (angular.isFunction(watcher)) {
                                    watcher();
                                }
                                debouncedUpdatePagination();
                                watcher = null;
                            }
                        }, 0, false);
                    });
                }
            }
            function slideTabButtons(x) {
                if (tabsCtrl.pagingOffset === x) {
                    return $$q.when();
                }
                var deferred = $$q.defer();
                tabsCtrl.$$pagingOffset = x;
                tabsParent.css($mdConstant.CSS.TRANSFORM, "translate3d(" + x + "px,0,0)");
                tabsParent.on($mdConstant.CSS.TRANSITIONEND, onTabsParentTransitionEnd);
                return deferred.promise;
                function onTabsParentTransitionEnd(ev) {
                    if (ev.target === tabsParent[0]) {
                        tabsParent.off($mdConstant.CSS.TRANSITIONEND, onTabsParentTransitionEnd);
                        deferred.resolve();
                    }
                }
            }
            function shouldStretchTabs() {
                switch (scope.stretchTabs) {
                  case "never":
                    return false;

                  case "always":
                    return true;

                  default:
                    return $mdMedia("sm");
                }
            }
            function calculateTabData(noAdjust) {
                var clientWidth = element.parent().prop("offsetWidth");
                var tabsWidth = clientWidth - PAGINATORS_WIDTH - 1;
                var $tabs = angular.element(tabs);
                var totalWidth = 0;
                var max = 0;
                var tabData = [];
                var pages = [];
                var currentPage;
                $tabs.css("max-width", "");
                angular.forEach(tabs, function(tab, index) {
                    var tabWidth = Math.min(tabsWidth, tab.offsetWidth);
                    var data = {
                        element: tab,
                        left: totalWidth,
                        width: tabWidth,
                        right: totalWidth + tabWidth,
                        filler: 0
                    };
                    data.page = Math.ceil(data.right / (pages.length === 1 && index === tabs.length - 1 ? clientWidth : tabsWidth)) - 1;
                    if (data.page >= pages.length) {
                        data.filler = tabsWidth * data.page - data.left;
                        data.right += data.filler;
                        data.left += data.filler;
                        currentPage = {
                            left: data.left,
                            firstTabIndex: index,
                            lastTabIndex: index,
                            tabs: [ data ]
                        };
                        pages.push(currentPage);
                    } else {
                        currentPage.lastTabIndex = index;
                        currentPage.tabs.push(data);
                    }
                    totalWidth = data.right;
                    max = Math.max(max, tabWidth);
                    tabData.push(data);
                });
                $tabs.css("max-width", tabsWidth + "px");
                if (!noAdjust && shouldStretchTabs()) {
                    return adjustForStretchedTabs();
                } else {
                    return {
                        width: totalWidth,
                        max: max,
                        tabs: tabData,
                        pages: pages,
                        tabElements: tabs
                    };
                }
                function adjustForStretchedTabs() {
                    var canvasWidth = pages.length === 1 ? clientWidth : tabsWidth;
                    var tabsPerPage = Math.min(Math.floor(canvasWidth / max), tabs.length);
                    var tabWidth = Math.floor(canvasWidth / tabsPerPage);
                    $tabs.css("width", tabWidth + "px");
                    return calculateTabData(true);
                }
            }
            function getPageForTab(tab) {
                var tabIndex = tabsCtrl.indexOf(tab);
                if (tabIndex === -1) return 0;
                var sizeData = state.tabData;
                return sizeData ? sizeData.tabs[tabIndex].page : 0;
            }
            function setPage(page) {
                if (page === state.page) return;
                var lastPage = state.tabData.pages.length - 1;
                if (page < 0) page = 0;
                if (page > lastPage) page = lastPage;
                state.hasPrev = page > 0;
                state.hasNext = page < lastPage;
                state.page = page;
                scope.$broadcast("$mdTabsPaginationChanged");
                return slideTabButtons(-state.tabData.pages[page].left);
            }
        }
    }
    TabPaginationDirective.$inject = [ "$mdConstant", "$window", "$$rAF", "$$q", "$timeout", "$mdMedia" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").controller("$mdTab", TabItemController);
    function TabItemController($scope, $element, $attrs, $compile, $animate, $mdUtil, $parse, $timeout) {
        var self = this;
        var tabsCtrl = $element.controller("mdTabs");
        self.contentContainer = angular.element('<div class="md-tab-content ng-hide">');
        self.element = $element;
        self.isDisabled = isDisabled;
        self.onAdd = onAdd;
        self.onRemove = onRemove;
        self.onSelect = onSelect;
        self.onDeselect = onDeselect;
        var disabledParsed = $parse($attrs.ngDisabled);
        function isDisabled() {
            return disabledParsed($scope.$parent);
        }
        function onAdd(contentArea, shouldDisconnectScope) {
            if (self.content.length) {
                self.contentContainer.append(self.content);
                self.contentScope = $scope.$parent.$new();
                contentArea.append(self.contentContainer);
                $compile(self.contentContainer)(self.contentScope);
                if (shouldDisconnectScope === true) {
                    $timeout(function() {
                        $mdUtil.disconnectScope(self.contentScope);
                    }, 0, false);
                }
            }
        }
        function onRemove() {
            $animate.leave(self.contentContainer).then(function() {
                self.contentScope && self.contentScope.$destroy();
                self.contentScope = null;
            });
        }
        function toggleAnimationClass(rightToLeft) {
            self.contentContainer[rightToLeft ? "addClass" : "removeClass"]("md-transition-rtl");
        }
        function onSelect(rightToLeft) {
            $mdUtil.reconnectScope(self.contentScope);
            $element.addClass("active").attr({
                "aria-selected": true,
                tabIndex: 0
            }).on("$md.swipeleft $md.swiperight", onSwipe);
            toggleAnimationClass(rightToLeft);
            $animate.removeClass(self.contentContainer, "ng-hide");
            $scope.onSelect();
        }
        function onDeselect(rightToLeft) {
            $mdUtil.disconnectScope(self.contentScope);
            $element.removeClass("active").attr({
                "aria-selected": false,
                tabIndex: -1
            }).off("$md.swipeleft $md.swiperight", onSwipe);
            toggleAnimationClass(rightToLeft);
            $animate.addClass(self.contentContainer, "ng-hide");
            $scope.onDeselect();
        }
        function onSwipe(ev) {
            $scope.$apply(function() {
                if (/left/.test(ev.type)) {
                    tabsCtrl.select(tabsCtrl.next());
                } else {
                    tabsCtrl.select(tabsCtrl.previous());
                }
            });
        }
    }
    TabItemController.$inject = [ "$scope", "$element", "$attrs", "$compile", "$animate", "$mdUtil", "$parse", "$timeout" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTab", MdTabDirective);
    function MdTabDirective($mdInkRipple, $compile, $mdUtil, $mdConstant, $timeout) {
        return {
            restrict: "E",
            require: [ "mdTab", "^mdTabs" ],
            controller: "$mdTab",
            scope: {
                onSelect: "&mdOnSelect",
                onDeselect: "&mdOnDeselect",
                label: "@"
            },
            compile: compile
        };
        function compile(element, attr) {
            var tabLabel = element.find("md-tab-label");
            if (tabLabel.length) {
                tabLabel.remove();
            } else if (angular.isDefined(attr.label)) {
                tabLabel = angular.element("<md-tab-label>").html(attr.label);
            } else {
                tabLabel = angular.element("<md-tab-label>").append(element.contents().remove());
            }
            var tabContent = element.contents().remove();
            return function postLink(scope, element, attr, ctrls) {
                var tabItemCtrl = ctrls[0];
                var tabsCtrl = ctrls[1];
                $timeout(element.addClass.bind(element, "md-tab-themed"), 0, false);
                scope.$watch(function() {
                    return attr.label;
                }, function() {
                    $timeout(function() {
                        tabsCtrl.scope.$broadcast("$mdTabsChanged");
                    }, 0, false);
                });
                transcludeTabContent();
                configureAria();
                $mdInkRipple.attachTabBehavior(scope, element, {
                    colorElement: tabsCtrl.inkBarElement
                });
                tabsCtrl.add(tabItemCtrl);
                scope.$on("$destroy", function() {
                    tabsCtrl.remove(tabItemCtrl);
                });
                element.on("$destroy", function() {
                    $timeout(function() {
                        tabsCtrl.scope.$broadcast("$mdTabsChanged");
                    }, 0, false);
                });
                if (!angular.isDefined(attr.ngClick)) {
                    element.on("click", defaultClickListener);
                }
                element.on("keydown", keydownListener);
                if (angular.isNumber(scope.$parent.$index)) {
                    watchNgRepeatIndex();
                }
                if (angular.isDefined(attr.mdActive)) {
                    watchActiveAttribute();
                }
                watchDisabled();
                function transcludeTabContent() {
                    var label = tabLabel.clone();
                    element.append(label);
                    $compile(label)(scope.$parent);
                    tabItemCtrl.content = tabContent.clone();
                }
                function defaultClickListener() {
                    scope.$apply(function() {
                        tabsCtrl.select(tabItemCtrl);
                        tabsCtrl.focus(tabItemCtrl);
                    });
                }
                function keydownListener(ev) {
                    if (ev.keyCode == $mdConstant.KEY_CODE.SPACE || ev.keyCode == $mdConstant.KEY_CODE.ENTER) {
                        element.triggerHandler("click");
                        ev.preventDefault();
                    } else if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {
                        scope.$evalAsync(function() {
                            tabsCtrl.focus(tabsCtrl.previous(tabItemCtrl));
                        });
                    } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {
                        scope.$evalAsync(function() {
                            tabsCtrl.focus(tabsCtrl.next(tabItemCtrl));
                        });
                    }
                }
                function watchNgRepeatIndex() {
                    scope.$watch("$parent.$index", function $indexWatchAction(newIndex) {
                        tabsCtrl.move(tabItemCtrl, newIndex);
                    });
                }
                function watchActiveAttribute() {
                    var unwatch = scope.$parent.$watch("!!(" + attr.mdActive + ")", activeWatchAction);
                    scope.$on("$destroy", unwatch);
                    function activeWatchAction(isActive) {
                        var isSelected = tabsCtrl.getSelectedItem() === tabItemCtrl;
                        if (isActive && !isSelected) {
                            tabsCtrl.select(tabItemCtrl);
                        } else if (!isActive && isSelected) {
                            tabsCtrl.deselect(tabItemCtrl);
                        }
                    }
                }
                function watchDisabled() {
                    scope.$watch(tabItemCtrl.isDisabled, disabledWatchAction);
                    function disabledWatchAction(isDisabled) {
                        element.attr("aria-disabled", isDisabled);
                        var isSelected = tabsCtrl.getSelectedItem() === tabItemCtrl;
                        if (isSelected && isDisabled) {
                            tabsCtrl.select(tabsCtrl.next() || tabsCtrl.previous());
                        }
                    }
                }
                function configureAria() {
                    var tabId = attr.id || "tab_" + $mdUtil.nextUid();
                    element.attr({
                        id: tabId,
                        role: "tab",
                        tabIndex: -1
                    });
                    if (tabContent.length) {
                        var tabContentId = "content_" + tabId;
                        if (!element.attr("aria-controls")) {
                            element.attr("aria-controls", tabContentId);
                        }
                        tabItemCtrl.contentContainer.attr({
                            id: tabContentId,
                            role: "tabpanel",
                            "aria-labelledby": tabId
                        });
                    }
                }
            };
        }
    }
    MdTabDirective.$inject = [ "$mdInkRipple", "$compile", "$mdUtil", "$mdConstant", "$timeout" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").controller("$mdTabs", MdTabsController);
    function MdTabsController($scope, $element, $mdUtil, $timeout) {
        var tabsList = $mdUtil.iterator([], false);
        var self = this;
        self.$element = $element;
        self.scope = $scope;
        var contentArea = self.contentArea = angular.element($element[0].querySelector(".md-tabs-content"));
        var inRange = self.inRange = tabsList.inRange;
        var indexOf = self.indexOf = tabsList.indexOf;
        var itemAt = self.itemAt = tabsList.itemAt;
        self.count = tabsList.count;
        self.getSelectedItem = getSelectedItem;
        self.getSelectedIndex = getSelectedIndex;
        self.add = add;
        self.remove = remove;
        self.move = move;
        self.select = select;
        self.focus = focus;
        self.deselect = deselect;
        self.next = next;
        self.previous = previous;
        $scope.$on("$destroy", function() {
            deselect(getSelectedItem());
            for (var i = tabsList.count() - 1; i >= 0; i--) {
                remove(tabsList[i], true);
            }
        });
        function getSelectedItem() {
            return itemAt($scope.selectedIndex);
        }
        function getSelectedIndex() {
            return $scope.selectedIndex;
        }
        function add(tab, index) {
            tabsList.add(tab, index);
            if (!angular.isDefined(tab.element.attr("md-active")) && ($scope.selectedIndex === -1 || !angular.isNumber($scope.selectedIndex) || $scope.selectedIndex === self.indexOf(tab))) {
                tab.onAdd(self.contentArea, false);
                self.select(tab);
            } else {
                tab.onAdd(self.contentArea, true);
            }
            $scope.$broadcast("$mdTabsChanged");
        }
        function remove(tab, noReselect) {
            if (!tabsList.contains(tab)) return;
            if (noReselect) return;
            var isSelectedItem = getSelectedItem() === tab, newTab = previous() || next();
            deselect(tab);
            tabsList.remove(tab);
            tab.onRemove();
            $scope.$broadcast("$mdTabsChanged");
            if (isSelectedItem) {
                select(newTab);
            }
        }
        function move(tab, toIndex) {
            var isSelected = getSelectedItem() === tab;
            tabsList.remove(tab);
            tabsList.add(tab, toIndex);
            if (isSelected) select(tab);
            $scope.$broadcast("$mdTabsChanged");
        }
        function select(tab, rightToLeft) {
            if (!tab || tab.isSelected || tab.isDisabled()) return;
            if (!tabsList.contains(tab)) return;
            if (!angular.isDefined(rightToLeft)) {
                rightToLeft = indexOf(tab) < $scope.selectedIndex;
            }
            deselect(getSelectedItem(), rightToLeft);
            $scope.selectedIndex = indexOf(tab);
            tab.isSelected = true;
            tab.onSelect(rightToLeft);
            $scope.$broadcast("$mdTabsChanged");
        }
        function focus(tab) {
            self.tabToFocus = tab;
        }
        function deselect(tab, rightToLeft) {
            if (!tab || !tab.isSelected) return;
            if (!tabsList.contains(tab)) return;
            $scope.selectedIndex = -1;
            tab.isSelected = false;
            tab.onDeselect(rightToLeft);
        }
        function next(tab, filterFn) {
            return tabsList.next(tab || getSelectedItem(), filterFn || isTabEnabled);
        }
        function previous(tab, filterFn) {
            return tabsList.previous(tab || getSelectedItem(), filterFn || isTabEnabled);
        }
        function isTabEnabled(tab) {
            return tab && !tab.isDisabled();
        }
    }
    MdTabsController.$inject = [ "$scope", "$element", "$mdUtil", "$timeout" ];
})();

(function() {
    "use strict";
    angular.module("material.components.tabs").directive("mdTabs", TabsDirective);
    function TabsDirective($mdTheming) {
        return {
            restrict: "E",
            controller: "$mdTabs",
            require: "mdTabs",
            transclude: true,
            scope: {
                selectedIndex: "=?mdSelected"
            },
            template: '<section class="md-header" ' + "ng-class=\"{'md-paginating': pagination.active}\">" + '<button class="md-paginator md-prev" ' + 'ng-if="pagination.active && pagination.hasPrev" ' + 'ng-click="pagination.clickPrevious()" ' + 'aria-hidden="true">' + '<md-icon md-svg-icon="tabs-arrow"></md-icon>' + "</button>" + '<div class="md-header-items-container" md-tabs-pagination>' + '<div class="md-header-items">' + "<md-tabs-ink-bar></md-tabs-ink-bar>" + "</div>" + "</div>" + '<button class="md-paginator md-next" ' + 'ng-if="pagination.active && pagination.hasNext" ' + 'ng-click="pagination.clickNext()" ' + 'aria-hidden="true">' + '<md-icon md-svg-icon="tabs-arrow"></md-icon>' + "</button>" + "</section>" + '<section class="md-tabs-content"></section>',
            link: postLink
        };
        function postLink(scope, element, attr, tabsCtrl, transclude) {
            scope.stretchTabs = attr.hasOwnProperty("mdStretchTabs") ? attr.mdStretchTabs || "always" : "auto";
            $mdTheming(element);
            configureAria();
            watchSelected();
            transclude(scope.$parent, function(clone) {
                angular.element(element[0].querySelector(".md-header-items")).append(clone);
            });
            function configureAria() {
                element.attr("role", "tablist");
            }
            function watchSelected() {
                scope.$watch("selectedIndex", function watchSelectedIndex(newIndex, oldIndex) {
                    if (oldIndex == newIndex) return;
                    var rightToLeft = oldIndex > newIndex;
                    tabsCtrl.deselect(tabsCtrl.itemAt(oldIndex), rightToLeft);
                    if (tabsCtrl.inRange(newIndex)) {
                        var newTab = tabsCtrl.itemAt(newIndex);
                        while (newTab && newTab.isDisabled()) {
                            newTab = newIndex > oldIndex ? tabsCtrl.next(newTab) : tabsCtrl.previous(newTab);
                        }
                        tabsCtrl.select(newTab, rightToLeft);
                    }
                });
            }
        }
    }
    TabsDirective.$inject = [ "$mdTheming" ];
})();

(function() {
    angular.module("material.core").constant("$MD_THEME_CSS", "md-autocomplete {  background: '{{background-50}}'; }  md-autocomplete button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete button:after {    background: '{{background-600-0.3}}'; }  md-autocomplete ul {    background: '{{background-50}}'; }    md-autocomplete ul li {      border-top: 1px solid '{{background-400}}';      color: '{{background-900}}'; }      md-autocomplete ul li .highlight {        color: '{{background-600}}'; }      md-autocomplete ul li:hover, md-autocomplete ul li.selected {        background: '{{background-200}}'; }md-backdrop.md-opaque.md-THEME_NAME-theme {  background-color: '{{foreground-4-0.5}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }md-toolbar .md-button.md-THEME_NAME-theme.md-fab {  background-color: white; }.md-button.md-THEME_NAME-theme {  border-radius: 3px; }  .md-button.md-THEME_NAME-theme:not([disabled]):hover, .md-button.md-THEME_NAME-theme:not([disabled]):focus {    background-color: '{{background-500-0.2}}'; }  .md-button.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised, .md-button.md-THEME_NAME-theme.md-primary.md-fab {      color: '{{primary-contrast}}';      background-color: '{{primary-color}}'; }      .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):focus, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):focus {        background-color: '{{primary-600}}'; }  .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%;    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):focus {      background-color: '{{accent-A700}}'; }  .md-button.md-THEME_NAME-theme.md-raised {    color: '{{background-contrast}}';    background-color: '{{background-50}}'; }    .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):focus {      background-color: '{{background-200}}'; }  .md-button.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised, .md-button.md-THEME_NAME-theme.md-warn.md-fab {      color: '{{warn-contrast}}';      background-color: '{{warn-color}}'; }      .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):focus, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):focus {        background-color: '{{warn-700}}'; }  .md-button.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised, .md-button.md-THEME_NAME-theme.md-accent.md-fab {      color: '{{accent-contrast}}';      background-color: '{{accent-color}}'; }      .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):focus, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):focus {        background-color: '{{accent-700}}'; }  .md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled] {    color: '{{foreground-3}}';    background-color: transparent;    cursor: not-allowed; }md-card.md-THEME_NAME-theme {  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-content.md-THEME_NAME-theme {  background-color: '{{background-hue-3}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-hue-3}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }md-icon.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }md-icon.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }md-icon.md-THEME_NAME-theme.md-danger {  color: '{{danger-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme > md-icon {  fill: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label, md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  fill: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled], [disabled] md-input-container.md-THEME_NAME-theme .md-input {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, '{{foreground-4}}' 0%, '{{foreground-4}}' 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, '{{foreground-4}}' 100%); }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient('{{warn-100}}' 0%, '{{warn-100}}' 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient('{{accent-100}}' 0%, '{{accent-100}}' 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {  border-color: '{{foreground-3}}'; }md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {  border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme:focus:not(:empty) {  border-color: '{{foreground-1}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label.md-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-label {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-label {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-label {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-label.md-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme .md-select-label {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-label.md-placeholder {    color: '{{foreground-2}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  background-color: '{{primary-50}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    background-color: '{{primary-100}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    background-color: '{{accent-50}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      background-color: '{{accent-100}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([selected]) {  background: '{{background-200}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-hue-3}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  border-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-hue-3}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-hue-3}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-hue-3}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-switch.md-THEME_NAME-theme:focus .md-label:not(:empty) {  border-color: '{{foreground-1}}';  border-style: dotted; }md-tabs.md-THEME_NAME-theme .md-header {  background-color: transparent; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme.md-accent .md-header {  background-color: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tab:not([disabled]) {  color: '{{accent-100}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab:not([disabled]).active {    color: '{{accent-contrast}}'; }md-tabs.md-THEME_NAME-theme.md-primary .md-header {  background-color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tab:not([disabled]) {  color: '{{primary-100}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab:not([disabled]).active {    color: '{{primary-contrast}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tab {  color: '{{primary-100}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab[disabled] {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab:focus {    color: '{{primary-contrast}}';    background-color: '{{primary-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab.active {    color: '{{primary-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab .md-ripple-container {    color: '{{primary-contrast}}'; }md-tabs.md-THEME_NAME-theme.md-warn .md-header {  background-color: '{{warn-color}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tab:not([disabled]) {  color: '{{warn-100}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab:not([disabled]).active {    color: '{{warn-contrast}}'; }md-tabs.md-THEME_NAME-theme md-tabs-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme md-tab[disabled] {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme md-tab:focus {    color: '{{foreground-1}}'; }  md-tabs.md-THEME_NAME-theme md-tab.active {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-input-group.md-THEME_NAME-theme input, md-input-group.md-THEME_NAME-theme textarea {  text-shadow: '{{foreground-shadow}}'; }  md-input-group.md-THEME_NAME-theme input::-webkit-input-placeholder, md-input-group.md-THEME_NAME-theme input::-moz-placeholder, md-input-group.md-THEME_NAME-theme input:-moz-placeholder, md-input-group.md-THEME_NAME-theme input:-ms-input-placeholder, md-input-group.md-THEME_NAME-theme textarea::-webkit-input-placeholder, md-input-group.md-THEME_NAME-theme textarea::-moz-placeholder, md-input-group.md-THEME_NAME-theme textarea:-moz-placeholder, md-input-group.md-THEME_NAME-theme textarea:-ms-input-placeholder {    color: '{{foreground-3}}'; }md-input-group.md-THEME_NAME-theme label {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-group.md-THEME_NAME-theme input, md-input-group.md-THEME_NAME-theme textarea {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused input, md-input-group.md-THEME_NAME-theme.md-input-focused textarea {  border-color: '{{primary-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused label {  color: '{{primary-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused.md-accent input, md-input-group.md-THEME_NAME-theme.md-input-focused.md-accent textarea {  border-color: '{{accent-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-group.md-THEME_NAME-theme.md-input-has-value:not(.md-input-focused) label {  color: '{{foreground-2}}'; }md-input-group.md-THEME_NAME-theme .md-input[disabled] {  border-bottom-color: '{{foreground-4}}';  color: '{{foreground-3}}'; }md-toast.md-THEME_NAME-theme {  background-color: '{{foreground-1}}';  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-toolbar.md-THEME_NAME-theme {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme .md-button {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-background {    background-color: '{{foreground-2}}'; }");
})();

(function(window, angular, undefined) {
    "use strict";
    angular.module("ngAnimate", [ "ng" ]).directive("ngAnimateChildren", function() {
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        return function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
                element.data(NG_ANIMATE_CHILDREN, true);
            } else {
                scope.$watch(val, function(value) {
                    element.data(NG_ANIMATE_CHILDREN, !!value);
                });
            }
        };
    }).factory("$$animateReflow", [ "$$rAF", "$document", function($$rAF, $document) {
        var bod = $document[0].body;
        return function(fn) {
            return $$rAF(function() {
                var a = bod.offsetWidth + 1;
                fn();
            });
        };
    } ]).config([ "$provide", "$animateProvider", function($provide, $animateProvider) {
        var noop = angular.noop;
        var forEach = angular.forEach;
        var selectors = $animateProvider.$$selectors;
        var isArray = angular.isArray;
        var isString = angular.isString;
        var isObject = angular.isObject;
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_STATE = "$$ngAnimateState";
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        var NG_ANIMATE_CLASS_NAME = "ng-animate";
        var rootAnimateState = {
            running: true
        };
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType == ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function prepareElement(element) {
            return element && angular.element(element);
        }
        function stripCommentsFromElement(element) {
            return angular.element(extractElementNode(element));
        }
        function isMatchingElement(elm1, elm2) {
            return extractElementNode(elm1) == extractElementNode(elm2);
        }
        var $$jqLite;
        $provide.decorator("$animate", [ "$delegate", "$$q", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", "$templateRequest", "$$jqLite", function($delegate, $$q, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document, $templateRequest, $$$jqLite) {
            $$jqLite = $$$jqLite;
            $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);
            var deregisterWatch = $rootScope.$watch(function() {
                return $templateRequest.totalPendingRequests;
            }, function(val, oldVal) {
                if (val !== 0) return;
                deregisterWatch();
                $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        rootAnimateState.running = false;
                    });
                });
            });
            var globalAnimationCounter = 0;
            var classNameFilter = $animateProvider.classNameFilter();
            var isAnimatableClassName = !classNameFilter ? function() {
                return true;
            } : function(className) {
                return classNameFilter.test(className);
            };
            function classBasedAnimationsBlocked(element, setter) {
                var data = element.data(NG_ANIMATE_STATE) || {};
                if (setter) {
                    data.running = true;
                    data.structural = true;
                    element.data(NG_ANIMATE_STATE, data);
                }
                return data.disabled || data.running && data.structural;
            }
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                defer.promise.$$cancelFn = function() {
                    cancelFn && cancelFn();
                };
                $rootScope.$$postDigest(function() {
                    cancelFn = fn(function() {
                        defer.resolve();
                    });
                });
                return defer.promise;
            }
            function parseAnimateOptions(options) {
                if (isObject(options)) {
                    if (options.tempClasses && isString(options.tempClasses)) {
                        options.tempClasses = options.tempClasses.split(/\s+/);
                    }
                    return options;
                }
            }
            function resolveElementClasses(element, cache, runningAnimations) {
                runningAnimations = runningAnimations || {};
                var lookup = {};
                forEach(runningAnimations, function(data, selector) {
                    forEach(selector.split(" "), function(s) {
                        lookup[s] = data;
                    });
                });
                var hasClasses = Object.create(null);
                forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = true;
                });
                var toAdd = [], toRemove = [];
                forEach(cache && cache.classes || [], function(status, className) {
                    var hasClass = hasClasses[className];
                    var matchingAnimation = lookup[className] || {};
                    if (status === false) {
                        if (hasClass || matchingAnimation.event == "addClass") {
                            toRemove.push(className);
                        }
                    } else if (status === true) {
                        if (!hasClass || matchingAnimation.event == "removeClass") {
                            toAdd.push(className);
                        }
                    }
                });
                return toAdd.length + toRemove.length > 0 && [ toAdd.join(" "), toRemove.join(" ") ];
            }
            function lookup(name) {
                if (name) {
                    var matches = [], flagMap = {}, classes = name.substr(1).split(".");
                    if ($sniffer.transitions || $sniffer.animations) {
                        matches.push($injector.get(selectors[""]));
                    }
                    for (var i = 0; i < classes.length; i++) {
                        var klass = classes[i], selectorFactoryName = selectors[klass];
                        if (selectorFactoryName && !flagMap[klass]) {
                            matches.push($injector.get(selectorFactoryName));
                            flagMap[klass] = true;
                        }
                    }
                    return matches;
                }
            }
            function animationRunner(element, animationEvent, className, options) {
                var node = element[0];
                if (!node) {
                    return;
                }
                if (options) {
                    options.to = options.to || {};
                    options.from = options.from || {};
                }
                var classNameAdd;
                var classNameRemove;
                if (isArray(className)) {
                    classNameAdd = className[0];
                    classNameRemove = className[1];
                    if (!classNameAdd) {
                        className = classNameRemove;
                        animationEvent = "removeClass";
                    } else if (!classNameRemove) {
                        className = classNameAdd;
                        animationEvent = "addClass";
                    } else {
                        className = classNameAdd + " " + classNameRemove;
                    }
                }
                var isSetClassOperation = animationEvent == "setClass";
                var isClassBased = isSetClassOperation || animationEvent == "addClass" || animationEvent == "removeClass" || animationEvent == "animate";
                var currentClassName = element.attr("class");
                var classes = currentClassName + " " + className;
                if (!isAnimatableClassName(classes)) {
                    return;
                }
                var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [];
                var animationLookup = (" " + classes).replace(/\s+/g, ".");
                forEach(lookup(animationLookup), function(animationFactory) {
                    var created = registerAnimation(animationFactory, animationEvent);
                    if (!created && isSetClassOperation) {
                        registerAnimation(animationFactory, "addClass");
                        registerAnimation(animationFactory, "removeClass");
                    }
                });
                function registerAnimation(animationFactory, event) {
                    var afterFn = animationFactory[event];
                    var beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
                    if (afterFn || beforeFn) {
                        if (event == "leave") {
                            beforeFn = afterFn;
                            afterFn = null;
                        }
                        after.push({
                            event: event,
                            fn: afterFn
                        });
                        before.push({
                            event: event,
                            fn: beforeFn
                        });
                        return true;
                    }
                }
                function run(fns, cancellations, allCompleteFn) {
                    var animations = [];
                    forEach(fns, function(animation) {
                        animation.fn && animations.push(animation);
                    });
                    var count = 0;
                    function afterAnimationComplete(index) {
                        if (cancellations) {
                            (cancellations[index] || noop)();
                            if (++count < animations.length) return;
                            cancellations = null;
                        }
                        allCompleteFn();
                    }
                    forEach(animations, function(animation, index) {
                        var progress = function() {
                            afterAnimationComplete(index);
                        };
                        switch (animation.event) {
                          case "setClass":
                            cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress, options));
                            break;

                          case "animate":
                            cancellations.push(animation.fn(element, className, options.from, options.to, progress));
                            break;

                          case "addClass":
                            cancellations.push(animation.fn(element, classNameAdd || className, progress, options));
                            break;

                          case "removeClass":
                            cancellations.push(animation.fn(element, classNameRemove || className, progress, options));
                            break;

                          default:
                            cancellations.push(animation.fn(element, progress, options));
                            break;
                        }
                    });
                    if (cancellations && cancellations.length === 0) {
                        allCompleteFn();
                    }
                }
                return {
                    node: node,
                    event: animationEvent,
                    className: className,
                    isClassBased: isClassBased,
                    isSetClassOperation: isSetClassOperation,
                    applyStyles: function() {
                        if (options) {
                            element.css(angular.extend(options.from || {}, options.to || {}));
                        }
                    },
                    before: function(allCompleteFn) {
                        beforeComplete = allCompleteFn;
                        run(before, beforeCancel, function() {
                            beforeComplete = noop;
                            allCompleteFn();
                        });
                    },
                    after: function(allCompleteFn) {
                        afterComplete = allCompleteFn;
                        run(after, afterCancel, function() {
                            afterComplete = noop;
                            allCompleteFn();
                        });
                    },
                    cancel: function() {
                        if (beforeCancel) {
                            forEach(beforeCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            beforeComplete(true);
                        }
                        if (afterCancel) {
                            forEach(afterCancel, function(cancelFn) {
                                (cancelFn || noop)(true);
                            });
                            afterComplete(true);
                        }
                    }
                };
            }
            return {
                animate: function(element, from, to, className, options) {
                    className = className || "ng-inline-animate";
                    options = parseAnimateOptions(options) || {};
                    options.from = to ? from : null;
                    options.to = to ? to : from;
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("animate", className, stripCommentsFromElement(element), null, null, noop, options, done);
                    });
                },
                enter: function(element, parentElement, afterElement, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    classBasedAnimationsBlocked(element, true);
                    $delegate.enter(element, parentElement, afterElement);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("enter", "ng-enter", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);
                    });
                },
                leave: function(element, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    cancelChildAnimations(element);
                    classBasedAnimationsBlocked(element, true);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function() {
                            $delegate.leave(element);
                        }, options, done);
                    });
                },
                move: function(element, parentElement, afterElement, options) {
                    options = parseAnimateOptions(options);
                    element = angular.element(element);
                    parentElement = prepareElement(parentElement);
                    afterElement = prepareElement(afterElement);
                    cancelChildAnimations(element);
                    classBasedAnimationsBlocked(element, true);
                    $delegate.move(element, parentElement, afterElement);
                    return runAnimationPostDigest(function(done) {
                        return performAnimation("move", "ng-move", stripCommentsFromElement(element), parentElement, afterElement, noop, options, done);
                    });
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                setClass: function(element, add, remove, options) {
                    options = parseAnimateOptions(options);
                    var STORAGE_KEY = "$$animateClasses";
                    element = angular.element(element);
                    element = stripCommentsFromElement(element);
                    if (classBasedAnimationsBlocked(element)) {
                        return $delegate.$$setClassImmediately(element, add, remove, options);
                    }
                    var classes, cache = element.data(STORAGE_KEY);
                    var hasCache = !!cache;
                    if (!cache) {
                        cache = {};
                        cache.classes = {};
                    }
                    classes = cache.classes;
                    add = isArray(add) ? add : add.split(" ");
                    forEach(add, function(c) {
                        if (c && c.length) {
                            classes[c] = true;
                        }
                    });
                    remove = isArray(remove) ? remove : remove.split(" ");
                    forEach(remove, function(c) {
                        if (c && c.length) {
                            classes[c] = false;
                        }
                    });
                    if (hasCache) {
                        if (options && cache.options) {
                            cache.options = angular.extend(cache.options || {}, options);
                        }
                        return cache.promise;
                    } else {
                        element.data(STORAGE_KEY, cache = {
                            classes: classes,
                            options: options
                        });
                    }
                    return cache.promise = runAnimationPostDigest(function(done) {
                        var parentElement = element.parent();
                        var elementNode = extractElementNode(element);
                        var parentNode = elementNode.parentNode;
                        if (!parentNode || parentNode["$$NG_REMOVED"] || elementNode["$$NG_REMOVED"]) {
                            done();
                            return;
                        }
                        var cache = element.data(STORAGE_KEY);
                        element.removeData(STORAGE_KEY);
                        var state = element.data(NG_ANIMATE_STATE) || {};
                        var classes = resolveElementClasses(element, cache, state.active);
                        return !classes ? done() : performAnimation("setClass", classes, element, parentElement, null, function() {
                            if (classes[0]) $delegate.$$addClassImmediately(element, classes[0]);
                            if (classes[1]) $delegate.$$removeClassImmediately(element, classes[1]);
                        }, cache.options, done);
                    });
                },
                cancel: function(promise) {
                    promise.$$cancelFn();
                },
                enabled: function(value, element) {
                    switch (arguments.length) {
                      case 2:
                        if (value) {
                            cleanup(element);
                        } else {
                            var data = element.data(NG_ANIMATE_STATE) || {};
                            data.disabled = true;
                            element.data(NG_ANIMATE_STATE, data);
                        }
                        break;

                      case 1:
                        rootAnimateState.disabled = !value;
                        break;

                      default:
                        value = !rootAnimateState.disabled;
                        break;
                    }
                    return !!value;
                }
            };
            function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, options, doneCallback) {
                var noopCancel = noop;
                var runner = animationRunner(element, animationEvent, className, options);
                if (!runner) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return noopCancel;
                }
                animationEvent = runner.event;
                className = runner.className;
                var elementEvents = angular.element._data(runner.node);
                elementEvents = elementEvents && elementEvents.events;
                if (!parentElement) {
                    parentElement = afterElement ? afterElement.parent() : element.parent();
                }
                if (animationsDisabled(element, parentElement)) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    closeAnimation();
                    return noopCancel;
                }
                var ngAnimateState = element.data(NG_ANIMATE_STATE) || {};
                var runningAnimations = ngAnimateState.active || {};
                var totalActiveAnimations = ngAnimateState.totalActive || 0;
                var lastAnimation = ngAnimateState.last;
                var skipAnimation = false;
                if (totalActiveAnimations > 0) {
                    var animationsToCancel = [];
                    if (!runner.isClassBased) {
                        if (animationEvent == "leave" && runningAnimations["ng-leave"]) {
                            skipAnimation = true;
                        } else {
                            for (var klass in runningAnimations) {
                                animationsToCancel.push(runningAnimations[klass]);
                            }
                            ngAnimateState = {};
                            cleanup(element, true);
                        }
                    } else if (lastAnimation.event == "setClass") {
                        animationsToCancel.push(lastAnimation);
                        cleanup(element, className);
                    } else if (runningAnimations[className]) {
                        var current = runningAnimations[className];
                        if (current.event == animationEvent) {
                            skipAnimation = true;
                        } else {
                            animationsToCancel.push(current);
                            cleanup(element, className);
                        }
                    }
                    if (animationsToCancel.length > 0) {
                        forEach(animationsToCancel, function(operation) {
                            operation.cancel();
                        });
                    }
                }
                if (runner.isClassBased && !runner.isSetClassOperation && animationEvent != "animate" && !skipAnimation) {
                    skipAnimation = animationEvent == "addClass" == element.hasClass(className);
                }
                if (skipAnimation) {
                    fireDOMOperation();
                    fireBeforeCallbackAsync();
                    fireAfterCallbackAsync();
                    fireDoneCallbackAsync();
                    return noopCancel;
                }
                runningAnimations = ngAnimateState.active || {};
                totalActiveAnimations = ngAnimateState.totalActive || 0;
                if (animationEvent == "leave") {
                    element.one("$destroy", function(e) {
                        var element = angular.element(this);
                        var state = element.data(NG_ANIMATE_STATE);
                        if (state) {
                            var activeLeaveAnimation = state.active["ng-leave"];
                            if (activeLeaveAnimation) {
                                activeLeaveAnimation.cancel();
                                cleanup(element, "ng-leave");
                            }
                        }
                    });
                }
                $$jqLite.addClass(element, NG_ANIMATE_CLASS_NAME);
                if (options && options.tempClasses) {
                    forEach(options.tempClasses, function(className) {
                        $$jqLite.addClass(element, className);
                    });
                }
                var localAnimationCount = globalAnimationCounter++;
                totalActiveAnimations++;
                runningAnimations[className] = runner;
                element.data(NG_ANIMATE_STATE, {
                    last: runner,
                    active: runningAnimations,
                    index: localAnimationCount,
                    totalActive: totalActiveAnimations
                });
                fireBeforeCallbackAsync();
                runner.before(function(cancelled) {
                    var data = element.data(NG_ANIMATE_STATE);
                    cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent;
                    fireDOMOperation();
                    if (cancelled === true) {
                        closeAnimation();
                    } else {
                        fireAfterCallbackAsync();
                        runner.after(closeAnimation);
                    }
                });
                return runner.cancel;
                function fireDOMCallback(animationPhase) {
                    var eventName = "$animate:" + animationPhase;
                    if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {
                        $$asyncCallback(function() {
                            element.triggerHandler(eventName, {
                                event: animationEvent,
                                className: className
                            });
                        });
                    }
                }
                function fireBeforeCallbackAsync() {
                    fireDOMCallback("before");
                }
                function fireAfterCallbackAsync() {
                    fireDOMCallback("after");
                }
                function fireDoneCallbackAsync() {
                    fireDOMCallback("close");
                    doneCallback();
                }
                function fireDOMOperation() {
                    if (!fireDOMOperation.hasBeenRun) {
                        fireDOMOperation.hasBeenRun = true;
                        domOperation();
                    }
                }
                function closeAnimation() {
                    if (!closeAnimation.hasBeenRun) {
                        if (runner) {
                            runner.applyStyles();
                        }
                        closeAnimation.hasBeenRun = true;
                        if (options && options.tempClasses) {
                            forEach(options.tempClasses, function(className) {
                                $$jqLite.removeClass(element, className);
                            });
                        }
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data) {
                            if (runner && runner.isClassBased) {
                                cleanup(element, className);
                            } else {
                                $$asyncCallback(function() {
                                    var data = element.data(NG_ANIMATE_STATE) || {};
                                    if (localAnimationCount == data.index) {
                                        cleanup(element, className, animationEvent);
                                    }
                                });
                                element.data(NG_ANIMATE_STATE, data);
                            }
                        }
                        fireDoneCallbackAsync();
                    }
                }
            }
            function cancelChildAnimations(element) {
                var node = extractElementNode(element);
                if (node) {
                    var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
                    forEach(nodes, function(element) {
                        element = angular.element(element);
                        var data = element.data(NG_ANIMATE_STATE);
                        if (data && data.active) {
                            forEach(data.active, function(runner) {
                                runner.cancel();
                            });
                        }
                    });
                }
            }
            function cleanup(element, className) {
                if (isMatchingElement(element, $rootElement)) {
                    if (!rootAnimateState.disabled) {
                        rootAnimateState.running = false;
                        rootAnimateState.structural = false;
                    }
                } else if (className) {
                    var data = element.data(NG_ANIMATE_STATE) || {};
                    var removeAnimations = className === true;
                    if (!removeAnimations && data.active && data.active[className]) {
                        data.totalActive--;
                        delete data.active[className];
                    }
                    if (removeAnimations || !data.totalActive) {
                        $$jqLite.removeClass(element, NG_ANIMATE_CLASS_NAME);
                        element.removeData(NG_ANIMATE_STATE);
                    }
                }
            }
            function animationsDisabled(element, parentElement) {
                if (rootAnimateState.disabled) {
                    return true;
                }
                if (isMatchingElement(element, $rootElement)) {
                    return rootAnimateState.running;
                }
                var allowChildAnimations, parentRunningAnimation, hasParent;
                do {
                    if (parentElement.length === 0) break;
                    var isRoot = isMatchingElement(parentElement, $rootElement);
                    var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {};
                    if (state.disabled) {
                        return true;
                    }
                    if (isRoot) {
                        hasParent = true;
                    }
                    if (allowChildAnimations !== false) {
                        var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
                        if (angular.isDefined(animateChildrenFlag)) {
                            allowChildAnimations = animateChildrenFlag;
                        }
                    }
                    parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased;
                } while (parentElement = parentElement.parent());
                return !hasParent || !allowChildAnimations && parentRunningAnimation;
            }
        } ]);
        $animateProvider.register("", [ "$window", "$sniffer", "$timeout", "$$animateReflow", function($window, $sniffer, $timeout, $$animateReflow) {
            var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
            if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
                CSS_PREFIX = "-webkit-";
                TRANSITION_PROP = "WebkitTransition";
                TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
            } else {
                TRANSITION_PROP = "transition";
                TRANSITIONEND_EVENT = "transitionend";
            }
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS_PREFIX = "-webkit-";
                ANIMATION_PROP = "WebkitAnimation";
                ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
            } else {
                ANIMATION_PROP = "animation";
                ANIMATIONEND_EVENT = "animationend";
            }
            var DURATION_KEY = "Duration";
            var PROPERTY_KEY = "Property";
            var DELAY_KEY = "Delay";
            var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
            var ANIMATION_PLAYSTATE_KEY = "PlayState";
            var NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey";
            var NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data";
            var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
            var CLOSING_TIME_BUFFER = 1.5;
            var ONE_SECOND = 1e3;
            var lookupCache = {};
            var parentCounter = 0;
            var animationReflowQueue = [];
            var cancelAnimationReflow;
            function clearCacheAfterReflow() {
                if (!cancelAnimationReflow) {
                    cancelAnimationReflow = $$animateReflow(function() {
                        animationReflowQueue = [];
                        cancelAnimationReflow = null;
                        lookupCache = {};
                    });
                }
            }
            function afterReflow(element, callback) {
                if (cancelAnimationReflow) {
                    cancelAnimationReflow();
                }
                animationReflowQueue.push(callback);
                cancelAnimationReflow = $$animateReflow(function() {
                    forEach(animationReflowQueue, function(fn) {
                        fn();
                    });
                    animationReflowQueue = [];
                    cancelAnimationReflow = null;
                    lookupCache = {};
                });
            }
            var closingTimer = null;
            var closingTimestamp = 0;
            var animationElementQueue = [];
            function animationCloseHandler(element, totalTime) {
                var node = extractElementNode(element);
                element = angular.element(node);
                animationElementQueue.push(element);
                var futureTimestamp = Date.now() + totalTime;
                if (futureTimestamp <= closingTimestamp) {
                    return;
                }
                $timeout.cancel(closingTimer);
                closingTimestamp = futureTimestamp;
                closingTimer = $timeout(function() {
                    closeAllAnimations(animationElementQueue);
                    animationElementQueue = [];
                }, totalTime, false);
            }
            function closeAllAnimations(elements) {
                forEach(elements, function(element) {
                    var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                    if (elementData) {
                        forEach(elementData.closeAnimationFns, function(fn) {
                            fn();
                        });
                    }
                });
            }
            function getElementAnimationDetails(element, cacheKey) {
                var data = cacheKey ? lookupCache[cacheKey] : null;
                if (!data) {
                    var transitionDuration = 0;
                    var transitionDelay = 0;
                    var animationDuration = 0;
                    var animationDelay = 0;
                    forEach(element, function(element) {
                        if (element.nodeType == ELEMENT_NODE) {
                            var elementStyles = $window.getComputedStyle(element) || {};
                            var transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];
                            transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);
                            var transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];
                            transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);
                            var animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];
                            animationDelay = Math.max(parseMaxTime(elementStyles[ANIMATION_PROP + DELAY_KEY]), animationDelay);
                            var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
                            if (aDuration > 0) {
                                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
                            }
                            animationDuration = Math.max(aDuration, animationDuration);
                        }
                    });
                    data = {
                        total: 0,
                        transitionDelay: transitionDelay,
                        transitionDuration: transitionDuration,
                        animationDelay: animationDelay,
                        animationDuration: animationDuration
                    };
                    if (cacheKey) {
                        lookupCache[cacheKey] = data;
                    }
                }
                return data;
            }
            function parseMaxTime(str) {
                var maxValue = 0;
                var values = isString(str) ? str.split(/\s*,\s*/) : [];
                forEach(values, function(value) {
                    maxValue = Math.max(parseFloat(value) || 0, maxValue);
                });
                return maxValue;
            }
            function getCacheKey(element) {
                var parentElement = element.parent();
                var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
                if (!parentID) {
                    parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);
                    parentID = parentCounter;
                }
                return parentID + "-" + extractElementNode(element).getAttribute("class");
            }
            function animateSetup(animationEvent, element, className, styles) {
                var structural = [ "ng-enter", "ng-leave", "ng-move" ].indexOf(className) >= 0;
                var cacheKey = getCacheKey(element);
                var eventCacheKey = cacheKey + " " + className;
                var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;
                var stagger = {};
                if (itemIndex > 0) {
                    var staggerClassName = className + "-stagger";
                    var staggerCacheKey = cacheKey + " " + staggerClassName;
                    var applyClasses = !lookupCache[staggerCacheKey];
                    applyClasses && $$jqLite.addClass(element, staggerClassName);
                    stagger = getElementAnimationDetails(element, staggerCacheKey);
                    applyClasses && $$jqLite.removeClass(element, staggerClassName);
                }
                $$jqLite.addClass(element, className);
                var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};
                var timings = getElementAnimationDetails(element, eventCacheKey);
                var transitionDuration = timings.transitionDuration;
                var animationDuration = timings.animationDuration;
                if (structural && transitionDuration === 0 && animationDuration === 0) {
                    $$jqLite.removeClass(element, className);
                    return false;
                }
                var blockTransition = styles || structural && transitionDuration > 0;
                var blockAnimation = animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                var closeAnimationFns = formerData.closeAnimationFns || [];
                element.data(NG_ANIMATE_CSS_DATA_KEY, {
                    stagger: stagger,
                    cacheKey: eventCacheKey,
                    running: formerData.running || 0,
                    itemIndex: itemIndex,
                    blockTransition: blockTransition,
                    closeAnimationFns: closeAnimationFns
                });
                var node = extractElementNode(element);
                if (blockTransition) {
                    blockTransitions(node, true);
                    if (styles) {
                        element.css(styles);
                    }
                }
                if (blockAnimation) {
                    blockAnimations(node, true);
                }
                return true;
            }
            function animateRun(animationEvent, element, className, activeAnimationComplete, styles) {
                var node = extractElementNode(element);
                var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (node.getAttribute("class").indexOf(className) == -1 || !elementData) {
                    activeAnimationComplete();
                    return;
                }
                var activeClassName = "";
                var pendingClassName = "";
                forEach(className.split(" "), function(klass, i) {
                    var prefix = (i > 0 ? " " : "") + klass;
                    activeClassName += prefix + "-active";
                    pendingClassName += prefix + "-pending";
                });
                var style = "";
                var appliedStyles = [];
                var itemIndex = elementData.itemIndex;
                var stagger = elementData.stagger;
                var staggerTime = 0;
                if (itemIndex > 0) {
                    var transitionStaggerDelay = 0;
                    if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
                        transitionStaggerDelay = stagger.transitionDelay * itemIndex;
                    }
                    var animationStaggerDelay = 0;
                    if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {
                        animationStaggerDelay = stagger.animationDelay * itemIndex;
                        appliedStyles.push(CSS_PREFIX + "animation-play-state");
                    }
                    staggerTime = Math.round(Math.max(transitionStaggerDelay, animationStaggerDelay) * 100) / 100;
                }
                if (!staggerTime) {
                    $$jqLite.addClass(element, activeClassName);
                    if (elementData.blockTransition) {
                        blockTransitions(node, false);
                    }
                }
                var eventCacheKey = elementData.cacheKey + " " + activeClassName;
                var timings = getElementAnimationDetails(element, eventCacheKey);
                var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
                if (maxDuration === 0) {
                    $$jqLite.removeClass(element, activeClassName);
                    animateClose(element, className);
                    activeAnimationComplete();
                    return;
                }
                if (!staggerTime && styles && Object.keys(styles).length > 0) {
                    if (!timings.transitionDuration) {
                        element.css("transition", timings.animationDuration + "s linear all");
                        appliedStyles.push("transition");
                    }
                    element.css(styles);
                }
                var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);
                var maxDelayTime = maxDelay * ONE_SECOND;
                if (appliedStyles.length > 0) {
                    var oldStyle = node.getAttribute("style") || "";
                    if (oldStyle.charAt(oldStyle.length - 1) !== ";") {
                        oldStyle += ";";
                    }
                    node.setAttribute("style", oldStyle + " " + style);
                }
                var startTime = Date.now();
                var css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT;
                var animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;
                var totalTime = (staggerTime + animationTime) * ONE_SECOND;
                var staggerTimeout;
                if (staggerTime > 0) {
                    $$jqLite.addClass(element, pendingClassName);
                    staggerTimeout = $timeout(function() {
                        staggerTimeout = null;
                        if (timings.transitionDuration > 0) {
                            blockTransitions(node, false);
                        }
                        if (timings.animationDuration > 0) {
                            blockAnimations(node, false);
                        }
                        $$jqLite.addClass(element, activeClassName);
                        $$jqLite.removeClass(element, pendingClassName);
                        if (styles) {
                            if (timings.transitionDuration === 0) {
                                element.css("transition", timings.animationDuration + "s linear all");
                            }
                            element.css(styles);
                            appliedStyles.push("transition");
                        }
                    }, staggerTime * ONE_SECOND, false);
                }
                element.on(css3AnimationEvents, onAnimationProgress);
                elementData.closeAnimationFns.push(function() {
                    onEnd();
                    activeAnimationComplete();
                });
                elementData.running++;
                animationCloseHandler(element, totalTime);
                return onEnd;
                function onEnd() {
                    element.off(css3AnimationEvents, onAnimationProgress);
                    $$jqLite.removeClass(element, activeClassName);
                    $$jqLite.removeClass(element, pendingClassName);
                    if (staggerTimeout) {
                        $timeout.cancel(staggerTimeout);
                    }
                    animateClose(element, className);
                    var node = extractElementNode(element);
                    for (var i in appliedStyles) {
                        node.style.removeProperty(appliedStyles[i]);
                    }
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event;
                    var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                    var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                        activeAnimationComplete();
                    }
                }
            }
            function blockTransitions(node, bool) {
                node.style[TRANSITION_PROP + PROPERTY_KEY] = bool ? "none" : "";
            }
            function blockAnimations(node, bool) {
                node.style[ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY] = bool ? "paused" : "";
            }
            function animateBefore(animationEvent, element, className, styles) {
                if (animateSetup(animationEvent, element, className, styles)) {
                    return function(cancelled) {
                        cancelled && animateClose(element, className);
                    };
                }
            }
            function animateAfter(animationEvent, element, className, afterAnimationComplete, styles) {
                if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {
                    return animateRun(animationEvent, element, className, afterAnimationComplete, styles);
                } else {
                    animateClose(element, className);
                    afterAnimationComplete();
                }
            }
            function animate(animationEvent, element, className, animationComplete, options) {
                var preReflowCancellation = animateBefore(animationEvent, element, className, options.from);
                if (!preReflowCancellation) {
                    clearCacheAfterReflow();
                    animationComplete();
                    return;
                }
                var cancel = preReflowCancellation;
                afterReflow(element, function() {
                    cancel = animateAfter(animationEvent, element, className, animationComplete, options.to);
                });
                return function(cancelled) {
                    (cancel || noop)(cancelled);
                };
            }
            function animateClose(element, className) {
                $$jqLite.removeClass(element, className);
                var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (data) {
                    if (data.running) {
                        data.running--;
                    }
                    if (!data.running || data.running === 0) {
                        element.removeData(NG_ANIMATE_CSS_DATA_KEY);
                    }
                }
            }
            return {
                animate: function(element, className, from, to, animationCompleted, options) {
                    options = options || {};
                    options.from = from;
                    options.to = to;
                    return animate("animate", element, className, animationCompleted, options);
                },
                enter: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("enter", element, "ng-enter", animationCompleted, options);
                },
                leave: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("leave", element, "ng-leave", animationCompleted, options);
                },
                move: function(element, animationCompleted, options) {
                    options = options || {};
                    return animate("move", element, "ng-move", animationCompleted, options);
                },
                beforeSetClass: function(element, add, remove, animationCompleted, options) {
                    options = options || {};
                    var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add");
                    var cancellationMethod = animateBefore("setClass", element, className, options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                beforeAddClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                beforeRemoveClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), options.from);
                    if (cancellationMethod) {
                        afterReflow(element, animationCompleted);
                        return cancellationMethod;
                    }
                    clearCacheAfterReflow();
                    animationCompleted();
                },
                setClass: function(element, add, remove, animationCompleted, options) {
                    options = options || {};
                    remove = suffixClasses(remove, "-remove");
                    add = suffixClasses(add, "-add");
                    var className = remove + " " + add;
                    return animateAfter("setClass", element, className, animationCompleted, options.to);
                },
                addClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted, options.to);
                },
                removeClass: function(element, className, animationCompleted, options) {
                    options = options || {};
                    return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted, options.to);
                }
            };
            function suffixClasses(classes, suffix) {
                var className = "";
                classes = isArray(classes) ? classes : classes.split(/\s+/);
                forEach(classes, function(klass, i) {
                    if (klass && klass.length > 0) {
                        className += (i > 0 ? " " : "") + klass + suffix;
                    }
                });
                return className;
            }
        } ]);
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    var ngAriaModule = angular.module("ngAria", [ "ng" ]).provider("$aria", $AriaProvider);
    function $AriaProvider() {
        var config = {
            ariaHidden: true,
            ariaChecked: true,
            ariaDisabled: true,
            ariaRequired: true,
            ariaInvalid: true,
            ariaMultiline: true,
            ariaValue: true,
            tabindex: true,
            bindKeypress: true
        };
        this.config = function(newConfig) {
            config = angular.extend(config, newConfig);
        };
        function watchExpr(attrName, ariaAttr, negate) {
            return function(scope, elem, attr) {
                var ariaCamelName = attr.$normalize(ariaAttr);
                if (config[ariaCamelName] && !attr[ariaCamelName]) {
                    scope.$watch(attr[attrName], function(boolVal) {
                        if (negate) {
                            boolVal = !boolVal;
                        }
                        elem.attr(ariaAttr, boolVal);
                    });
                }
            };
        }
        this.$get = function() {
            return {
                config: function(key) {
                    return config[key];
                },
                $$watchExpr: watchExpr
            };
        };
    }
    ngAriaModule.directive("ngShow", [ "$aria", function($aria) {
        return $aria.$$watchExpr("ngShow", "aria-hidden", true);
    } ]).directive("ngHide", [ "$aria", function($aria) {
        return $aria.$$watchExpr("ngHide", "aria-hidden", false);
    } ]).directive("ngModel", [ "$aria", function($aria) {
        function shouldAttachAttr(attr, normalizedAttr, elem) {
            return $aria.config(normalizedAttr) && !elem.attr(attr);
        }
        function getShape(attr, elem) {
            var type = attr.type, role = attr.role;
            return (type || role) === "checkbox" || role === "menuitemcheckbox" ? "checkbox" : (type || role) === "radio" || role === "menuitemradio" ? "radio" : type === "range" || role === "progressbar" || role === "slider" ? "range" : (type || role) === "textbox" || elem[0].nodeName === "TEXTAREA" ? "multiline" : "";
        }
        return {
            restrict: "A",
            require: "?ngModel",
            priority: 200,
            link: function(scope, elem, attr, ngModel) {
                var shape = getShape(attr, elem);
                var needsTabIndex = shouldAttachAttr("tabindex", "tabindex", elem);
                function ngAriaWatchModelValue() {
                    return ngModel.$modelValue;
                }
                function getRadioReaction() {
                    if (needsTabIndex) {
                        needsTabIndex = false;
                        return function ngAriaRadioReaction(newVal) {
                            var boolVal = attr.value == ngModel.$viewValue;
                            elem.attr("aria-checked", boolVal);
                            elem.attr("tabindex", 0 - !boolVal);
                        };
                    } else {
                        return function ngAriaRadioReaction(newVal) {
                            elem.attr("aria-checked", attr.value == ngModel.$viewValue);
                        };
                    }
                }
                function ngAriaCheckboxReaction(newVal) {
                    elem.attr("aria-checked", !ngModel.$isEmpty(ngModel.$viewValue));
                }
                switch (shape) {
                  case "radio":
                  case "checkbox":
                    if (shouldAttachAttr("aria-checked", "ariaChecked", elem)) {
                        scope.$watch(ngAriaWatchModelValue, shape === "radio" ? getRadioReaction() : ngAriaCheckboxReaction);
                    }
                    break;

                  case "range":
                    if ($aria.config("ariaValue")) {
                        if (attr.min && !elem.attr("aria-valuemin")) {
                            elem.attr("aria-valuemin", attr.min);
                        }
                        if (attr.max && !elem.attr("aria-valuemax")) {
                            elem.attr("aria-valuemax", attr.max);
                        }
                        if (!elem.attr("aria-valuenow")) {
                            scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                                elem.attr("aria-valuenow", newVal);
                            });
                        }
                    }
                    break;

                  case "multiline":
                    if (shouldAttachAttr("aria-multiline", "ariaMultiline", elem)) {
                        elem.attr("aria-multiline", true);
                    }
                    break;
                }
                if (needsTabIndex) {
                    elem.attr("tabindex", 0);
                }
                if (ngModel.$validators.required && shouldAttachAttr("aria-required", "ariaRequired", elem)) {
                    scope.$watch(function ngAriaRequiredWatch() {
                        return ngModel.$error.required;
                    }, function ngAriaRequiredReaction(newVal) {
                        elem.attr("aria-required", !!newVal);
                    });
                }
                if (shouldAttachAttr("aria-invalid", "ariaInvalid", elem)) {
                    scope.$watch(function ngAriaInvalidWatch() {
                        return ngModel.$invalid;
                    }, function ngAriaInvalidReaction(newVal) {
                        elem.attr("aria-invalid", !!newVal);
                    });
                }
            }
        };
    } ]).directive("ngDisabled", [ "$aria", function($aria) {
        return $aria.$$watchExpr("ngDisabled", "aria-disabled");
    } ]).directive("ngMessages", function() {
        return {
            restrict: "A",
            require: "?ngMessages",
            link: function(scope, elem, attr, ngMessages) {
                if (!elem.attr("aria-live")) {
                    elem.attr("aria-live", "assertive");
                }
            }
        };
    }).directive("ngClick", [ "$aria", "$parse", function($aria, $parse) {
        return {
            restrict: "A",
            compile: function(elem, attr) {
                var fn = $parse(attr.ngClick, null, true);
                return function(scope, elem, attr) {
                    function isNodeOneOf(elem, nodeTypeArray) {
                        if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
                            return true;
                        }
                    }
                    if ($aria.config("tabindex") && !elem.attr("tabindex")) {
                        elem.attr("tabindex", 0);
                    }
                    if ($aria.config("bindKeypress") && !attr.ngKeypress && isNodeOneOf(elem, [ "DIV", "LI" ])) {
                        elem.on("keypress", function(event) {
                            if (event.keyCode === 32 || event.keyCode === 13) {
                                scope.$apply(callback);
                            }
                            function callback() {
                                fn(scope, {
                                    $event: event
                                });
                            }
                        });
                    }
                };
            }
        };
    } ]).directive("ngDblclick", [ "$aria", function($aria) {
        return function(scope, elem, attr) {
            if ($aria.config("tabindex") && !elem.attr("tabindex")) {
                elem.attr("tabindex", 0);
            }
        };
    } ]);
})(window, window.angular);

(function(window, angular, undefined) {
    "use strict";
    var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isNumber = angular.isNumber, isObject = angular.isObject, isArray = angular.isArray, extend = angular.extend, toJson = angular.toJson, fromJson = angular.fromJson;
    function isStringNumber(num) {
        return /^-?\d+\.?\d*$/.test(num.replace(/["']/g, ""));
    }
    var angularLocalStorage = angular.module("LocalStorageModule", []);
    angularLocalStorage.provider("localStorageService", function() {
        this.prefix = "ls";
        this.storageType = "localStorage";
        this.cookie = {
            expiry: 30,
            path: "/"
        };
        this.notify = {
            setItem: true,
            removeItem: false
        };
        this.setPrefix = function(prefix) {
            this.prefix = prefix;
            return this;
        };
        this.setStorageType = function(storageType) {
            this.storageType = storageType;
            return this;
        };
        this.setStorageCookie = function(exp, path) {
            this.cookie = {
                expiry: exp,
                path: path
            };
            return this;
        };
        this.setStorageCookieDomain = function(domain) {
            this.cookie.domain = domain;
            return this;
        };
        this.setNotify = function(itemSet, itemRemove) {
            this.notify = {
                setItem: itemSet,
                removeItem: itemRemove
            };
            return this;
        };
        this.$get = [ "$rootScope", "$window", "$document", "$parse", function($rootScope, $window, $document, $parse) {
            var self = this;
            var prefix = self.prefix;
            var cookie = self.cookie;
            var notify = self.notify;
            var storageType = self.storageType;
            var webStorage;
            if (!$document) {
                $document = document;
            } else if ($document[0]) {
                $document = $document[0];
            }
            if (prefix.substr(-1) !== ".") {
                prefix = !!prefix ? prefix + "." : "";
            }
            var deriveQualifiedKey = function(key) {
                return prefix + key;
            };
            var browserSupportsLocalStorage = function() {
                try {
                    var supported = storageType in $window && $window[storageType] !== null;
                    var key = deriveQualifiedKey("__" + Math.round(Math.random() * 1e7));
                    if (supported) {
                        webStorage = $window[storageType];
                        webStorage.setItem(key, "");
                        webStorage.removeItem(key);
                    }
                    return supported;
                } catch (e) {
                    storageType = "cookie";
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
            }();
            var addToLocalStorage = function(key, value) {
                if (isUndefined(value)) {
                    value = null;
                } else if (isObject(value) || isArray(value) || isNumber(+value || value)) {
                    value = toJson(value);
                }
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    if (notify.setItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: "cookie"
                        });
                    }
                    return addToCookies(key, value);
                }
                try {
                    if (isObject(value) || isArray(value)) {
                        value = toJson(value);
                    }
                    if (webStorage) {
                        webStorage.setItem(deriveQualifiedKey(key), value);
                    }
                    if (notify.setItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: self.storageType
                        });
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return addToCookies(key, value);
                }
                return true;
            };
            var getFromLocalStorage = function(key) {
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    return getFromCookies(key);
                }
                var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                if (!item || item === "null") {
                    return null;
                }
                if (item.charAt(0) === "{" || item.charAt(0) === "[" || isStringNumber(item)) {
                    return fromJson(item);
                }
                return item;
            };
            var removeFromLocalStorage = function(key) {
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    if (notify.removeItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                            key: key,
                            storageType: "cookie"
                        });
                    }
                    return removeFromCookies(key);
                }
                try {
                    webStorage.removeItem(deriveQualifiedKey(key));
                    if (notify.removeItem) {
                        $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                            key: key,
                            storageType: self.storageType
                        });
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return removeFromCookies(key);
                }
                return true;
            };
            var getKeysForLocalStorage = function() {
                if (!browserSupportsLocalStorage) {
                    $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    return false;
                }
                var prefixLength = prefix.length;
                var keys = [];
                for (var key in webStorage) {
                    if (key.substr(0, prefixLength) === prefix) {
                        try {
                            keys.push(key.substr(prefixLength));
                        } catch (e) {
                            $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description);
                            return [];
                        }
                    }
                }
                return keys;
            };
            var clearAllFromLocalStorage = function(regularExpression) {
                regularExpression = regularExpression || "";
                var tempPrefix = prefix.slice(0, -1);
                var testRegex = new RegExp(tempPrefix + "." + regularExpression);
                if (!browserSupportsLocalStorage || self.storageType === "cookie") {
                    if (!browserSupportsLocalStorage) {
                        $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    }
                    return clearAllFromCookies();
                }
                var prefixLength = prefix.length;
                for (var key in webStorage) {
                    if (testRegex.test(key)) {
                        try {
                            removeFromLocalStorage(key.substr(prefixLength));
                        } catch (e) {
                            $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                            return clearAllFromCookies();
                        }
                    }
                }
                return true;
            };
            var browserSupportsCookies = function() {
                try {
                    return $window.navigator.cookieEnabled || "cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1);
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
            }();
            var addToCookies = function(key, value) {
                if (isUndefined(value)) {
                    return false;
                } else if (isArray(value) || isObject(value)) {
                    value = toJson(value);
                }
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return false;
                }
                try {
                    var expiry = "", expiryDate = new Date(), cookieDomain = "";
                    if (value === null) {
                        expiryDate.setTime(expiryDate.getTime() + -1 * 24 * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                        value = "";
                    } else if (cookie.expiry !== 0) {
                        expiryDate.setTime(expiryDate.getTime() + cookie.expiry * 24 * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                    }
                    if (!!key) {
                        var cookiePath = "; path=" + cookie.path;
                        if (cookie.domain) {
                            cookieDomain = "; domain=" + cookie.domain;
                        }
                        $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return false;
                }
                return true;
            };
            var getFromCookies = function(key) {
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return false;
                }
                var cookies = $document.cookie && $document.cookie.split(";") || [];
                for (var i = 0; i < cookies.length; i++) {
                    var thisCookie = cookies[i];
                    while (thisCookie.charAt(0) === " ") {
                        thisCookie = thisCookie.substring(1, thisCookie.length);
                    }
                    if (thisCookie.indexOf(deriveQualifiedKey(key) + "=") === 0) {
                        var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                        try {
                            var obj = JSON.parse(storedValues);
                            return fromJson(obj);
                        } catch (e) {
                            return storedValues;
                        }
                    }
                }
                return null;
            };
            var removeFromCookies = function(key) {
                addToCookies(key, null);
            };
            var clearAllFromCookies = function() {
                var thisCookie = null, thisKey = null;
                var prefixLength = prefix.length;
                var cookies = $document.cookie.split(";");
                for (var i = 0; i < cookies.length; i++) {
                    thisCookie = cookies[i];
                    while (thisCookie.charAt(0) === " ") {
                        thisCookie = thisCookie.substring(1, thisCookie.length);
                    }
                    var key = thisCookie.substring(prefixLength, thisCookie.indexOf("="));
                    removeFromCookies(key);
                }
            };
            var getStorageType = function() {
                return storageType;
            };
            var bindToScope = function(scope, key, def, lsKey) {
                lsKey = lsKey || key;
                var value = getFromLocalStorage(lsKey);
                if (value === null && isDefined(def)) {
                    value = def;
                } else if (isObject(value) && isObject(def)) {
                    value = extend(def, value);
                }
                $parse(key).assign(scope, value);
                return scope.$watch(key, function(newVal) {
                    addToLocalStorage(lsKey, newVal);
                }, isObject(scope[key]));
            };
            var lengthOfLocalStorage = function() {
                var count = 0;
                var storage = $window[storageType];
                for (var i = 0; i < storage.length; i++) {
                    if (storage.key(i).indexOf(prefix) === 0) {
                        count++;
                    }
                }
                return count;
            };
            return {
                isSupported: browserSupportsLocalStorage,
                getStorageType: getStorageType,
                set: addToLocalStorage,
                add: addToLocalStorage,
                get: getFromLocalStorage,
                keys: getKeysForLocalStorage,
                remove: removeFromLocalStorage,
                clearAll: clearAllFromLocalStorage,
                bind: bindToScope,
                deriveKey: deriveQualifiedKey,
                length: lengthOfLocalStorage,
                cookie: {
                    isSupported: browserSupportsCookies,
                    set: addToCookies,
                    add: addToCookies,
                    get: getFromCookies,
                    remove: removeFromCookies,
                    clearAll: clearAllFromCookies
                }
            };
        } ];
    });
})(window, window.angular);

angular.module("xeditable", []).value("editableOptions", {
    theme: "default",
    buttons: "right",
    blurElem: "cancel",
    blurForm: "ignore",
    activate: "focus"
});

angular.module("xeditable").directive("editableBsdate", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableBsdate",
        inputTpl: '<input type="text">'
    });
} ]);

angular.module("xeditable").directive("editableBstime", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableBstime",
        inputTpl: "<timepicker></timepicker>",
        render: function() {
            this.parent.render.call(this);
            var div = angular.element('<div class="well well-small" style="display:inline-block;"></div>');
            div.attr("ng-model", this.inputEl.attr("ng-model"));
            this.inputEl.removeAttr("ng-model");
            if (this.attrs.eNgChange) {
                div.attr("ng-change", this.inputEl.attr("ng-change"));
                this.inputEl.removeAttr("ng-change");
            }
            this.inputEl.wrap(div);
        }
    });
} ]);

angular.module("xeditable").directive("editableCheckbox", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableCheckbox",
        inputTpl: '<input type="checkbox">',
        render: function() {
            this.parent.render.call(this);
            if (this.attrs.eTitle) {
                this.inputEl.wrap("<label></label>");
                this.inputEl.after(angular.element("<span></span>").text(this.attrs.eTitle));
            }
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableChecklist", [ "editableDirectiveFactory", "editableNgOptionsParser", function(editableDirectiveFactory, editableNgOptionsParser) {
    return editableDirectiveFactory({
        directiveName: "editableChecklist",
        inputTpl: "<span></span>",
        useCopy: true,
        render: function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="checkbox" checklist-model="$parent.$data" checklist-value="' + parsed.locals.valueFn + '">' + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.html(html);
        }
    });
} ]);

(function() {
    var types = "text|email|tel|number|url|search|color|date|datetime|time|month|week".split("|");
    angular.forEach(types, function(type) {
        var directiveName = "editable" + type.charAt(0).toUpperCase() + type.slice(1);
        angular.module("xeditable").directive(directiveName, [ "editableDirectiveFactory", function(editableDirectiveFactory) {
            return editableDirectiveFactory({
                directiveName: directiveName,
                inputTpl: '<input type="' + type + '">'
            });
        } ]);
    });
    angular.module("xeditable").directive("editableRange", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
        return editableDirectiveFactory({
            directiveName: "editableRange",
            inputTpl: '<input type="range" id="range" name="range">',
            render: function() {
                this.parent.render.call(this);
                this.inputEl.after("<output>{{$data}}</output>");
            }
        });
    } ]);
})();

angular.module("xeditable").directive("editableRadiolist", [ "editableDirectiveFactory", "editableNgOptionsParser", function(editableDirectiveFactory, editableNgOptionsParser) {
    return editableDirectiveFactory({
        directiveName: "editableRadiolist",
        inputTpl: "<span></span>",
        render: function() {
            this.parent.render.call(this);
            var parsed = editableNgOptionsParser(this.attrs.eNgOptions);
            var html = '<label ng-repeat="' + parsed.ngRepeat + '">' + '<input type="radio" ng-model="$parent.$data" value="{{' + parsed.locals.valueFn + '}}">' + '<span ng-bind="' + parsed.locals.displayFn + '"></span></label>';
            this.inputEl.removeAttr("ng-model");
            this.inputEl.removeAttr("ng-options");
            this.inputEl.html(html);
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableSelect", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableSelect",
        inputTpl: "<select></select>",
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                self.scope.$apply(function() {
                    self.scope.$form.$submit();
                });
            });
        }
    });
} ]);

angular.module("xeditable").directive("editableTextarea", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableTextarea",
        inputTpl: "<textarea></textarea>",
        addListeners: function() {
            var self = this;
            self.parent.addListeners.call(self);
            if (self.single && self.buttons !== "no") {
                self.autosubmit();
            }
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("keydown", function(e) {
                if ((e.ctrlKey || e.metaKey) && e.keyCode === 13) {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }
            });
        }
    });
} ]);

angular.module("xeditable").factory("editableController", [ "$q", "editableUtils", function($q, editableUtils) {
    EditableController.$inject = [ "$scope", "$attrs", "$element", "$parse", "editableThemes", "editableOptions", "$rootScope", "$compile", "$q" ];
    function EditableController($scope, $attrs, $element, $parse, editableThemes, editableOptions, $rootScope, $compile, $q) {
        var valueGetter;
        var inWaiting;
        var self = this;
        self.scope = $scope;
        self.elem = $element;
        self.attrs = $attrs;
        self.inputEl = null;
        self.editorEl = null;
        self.single = true;
        self.error = "";
        self.theme = editableThemes[editableOptions.theme] || editableThemes["default"];
        self.parent = {};
        self.inputTpl = "";
        self.directiveName = "";
        self.useCopy = false;
        self.single = null;
        self.buttons = "right";
        self.init = function(single) {
            self.single = single;
            self.name = $attrs.eName || $attrs[self.directiveName];
            if ($attrs[self.directiveName]) {
                valueGetter = $parse($attrs[self.directiveName]);
            } else {
                throw "You should provide value for `" + self.directiveName + "` in editable element!";
            }
            if (!self.single) {
                self.buttons = "no";
            } else {
                self.buttons = self.attrs.buttons || editableOptions.buttons;
            }
            if ($attrs.eName) {
                self.scope.$watch("$data", function(newVal) {
                    self.scope.$form.$data[$attrs.eName] = newVal;
                });
            }
            if ($attrs.onshow) {
                self.onshow = function() {
                    return self.catchError($parse($attrs.onshow)($scope));
                };
            }
            if ($attrs.onhide) {
                self.onhide = function() {
                    return $parse($attrs.onhide)($scope);
                };
            }
            if ($attrs.oncancel) {
                self.oncancel = function() {
                    return $parse($attrs.oncancel)($scope);
                };
            }
            if ($attrs.onbeforesave) {
                self.onbeforesave = function() {
                    return self.catchError($parse($attrs.onbeforesave)($scope));
                };
            }
            if ($attrs.onaftersave) {
                self.onaftersave = function() {
                    return self.catchError($parse($attrs.onaftersave)($scope));
                };
            }
            $scope.$parent.$watch($attrs[self.directiveName], function(newVal, oldVal) {
                self.handleEmpty();
            });
        };
        self.render = function() {
            var theme = self.theme;
            self.inputEl = angular.element(self.inputTpl);
            self.controlsEl = angular.element(theme.controlsTpl);
            self.controlsEl.append(self.inputEl);
            if (self.buttons !== "no") {
                self.buttonsEl = angular.element(theme.buttonsTpl);
                self.submitEl = angular.element(theme.submitTpl);
                self.cancelEl = angular.element(theme.cancelTpl);
                self.buttonsEl.append(self.submitEl).append(self.cancelEl);
                self.controlsEl.append(self.buttonsEl);
                self.inputEl.addClass("editable-has-buttons");
            }
            self.errorEl = angular.element(theme.errorTpl);
            self.controlsEl.append(self.errorEl);
            self.editorEl = angular.element(self.single ? theme.formTpl : theme.noformTpl);
            self.editorEl.append(self.controlsEl);
            for (var k in $attrs.$attr) {
                if (k.length <= 1) {
                    continue;
                }
                var transferAttr = false;
                var nextLetter = k.substring(1, 2);
                if (k.substring(0, 1) === "e" && nextLetter === nextLetter.toUpperCase()) {
                    transferAttr = k.substring(1);
                } else {
                    continue;
                }
                if (transferAttr === "Form" || transferAttr === "NgSubmit") {
                    continue;
                }
                transferAttr = transferAttr.substring(0, 1).toLowerCase() + editableUtils.camelToDash(transferAttr.substring(1));
                var attrValue = $attrs[k] === "" ? transferAttr : $attrs[k];
                self.inputEl.attr(transferAttr, attrValue);
            }
            self.inputEl.addClass("editable-input");
            self.inputEl.attr("ng-model", "$data");
            self.editorEl.addClass(editableUtils.camelToDash(self.directiveName));
            if (self.single) {
                self.editorEl.attr("editable-form", "$form");
                self.editorEl.attr("blur", self.attrs.blur || (self.buttons === "no" ? "cancel" : editableOptions.blurElem));
            }
            if (angular.isFunction(theme.postrender)) {
                theme.postrender.call(self);
            }
        };
        self.setLocalValue = function() {
            self.scope.$data = self.useCopy ? angular.copy(valueGetter($scope.$parent)) : valueGetter($scope.$parent);
        };
        self.show = function() {
            self.setLocalValue();
            self.render();
            $element.after(self.editorEl);
            $compile(self.editorEl)($scope);
            self.addListeners();
            $element.addClass("editable-hide");
            return self.onshow();
        };
        self.hide = function() {
            self.editorEl.remove();
            $element.removeClass("editable-hide");
            return self.onhide();
        };
        self.cancel = function() {
            self.oncancel();
        };
        self.addListeners = function() {
            self.inputEl.bind("keyup", function(e) {
                if (!self.single) {
                    return;
                }
                switch (e.keyCode) {
                  case 27:
                    self.scope.$apply(function() {
                        self.scope.$form.$cancel();
                    });
                    break;
                }
            });
            if (self.single && self.buttons === "no") {
                self.autosubmit();
            }
            self.editorEl.bind("click", function(e) {
                if (e.which !== 1) {
                    return;
                }
                if (self.scope.$form.$visible) {
                    self.scope.$form._clicked = true;
                }
            });
        };
        self.setWaiting = function(value) {
            if (value) {
                inWaiting = !self.inputEl.attr("disabled") && !self.inputEl.attr("ng-disabled") && !self.inputEl.attr("ng-enabled");
                if (inWaiting) {
                    self.inputEl.attr("disabled", "disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").attr("disabled", "disabled");
                    }
                }
            } else {
                if (inWaiting) {
                    self.inputEl.removeAttr("disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").removeAttr("disabled");
                    }
                }
            }
        };
        self.activate = function() {
            setTimeout(function() {
                var el = self.inputEl[0];
                if (editableOptions.activate === "focus" && el.focus) {
                    el.focus();
                }
                if (editableOptions.activate === "select" && el.select) {
                    el.select();
                }
            }, 0);
        };
        self.setError = function(msg) {
            if (!angular.isObject(msg)) {
                $scope.$error = msg;
                self.error = msg;
            }
        };
        self.catchError = function(result, noPromise) {
            if (angular.isObject(result) && noPromise !== true) {
                $q.when(result).then(angular.bind(this, function(r) {
                    this.catchError(r, true);
                }), angular.bind(this, function(r) {
                    this.catchError(r, true);
                }));
            } else if (noPromise && angular.isObject(result) && result.status && result.status !== 200 && result.data && angular.isString(result.data)) {
                this.setError(result.data);
                result = result.data;
            } else if (angular.isString(result)) {
                this.setError(result);
            }
            return result;
        };
        self.save = function() {
            valueGetter.assign($scope.$parent, angular.copy(self.scope.$data));
        };
        self.handleEmpty = function() {
            var val = valueGetter($scope.$parent);
            var isEmpty = val === null || val === undefined || val === "" || angular.isArray(val) && val.length === 0;
            $element.toggleClass("editable-empty", isEmpty);
        };
        self.autosubmit = angular.noop;
        self.onshow = angular.noop;
        self.onhide = angular.noop;
        self.oncancel = angular.noop;
        self.onbeforesave = angular.noop;
        self.onaftersave = angular.noop;
    }
    return EditableController;
} ]);

angular.module("xeditable").factory("editableDirectiveFactory", [ "$parse", "$compile", "editableThemes", "$rootScope", "$document", "editableController", "editableFormController", function($parse, $compile, editableThemes, $rootScope, $document, editableController, editableFormController) {
    return function(overwrites) {
        return {
            restrict: "A",
            scope: true,
            require: [ overwrites.directiveName, "?^form" ],
            controller: editableController,
            link: function(scope, elem, attrs, ctrl) {
                var eCtrl = ctrl[0];
                var eFormCtrl;
                var hasForm = false;
                if (ctrl[1]) {
                    eFormCtrl = ctrl[1];
                    hasForm = true;
                } else if (attrs.eForm) {
                    var getter = $parse(attrs.eForm)(scope);
                    if (getter) {
                        eFormCtrl = getter;
                        hasForm = true;
                    } else {
                        for (var i = 0; i < $document[0].forms.length; i++) {
                            if ($document[0].forms[i].name === attrs.eForm) {
                                eFormCtrl = null;
                                hasForm = true;
                                break;
                            }
                        }
                    }
                }
                angular.forEach(overwrites, function(v, k) {
                    if (eCtrl[k] !== undefined) {
                        eCtrl.parent[k] = eCtrl[k];
                    }
                });
                angular.extend(eCtrl, overwrites);
                eCtrl.init(!hasForm);
                scope.$editable = eCtrl;
                elem.addClass("editable");
                if (hasForm) {
                    if (eFormCtrl) {
                        scope.$form = eFormCtrl;
                        if (!scope.$form.$addEditable) {
                            throw "Form with editable elements should have `editable-form` attribute.";
                        }
                        scope.$form.$addEditable(eCtrl);
                    } else {
                        $rootScope.$$editableBuffer = $rootScope.$$editableBuffer || {};
                        $rootScope.$$editableBuffer[attrs.eForm] = $rootScope.$$editableBuffer[attrs.eForm] || [];
                        $rootScope.$$editableBuffer[attrs.eForm].push(eCtrl);
                        scope.$form = null;
                    }
                } else {
                    scope.$form = editableFormController();
                    scope.$form.$addEditable(eCtrl);
                    if (attrs.eForm) {
                        scope.$parent[attrs.eForm] = scope.$form;
                    }
                    if (!attrs.eForm) {
                        elem.addClass("editable-click");
                        elem.bind("click", function(e) {
                            e.preventDefault();
                            e.editable = eCtrl;
                            scope.$apply(function() {
                                scope.$form.$show();
                            });
                        });
                    }
                }
            }
        };
    };
} ]);

angular.module("xeditable").factory("editableFormController", [ "$parse", "$document", "$rootScope", "editablePromiseCollection", "editableUtils", function($parse, $document, $rootScope, editablePromiseCollection, editableUtils) {
    var shown = [];
    $document.bind("click", function(e) {
        if (e.which !== 1) {
            return;
        }
        var toCancel = [];
        var toSubmit = [];
        for (var i = 0; i < shown.length; i++) {
            if (shown[i]._clicked) {
                shown[i]._clicked = false;
                continue;
            }
            if (shown[i].$waiting) {
                continue;
            }
            if (shown[i]._blur === "cancel") {
                toCancel.push(shown[i]);
            }
            if (shown[i]._blur === "submit") {
                toSubmit.push(shown[i]);
            }
        }
        if (toCancel.length || toSubmit.length) {
            $rootScope.$apply(function() {
                angular.forEach(toCancel, function(v) {
                    v.$cancel();
                });
                angular.forEach(toSubmit, function(v) {
                    v.$submit();
                });
            });
        }
    });
    var base = {
        $addEditable: function(editable) {
            this.$editables.push(editable);
            editable.elem.bind("$destroy", angular.bind(this, this.$removeEditable, editable));
            if (!editable.scope.$form) {
                editable.scope.$form = this;
            }
            if (this.$visible) {
                editable.catchError(editable.show());
            }
        },
        $removeEditable: function(editable) {
            for (var i = 0; i < this.$editables.length; i++) {
                if (this.$editables[i] === editable) {
                    this.$editables.splice(i, 1);
                    return;
                }
            }
        },
        $show: function() {
            if (this.$visible) {
                return;
            }
            this.$visible = true;
            var pc = editablePromiseCollection();
            pc.when(this.$onshow());
            this.$setError(null, "");
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.show());
            });
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, this.$activate),
                onFalse: angular.bind(this, this.$activate),
                onString: angular.bind(this, this.$activate)
            });
            setTimeout(angular.bind(this, function() {
                this._clicked = false;
                if (editableUtils.indexOf(shown, this) === -1) {
                    shown.push(this);
                }
            }), 0);
        },
        $activate: function(name) {
            var i;
            if (this.$editables.length) {
                if (angular.isString(name)) {
                    for (i = 0; i < this.$editables.length; i++) {
                        if (this.$editables[i].name === name) {
                            this.$editables[i].activate();
                            return;
                        }
                    }
                }
                for (i = 0; i < this.$editables.length; i++) {
                    if (this.$editables[i].error) {
                        this.$editables[i].activate();
                        return;
                    }
                }
                this.$editables[0].activate();
            }
        },
        $hide: function() {
            if (!this.$visible) {
                return;
            }
            this.$visible = false;
            this.$onhide();
            angular.forEach(this.$editables, function(editable) {
                editable.hide();
            });
            editableUtils.arrayRemove(shown, this);
        },
        $cancel: function() {
            if (!this.$visible) {
                return;
            }
            this.$oncancel();
            angular.forEach(this.$editables, function(editable) {
                editable.cancel();
            });
            this.$hide();
        },
        $setWaiting: function(value) {
            this.$waiting = !!value;
            angular.forEach(this.$editables, function(editable) {
                editable.setWaiting(!!value);
            });
        },
        $setError: function(name, msg) {
            angular.forEach(this.$editables, function(editable) {
                if (!name || editable.name === name) {
                    editable.setError(msg);
                }
            });
        },
        $submit: function() {
            if (this.$waiting) {
                return;
            }
            this.$setError(null, "");
            var pc = editablePromiseCollection();
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onbeforesave());
            });
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, checkSelf, true),
                onFalse: angular.bind(this, checkSelf, false),
                onString: angular.bind(this, this.$activate)
            });
            function checkSelf(childrenTrue) {
                var pc = editablePromiseCollection();
                pc.when(this.$onbeforesave());
                pc.then({
                    onWait: angular.bind(this, this.$setWaiting),
                    onTrue: childrenTrue ? angular.bind(this, this.$save) : angular.bind(this, this.$hide),
                    onFalse: angular.bind(this, this.$hide),
                    onString: angular.bind(this, this.$activate)
                });
            }
        },
        $save: function() {
            angular.forEach(this.$editables, function(editable) {
                editable.save();
            });
            var pc = editablePromiseCollection();
            pc.when(this.$onaftersave());
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onaftersave());
            });
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, this.$hide),
                onFalse: angular.bind(this, this.$hide),
                onString: angular.bind(this, this.$activate)
            });
        },
        $onshow: angular.noop,
        $oncancel: angular.noop,
        $onhide: angular.noop,
        $onbeforesave: angular.noop,
        $onaftersave: angular.noop
    };
    return function() {
        return angular.extend({
            $editables: [],
            $visible: false,
            $waiting: false,
            $data: {},
            _clicked: false,
            _blur: null
        }, base);
    };
} ]);

angular.module("xeditable").directive("editableForm", [ "$rootScope", "$parse", "editableFormController", "editableOptions", function($rootScope, $parse, editableFormController, editableOptions) {
    return {
        restrict: "A",
        require: [ "form" ],
        compile: function() {
            return {
                pre: function(scope, elem, attrs, ctrl) {
                    var form = ctrl[0];
                    var eForm;
                    if (attrs.editableForm) {
                        if (scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                            eForm = scope[attrs.editableForm];
                            angular.extend(form, eForm);
                        } else {
                            eForm = editableFormController();
                            scope[attrs.editableForm] = eForm;
                            angular.extend(eForm, form);
                        }
                    } else {
                        eForm = editableFormController();
                        angular.extend(form, eForm);
                    }
                    var buf = $rootScope.$$editableBuffer;
                    var name = form.$name;
                    if (name && buf && buf[name]) {
                        angular.forEach(buf[name], function(editable) {
                            eForm.$addEditable(editable);
                        });
                        delete buf[name];
                    }
                },
                post: function(scope, elem, attrs, ctrl) {
                    var eForm;
                    if (attrs.editableForm && scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                        eForm = scope[attrs.editableForm];
                    } else {
                        eForm = ctrl[0];
                    }
                    if (attrs.onshow) {
                        eForm.$onshow = angular.bind(eForm, $parse(attrs.onshow), scope);
                    }
                    if (attrs.onhide) {
                        eForm.$onhide = angular.bind(eForm, $parse(attrs.onhide), scope);
                    }
                    if (attrs.oncancel) {
                        eForm.$oncancel = angular.bind(eForm, $parse(attrs.oncancel), scope);
                    }
                    if (attrs.shown && $parse(attrs.shown)(scope)) {
                        eForm.$show();
                    }
                    eForm._blur = attrs.blur || editableOptions.blurForm;
                    if (!attrs.ngSubmit && !attrs.submit) {
                        if (attrs.onbeforesave) {
                            eForm.$onbeforesave = function() {
                                return $parse(attrs.onbeforesave)(scope, {
                                    $data: eForm.$data
                                });
                            };
                        }
                        if (attrs.onaftersave) {
                            eForm.$onaftersave = function() {
                                return $parse(attrs.onaftersave)(scope, {
                                    $data: eForm.$data
                                });
                            };
                        }
                        elem.bind("submit", function(event) {
                            event.preventDefault();
                            scope.$apply(function() {
                                eForm.$submit();
                            });
                        });
                    }
                    elem.bind("click", function(e) {
                        if (e.which !== 1) {
                            return;
                        }
                        if (eForm.$visible) {
                            eForm._clicked = true;
                        }
                    });
                }
            };
        }
    };
} ]);

angular.module("xeditable").factory("editablePromiseCollection", [ "$q", function($q) {
    function promiseCollection() {
        return {
            promises: [],
            hasFalse: false,
            hasString: false,
            when: function(result, noPromise) {
                if (result === false) {
                    this.hasFalse = true;
                } else if (!noPromise && angular.isObject(result)) {
                    this.promises.push($q.when(result));
                } else if (angular.isString(result)) {
                    this.hasString = true;
                } else {
                    return;
                }
            },
            then: function(callbacks) {
                callbacks = callbacks || {};
                var onTrue = callbacks.onTrue || angular.noop;
                var onFalse = callbacks.onFalse || angular.noop;
                var onString = callbacks.onString || angular.noop;
                var onWait = callbacks.onWait || angular.noop;
                var self = this;
                if (this.promises.length) {
                    onWait(true);
                    $q.all(this.promises).then(function(results) {
                        onWait(false);
                        angular.forEach(results, function(result) {
                            self.when(result, true);
                        });
                        applyCallback();
                    }, function(error) {
                        onWait(false);
                        onString();
                    });
                } else {
                    applyCallback();
                }
                function applyCallback() {
                    if (!self.hasString && !self.hasFalse) {
                        onTrue();
                    } else if (!self.hasString && self.hasFalse) {
                        onFalse();
                    } else {
                        onString();
                    }
                }
            }
        };
    }
    return promiseCollection;
} ]);

angular.module("xeditable").factory("editableUtils", [ function() {
    return {
        indexOf: function(array, obj) {
            if (array.indexOf) return array.indexOf(obj);
            for (var i = 0; i < array.length; i++) {
                if (obj === array[i]) return i;
            }
            return -1;
        },
        arrayRemove: function(array, value) {
            var index = this.indexOf(array, value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return value;
        },
        camelToDash: function(str) {
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            return str.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                return (pos ? "-" : "") + letter.toLowerCase();
            });
        },
        dashToCamel: function(str) {
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var MOZ_HACK_REGEXP = /^moz([A-Z])/;
            return str.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).replace(MOZ_HACK_REGEXP, "Moz$1");
        }
    };
} ]);

angular.module("xeditable").factory("editableNgOptionsParser", [ function() {
    var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/;
    function parser(optionsExp) {
        var match;
        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
            throw "ng-options parse error";
        }
        var displayFn = match[2] || match[1], valueName = match[4] || match[6], keyName = match[5], groupByFn = match[3] || "", valueFn = match[2] ? match[1] : valueName, valuesFn = match[7], track = match[8], trackFn = track ? match[8] : null;
        var ngRepeat;
        if (keyName === undefined) {
            ngRepeat = valueName + " in " + valuesFn;
            if (track !== undefined) {
                ngRepeat += " track by " + trackFn;
            }
        } else {
            ngRepeat = "(" + keyName + ", " + valueName + ") in " + valuesFn;
        }
        return {
            ngRepeat: ngRepeat,
            locals: {
                valueName: valueName,
                keyName: keyName,
                valueFn: valueFn,
                displayFn: displayFn
            }
        };
    }
    return parser;
} ]);

angular.module("xeditable").factory("editableThemes", function() {
    var themes = {
        "default": {
            formTpl: '<form class="editable-wrap"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<span class="editable-controls"></span>',
            inputTpl: "",
            errorTpl: '<div class="editable-error" ng-show="$error" ng-bind="$error"></div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit">save</button>',
            cancelTpl: '<button type="button" ng-click="$form.$cancel()">cancel</button>'
        },
        bs2: {
            formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',
            inputTpl: "",
            errorTpl: '<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit" class="btn btn-primary"><span class="icon-ok icon-white"></span></button>',
            cancelTpl: '<button type="button" class="btn" ng-click="$form.$cancel()">' + '<span class="icon-remove"></span>' + "</button>"
        },
        bs3: {
            formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',
            inputTpl: "",
            errorTpl: '<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit" class="btn btn-primary"><span class="glyphicon glyphicon-ok"></span></button>',
            cancelTpl: '<button type="button" class="btn btn-default" ng-click="$form.$cancel()">' + '<span class="glyphicon glyphicon-remove"></span>' + "</button>",
            buttonsClass: "",
            inputClass: "",
            postrender: function() {
                switch (this.directiveName) {
                  case "editableText":
                  case "editableSelect":
                  case "editableTextarea":
                  case "editableEmail":
                  case "editableTel":
                  case "editableNumber":
                  case "editableUrl":
                  case "editableSearch":
                  case "editableDate":
                  case "editableDatetime":
                  case "editableTime":
                  case "editableMonth":
                  case "editableWeek":
                    this.inputEl.addClass("form-control");
                    if (this.theme.inputClass) {
                        if (this.inputEl.attr("multiple") && (this.theme.inputClass === "input-sm" || this.theme.inputClass === "input-lg")) {
                            break;
                        }
                        this.inputEl.addClass(this.theme.inputClass);
                    }
                    break;
                }
                if (this.buttonsEl && this.theme.buttonsClass) {
                    this.buttonsEl.find("button").addClass(this.theme.buttonsClass);
                }
            }
        }
    };
    return themes;
});

(function(window, angular, undefined) {
    "use strict";
    var $sanitizeMinErr = angular.$$minErr("$sanitize");
    function $SanitizeProvider() {
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join("");
            };
        } ];
    }
    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join("");
    }
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    var voidElements = makeMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," + "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," + "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," + "stop,svg,switch,text,title,tspan,use");
    var specialElements = makeMap("script,style");
    var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
    var htmlAttrs = makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," + "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," + "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," + "scope,scrolling,shape,size,span,start,summary,target,title,type," + "valign,value,vspace,width");
    var svgAttrs = makeMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent," + "attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color," + "color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family," + "font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name," + "gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints," + "keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits," + "markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position," + "overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY," + "repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh," + "stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke," + "stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit," + "stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2," + "underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version," + "viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role," + "xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2," + "zoomAndPan", true);
    var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
    function makeMap(str, lowercaseKeys) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) {
            obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
    }
    function htmlParser(html, handler) {
        if (typeof html !== "string") {
            if (html === null || typeof html === "undefined") {
                html = "";
            } else {
                html = "" + html;
            }
        }
        var index, chars, match, stack = [], last = html, text;
        stack.last = function() {
            return stack[stack.length - 1];
        };
        while (html) {
            text = "";
            chars = true;
            if (!stack.last() || !specialElements[stack.last()]) {
                if (html.indexOf("<!--") === 0) {
                    index = html.indexOf("--", 4);
                    if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                        if (handler.comment) handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (DOCTYPE_REGEXP.test(html)) {
                    match = html.match(DOCTYPE_REGEXP);
                    if (match) {
                        html = html.replace(match[0], "");
                        chars = false;
                    }
                } else if (BEGING_END_TAGE_REGEXP.test(html)) {
                    match = html.match(END_TAG_REGEXP);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(END_TAG_REGEXP, parseEndTag);
                        chars = false;
                    }
                } else if (BEGIN_TAG_REGEXP.test(html)) {
                    match = html.match(START_TAG_REGEXP);
                    if (match) {
                        if (match[4]) {
                            html = html.substring(match[0].length);
                            match[0].replace(START_TAG_REGEXP, parseStartTag);
                        }
                        chars = false;
                    } else {
                        text += "<";
                        html = html.substring(1);
                    }
                }
                if (chars) {
                    index = html.indexOf("<");
                    text += index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);
                    if (handler.chars) handler.chars(decodeEntities(text));
                }
            } else {
                html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
                    text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
                    if (handler.chars) handler.chars(decodeEntities(text));
                    return "";
                });
                parseEndTag("", stack.last());
            }
            if (html == last) {
                throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block " + "of html: {0}", html);
            }
            last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = angular.lowercase(tagName);
            if (blockElements[tagName]) {
                while (stack.last() && inlineElements[stack.last()]) {
                    parseEndTag("", stack.last());
                }
            }
            if (optionalEndTagElements[tagName] && stack.last() == tagName) {
                parseEndTag("", tagName);
            }
            unary = voidElements[tagName] || !!unary;
            if (!unary) {
                stack.push(tagName);
            }
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value);
            });
            if (handler.start) handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
            var pos = 0, i;
            tagName = angular.lowercase(tagName);
            if (tagName) {
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] == tagName) break;
                }
            }
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--) if (handler.end) handler.end(stack[i]);
                stack.length = pos;
            }
        }
    }
    var hiddenPre = document.createElement("pre");
    function decodeEntities(value) {
        if (!value) {
            return "";
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0);
            var low = value.charCodeAt(1);
            return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return "&#" + value.charCodeAt(0) + ";";
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] === true) {
                    out("<");
                    out(tag);
                    angular.forEach(attrs, function(value, key) {
                        var lkey = angular.lowercase(key);
                        var isImage = tag === "img" && lkey === "src" || lkey === "background";
                        if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                            out(" ");
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? "/>" : ">");
                }
            },
            end: function(tag) {
                tag = angular.lowercase(tag);
                if (!ignore && validElements[tag] === true) {
                    out("</");
                    out(tag);
                    out(">");
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars) {
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
    angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"”’]/, MAILTO_REGEXP = /^mailto:/;
        return function(text, target) {
            if (!text) return text;
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while (match = raw.match(LINKY_URL_REGEXP)) {
                url = match[0];
                if (!match[2] && !match[4]) {
                    url = (match[3] ? "http://" : "mailto:") + url;
                }
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ""));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(""));
            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                html.push("<a ");
                if (angular.isDefined(target)) {
                    html.push('target="', target, '" ');
                }
                html.push('href="', url.replace(/"/g, "&quot;"), '">');
                addText(text);
                html.push("</a>");
            }
        };
    } ]);
})(window, window.angular);

"format global";

"deps angular";

"deps moment";

(function() {
    "use strict";
    function angularMoment(angular, moment) {
        return angular.module("angularMoment", []).constant("angularMomentConfig", {
            preprocess: null,
            timezone: "",
            format: null,
            statefulFilters: true
        }).constant("moment", moment).constant("amTimeAgoConfig", {
            withoutSuffix: false,
            serverTime: null,
            titleFormat: null
        }).directive("amTimeAgo", [ "$window", "moment", "amMoment", "amTimeAgoConfig", "angularMomentConfig", function($window, moment, amMoment, amTimeAgoConfig, angularMomentConfig) {
            return function(scope, element, attr) {
                var activeTimeout = null;
                var currentValue;
                var currentFormat = angularMomentConfig.format;
                var withoutSuffix = amTimeAgoConfig.withoutSuffix;
                var titleFormat = amTimeAgoConfig.titleFormat;
                var localDate = new Date().getTime();
                var preprocess = angularMomentConfig.preprocess;
                var modelName = attr.amTimeAgo.replace(/^::/, "");
                var isBindOnce = attr.amTimeAgo.indexOf("::") === 0;
                var isTimeElement = "TIME" === element[0].nodeName.toUpperCase();
                var unwatchChanges;
                function getNow() {
                    var now;
                    if (amTimeAgoConfig.serverTime) {
                        var localNow = new Date().getTime();
                        var nowMillis = localNow - localDate + amTimeAgoConfig.serverTime;
                        now = moment(nowMillis);
                    } else {
                        now = moment();
                    }
                    return now;
                }
                function cancelTimer() {
                    if (activeTimeout) {
                        $window.clearTimeout(activeTimeout);
                        activeTimeout = null;
                    }
                }
                function updateTime(momentInstance) {
                    element.text(momentInstance.from(getNow(), withoutSuffix));
                    if (titleFormat && !element.attr("title")) {
                        element.attr("title", momentInstance.local().format(titleFormat));
                    }
                    if (!isBindOnce) {
                        var howOld = Math.abs(getNow().diff(momentInstance, "minute"));
                        var secondsUntilUpdate = 3600;
                        if (howOld < 1) {
                            secondsUntilUpdate = 1;
                        } else if (howOld < 60) {
                            secondsUntilUpdate = 30;
                        } else if (howOld < 180) {
                            secondsUntilUpdate = 300;
                        }
                        activeTimeout = $window.setTimeout(function() {
                            updateTime(momentInstance);
                        }, secondsUntilUpdate * 1e3);
                    }
                }
                function updateDateTimeAttr(value) {
                    if (isTimeElement) {
                        element.attr("datetime", value);
                    }
                }
                function updateMoment() {
                    cancelTimer();
                    if (currentValue) {
                        var momentValue = amMoment.preprocessDate(currentValue, preprocess, currentFormat);
                        updateTime(momentValue);
                        updateDateTimeAttr(momentValue.toISOString());
                    }
                }
                unwatchChanges = scope.$watch(modelName, function(value) {
                    if (typeof value === "undefined" || value === null || value === "") {
                        cancelTimer();
                        if (currentValue) {
                            element.text("");
                            updateDateTimeAttr("");
                            currentValue = null;
                        }
                        return;
                    }
                    currentValue = value;
                    updateMoment();
                    if (value !== undefined && isBindOnce) {
                        unwatchChanges();
                    }
                });
                if (angular.isDefined(attr.amWithoutSuffix)) {
                    scope.$watch(attr.amWithoutSuffix, function(value) {
                        if (typeof value === "boolean") {
                            withoutSuffix = value;
                            updateMoment();
                        } else {
                            withoutSuffix = amTimeAgoConfig.withoutSuffix;
                        }
                    });
                }
                attr.$observe("amFormat", function(format) {
                    if (typeof format !== "undefined") {
                        currentFormat = format;
                        updateMoment();
                    }
                });
                attr.$observe("amPreprocess", function(newValue) {
                    preprocess = newValue;
                    updateMoment();
                });
                scope.$on("$destroy", function() {
                    cancelTimer();
                });
                scope.$on("amMoment:localeChanged", function() {
                    updateMoment();
                });
            };
        } ]).service("amMoment", [ "moment", "$rootScope", "$log", "angularMomentConfig", function(moment, $rootScope, $log, angularMomentConfig) {
            this.preprocessors = {
                utc: moment.utc,
                unix: moment.unix
            };
            this.changeLocale = function(locale) {
                var result = moment.locale(locale);
                if (angular.isDefined(locale)) {
                    $rootScope.$broadcast("amMoment:localeChanged");
                }
                return result;
            };
            this.preprocessDate = function(value, preprocess, format) {
                if (angular.isUndefined(preprocess)) {
                    preprocess = angularMomentConfig.preprocess;
                }
                if (this.preprocessors[preprocess]) {
                    return this.preprocessors[preprocess](value, format);
                }
                if (preprocess) {
                    $log.warn("angular-moment: Ignoring unsupported value for preprocess: " + preprocess);
                }
                if (!isNaN(parseFloat(value)) && isFinite(value)) {
                    return moment(parseInt(value, 10));
                }
                return moment(value, format);
            };
            this.applyTimezone = function(aMoment) {
                var timezone = angularMomentConfig.timezone;
                if (aMoment && timezone) {
                    if (aMoment.tz) {
                        aMoment = aMoment.tz(timezone);
                    } else {
                        $log.warn("angular-moment: timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js?");
                    }
                }
                return aMoment;
            };
        } ]).filter("amCalendar", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amCalendarFilter(value, preprocess) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).calendar();
            }
            amCalendarFilter.$stateful = angularMomentConfig.statefulFilters;
            return amCalendarFilter;
        } ]).filter("amDateFormat", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDateFormatFilter(value, format, preprocess) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).format(format);
            }
            amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDateFormatFilter;
        } ]).filter("amDurationFormat", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amDurationFormatFilter(value, format, suffix) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                return moment.duration(value, format).humanize(suffix);
            }
            amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDurationFormatFilter;
        } ]).filter("amTimeAgo", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amTimeAgoFilter(value, preprocess, suffix) {
                if (typeof value === "undefined" || value === null) {
                    return "";
                }
                value = amMoment.preprocessDate(value, preprocess);
                var date = moment(value);
                if (!date.isValid()) {
                    return "";
                }
                return amMoment.applyTimezone(date).fromNow(suffix);
            }
            amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters;
            return amTimeAgoFilter;
        } ]);
    }
    if (typeof define === "function" && define.amd) {
        define("angular-moment", [ "angular", "moment" ], angularMoment);
    } else if (typeof module !== "undefined" && module && module.exports) {
        angularMoment(angular, require("moment"));
    } else {
        angularMoment(angular, window.moment);
    }
})();

angular.module("QuickList", []);

angular.module("QuickList").value("quickRepeatList", {});

angular.module("QuickList").directive("quickNgRepeat", [ "$parse", "$animate", "quickRepeatList", function($parse, $animate, quick_repeat_list) {
    var NG_REMOVED = "$$NG_REMOVED";
    var ngRepeatMinErr = "err";
    var uid = [ "0", "0", "0" ];
    var list_id = window.list_id = function() {
        var i = 0;
        return function() {
            return "list_" + ++i;
        };
    }();
    function hashKey(obj) {
        var objType = typeof obj, key;
        if (objType == "object" && obj !== null) {
            if (typeof (key = obj.$$hashKey) == "function") {
                key = obj.$$hashKey();
            } else if (key === undefined) {
                key = obj.$$hashKey = nextUid();
            }
        } else {
            key = obj;
        }
        return objType + ":" + key;
    }
    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    }
    function nextUid() {
        var index = uid.length;
        var digit;
        while (index) {
            index--;
            digit = uid[index].charCodeAt(0);
            if (digit == 57) {
                uid[index] = "A";
                return uid.join("");
            }
            if (digit == 90) {
                uid[index] = "0";
            } else {
                uid[index] = String.fromCharCode(digit + 1);
                return uid.join("");
            }
        }
        uid.unshift("0");
        return uid.join("");
    }
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false;
        }
        var length = obj.length;
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return angular.isArray(obj) || !angular.isFunction(obj) && (length === 0 || typeof length === "number" && length > 0 && length - 1 in obj);
    }
    return {
        transclude: "element",
        priority: 1e3,
        terminal: true,
        compile: function(element, attr, linker) {
            return function($scope, $element, $attr) {
                var expression = $attr.quickNgRepeat;
                var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/), trackByExp, trackByExpGetter, trackByIdFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, hashFnLocals = {
                    $id: hashKey
                };
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                lhs = match[1];
                rhs = match[2];
                trackByExp = match[4];
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                    trackByIdFn = function(key, value, index) {
                        if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                        hashFnLocals[valueIdentifier] = value;
                        hashFnLocals.$index = index;
                        return trackByExpGetter($scope, hashFnLocals);
                    };
                } else {
                    trackByIdArrayFn = function(key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function(key) {
                        return key;
                    };
                }
                match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                valueIdentifier = match[3] || match[1];
                keyIdentifier = match[2];
                var lastBlockMap = {};
                var list_name = $attr.quickRepeatList || list_id();
                $scope.$watch(rhs, quick_repeat_list[list_name] = function(collection) {
                    var index, length, previousNode = $element[0], nextNode, nextBlockMap = {}, arrayLength, childScope, key, value, trackById, collectionKeys, block, nextBlockOrder = [];
                    if (isArrayLike(collection)) {
                        collectionKeys = collection;
                        trackByIdFn = trackByIdFn || trackByIdArrayFn;
                    } else {
                        trackByIdFn = trackByIdFn || trackByIdObjFn;
                        collectionKeys = [];
                        for (key in collection) {
                            if (collection.hasOwnProperty(key) && key.charAt(0) != "$") {
                                collectionKeys.push(key);
                            }
                        }
                        collectionKeys.sort();
                    }
                    arrayLength = collectionKeys.length;
                    length = nextBlockOrder.length = collectionKeys.length;
                    for (index = 0; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index];
                        value = collection[key];
                        trackById = trackByIdFn(key, value, index);
                        if (lastBlockMap.hasOwnProperty(trackById)) {
                            block = lastBlockMap[trackById];
                            delete lastBlockMap[trackById];
                            nextBlockMap[trackById] = block;
                            nextBlockOrder[index] = block;
                        } else if (nextBlockMap.hasOwnProperty(trackById)) {
                            angular.forEach(nextBlockOrder, function(block) {
                                if (block && block.startNode) lastBlockMap[block.id] = block;
                            });
                            throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}", expression, trackById);
                        } else {
                            nextBlockOrder[index] = {
                                id: trackById
                            };
                            nextBlockMap[trackById] = false;
                        }
                    }
                    for (key in lastBlockMap) {
                        if (lastBlockMap.hasOwnProperty(key)) {
                            block = lastBlockMap[key];
                            $animate.leave(block.elements);
                            angular.forEach(block.elements, function(element) {
                                element[NG_REMOVED] = true;
                            });
                            block.scope.$destroy();
                        }
                    }
                    for (index = 0, length = collectionKeys.length; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index];
                        value = collection[key];
                        block = nextBlockOrder[index];
                        if (block.startNode) {
                            childScope = block.scope;
                            nextNode = previousNode;
                            do {
                                nextNode = nextNode.nextSibling;
                            } while (nextNode && nextNode[NG_REMOVED]);
                            if (block.startNode == nextNode) {} else {
                                $animate.move(block.elements, null, angular.element(previousNode));
                            }
                            previousNode = block.endNode;
                        } else {
                            childScope = $scope.$new();
                        }
                        childScope[valueIdentifier] = value;
                        if (keyIdentifier) childScope[keyIdentifier] = key;
                        childScope.$index = index;
                        childScope.$first = index === 0;
                        childScope.$last = index === arrayLength - 1;
                        childScope.$middle = !(childScope.$first || childScope.$last);
                        childScope.$odd = !(childScope.$even = index % 2 == 0);
                        if (!block.startNode) {
                            linker(childScope, function(clone) {
                                $animate.enter(clone, null, angular.element(previousNode));
                                previousNode = clone;
                                block.scope = childScope;
                                block.startNode = clone[0];
                                block.elements = clone;
                                block.endNode = clone[clone.length - 1];
                                nextBlockMap[block.id] = block;
                            });
                            if (childScope.$$phase !== "$digest") {
                                childScope.$digest();
                            }
                        }
                    }
                    lastBlockMap = nextBlockMap;
                });
            };
        }
    };
} ]);

(function(window, angular, undefined) {
    "use strict";
    var ngTouch = angular.module("ngTouch", []);
    ngTouch.factory("$swipe", [ function() {
        var MOVE_BUFFER_RADIUS = 10;
        var POINTER_EVENTS = {
            mouse: {
                start: "mousedown",
                move: "mousemove",
                end: "mouseup"
            },
            touch: {
                start: "touchstart",
                move: "touchmove",
                end: "touchend",
                cancel: "touchcancel"
            }
        };
        function getCoordinates(event) {
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var e = event.changedTouches && event.changedTouches[0] || event.originalEvent && event.originalEvent.changedTouches && event.originalEvent.changedTouches[0] || touches[0].originalEvent || touches[0];
            return {
                x: e.clientX,
                y: e.clientY
            };
        }
        function getEvents(pointerTypes, eventType) {
            var res = [];
            angular.forEach(pointerTypes, function(pointerType) {
                var eventName = POINTER_EVENTS[pointerType][eventType];
                if (eventName) {
                    res.push(eventName);
                }
            });
            return res.join(" ");
        }
        return {
            bind: function(element, eventHandlers, pointerTypes) {
                var totalX, totalY;
                var startCoords;
                var lastPos;
                var active = false;
                pointerTypes = pointerTypes || [ "mouse", "touch" ];
                element.on(getEvents(pointerTypes, "start"), function(event) {
                    startCoords = getCoordinates(event);
                    active = true;
                    totalX = 0;
                    totalY = 0;
                    lastPos = startCoords;
                    eventHandlers["start"] && eventHandlers["start"](startCoords, event);
                });
                var events = getEvents(pointerTypes, "cancel");
                if (events) {
                    element.on(events, function(event) {
                        active = false;
                        eventHandlers["cancel"] && eventHandlers["cancel"](event);
                    });
                }
                element.on(getEvents(pointerTypes, "move"), function(event) {
                    if (!active) return;
                    if (!startCoords) return;
                    var coords = getCoordinates(event);
                    totalX += Math.abs(coords.x - lastPos.x);
                    totalY += Math.abs(coords.y - lastPos.y);
                    lastPos = coords;
                    if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
                        return;
                    }
                    if (totalY > totalX) {
                        active = false;
                        eventHandlers["cancel"] && eventHandlers["cancel"](event);
                        return;
                    } else {
                        event.preventDefault();
                        eventHandlers["move"] && eventHandlers["move"](coords, event);
                    }
                });
                element.on(getEvents(pointerTypes, "end"), function(event) {
                    if (!active) return;
                    active = false;
                    eventHandlers["end"] && eventHandlers["end"](getCoordinates(event), event);
                });
            }
        };
    } ]);
    ngTouch.config([ "$provide", function($provide) {
        $provide.decorator("ngClickDirective", [ "$delegate", function($delegate) {
            $delegate.shift();
            return $delegate;
        } ]);
    } ]);
    ngTouch.directive("ngClick", [ "$parse", "$timeout", "$rootElement", function($parse, $timeout, $rootElement) {
        var TAP_DURATION = 750;
        var MOVE_TOLERANCE = 12;
        var PREVENT_DURATION = 2500;
        var CLICKBUSTER_THRESHOLD = 25;
        var ACTIVE_CLASS_NAME = "ng-click-active";
        var lastPreventedTime;
        var touchCoordinates;
        var lastLabelClickCoordinates;
        function hit(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;
        }
        function checkAllowableRegions(touchCoordinates, x, y) {
            for (var i = 0; i < touchCoordinates.length; i += 2) {
                if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
                    touchCoordinates.splice(i, i + 2);
                    return true;
                }
            }
            return false;
        }
        function onClick(event) {
            if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
                return;
            }
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var x = touches[0].clientX;
            var y = touches[0].clientY;
            if (x < 1 && y < 1) {
                return;
            }
            if (lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {
                return;
            }
            if (lastLabelClickCoordinates) {
                lastLabelClickCoordinates = null;
            }
            if (event.target.tagName.toLowerCase() === "label") {
                lastLabelClickCoordinates = [ x, y ];
            }
            if (checkAllowableRegions(touchCoordinates, x, y)) {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            event.target && event.target.blur();
        }
        function onTouchStart(event) {
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var x = touches[0].clientX;
            var y = touches[0].clientY;
            touchCoordinates.push(x, y);
            $timeout(function() {
                for (var i = 0; i < touchCoordinates.length; i += 2) {
                    if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {
                        touchCoordinates.splice(i, i + 2);
                        return;
                    }
                }
            }, PREVENT_DURATION, false);
        }
        function preventGhostClick(x, y) {
            if (!touchCoordinates) {
                $rootElement[0].addEventListener("click", onClick, true);
                $rootElement[0].addEventListener("touchstart", onTouchStart, true);
                touchCoordinates = [];
            }
            lastPreventedTime = Date.now();
            checkAllowableRegions(touchCoordinates, x, y);
        }
        return function(scope, element, attr) {
            var clickHandler = $parse(attr.ngClick), tapping = false, tapElement, startTime, touchStartX, touchStartY;
            function resetState() {
                tapping = false;
                element.removeClass(ACTIVE_CLASS_NAME);
            }
            element.on("touchstart", function(event) {
                tapping = true;
                tapElement = event.target ? event.target : event.srcElement;
                if (tapElement.nodeType == 3) {
                    tapElement = tapElement.parentNode;
                }
                element.addClass(ACTIVE_CLASS_NAME);
                startTime = Date.now();
                var touches = event.touches && event.touches.length ? event.touches : [ event ];
                var e = touches[0].originalEvent || touches[0];
                touchStartX = e.clientX;
                touchStartY = e.clientY;
            });
            element.on("touchmove", function(event) {
                resetState();
            });
            element.on("touchcancel", function(event) {
                resetState();
            });
            element.on("touchend", function(event) {
                var diff = Date.now() - startTime;
                var touches = event.changedTouches && event.changedTouches.length ? event.changedTouches : event.touches && event.touches.length ? event.touches : [ event ];
                var e = touches[0].originalEvent || touches[0];
                var x = e.clientX;
                var y = e.clientY;
                var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
                if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
                    preventGhostClick(x, y);
                    if (tapElement) {
                        tapElement.blur();
                    }
                    if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
                        element.triggerHandler("click", [ event ]);
                    }
                }
                resetState();
            });
            element.onclick = function(event) {};
            element.on("click", function(event, touchend) {
                scope.$apply(function() {
                    clickHandler(scope, {
                        $event: touchend || event
                    });
                });
            });
            element.on("mousedown", function(event) {
                element.addClass(ACTIVE_CLASS_NAME);
            });
            element.on("mousemove mouseup", function(event) {
                element.removeClass(ACTIVE_CLASS_NAME);
            });
        };
    } ]);
    function makeSwipeDirective(directiveName, direction, eventName) {
        ngTouch.directive(directiveName, [ "$parse", "$swipe", function($parse, $swipe) {
            var MAX_VERTICAL_DISTANCE = 75;
            var MAX_VERTICAL_RATIO = .3;
            var MIN_HORIZONTAL_DISTANCE = 30;
            return function(scope, element, attr) {
                var swipeHandler = $parse(attr[directiveName]);
                var startCoords, valid;
                function validSwipe(coords) {
                    if (!startCoords) return false;
                    var deltaY = Math.abs(coords.y - startCoords.y);
                    var deltaX = (coords.x - startCoords.x) * direction;
                    return valid && deltaY < MAX_VERTICAL_DISTANCE && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && deltaY / deltaX < MAX_VERTICAL_RATIO;
                }
                var pointerTypes = [ "touch" ];
                if (!angular.isDefined(attr["ngSwipeDisableMouse"])) {
                    pointerTypes.push("mouse");
                }
                $swipe.bind(element, {
                    start: function(coords, event) {
                        startCoords = coords;
                        valid = true;
                    },
                    cancel: function(event) {
                        valid = false;
                    },
                    end: function(coords, event) {
                        if (validSwipe(coords)) {
                            scope.$apply(function() {
                                element.triggerHandler(eventName);
                                swipeHandler(scope, {
                                    $event: event
                                });
                            });
                        }
                    }
                }, pointerTypes);
            };
        } ]);
    }
    makeSwipeDirective("ngSwipeLeft", -1, "swipeleft");
    makeSwipeDirective("ngSwipeRight", 1, "swiperight");
})(window, window.angular);

angular.module("angular-carousel", [ "ngTouch", "angular-carousel.shifty" ]);

angular.module("angular-carousel").directive("rnCarouselAutoSlide", [ "$interval", function($interval) {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            var stopAutoPlay = function() {
                if (scope.autoSlider) {
                    $interval.cancel(scope.autoSlider);
                    scope.autoSlider = null;
                }
            };
            var restartTimer = function() {
                scope.autoSlide();
            };
            scope.$watch("carouselIndex", restartTimer);
            if (attrs.hasOwnProperty("rnCarouselPauseOnHover") && attrs.rnCarouselPauseOnHover !== "false") {
                element.on("mouseenter", stopAutoPlay);
                element.on("mouseleave", restartTimer);
            }
            scope.$on("$destroy", function() {
                stopAutoPlay();
                element.off("mouseenter", stopAutoPlay);
                element.off("mouseleave", restartTimer);
            });
        }
    };
} ]);

angular.module("angular-carousel").directive("rnCarouselIndicators", [ "$parse", function($parse) {
    return {
        restrict: "A",
        scope: {
            slides: "=",
            index: "=rnCarouselIndex"
        },
        templateUrl: "carousel-indicators.html",
        link: function(scope, iElement, iAttributes) {
            var indexModel = $parse(iAttributes.rnCarouselIndex);
            scope.goToSlide = function(index) {
                indexModel.assign(scope.$parent.$parent, index);
            };
        }
    };
} ]);

angular.module("angular-carousel").run([ "$templateCache", function($templateCache) {
    $templateCache.put("carousel-indicators.html", '<div class="rn-carousel-indicator">\n' + '<span ng-repeat="slide in slides" ng-class="{active: $index==index}" ng-click="goToSlide($index)">●</span>' + "</div>");
} ]);

(function() {
    "use strict";
    angular.module("angular-carousel").service("DeviceCapabilities", function() {
        function detectTransformProperty() {
            var transformProperty = "transform", safariPropertyHack = "webkitTransform";
            if (typeof document.body.style[transformProperty] !== "undefined") {
                [ "webkit", "moz", "o", "ms" ].every(function(prefix) {
                    var e = "-" + prefix + "-transform";
                    if (typeof document.body.style[e] !== "undefined") {
                        transformProperty = e;
                        return false;
                    }
                    return true;
                });
            } else if (typeof document.body.style[safariPropertyHack] !== "undefined") {
                transformProperty = "-webkit-transform";
            } else {
                transformProperty = undefined;
            }
            return transformProperty;
        }
        function detect3dSupport() {
            var el = document.createElement("p"), has3d, transforms = {
                webkitTransform: "-webkit-transform",
                msTransform: "-ms-transform",
                transform: "transform"
            };
            document.body.insertBefore(el, null);
            for (var t in transforms) {
                if (el.style[t] !== undefined) {
                    el.style[t] = "translate3d(1px,1px,1px)";
                    has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
                }
            }
            document.body.removeChild(el);
            return has3d !== undefined && has3d.length > 0 && has3d !== "none";
        }
        return {
            has3d: detect3dSupport(),
            transformProperty: detectTransformProperty()
        };
    }).service("computeCarouselSlideStyle", [ "DeviceCapabilities", function(DeviceCapabilities) {
        return function(slideIndex, offset, transitionType) {
            var style = {
                display: "inline-block"
            }, opacity, absoluteLeft = slideIndex * 100 + offset, slideTransformValue = DeviceCapabilities.has3d ? "translate3d(" + absoluteLeft + "%, 0, 0)" : "translate3d(" + absoluteLeft + "%, 0)", distance = (100 - Math.abs(absoluteLeft)) / 100;
            if (!DeviceCapabilities.transformProperty) {
                style["margin-left"] = absoluteLeft + "%";
            } else {
                if (transitionType == "fadeAndSlide") {
                    style[DeviceCapabilities.transformProperty] = slideTransformValue;
                    opacity = 0;
                    if (Math.abs(absoluteLeft) < 100) {
                        opacity = .3 + distance * .7;
                    }
                    style.opacity = opacity;
                } else if (transitionType == "hexagon") {
                    var transformFrom = 100, degrees = 0, maxDegrees = 60 * (distance - 1);
                    transformFrom = offset < slideIndex * -100 ? 100 : 0;
                    degrees = offset < slideIndex * -100 ? maxDegrees : -maxDegrees;
                    style[DeviceCapabilities.transformProperty] = slideTransformValue + " " + "rotateY(" + degrees + "deg)";
                    style[DeviceCapabilities.transformProperty + "-origin"] = transformFrom + "% 50%";
                } else if (transitionType == "zoom") {
                    style[DeviceCapabilities.transformProperty] = slideTransformValue;
                    var scale = 1;
                    if (Math.abs(absoluteLeft) < 100) {
                        scale = 1 + (1 - distance) * 2;
                    }
                    style[DeviceCapabilities.transformProperty] += " scale(" + scale + ")";
                    style[DeviceCapabilities.transformProperty + "-origin"] = "50% 50%";
                    opacity = 0;
                    if (Math.abs(absoluteLeft) < 100) {
                        opacity = .3 + distance * .7;
                    }
                    style.opacity = opacity;
                } else {
                    style[DeviceCapabilities.transformProperty] = slideTransformValue;
                }
            }
            return style;
        };
    } ]).service("createStyleString", function() {
        return function(object) {
            var styles = [];
            angular.forEach(object, function(value, key) {
                styles.push(key + ":" + value);
            });
            return styles.join(";");
        };
    }).directive("rnCarousel", [ "$swipe", "$window", "$document", "$parse", "$compile", "$timeout", "$interval", "computeCarouselSlideStyle", "createStyleString", "Tweenable", function($swipe, $window, $document, $parse, $compile, $timeout, $interval, computeCarouselSlideStyle, createStyleString, Tweenable) {
        var carouselId = 0, rubberTreshold = 3;
        var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
        function getItemIndex(collection, target, defaultIndex) {
            var result = defaultIndex;
            collection.every(function(item, index) {
                if (angular.equals(item, target)) {
                    result = index;
                    return false;
                }
                return true;
            });
            return result;
        }
        return {
            restrict: "A",
            scope: true,
            compile: function(tElement, tAttributes) {
                var firstChild = tElement[0].querySelector("li"), firstChildAttributes = firstChild ? firstChild.attributes : [], isRepeatBased = false, isBuffered = false, repeatItem, repeatCollection;
                [ "ng-repeat", "data-ng-repeat", "ng:repeat", "x-ng-repeat" ].every(function(attr) {
                    var repeatAttribute = firstChildAttributes[attr];
                    if (angular.isDefined(repeatAttribute)) {
                        var exprMatch = repeatAttribute.value.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), trackProperty = exprMatch[3];
                        repeatItem = exprMatch[1];
                        repeatCollection = exprMatch[2];
                        if (repeatItem) {
                            if (angular.isDefined(tAttributes["rnCarouselBuffered"])) {
                                isBuffered = true;
                                repeatAttribute.value = repeatItem + " in " + repeatCollection + "|carouselSlice:carouselBufferIndex:carouselBufferSize";
                                if (trackProperty) {
                                    repeatAttribute.value += " track by " + trackProperty;
                                }
                            }
                            isRepeatBased = true;
                            return false;
                        }
                    }
                    return true;
                });
                return function(scope, iElement, iAttributes, containerCtrl) {
                    carouselId++;
                    var defaultOptions = {
                        transitionType: iAttributes.rnCarouselTransition || "slide",
                        transitionEasing: iAttributes.rnCarouselEasing || "easeTo",
                        transitionDuration: parseInt(iAttributes.rnCarouselDuration, 10) || 300,
                        isSequential: true,
                        autoSlideDuration: 3,
                        bufferSize: 5,
                        moveTreshold: .1
                    };
                    var options = angular.extend({}, defaultOptions);
                    var pressed, startX, isIndexBound = false, offset = 0, destination, swipeMoved = false, currentSlides = [], elWidth = null, elX = null, animateTransitions = true, intialState = true, animating = false, mouseUpBound = false, locked = false;
                    $swipe.bind(iElement, {
                        start: swipeStart,
                        move: swipeMove,
                        end: swipeEnd,
                        cancel: function(event) {
                            swipeEnd({}, event);
                        }
                    });
                    function getSlidesDOM() {
                        return iElement[0].querySelectorAll("ul[rn-carousel] > li");
                    }
                    function documentMouseUpEvent(event) {
                        swipeMoved = true;
                        swipeEnd({
                            x: event.clientX,
                            y: event.clientY
                        }, event);
                    }
                    function updateSlidesPosition(offset) {
                        var x = scope.carouselBufferIndex * 100 + offset;
                        angular.forEach(getSlidesDOM(), function(child, index) {
                            child.style.cssText = createStyleString(computeCarouselSlideStyle(index, x, options.transitionType));
                        });
                    }
                    scope.nextSlide = function(slideOptions) {
                        var index = scope.carouselIndex + 1;
                        if (index > currentSlides.length - 1) {
                            index = 0;
                        }
                        if (!locked) {
                            goToSlide(index, slideOptions);
                        }
                    };
                    scope.prevSlide = function(slideOptions) {
                        var index = scope.carouselIndex - 1;
                        if (index < 0) {
                            index = currentSlides.length - 1;
                        }
                        goToSlide(index, slideOptions);
                    };
                    function goToSlide(index, slideOptions) {
                        if (index === undefined) {
                            index = scope.carouselIndex;
                        }
                        slideOptions = slideOptions || {};
                        if (slideOptions.animate === false || options.transitionType === "none") {
                            locked = false;
                            offset = index * -100;
                            scope.carouselIndex = index;
                            updateBufferIndex();
                            return;
                        }
                        locked = true;
                        var tweenable = new Tweenable();
                        tweenable.tween({
                            from: {
                                x: offset
                            },
                            to: {
                                x: index * -100
                            },
                            duration: options.transitionDuration,
                            easing: options.transitionEasing,
                            step: function(state) {
                                updateSlidesPosition(state.x);
                            },
                            finish: function() {
                                scope.$apply(function() {
                                    scope.carouselIndex = index;
                                    offset = index * -100;
                                    updateBufferIndex();
                                    $timeout(function() {
                                        locked = false;
                                    }, 0, false);
                                });
                            }
                        });
                    }
                    function getContainerWidth() {
                        var rect = iElement[0].getBoundingClientRect();
                        return rect.width ? rect.width : rect.right - rect.left;
                    }
                    function updateContainerWidth() {
                        elWidth = getContainerWidth();
                    }
                    function bindMouseUpEvent() {
                        if (!mouseUpBound) {
                            mouseUpBound = true;
                            $document.bind("mouseup", documentMouseUpEvent);
                        }
                    }
                    function unbindMouseUpEvent() {
                        if (mouseUpBound) {
                            mouseUpBound = false;
                            $document.unbind("mouseup", documentMouseUpEvent);
                        }
                    }
                    function swipeStart(coords, event) {
                        if (locked || currentSlides.length <= 1) {
                            return;
                        }
                        updateContainerWidth();
                        elX = iElement[0].querySelector("li").getBoundingClientRect().left;
                        pressed = true;
                        startX = coords.x;
                        return false;
                    }
                    function swipeMove(coords, event) {
                        var x, delta;
                        bindMouseUpEvent();
                        if (pressed) {
                            x = coords.x;
                            delta = startX - x;
                            if (delta > 2 || delta < -2) {
                                swipeMoved = true;
                                var moveOffset = offset + -delta * 100 / elWidth;
                                updateSlidesPosition(moveOffset);
                            }
                        }
                        return false;
                    }
                    var init = true;
                    scope.carouselIndex = 0;
                    if (!isRepeatBased) {
                        currentSlides = [];
                        angular.forEach(getSlidesDOM(), function(node, index) {
                            currentSlides.push({
                                id: index
                            });
                        });
                    }
                    if (iAttributes.rnCarouselControls !== undefined) {
                        var nextSlideIndexCompareValue = isRepeatBased ? repeatCollection.replace("::", "") + ".length - 1" : currentSlides.length - 1;
                        var tpl = '<div class="rn-carousel-controls">\n' + '  <span class="rn-carousel-control rn-carousel-control-prev" ng-click="prevSlide()" ng-if="carouselIndex > 0"></span>\n' + '  <span class="rn-carousel-control rn-carousel-control-next" ng-click="nextSlide()" ng-if="carouselIndex < ' + nextSlideIndexCompareValue + '"></span>\n' + "</div>";
                        iElement.append($compile(angular.element(tpl))(scope));
                    }
                    if (iAttributes.rnCarouselAutoSlide !== undefined) {
                        var duration = parseInt(iAttributes.rnCarouselAutoSlide, 10) || options.autoSlideDuration;
                        scope.autoSlide = function() {
                            if (scope.autoSlider) {
                                $interval.cancel(scope.autoSlider);
                                scope.autoSlider = null;
                            }
                            scope.autoSlider = $interval(function() {
                                if (!locked && !pressed) {
                                    scope.nextSlide();
                                }
                            }, duration * 1e3);
                        };
                    }
                    if (iAttributes.rnCarouselIndex) {
                        var updateParentIndex = function(value) {
                            indexModel.assign(scope.$parent, value);
                        };
                        var indexModel = $parse(iAttributes.rnCarouselIndex);
                        if (angular.isFunction(indexModel.assign)) {
                            scope.$watch("carouselIndex", function(newValue) {
                                updateParentIndex(newValue);
                            });
                            scope.$parent.$watch(indexModel, function(newValue, oldValue) {
                                if (newValue !== undefined && newValue !== null) {
                                    if (currentSlides && newValue >= currentSlides.length) {
                                        newValue = currentSlides.length - 1;
                                        updateParentIndex(newValue);
                                    } else if (currentSlides && newValue < 0) {
                                        newValue = 0;
                                        updateParentIndex(newValue);
                                    }
                                    if (!locked) {
                                        goToSlide(newValue, {
                                            animate: !init
                                        });
                                    }
                                    init = false;
                                }
                            });
                            isIndexBound = true;
                        } else if (!isNaN(iAttributes.rnCarouselIndex)) {
                            goToSlide(parseInt(iAttributes.rnCarouselIndex, 10), {
                                animate: false
                            });
                        }
                    } else {
                        goToSlide(0, {
                            animate: !init
                        });
                        init = false;
                    }
                    if (iAttributes.rnCarouselLocked) {
                        scope.$watch(iAttributes.rnCarouselLocked, function(newValue, oldValue) {
                            if (newValue === true) {
                                locked = true;
                            } else {
                                locked = false;
                            }
                        });
                    }
                    if (isRepeatBased) {
                        var deepWatch = iAttributes.rnCarouselDeepWatch !== undefined;
                        scope[deepWatch ? "$watch" : "$watchCollection"](repeatCollection, function(newValue, oldValue) {
                            currentSlides = newValue;
                            if (deepWatch && angular.isArray(newValue)) {
                                var activeElement = oldValue[scope.carouselIndex];
                                var newIndex = getItemIndex(newValue, activeElement, scope.carouselIndex);
                                goToSlide(newIndex, {
                                    animate: false
                                });
                            } else {
                                goToSlide(scope.carouselIndex, {
                                    animate: false
                                });
                            }
                        }, true);
                    }
                    function swipeEnd(coords, event, forceAnimation) {
                        if (event && !swipeMoved) {
                            return;
                        }
                        unbindMouseUpEvent();
                        pressed = false;
                        swipeMoved = false;
                        destination = startX - coords.x;
                        if (destination === 0) {
                            return;
                        }
                        if (locked) {
                            return;
                        }
                        offset += -destination * 100 / elWidth;
                        if (options.isSequential) {
                            var minMove = options.moveTreshold * elWidth, absMove = -destination, slidesMove = -Math[absMove >= 0 ? "ceil" : "floor"](absMove / elWidth), shouldMove = Math.abs(absMove) > minMove;
                            if (currentSlides && slidesMove + scope.carouselIndex >= currentSlides.length) {
                                slidesMove = currentSlides.length - 1 - scope.carouselIndex;
                            }
                            if (slidesMove + scope.carouselIndex < 0) {
                                slidesMove = -scope.carouselIndex;
                            }
                            var moveOffset = shouldMove ? slidesMove : 0;
                            destination = scope.carouselIndex + moveOffset;
                            goToSlide(destination);
                        } else {
                            scope.$apply(function() {
                                scope.carouselIndex = parseInt(-offset / 100, 10);
                                updateBufferIndex();
                            });
                        }
                    }
                    scope.$on("$destroy", function() {
                        unbindMouseUpEvent();
                    });
                    scope.carouselBufferIndex = 0;
                    scope.carouselBufferSize = options.bufferSize;
                    function updateBufferIndex() {
                        var bufferIndex = 0;
                        var bufferEdgeSize = (scope.carouselBufferSize - 1) / 2;
                        if (isBuffered) {
                            if (scope.carouselIndex <= bufferEdgeSize) {
                                bufferIndex = 0;
                            } else if (currentSlides && currentSlides.length < scope.carouselBufferSize) {
                                bufferIndex = 0;
                            } else if (currentSlides && scope.carouselIndex > currentSlides.length - scope.carouselBufferSize) {
                                bufferIndex = currentSlides.length - scope.carouselBufferSize;
                            } else {
                                bufferIndex = scope.carouselIndex - bufferEdgeSize;
                            }
                            scope.carouselBufferIndex = bufferIndex;
                            $timeout(function() {
                                updateSlidesPosition(offset);
                            }, 0, false);
                        } else {
                            $timeout(function() {
                                updateSlidesPosition(offset);
                            }, 0, false);
                        }
                    }
                    function onOrientationChange() {
                        updateContainerWidth();
                        goToSlide();
                    }
                    var winEl = angular.element($window);
                    winEl.bind("orientationchange", onOrientationChange);
                    winEl.bind("resize", onOrientationChange);
                    scope.$on("$destroy", function() {
                        unbindMouseUpEvent();
                        winEl.unbind("orientationchange", onOrientationChange);
                        winEl.unbind("resize", onOrientationChange);
                    });
                };
            }
        };
    } ]);
})();

angular.module("angular-carousel.shifty", []).factory("Tweenable", function() {
    (function(root) {
        var Tweenable = function() {
            "use strict";
            var formula;
            var DEFAULT_SCHEDULE_FUNCTION;
            var DEFAULT_EASING = "linear";
            var DEFAULT_DURATION = 500;
            var UPDATE_TIME = 1e3 / 60;
            var _now = Date.now ? Date.now : function() {
                return +new Date();
            };
            var now = typeof SHIFTY_DEBUG_NOW !== "undefined" ? SHIFTY_DEBUG_NOW : _now;
            if (typeof window !== "undefined") {
                DEFAULT_SCHEDULE_FUNCTION = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.mozCancelRequestAnimationFrame && window.mozRequestAnimationFrame || setTimeout;
            } else {
                DEFAULT_SCHEDULE_FUNCTION = setTimeout;
            }
            function noop() {}
            function each(obj, fn) {
                var key;
                for (key in obj) {
                    if (Object.hasOwnProperty.call(obj, key)) {
                        fn(key);
                    }
                }
            }
            function shallowCopy(targetObj, srcObj) {
                each(srcObj, function(prop) {
                    targetObj[prop] = srcObj[prop];
                });
                return targetObj;
            }
            function defaults(target, src) {
                each(src, function(prop) {
                    if (typeof target[prop] === "undefined") {
                        target[prop] = src[prop];
                    }
                });
            }
            function tweenProps(forPosition, currentState, originalState, targetState, duration, timestamp, easing) {
                var normalizedPosition = (forPosition - timestamp) / duration;
                var prop;
                for (prop in currentState) {
                    if (currentState.hasOwnProperty(prop)) {
                        currentState[prop] = tweenProp(originalState[prop], targetState[prop], formula[easing[prop]], normalizedPosition);
                    }
                }
                return currentState;
            }
            function tweenProp(start, end, easingFunc, position) {
                return start + (end - start) * easingFunc(position);
            }
            function applyFilter(tweenable, filterName) {
                var filters = Tweenable.prototype.filter;
                var args = tweenable._filterArgs;
                each(filters, function(name) {
                    if (typeof filters[name][filterName] !== "undefined") {
                        filters[name][filterName].apply(tweenable, args);
                    }
                });
            }
            var timeoutHandler_endTime;
            var timeoutHandler_currentTime;
            var timeoutHandler_isEnded;
            var timeoutHandler_offset;
            function timeoutHandler(tweenable, timestamp, duration, currentState, originalState, targetState, easing, step, schedule) {
                timeoutHandler_endTime = timestamp + duration;
                timeoutHandler_currentTime = Math.min(now(), timeoutHandler_endTime);
                timeoutHandler_isEnded = timeoutHandler_currentTime >= timeoutHandler_endTime;
                timeoutHandler_offset = duration - (timeoutHandler_endTime - timeoutHandler_currentTime);
                if (tweenable.isPlaying() && !timeoutHandler_isEnded) {
                    tweenable._scheduleId = schedule(tweenable._timeoutHandler, UPDATE_TIME);
                    applyFilter(tweenable, "beforeTween");
                    tweenProps(timeoutHandler_currentTime, currentState, originalState, targetState, duration, timestamp, easing);
                    applyFilter(tweenable, "afterTween");
                    step(currentState, tweenable._attachment, timeoutHandler_offset);
                } else if (timeoutHandler_isEnded) {
                    step(targetState, tweenable._attachment, timeoutHandler_offset);
                    tweenable.stop(true);
                }
            }
            function composeEasingObject(fromTweenParams, easing) {
                var composedEasing = {};
                if (typeof easing === "string") {
                    each(fromTweenParams, function(prop) {
                        composedEasing[prop] = easing;
                    });
                } else {
                    each(fromTweenParams, function(prop) {
                        if (!composedEasing[prop]) {
                            composedEasing[prop] = easing[prop] || DEFAULT_EASING;
                        }
                    });
                }
                return composedEasing;
            }
            function Tweenable(opt_initialState, opt_config) {
                this._currentState = opt_initialState || {};
                this._configured = false;
                this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;
                if (typeof opt_config !== "undefined") {
                    this.setConfig(opt_config);
                }
            }
            Tweenable.prototype.tween = function(opt_config) {
                if (this._isTweening) {
                    return this;
                }
                if (opt_config !== undefined || !this._configured) {
                    this.setConfig(opt_config);
                }
                this._timestamp = now();
                this._start(this.get(), this._attachment);
                return this.resume();
            };
            Tweenable.prototype.setConfig = function(config) {
                config = config || {};
                this._configured = true;
                this._attachment = config.attachment;
                this._pausedAtTime = null;
                this._scheduleId = null;
                this._start = config.start || noop;
                this._step = config.step || noop;
                this._finish = config.finish || noop;
                this._duration = config.duration || DEFAULT_DURATION;
                this._currentState = config.from || this.get();
                this._originalState = this.get();
                this._targetState = config.to || this.get();
                var currentState = this._currentState;
                var targetState = this._targetState;
                defaults(targetState, currentState);
                this._easing = composeEasingObject(currentState, config.easing || DEFAULT_EASING);
                this._filterArgs = [ currentState, this._originalState, targetState, this._easing ];
                applyFilter(this, "tweenCreated");
                return this;
            };
            Tweenable.prototype.get = function() {
                return shallowCopy({}, this._currentState);
            };
            Tweenable.prototype.set = function(state) {
                this._currentState = state;
            };
            Tweenable.prototype.pause = function() {
                this._pausedAtTime = now();
                this._isPaused = true;
                return this;
            };
            Tweenable.prototype.resume = function() {
                if (this._isPaused) {
                    this._timestamp += now() - this._pausedAtTime;
                }
                this._isPaused = false;
                this._isTweening = true;
                var self = this;
                this._timeoutHandler = function() {
                    timeoutHandler(self, self._timestamp, self._duration, self._currentState, self._originalState, self._targetState, self._easing, self._step, self._scheduleFunction);
                };
                this._timeoutHandler();
                return this;
            };
            Tweenable.prototype.seek = function(millisecond) {
                this._timestamp = now() - millisecond;
                if (!this.isPlaying()) {
                    this._isTweening = true;
                    this._isPaused = false;
                    timeoutHandler(this, this._timestamp, this._duration, this._currentState, this._originalState, this._targetState, this._easing, this._step, this._scheduleFunction);
                    this._timeoutHandler();
                    this.pause();
                }
                return this;
            };
            Tweenable.prototype.stop = function(gotoEnd) {
                this._isTweening = false;
                this._isPaused = false;
                this._timeoutHandler = noop;
                (root.cancelAnimationFrame || root.webkitCancelAnimationFrame || root.oCancelAnimationFrame || root.msCancelAnimationFrame || root.mozCancelRequestAnimationFrame || root.clearTimeout)(this._scheduleId);
                if (gotoEnd) {
                    shallowCopy(this._currentState, this._targetState);
                    applyFilter(this, "afterTweenEnd");
                    this._finish.call(this, this._currentState, this._attachment);
                }
                return this;
            };
            Tweenable.prototype.isPlaying = function() {
                return this._isTweening && !this._isPaused;
            };
            Tweenable.prototype.setScheduleFunction = function(scheduleFunction) {
                this._scheduleFunction = scheduleFunction;
            };
            Tweenable.prototype.dispose = function() {
                var prop;
                for (prop in this) {
                    if (this.hasOwnProperty(prop)) {
                        delete this[prop];
                    }
                }
            };
            Tweenable.prototype.filter = {};
            Tweenable.prototype.formula = {
                linear: function(pos) {
                    return pos;
                }
            };
            formula = Tweenable.prototype.formula;
            shallowCopy(Tweenable, {
                now: now,
                each: each,
                tweenProps: tweenProps,
                tweenProp: tweenProp,
                applyFilter: applyFilter,
                shallowCopy: shallowCopy,
                defaults: defaults,
                composeEasingObject: composeEasingObject
            });
            root.Tweenable = Tweenable;
            return Tweenable;
        }();
        (function() {
            Tweenable.shallowCopy(Tweenable.prototype.formula, {
                easeInQuad: function(pos) {
                    return Math.pow(pos, 2);
                },
                easeOutQuad: function(pos) {
                    return -(Math.pow(pos - 1, 2) - 1);
                },
                easeInOutQuad: function(pos) {
                    if ((pos /= .5) < 1) {
                        return .5 * Math.pow(pos, 2);
                    }
                    return -.5 * ((pos -= 2) * pos - 2);
                },
                easeInCubic: function(pos) {
                    return Math.pow(pos, 3);
                },
                easeOutCubic: function(pos) {
                    return Math.pow(pos - 1, 3) + 1;
                },
                easeInOutCubic: function(pos) {
                    if ((pos /= .5) < 1) {
                        return .5 * Math.pow(pos, 3);
                    }
                    return .5 * (Math.pow(pos - 2, 3) + 2);
                },
                easeInQuart: function(pos) {
                    return Math.pow(pos, 4);
                },
                easeOutQuart: function(pos) {
                    return -(Math.pow(pos - 1, 4) - 1);
                },
                easeInOutQuart: function(pos) {
                    if ((pos /= .5) < 1) {
                        return .5 * Math.pow(pos, 4);
                    }
                    return -.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                },
                easeInQuint: function(pos) {
                    return Math.pow(pos, 5);
                },
                easeOutQuint: function(pos) {
                    return Math.pow(pos - 1, 5) + 1;
                },
                easeInOutQuint: function(pos) {
                    if ((pos /= .5) < 1) {
                        return .5 * Math.pow(pos, 5);
                    }
                    return .5 * (Math.pow(pos - 2, 5) + 2);
                },
                easeInSine: function(pos) {
                    return -Math.cos(pos * (Math.PI / 2)) + 1;
                },
                easeOutSine: function(pos) {
                    return Math.sin(pos * (Math.PI / 2));
                },
                easeInOutSine: function(pos) {
                    return -.5 * (Math.cos(Math.PI * pos) - 1);
                },
                easeInExpo: function(pos) {
                    return pos === 0 ? 0 : Math.pow(2, 10 * (pos - 1));
                },
                easeOutExpo: function(pos) {
                    return pos === 1 ? 1 : -Math.pow(2, -10 * pos) + 1;
                },
                easeInOutExpo: function(pos) {
                    if (pos === 0) {
                        return 0;
                    }
                    if (pos === 1) {
                        return 1;
                    }
                    if ((pos /= .5) < 1) {
                        return .5 * Math.pow(2, 10 * (pos - 1));
                    }
                    return .5 * (-Math.pow(2, -10 * --pos) + 2);
                },
                easeInCirc: function(pos) {
                    return -(Math.sqrt(1 - pos * pos) - 1);
                },
                easeOutCirc: function(pos) {
                    return Math.sqrt(1 - Math.pow(pos - 1, 2));
                },
                easeInOutCirc: function(pos) {
                    if ((pos /= .5) < 1) {
                        return -.5 * (Math.sqrt(1 - pos * pos) - 1);
                    }
                    return .5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
                },
                easeOutBounce: function(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + .75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + .9375;
                    } else {
                        return 7.5625 * (pos -= 2.625 / 2.75) * pos + .984375;
                    }
                },
                easeInBack: function(pos) {
                    var s = 1.70158;
                    return pos * pos * ((s + 1) * pos - s);
                },
                easeOutBack: function(pos) {
                    var s = 1.70158;
                    return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
                },
                easeInOutBack: function(pos) {
                    var s = 1.70158;
                    if ((pos /= .5) < 1) {
                        return .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s));
                    }
                    return .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                },
                elastic: function(pos) {
                    return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                },
                swingFromTo: function(pos) {
                    var s = 1.70158;
                    return (pos /= .5) < 1 ? .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                },
                swingFrom: function(pos) {
                    var s = 1.70158;
                    return pos * pos * ((s + 1) * pos - s);
                },
                swingTo: function(pos) {
                    var s = 1.70158;
                    return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                },
                bounce: function(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + .75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + .9375;
                    } else {
                        return 7.5625 * (pos -= 2.625 / 2.75) * pos + .984375;
                    }
                },
                bouncePast: function(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + .75);
                    } else if (pos < 2.5 / 2.75) {
                        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + .9375);
                    } else {
                        return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + .984375);
                    }
                },
                easeFromTo: function(pos) {
                    if ((pos /= .5) < 1) {
                        return .5 * Math.pow(pos, 4);
                    }
                    return -.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                },
                easeFrom: function(pos) {
                    return Math.pow(pos, 4);
                },
                easeTo: function(pos) {
                    return Math.pow(pos, .25);
                }
            });
        })();
        (function() {
            function cubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
                var ax = 0, bx = 0, cx = 0, ay = 0, by = 0, cy = 0;
                function sampleCurveX(t) {
                    return ((ax * t + bx) * t + cx) * t;
                }
                function sampleCurveY(t) {
                    return ((ay * t + by) * t + cy) * t;
                }
                function sampleCurveDerivativeX(t) {
                    return (3 * ax * t + 2 * bx) * t + cx;
                }
                function solveEpsilon(duration) {
                    return 1 / (200 * duration);
                }
                function solve(x, epsilon) {
                    return sampleCurveY(solveCurveX(x, epsilon));
                }
                function fabs(n) {
                    if (n >= 0) {
                        return n;
                    } else {
                        return 0 - n;
                    }
                }
                function solveCurveX(x, epsilon) {
                    var t0, t1, t2, x2, d2, i;
                    for (t2 = x, i = 0; i < 8; i++) {
                        x2 = sampleCurveX(t2) - x;
                        if (fabs(x2) < epsilon) {
                            return t2;
                        }
                        d2 = sampleCurveDerivativeX(t2);
                        if (fabs(d2) < 1e-6) {
                            break;
                        }
                        t2 = t2 - x2 / d2;
                    }
                    t0 = 0;
                    t1 = 1;
                    t2 = x;
                    if (t2 < t0) {
                        return t0;
                    }
                    if (t2 > t1) {
                        return t1;
                    }
                    while (t0 < t1) {
                        x2 = sampleCurveX(t2);
                        if (fabs(x2 - x) < epsilon) {
                            return t2;
                        }
                        if (x > x2) {
                            t0 = t2;
                        } else {
                            t1 = t2;
                        }
                        t2 = (t1 - t0) * .5 + t0;
                    }
                    return t2;
                }
                cx = 3 * p1x;
                bx = 3 * (p2x - p1x) - cx;
                ax = 1 - cx - bx;
                cy = 3 * p1y;
                by = 3 * (p2y - p1y) - cy;
                ay = 1 - cy - by;
                return solve(t, solveEpsilon(duration));
            }
            function getCubicBezierTransition(x1, y1, x2, y2) {
                return function(pos) {
                    return cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
                };
            }
            Tweenable.setBezierFunction = function(name, x1, y1, x2, y2) {
                var cubicBezierTransition = getCubicBezierTransition(x1, y1, x2, y2);
                cubicBezierTransition.x1 = x1;
                cubicBezierTransition.y1 = y1;
                cubicBezierTransition.x2 = x2;
                cubicBezierTransition.y2 = y2;
                return Tweenable.prototype.formula[name] = cubicBezierTransition;
            };
            Tweenable.unsetBezierFunction = function(name) {
                delete Tweenable.prototype.formula[name];
            };
        })();
        (function() {
            function getInterpolatedValues(from, current, targetState, position, easing) {
                return Tweenable.tweenProps(position, current, from, targetState, 1, 0, easing);
            }
            var mockTweenable = new Tweenable();
            mockTweenable._filterArgs = [];
            Tweenable.interpolate = function(from, targetState, position, easing) {
                var current = Tweenable.shallowCopy({}, from);
                var easingObject = Tweenable.composeEasingObject(from, easing || "linear");
                mockTweenable.set({});
                var filterArgs = mockTweenable._filterArgs;
                filterArgs.length = 0;
                filterArgs[0] = current;
                filterArgs[1] = from;
                filterArgs[2] = targetState;
                filterArgs[3] = easingObject;
                Tweenable.applyFilter(mockTweenable, "tweenCreated");
                Tweenable.applyFilter(mockTweenable, "beforeTween");
                var interpolatedValues = getInterpolatedValues(from, current, targetState, position, easingObject);
                Tweenable.applyFilter(mockTweenable, "afterTween");
                return interpolatedValues;
            };
        })();
        function token() {}
        (function(Tweenable) {
            var formatManifest;
            var R_NUMBER_COMPONENT = /(\d|\-|\.)/;
            var R_FORMAT_CHUNKS = /([^\-0-9\.]+)/g;
            var R_UNFORMATTED_VALUES = /[0-9.\-]+/g;
            var R_RGB = new RegExp("rgb\\(" + R_UNFORMATTED_VALUES.source + /,\s*/.source + R_UNFORMATTED_VALUES.source + /,\s*/.source + R_UNFORMATTED_VALUES.source + "\\)", "g");
            var R_RGB_PREFIX = /^.*\(/;
            var R_HEX = /#([0-9]|[a-f]){3,6}/gi;
            var VALUE_PLACEHOLDER = "VAL";
            var getFormatChunksFrom_accumulator = [];
            function getFormatChunksFrom(rawValues, prefix) {
                getFormatChunksFrom_accumulator.length = 0;
                var rawValuesLength = rawValues.length;
                var i;
                for (i = 0; i < rawValuesLength; i++) {
                    getFormatChunksFrom_accumulator.push("_" + prefix + "_" + i);
                }
                return getFormatChunksFrom_accumulator;
            }
            function getFormatStringFrom(formattedString) {
                var chunks = formattedString.match(R_FORMAT_CHUNKS);
                if (!chunks) {
                    chunks = [ "", "" ];
                } else if (chunks.length === 1 || formattedString[0].match(R_NUMBER_COMPONENT)) {
                    chunks.unshift("");
                }
                return chunks.join(VALUE_PLACEHOLDER);
            }
            function sanitizeObjectForHexProps(stateObject) {
                Tweenable.each(stateObject, function(prop) {
                    var currentProp = stateObject[prop];
                    if (typeof currentProp === "string" && currentProp.match(R_HEX)) {
                        stateObject[prop] = sanitizeHexChunksToRGB(currentProp);
                    }
                });
            }
            function sanitizeHexChunksToRGB(str) {
                return filterStringChunks(R_HEX, str, convertHexToRGB);
            }
            function convertHexToRGB(hexString) {
                var rgbArr = hexToRGBArray(hexString);
                return "rgb(" + rgbArr[0] + "," + rgbArr[1] + "," + rgbArr[2] + ")";
            }
            var hexToRGBArray_returnArray = [];
            function hexToRGBArray(hex) {
                hex = hex.replace(/#/, "");
                if (hex.length === 3) {
                    hex = hex.split("");
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                hexToRGBArray_returnArray[0] = hexToDec(hex.substr(0, 2));
                hexToRGBArray_returnArray[1] = hexToDec(hex.substr(2, 2));
                hexToRGBArray_returnArray[2] = hexToDec(hex.substr(4, 2));
                return hexToRGBArray_returnArray;
            }
            function hexToDec(hex) {
                return parseInt(hex, 16);
            }
            function filterStringChunks(pattern, unfilteredString, filter) {
                var pattenMatches = unfilteredString.match(pattern);
                var filteredString = unfilteredString.replace(pattern, VALUE_PLACEHOLDER);
                if (pattenMatches) {
                    var pattenMatchesLength = pattenMatches.length;
                    var currentChunk;
                    for (var i = 0; i < pattenMatchesLength; i++) {
                        currentChunk = pattenMatches.shift();
                        filteredString = filteredString.replace(VALUE_PLACEHOLDER, filter(currentChunk));
                    }
                }
                return filteredString;
            }
            function sanitizeRGBChunks(formattedString) {
                return filterStringChunks(R_RGB, formattedString, sanitizeRGBChunk);
            }
            function sanitizeRGBChunk(rgbChunk) {
                var numbers = rgbChunk.match(R_UNFORMATTED_VALUES);
                var numbersLength = numbers.length;
                var sanitizedString = rgbChunk.match(R_RGB_PREFIX)[0];
                for (var i = 0; i < numbersLength; i++) {
                    sanitizedString += parseInt(numbers[i], 10) + ",";
                }
                sanitizedString = sanitizedString.slice(0, -1) + ")";
                return sanitizedString;
            }
            function getFormatManifests(stateObject) {
                var manifestAccumulator = {};
                Tweenable.each(stateObject, function(prop) {
                    var currentProp = stateObject[prop];
                    if (typeof currentProp === "string") {
                        var rawValues = getValuesFrom(currentProp);
                        manifestAccumulator[prop] = {
                            formatString: getFormatStringFrom(currentProp),
                            chunkNames: getFormatChunksFrom(rawValues, prop)
                        };
                    }
                });
                return manifestAccumulator;
            }
            function expandFormattedProperties(stateObject, formatManifests) {
                Tweenable.each(formatManifests, function(prop) {
                    var currentProp = stateObject[prop];
                    var rawValues = getValuesFrom(currentProp);
                    var rawValuesLength = rawValues.length;
                    for (var i = 0; i < rawValuesLength; i++) {
                        stateObject[formatManifests[prop].chunkNames[i]] = +rawValues[i];
                    }
                    delete stateObject[prop];
                });
            }
            function collapseFormattedProperties(stateObject, formatManifests) {
                Tweenable.each(formatManifests, function(prop) {
                    var currentProp = stateObject[prop];
                    var formatChunks = extractPropertyChunks(stateObject, formatManifests[prop].chunkNames);
                    var valuesList = getValuesList(formatChunks, formatManifests[prop].chunkNames);
                    currentProp = getFormattedValues(formatManifests[prop].formatString, valuesList);
                    stateObject[prop] = sanitizeRGBChunks(currentProp);
                });
            }
            function extractPropertyChunks(stateObject, chunkNames) {
                var extractedValues = {};
                var currentChunkName, chunkNamesLength = chunkNames.length;
                for (var i = 0; i < chunkNamesLength; i++) {
                    currentChunkName = chunkNames[i];
                    extractedValues[currentChunkName] = stateObject[currentChunkName];
                    delete stateObject[currentChunkName];
                }
                return extractedValues;
            }
            var getValuesList_accumulator = [];
            function getValuesList(stateObject, chunkNames) {
                getValuesList_accumulator.length = 0;
                var chunkNamesLength = chunkNames.length;
                for (var i = 0; i < chunkNamesLength; i++) {
                    getValuesList_accumulator.push(stateObject[chunkNames[i]]);
                }
                return getValuesList_accumulator;
            }
            function getFormattedValues(formatString, rawValues) {
                var formattedValueString = formatString;
                var rawValuesLength = rawValues.length;
                for (var i = 0; i < rawValuesLength; i++) {
                    formattedValueString = formattedValueString.replace(VALUE_PLACEHOLDER, +rawValues[i].toFixed(4));
                }
                return formattedValueString;
            }
            function getValuesFrom(formattedString) {
                return formattedString.match(R_UNFORMATTED_VALUES);
            }
            function expandEasingObject(easingObject, tokenData) {
                Tweenable.each(tokenData, function(prop) {
                    var currentProp = tokenData[prop];
                    var chunkNames = currentProp.chunkNames;
                    var chunkLength = chunkNames.length;
                    var easingChunks = easingObject[prop].split(" ");
                    var lastEasingChunk = easingChunks[easingChunks.length - 1];
                    for (var i = 0; i < chunkLength; i++) {
                        easingObject[chunkNames[i]] = easingChunks[i] || lastEasingChunk;
                    }
                    delete easingObject[prop];
                });
            }
            function collapseEasingObject(easingObject, tokenData) {
                Tweenable.each(tokenData, function(prop) {
                    var currentProp = tokenData[prop];
                    var chunkNames = currentProp.chunkNames;
                    var chunkLength = chunkNames.length;
                    var composedEasingString = "";
                    for (var i = 0; i < chunkLength; i++) {
                        composedEasingString += " " + easingObject[chunkNames[i]];
                        delete easingObject[chunkNames[i]];
                    }
                    easingObject[prop] = composedEasingString.substr(1);
                });
            }
            Tweenable.prototype.filter.token = {
                tweenCreated: function(currentState, fromState, toState, easingObject) {
                    sanitizeObjectForHexProps(currentState);
                    sanitizeObjectForHexProps(fromState);
                    sanitizeObjectForHexProps(toState);
                    this._tokenData = getFormatManifests(currentState);
                },
                beforeTween: function(currentState, fromState, toState, easingObject) {
                    expandEasingObject(easingObject, this._tokenData);
                    expandFormattedProperties(currentState, this._tokenData);
                    expandFormattedProperties(fromState, this._tokenData);
                    expandFormattedProperties(toState, this._tokenData);
                },
                afterTween: function(currentState, fromState, toState, easingObject) {
                    collapseFormattedProperties(currentState, this._tokenData);
                    collapseFormattedProperties(fromState, this._tokenData);
                    collapseFormattedProperties(toState, this._tokenData);
                    collapseEasingObject(easingObject, this._tokenData);
                }
            };
        })(Tweenable);
    })(window);
    return window.Tweenable;
});

(function() {
    "use strict";
    angular.module("angular-carousel").filter("carouselSlice", function() {
        return function(collection, start, size) {
            if (angular.isArray(collection)) {
                return collection.slice(start, start + size);
            } else if (angular.isObject(collection)) {
                return collection;
            }
        };
    });
})();